"use strict";
(self["webpackChunkChatAng"] = self["webpackChunkChatAng"] || []).push([["vendor"],{

/***/ 64:
/*!*************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@angular+core@21.0.5_@angular+compiler@21.0.5_rxjs@7.8.2_zone.js@0.16.0/node_modules/@angular/core/fesm2022/_untracked-chunk.mjs ***!
  \*************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AFTER_RENDER_SEQUENCES_TO_ADD: () => (/* binding */ AFTER_RENDER_SEQUENCES_TO_ADD),
/* harmony export */   ANIMATIONS: () => (/* binding */ ANIMATIONS),
/* harmony export */   CHILD_HEAD: () => (/* binding */ CHILD_HEAD),
/* harmony export */   CHILD_TAIL: () => (/* binding */ CHILD_TAIL),
/* harmony export */   CLEANUP: () => (/* binding */ CLEANUP),
/* harmony export */   CONTAINER_HEADER_OFFSET: () => (/* binding */ CONTAINER_HEADER_OFFSET),
/* harmony export */   CONTEXT: () => (/* binding */ CONTEXT),
/* harmony export */   ChangeDetectionScheduler: () => (/* binding */ ChangeDetectionScheduler),
/* harmony export */   CheckNoChangesMode: () => (/* binding */ CheckNoChangesMode),
/* harmony export */   DECLARATION_COMPONENT_VIEW: () => (/* binding */ DECLARATION_COMPONENT_VIEW),
/* harmony export */   DECLARATION_LCONTAINER: () => (/* binding */ DECLARATION_LCONTAINER),
/* harmony export */   DECLARATION_VIEW: () => (/* binding */ DECLARATION_VIEW),
/* harmony export */   DEHYDRATED_VIEWS: () => (/* binding */ DEHYDRATED_VIEWS),
/* harmony export */   DOCUMENT: () => (/* binding */ DOCUMENT),
/* harmony export */   DestroyRef: () => (/* binding */ DestroyRef),
/* harmony export */   EFFECTS: () => (/* binding */ EFFECTS),
/* harmony export */   EFFECTS_TO_SCHEDULE: () => (/* binding */ EFFECTS_TO_SCHEDULE),
/* harmony export */   EMBEDDED_VIEW_INJECTOR: () => (/* binding */ EMBEDDED_VIEW_INJECTOR),
/* harmony export */   EMPTY_ARRAY: () => (/* binding */ EMPTY_ARRAY),
/* harmony export */   EMPTY_OBJ: () => (/* binding */ EMPTY_OBJ),
/* harmony export */   ENVIRONMENT: () => (/* binding */ ENVIRONMENT),
/* harmony export */   ENVIRONMENT_INITIALIZER: () => (/* binding */ ENVIRONMENT_INITIALIZER),
/* harmony export */   EffectRefImpl: () => (/* binding */ EffectRefImpl),
/* harmony export */   EffectScheduler: () => (/* binding */ EffectScheduler),
/* harmony export */   EnvironmentInjector: () => (/* binding */ EnvironmentInjector),
/* harmony export */   ErrorHandler: () => (/* binding */ ErrorHandler),
/* harmony export */   EventEmitter: () => (/* binding */ EventEmitter),
/* harmony export */   FLAGS: () => (/* binding */ FLAGS),
/* harmony export */   HEADER_OFFSET: () => (/* binding */ HEADER_OFFSET),
/* harmony export */   HOST: () => (/* binding */ HOST),
/* harmony export */   HYDRATION: () => (/* binding */ HYDRATION),
/* harmony export */   ID: () => (/* binding */ ID),
/* harmony export */   INJECTOR: () => (/* binding */ INJECTOR$1),
/* harmony export */   INJECTOR$1: () => (/* binding */ INJECTOR),
/* harmony export */   INJECTOR_DEF_TYPES: () => (/* binding */ INJECTOR_DEF_TYPES),
/* harmony export */   INJECTOR_SCOPE: () => (/* binding */ INJECTOR_SCOPE),
/* harmony export */   INTERNAL_APPLICATION_ERROR_HANDLER: () => (/* binding */ INTERNAL_APPLICATION_ERROR_HANDLER),
/* harmony export */   InjectionToken: () => (/* binding */ InjectionToken),
/* harmony export */   Injector: () => (/* binding */ Injector),
/* harmony export */   MATH_ML_NAMESPACE: () => (/* binding */ MATH_ML_NAMESPACE),
/* harmony export */   MOVED_VIEWS: () => (/* binding */ MOVED_VIEWS),
/* harmony export */   NATIVE: () => (/* binding */ NATIVE),
/* harmony export */   NEXT: () => (/* binding */ NEXT),
/* harmony export */   NG_COMP_DEF: () => (/* binding */ NG_COMP_DEF),
/* harmony export */   NG_DIR_DEF: () => (/* binding */ NG_DIR_DEF),
/* harmony export */   NG_ELEMENT_ID: () => (/* binding */ NG_ELEMENT_ID),
/* harmony export */   NG_FACTORY_DEF: () => (/* binding */ NG_FACTORY_DEF),
/* harmony export */   NG_INJ_DEF: () => (/* binding */ NG_INJ_DEF),
/* harmony export */   NG_MOD_DEF: () => (/* binding */ NG_MOD_DEF),
/* harmony export */   NG_PIPE_DEF: () => (/* binding */ NG_PIPE_DEF),
/* harmony export */   NG_PROV_DEF: () => (/* binding */ NG_PROV_DEF),
/* harmony export */   NgZone: () => (/* binding */ NgZone),
/* harmony export */   NoopNgZone: () => (/* binding */ NoopNgZone),
/* harmony export */   NullInjector: () => (/* binding */ NullInjector),
/* harmony export */   ON_DESTROY_HOOKS: () => (/* binding */ ON_DESTROY_HOOKS),
/* harmony export */   PARENT: () => (/* binding */ PARENT),
/* harmony export */   PREORDER_HOOK_FLAGS: () => (/* binding */ PREORDER_HOOK_FLAGS),
/* harmony export */   PROVIDED_ZONELESS: () => (/* binding */ PROVIDED_ZONELESS),
/* harmony export */   PendingTasks: () => (/* binding */ PendingTasks),
/* harmony export */   PendingTasksInternal: () => (/* binding */ PendingTasksInternal),
/* harmony export */   QUERIES: () => (/* binding */ QUERIES),
/* harmony export */   R3Injector: () => (/* binding */ R3Injector),
/* harmony export */   REACTIVE_TEMPLATE_CONSUMER: () => (/* binding */ REACTIVE_TEMPLATE_CONSUMER),
/* harmony export */   RENDERER: () => (/* binding */ RENDERER),
/* harmony export */   RuntimeError: () => (/* binding */ RuntimeError),
/* harmony export */   SCHEDULE_IN_ROOT_ZONE: () => (/* binding */ SCHEDULE_IN_ROOT_ZONE),
/* harmony export */   SCHEDULE_IN_ROOT_ZONE_DEFAULT: () => (/* binding */ SCHEDULE_IN_ROOT_ZONE_DEFAULT),
/* harmony export */   SVG_NAMESPACE: () => (/* binding */ SVG_NAMESPACE),
/* harmony export */   TVIEW: () => (/* binding */ TVIEW),
/* harmony export */   T_HOST: () => (/* binding */ T_HOST),
/* harmony export */   VERSION: () => (/* binding */ VERSION),
/* harmony export */   VIEW_REFS: () => (/* binding */ VIEW_REFS),
/* harmony export */   Version: () => (/* binding */ Version),
/* harmony export */   ViewContext: () => (/* binding */ ViewContext),
/* harmony export */   XSS_SECURITY_URL: () => (/* binding */ XSS_SECURITY_URL),
/* harmony export */   ZONELESS_ENABLED: () => (/* binding */ ZONELESS_ENABLED),
/* harmony export */   _global: () => (/* binding */ _global),
/* harmony export */   addToArray: () => (/* binding */ addToArray),
/* harmony export */   angularZoneInstanceIdProperty: () => (/* binding */ angularZoneInstanceIdProperty),
/* harmony export */   arrayEquals: () => (/* binding */ arrayEquals),
/* harmony export */   arrayInsert2: () => (/* binding */ arrayInsert2),
/* harmony export */   arraySplice: () => (/* binding */ arraySplice),
/* harmony export */   assertComponentType: () => (/* binding */ assertComponentType),
/* harmony export */   assertDefined: () => (/* binding */ assertDefined),
/* harmony export */   assertDirectiveDef: () => (/* binding */ assertDirectiveDef),
/* harmony export */   assertDomNode: () => (/* binding */ assertDomNode),
/* harmony export */   assertElement: () => (/* binding */ assertElement),
/* harmony export */   assertEqual: () => (/* binding */ assertEqual),
/* harmony export */   assertFirstCreatePass: () => (/* binding */ assertFirstCreatePass),
/* harmony export */   assertFirstUpdatePass: () => (/* binding */ assertFirstUpdatePass),
/* harmony export */   assertFunction: () => (/* binding */ assertFunction),
/* harmony export */   assertGreaterThan: () => (/* binding */ assertGreaterThan),
/* harmony export */   assertGreaterThanOrEqual: () => (/* binding */ assertGreaterThanOrEqual),
/* harmony export */   assertHasParent: () => (/* binding */ assertHasParent),
/* harmony export */   assertInInjectionContext: () => (/* binding */ assertInInjectionContext),
/* harmony export */   assertIndexInDeclRange: () => (/* binding */ assertIndexInDeclRange),
/* harmony export */   assertIndexInExpandoRange: () => (/* binding */ assertIndexInExpandoRange),
/* harmony export */   assertIndexInRange: () => (/* binding */ assertIndexInRange),
/* harmony export */   assertInjectImplementationNotEqual: () => (/* binding */ assertInjectImplementationNotEqual),
/* harmony export */   assertLContainer: () => (/* binding */ assertLContainer),
/* harmony export */   assertLView: () => (/* binding */ assertLView),
/* harmony export */   assertLessThan: () => (/* binding */ assertLessThan),
/* harmony export */   assertNgModuleType: () => (/* binding */ assertNgModuleType),
/* harmony export */   assertNodeInjector: () => (/* binding */ assertNodeInjector),
/* harmony export */   assertNotDefined: () => (/* binding */ assertNotDefined),
/* harmony export */   assertNotEqual: () => (/* binding */ assertNotEqual),
/* harmony export */   assertNotInReactiveContext: () => (/* binding */ assertNotInReactiveContext),
/* harmony export */   assertNotReactive: () => (/* binding */ assertNotReactive),
/* harmony export */   assertNotSame: () => (/* binding */ assertNotSame),
/* harmony export */   assertNumber: () => (/* binding */ assertNumber),
/* harmony export */   assertNumberInRange: () => (/* binding */ assertNumberInRange),
/* harmony export */   assertOneOf: () => (/* binding */ assertOneOf),
/* harmony export */   assertParentView: () => (/* binding */ assertParentView),
/* harmony export */   assertProjectionSlots: () => (/* binding */ assertProjectionSlots),
/* harmony export */   assertSame: () => (/* binding */ assertSame),
/* harmony export */   assertString: () => (/* binding */ assertString),
/* harmony export */   assertTIcu: () => (/* binding */ assertTIcu),
/* harmony export */   assertTNode: () => (/* binding */ assertTNode),
/* harmony export */   assertTNodeCreationIndex: () => (/* binding */ assertTNodeCreationIndex),
/* harmony export */   assertTNodeForLView: () => (/* binding */ assertTNodeForLView),
/* harmony export */   assertTNodeForTView: () => (/* binding */ assertTNodeForTView),
/* harmony export */   attachInjectFlag: () => (/* binding */ attachInjectFlag),
/* harmony export */   concatStringsWithSpace: () => (/* binding */ concatStringsWithSpace),
/* harmony export */   convertToBitFlags: () => (/* binding */ convertToBitFlags),
/* harmony export */   createInjector: () => (/* binding */ createInjector),
/* harmony export */   createInjectorWithoutInjectorInstances: () => (/* binding */ createInjectorWithoutInjectorInstances),
/* harmony export */   cyclicDependencyError: () => (/* binding */ cyclicDependencyError),
/* harmony export */   cyclicDependencyErrorWithDetails: () => (/* binding */ cyclicDependencyErrorWithDetails),
/* harmony export */   debugStringifyTypeForError: () => (/* binding */ debugStringifyTypeForError),
/* harmony export */   decreaseElementDepthCount: () => (/* binding */ decreaseElementDepthCount),
/* harmony export */   deepForEach: () => (/* binding */ deepForEach),
/* harmony export */   effect: () => (/* binding */ effect),
/* harmony export */   emitAfterRenderEffectPhaseCreatedEvent: () => (/* binding */ emitAfterRenderEffectPhaseCreatedEvent),
/* harmony export */   emitInjectEvent: () => (/* binding */ emitInjectEvent),
/* harmony export */   emitInjectorToCreateInstanceEvent: () => (/* binding */ emitInjectorToCreateInstanceEvent),
/* harmony export */   emitInstanceCreatedByInjectorEvent: () => (/* binding */ emitInstanceCreatedByInjectorEvent),
/* harmony export */   emitProviderConfiguredEvent: () => (/* binding */ emitProviderConfiguredEvent),
/* harmony export */   enterDI: () => (/* binding */ enterDI),
/* harmony export */   enterSkipHydrationBlock: () => (/* binding */ enterSkipHydrationBlock),
/* harmony export */   enterView: () => (/* binding */ enterView),
/* harmony export */   errorHandlerEnvironmentInitializer: () => (/* binding */ errorHandlerEnvironmentInitializer),
/* harmony export */   fillProperties: () => (/* binding */ fillProperties),
/* harmony export */   flatten: () => (/* binding */ flatten),
/* harmony export */   formatRuntimeError: () => (/* binding */ formatRuntimeError),
/* harmony export */   forwardRef: () => (/* binding */ forwardRef),
/* harmony export */   getBindingIndex: () => (/* binding */ getBindingIndex),
/* harmony export */   getBindingRoot: () => (/* binding */ getBindingRoot),
/* harmony export */   getBindingsEnabled: () => (/* binding */ getBindingsEnabled),
/* harmony export */   getClosureSafeProperty: () => (/* binding */ getClosureSafeProperty),
/* harmony export */   getComponentDef: () => (/* binding */ getComponentDef),
/* harmony export */   getComponentLViewByIndex: () => (/* binding */ getComponentLViewByIndex),
/* harmony export */   getConstant: () => (/* binding */ getConstant),
/* harmony export */   getContextLView: () => (/* binding */ getContextLView),
/* harmony export */   getCurrentDirectiveDef: () => (/* binding */ getCurrentDirectiveDef),
/* harmony export */   getCurrentDirectiveIndex: () => (/* binding */ getCurrentDirectiveIndex),
/* harmony export */   getCurrentParentTNode: () => (/* binding */ getCurrentParentTNode),
/* harmony export */   getCurrentQueryIndex: () => (/* binding */ getCurrentQueryIndex),
/* harmony export */   getCurrentTNode: () => (/* binding */ getCurrentTNode),
/* harmony export */   getCurrentTNodePlaceholderOk: () => (/* binding */ getCurrentTNodePlaceholderOk),
/* harmony export */   getDirectiveDef: () => (/* binding */ getDirectiveDef),
/* harmony export */   getDirectiveDefOrThrow: () => (/* binding */ getDirectiveDefOrThrow),
/* harmony export */   getElementDepthCount: () => (/* binding */ getElementDepthCount),
/* harmony export */   getFactoryDef: () => (/* binding */ getFactoryDef),
/* harmony export */   getInjectableDef: () => (/* binding */ getInjectableDef),
/* harmony export */   getInjectorDef: () => (/* binding */ getInjectorDef),
/* harmony export */   getLView: () => (/* binding */ getLView),
/* harmony export */   getLViewParent: () => (/* binding */ getLViewParent),
/* harmony export */   getNamespace: () => (/* binding */ getNamespace),
/* harmony export */   getNativeByIndex: () => (/* binding */ getNativeByIndex),
/* harmony export */   getNativeByTNode: () => (/* binding */ getNativeByTNode),
/* harmony export */   getNativeByTNodeOrNull: () => (/* binding */ getNativeByTNodeOrNull),
/* harmony export */   getNgModuleDef: () => (/* binding */ getNgModuleDef),
/* harmony export */   getNgModuleDefOrThrow: () => (/* binding */ getNgModuleDefOrThrow),
/* harmony export */   getNullInjector: () => (/* binding */ getNullInjector),
/* harmony export */   getOrCreateLViewCleanup: () => (/* binding */ getOrCreateLViewCleanup),
/* harmony export */   getOrCreateTViewCleanup: () => (/* binding */ getOrCreateTViewCleanup),
/* harmony export */   getPipeDef: () => (/* binding */ getPipeDef),
/* harmony export */   getSelectedIndex: () => (/* binding */ getSelectedIndex),
/* harmony export */   getSelectedTNode: () => (/* binding */ getSelectedTNode),
/* harmony export */   getTNode: () => (/* binding */ getTNode),
/* harmony export */   getTView: () => (/* binding */ getTView),
/* harmony export */   hasI18n: () => (/* binding */ hasI18n),
/* harmony export */   importProvidersFrom: () => (/* binding */ importProvidersFrom),
/* harmony export */   increaseElementDepthCount: () => (/* binding */ increaseElementDepthCount),
/* harmony export */   incrementBindingIndex: () => (/* binding */ incrementBindingIndex),
/* harmony export */   initNgDevMode: () => (/* binding */ initNgDevMode),
/* harmony export */   inject: () => (/* binding */ inject),
/* harmony export */   injectRootLimpMode: () => (/* binding */ injectRootLimpMode),
/* harmony export */   internalImportProvidersFrom: () => (/* binding */ internalImportProvidersFrom),
/* harmony export */   isClassProvider: () => (/* binding */ isClassProvider),
/* harmony export */   isComponentDef: () => (/* binding */ isComponentDef),
/* harmony export */   isComponentHost: () => (/* binding */ isComponentHost),
/* harmony export */   isContentQueryHost: () => (/* binding */ isContentQueryHost),
/* harmony export */   isCreationMode: () => (/* binding */ isCreationMode),
/* harmony export */   isCurrentTNodeParent: () => (/* binding */ isCurrentTNodeParent),
/* harmony export */   isDestroyed: () => (/* binding */ isDestroyed),
/* harmony export */   isDirectiveHost: () => (/* binding */ isDirectiveHost),
/* harmony export */   isEnvironmentProviders: () => (/* binding */ isEnvironmentProviders),
/* harmony export */   isExhaustiveCheckNoChanges: () => (/* binding */ isExhaustiveCheckNoChanges),
/* harmony export */   isForwardRef: () => (/* binding */ isForwardRef),
/* harmony export */   isInCheckNoChangesMode: () => (/* binding */ isInCheckNoChangesMode),
/* harmony export */   isInI18nBlock: () => (/* binding */ isInI18nBlock),
/* harmony export */   isInInjectionContext: () => (/* binding */ isInInjectionContext),
/* harmony export */   isInSkipHydrationBlock: () => (/* binding */ isInSkipHydrationBlock),
/* harmony export */   isInjectable: () => (/* binding */ isInjectable),
/* harmony export */   isLContainer: () => (/* binding */ isLContainer),
/* harmony export */   isLView: () => (/* binding */ isLView),
/* harmony export */   isProjectionTNode: () => (/* binding */ isProjectionTNode),
/* harmony export */   isRefreshingViews: () => (/* binding */ isRefreshingViews),
/* harmony export */   isRootView: () => (/* binding */ isRootView),
/* harmony export */   isSkipHydrationRootTNode: () => (/* binding */ isSkipHydrationRootTNode),
/* harmony export */   isStandalone: () => (/* binding */ isStandalone),
/* harmony export */   isTypeProvider: () => (/* binding */ isTypeProvider),
/* harmony export */   keyValueArrayGet: () => (/* binding */ keyValueArrayGet),
/* harmony export */   keyValueArrayIndexOf: () => (/* binding */ keyValueArrayIndexOf),
/* harmony export */   keyValueArraySet: () => (/* binding */ keyValueArraySet),
/* harmony export */   lastNodeWasCreated: () => (/* binding */ lastNodeWasCreated),
/* harmony export */   leaveDI: () => (/* binding */ leaveDI),
/* harmony export */   leaveSkipHydrationBlock: () => (/* binding */ leaveSkipHydrationBlock),
/* harmony export */   leaveView: () => (/* binding */ leaveView),
/* harmony export */   load: () => (/* binding */ load),
/* harmony export */   makeEnvironmentProviders: () => (/* binding */ makeEnvironmentProviders),
/* harmony export */   markAncestorsForTraversal: () => (/* binding */ markAncestorsForTraversal),
/* harmony export */   markViewForRefresh: () => (/* binding */ markViewForRefresh),
/* harmony export */   newArray: () => (/* binding */ newArray),
/* harmony export */   nextBindingIndex: () => (/* binding */ nextBindingIndex),
/* harmony export */   nextContextImpl: () => (/* binding */ nextContextImpl),
/* harmony export */   provideBrowserGlobalErrorListeners: () => (/* binding */ provideBrowserGlobalErrorListeners),
/* harmony export */   provideEnvironmentInitializer: () => (/* binding */ provideEnvironmentInitializer),
/* harmony export */   providerToFactory: () => (/* binding */ providerToFactory),
/* harmony export */   removeFromArray: () => (/* binding */ removeFromArray),
/* harmony export */   removeLViewOnDestroy: () => (/* binding */ removeLViewOnDestroy),
/* harmony export */   renderStringify: () => (/* binding */ renderStringify),
/* harmony export */   requiresRefreshOrTraversal: () => (/* binding */ requiresRefreshOrTraversal),
/* harmony export */   resetPreOrderHookFlags: () => (/* binding */ resetPreOrderHookFlags),
/* harmony export */   resolveForwardRef: () => (/* binding */ resolveForwardRef),
/* harmony export */   runInInjectionContext: () => (/* binding */ runInInjectionContext),
/* harmony export */   runInInjectorProfilerContext: () => (/* binding */ runInInjectorProfilerContext),
/* harmony export */   scheduleCallbackWithMicrotask: () => (/* binding */ scheduleCallbackWithMicrotask),
/* harmony export */   scheduleCallbackWithRafRace: () => (/* binding */ scheduleCallbackWithRafRace),
/* harmony export */   setBindingIndex: () => (/* binding */ setBindingIndex),
/* harmony export */   setBindingRootForHostBindings: () => (/* binding */ setBindingRootForHostBindings),
/* harmony export */   setCurrentDirectiveIndex: () => (/* binding */ setCurrentDirectiveIndex),
/* harmony export */   setCurrentQueryIndex: () => (/* binding */ setCurrentQueryIndex),
/* harmony export */   setCurrentTNode: () => (/* binding */ setCurrentTNode),
/* harmony export */   setCurrentTNodeAsNotParent: () => (/* binding */ setCurrentTNodeAsNotParent),
/* harmony export */   setInI18nBlock: () => (/* binding */ setInI18nBlock),
/* harmony export */   setInjectImplementation: () => (/* binding */ setInjectImplementation),
/* harmony export */   setInjectorProfiler: () => (/* binding */ setInjectorProfiler),
/* harmony export */   setInjectorProfilerContext: () => (/* binding */ setInjectorProfilerContext),
/* harmony export */   setIsInCheckNoChangesMode: () => (/* binding */ setIsInCheckNoChangesMode),
/* harmony export */   setIsRefreshingViews: () => (/* binding */ setIsRefreshingViews),
/* harmony export */   setSelectedIndex: () => (/* binding */ setSelectedIndex),
/* harmony export */   signal: () => (/* binding */ signal),
/* harmony export */   signalAsReadonlyFn: () => (/* binding */ signalAsReadonlyFn),
/* harmony export */   store: () => (/* binding */ store),
/* harmony export */   storeCleanupWithContext: () => (/* binding */ storeCleanupWithContext),
/* harmony export */   storeLViewOnDestroy: () => (/* binding */ storeLViewOnDestroy),
/* harmony export */   stringify: () => (/* binding */ stringify),
/* harmony export */   stringifyForError: () => (/* binding */ stringifyForError),
/* harmony export */   throwError: () => (/* binding */ throwError),
/* harmony export */   throwProviderNotFoundError: () => (/* binding */ throwProviderNotFoundError),
/* harmony export */   truncateMiddle: () => (/* binding */ truncateMiddle),
/* harmony export */   untracked: () => (/* binding */ untracked),
/* harmony export */   unwrapLView: () => (/* binding */ unwrapLView),
/* harmony export */   unwrapRNode: () => (/* binding */ unwrapRNode),
/* harmony export */   updateAncestorTraversalFlagsOnAttach: () => (/* binding */ updateAncestorTraversalFlagsOnAttach),
/* harmony export */   viewAttachedToChangeDetector: () => (/* binding */ viewAttachedToChangeDetector),
/* harmony export */   viewAttachedToContainer: () => (/* binding */ viewAttachedToContainer),
/* harmony export */   walkProviderTree: () => (/* binding */ walkProviderTree),
/* harmony export */   walkUpViews: () => (/* binding */ walkUpViews),
/* harmony export */   wasLastNodeCreated: () => (/* binding */ wasLastNodeCreated),
/* harmony export */   "ɵunwrapWritableSignal": () => (/* binding */ ɵunwrapWritableSignal),
/* harmony export */   "ɵɵdefineInjectable": () => (/* binding */ ɵɵdefineInjectable),
/* harmony export */   "ɵɵdefineInjector": () => (/* binding */ ɵɵdefineInjector),
/* harmony export */   "ɵɵdisableBindings": () => (/* binding */ ɵɵdisableBindings),
/* harmony export */   "ɵɵenableBindings": () => (/* binding */ ɵɵenableBindings),
/* harmony export */   "ɵɵinject": () => (/* binding */ ɵɵinject),
/* harmony export */   "ɵɵinvalidFactoryDep": () => (/* binding */ ɵɵinvalidFactoryDep),
/* harmony export */   "ɵɵnamespaceHTML": () => (/* binding */ ɵɵnamespaceHTML),
/* harmony export */   "ɵɵnamespaceMathML": () => (/* binding */ ɵɵnamespaceMathML),
/* harmony export */   "ɵɵnamespaceSVG": () => (/* binding */ ɵɵnamespaceSVG),
/* harmony export */   "ɵɵresetView": () => (/* binding */ ɵɵresetView),
/* harmony export */   "ɵɵrestoreView": () => (/* binding */ ɵɵrestoreView)
/* harmony export */ });
/* harmony import */ var _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core/primitives/signals */ 476);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ 1814);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ 1171);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ 8277);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ 1038);
/* harmony import */ var _not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/core/primitives/di */ 3667);
/**
 * @license Angular v21.0.5
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */






class Version {
  full;
  major;
  minor;
  patch;
  constructor(full) {
    this.full = full;
    const parts = full.split('.');
    this.major = parts[0];
    this.minor = parts[1];
    this.patch = parts.slice(2).join('.');
  }
}
const VERSION = /* @__PURE__ */new Version('21.0.5');
const ERROR_DETAILS_PAGE_BASE_URL = (() => {
  const versionSubDomain = VERSION.major !== '0' ? `v${VERSION.major}.` : '';
  return `https://${versionSubDomain}angular.dev/errors`;
})();
const XSS_SECURITY_URL = 'https://angular.dev/best-practices/security#preventing-cross-site-scripting-xss';
class RuntimeError extends Error {
  code;
  constructor(code, message) {
    super(formatRuntimeError(code, message));
    this.code = code;
  }
}
function formatRuntimeErrorCode(code) {
  return `NG0${Math.abs(code)}`;
}
function formatRuntimeError(code, message) {
  const fullCode = formatRuntimeErrorCode(code);
  let errorMessage = `${fullCode}${message ? ': ' + message : ''}`;
  if (ngDevMode && code < 0) {
    const addPeriodSeparator = !errorMessage.match(/[.,;!?\n]$/);
    const separator = addPeriodSeparator ? '.' : '';
    errorMessage = `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;
  }
  return errorMessage;
}
const _global = globalThis;
function ngDevModeResetPerfCounters() {
  const locationString = typeof location !== 'undefined' ? location.toString() : '';
  const newCounters = {
    hydratedNodes: 0,
    hydratedComponents: 0,
    dehydratedViewsRemoved: 0,
    dehydratedViewsCleanupRuns: 0,
    componentsSkippedHydration: 0,
    deferBlocksWithIncrementalHydration: 0
  };
  const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;
  if (!allowNgDevModeTrue) {
    _global['ngDevMode'] = false;
  } else {
    if (typeof _global['ngDevMode'] !== 'object') {
      _global['ngDevMode'] = {};
    }
    Object.assign(_global['ngDevMode'], newCounters);
  }
  return newCounters;
}
function initNgDevMode() {
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
    if (typeof ngDevMode !== 'object' || Object.keys(ngDevMode).length === 0) {
      ngDevModeResetPerfCounters();
    }
    return typeof ngDevMode !== 'undefined' && !!ngDevMode;
  }
  return false;
}
function getClosureSafeProperty(objWithPropertyToExtract) {
  for (let key in objWithPropertyToExtract) {
    if (objWithPropertyToExtract[key] === getClosureSafeProperty) {
      return key;
    }
  }
  throw Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Could not find renamed property on target object.' : '');
}
function fillProperties(target, source) {
  for (const key in source) {
    if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {
      target[key] = source[key];
    }
  }
}
function stringify(token) {
  if (typeof token === 'string') {
    return token;
  }
  if (Array.isArray(token)) {
    return `[${token.map(stringify).join(', ')}]`;
  }
  if (token == null) {
    return '' + token;
  }
  const name = token.overriddenName || token.name;
  if (name) {
    return `${name}`;
  }
  const result = token.toString();
  if (result == null) {
    return '' + result;
  }
  const newLineIndex = result.indexOf('\n');
  return newLineIndex >= 0 ? result.slice(0, newLineIndex) : result;
}
function concatStringsWithSpace(before, after) {
  if (!before) return after || '';
  if (!after) return before;
  return `${before} ${after}`;
}
function truncateMiddle(str, maxLength = 100) {
  if (!str || maxLength < 1 || str.length <= maxLength) return str;
  if (maxLength == 1) return str.substring(0, 1) + '...';
  const halfLimit = Math.round(maxLength / 2);
  return str.substring(0, halfLimit) + '...' + str.substring(str.length - halfLimit);
}
const __forward_ref__ = getClosureSafeProperty({
  __forward_ref__: getClosureSafeProperty
});
function forwardRef(forwardRefFn) {
  forwardRefFn.__forward_ref__ = forwardRef;
  forwardRefFn.toString = function () {
    return stringify(this());
  };
  return forwardRefFn;
}
function resolveForwardRef(type) {
  return isForwardRef(type) ? type() : type;
}
function isForwardRef(fn) {
  return typeof fn === 'function' && fn.hasOwnProperty(__forward_ref__) && fn.__forward_ref__ === forwardRef;
}
function assertNumber(actual, msg) {
  if (!(typeof actual === 'number')) {
    throwError(msg, typeof actual, 'number', '===');
  }
}
function assertNumberInRange(actual, minInclusive, maxInclusive) {
  assertNumber(actual, 'Expected a number');
  assertLessThanOrEqual(actual, maxInclusive, 'Expected number to be less than or equal to');
  assertGreaterThanOrEqual(actual, minInclusive, 'Expected number to be greater than or equal to');
}
function assertString(actual, msg) {
  if (!(typeof actual === 'string')) {
    throwError(msg, actual === null ? 'null' : typeof actual, 'string', '===');
  }
}
function assertFunction(actual, msg) {
  if (!(typeof actual === 'function')) {
    throwError(msg, actual === null ? 'null' : typeof actual, 'function', '===');
  }
}
function assertEqual(actual, expected, msg) {
  if (!(actual == expected)) {
    throwError(msg, actual, expected, '==');
  }
}
function assertNotEqual(actual, expected, msg) {
  if (!(actual != expected)) {
    throwError(msg, actual, expected, '!=');
  }
}
function assertSame(actual, expected, msg) {
  if (!(actual === expected)) {
    throwError(msg, actual, expected, '===');
  }
}
function assertNotSame(actual, expected, msg) {
  if (!(actual !== expected)) {
    throwError(msg, actual, expected, '!==');
  }
}
function assertLessThan(actual, expected, msg) {
  if (!(actual < expected)) {
    throwError(msg, actual, expected, '<');
  }
}
function assertLessThanOrEqual(actual, expected, msg) {
  if (!(actual <= expected)) {
    throwError(msg, actual, expected, '<=');
  }
}
function assertGreaterThan(actual, expected, msg) {
  if (!(actual > expected)) {
    throwError(msg, actual, expected, '>');
  }
}
function assertGreaterThanOrEqual(actual, expected, msg) {
  if (!(actual >= expected)) {
    throwError(msg, actual, expected, '>=');
  }
}
function assertNotDefined(actual, msg) {
  if (actual != null) {
    throwError(msg, actual, null, '==');
  }
}
function assertDefined(actual, msg) {
  if (actual == null) {
    throwError(msg, actual, null, '!=');
  }
}
function throwError(msg, actual, expected, comparison) {
  throw new Error(`ASSERTION ERROR: ${msg}` + (comparison == null ? '' : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));
}
function assertDomNode(node) {
  if (!(node instanceof Node)) {
    throwError(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);
  }
}
function assertElement(node) {
  if (!(node instanceof Element)) {
    throwError(`The provided value must be an element but got ${stringify(node)}`);
  }
}
function assertIndexInRange(arr, index) {
  assertDefined(arr, 'Array must be defined.');
  const maxLen = arr.length;
  if (index < 0 || index >= maxLen) {
    throwError(`Index expected to be less than ${maxLen} but got ${index}`);
  }
}
function assertOneOf(value, ...validValues) {
  if (validValues.indexOf(value) !== -1) return true;
  throwError(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`);
}
function assertNotReactive(fn) {
  if ((0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getActiveConsumer)() !== null) {
    throwError(`${fn}() should never be called in a reactive context.`);
  }
}
function ɵɵdefineInjectable(opts) {
  return {
    token: opts.token,
    providedIn: opts.providedIn || null,
    factory: opts.factory,
    value: undefined
  };
}
function ɵɵdefineInjector(options) {
  return {
    providers: options.providers || [],
    imports: options.imports || []
  };
}
function getInjectableDef(type) {
  return getOwnDefinition(type, NG_PROV_DEF);
}
function isInjectable(type) {
  return getInjectableDef(type) !== null;
}
function getOwnDefinition(type, field) {
  return type.hasOwnProperty(field) && type[field] || null;
}
function getInheritedInjectableDef(type) {
  const def = type?.[NG_PROV_DEF] ?? null;
  if (def) {
    ngDevMode && console.warn(`DEPRECATED: DI is instantiating a token "${type.name}" that inherits its @Injectable decorator but does not provide one itself.\n` + `This will become an error in a future version of Angular. Please add @Injectable() to the "${type.name}" class.`);
    return def;
  } else {
    return null;
  }
}
function getInjectorDef(type) {
  return type && type.hasOwnProperty(NG_INJ_DEF) ? type[NG_INJ_DEF] : null;
}
const NG_PROV_DEF = getClosureSafeProperty({
  ɵprov: getClosureSafeProperty
});
const NG_INJ_DEF = getClosureSafeProperty({
  ɵinj: getClosureSafeProperty
});
class InjectionToken {
  _desc;
  ngMetadataName = 'InjectionToken';
  ɵprov;
  constructor(_desc, options) {
    this._desc = _desc;
    this.ɵprov = undefined;
    if (typeof options == 'number') {
      (typeof ngDevMode === 'undefined' || ngDevMode) && assertLessThan(options, 0, 'Only negative numbers are supported here');
      this.__NG_ELEMENT_ID__ = options;
    } else if (options !== undefined) {
      this.ɵprov = ɵɵdefineInjectable({
        token: this,
        providedIn: options.providedIn || 'root',
        factory: options.factory
      });
    }
  }
  get multi() {
    return this;
  }
  toString() {
    return `InjectionToken ${this._desc}`;
  }
}
let _injectorProfilerContext;
function getInjectorProfilerContext() {
  !ngDevMode && throwError('getInjectorProfilerContext should never be called in production mode');
  return _injectorProfilerContext;
}
function setInjectorProfilerContext(context) {
  !ngDevMode && throwError('setInjectorProfilerContext should never be called in production mode');
  const previous = _injectorProfilerContext;
  _injectorProfilerContext = context;
  return previous;
}
const injectorProfilerCallbacks = [];
const NOOP_PROFILER_REMOVAL = () => {};
function removeProfiler(profiler) {
  const profilerIdx = injectorProfilerCallbacks.indexOf(profiler);
  if (profilerIdx !== -1) {
    injectorProfilerCallbacks.splice(profilerIdx, 1);
  }
}
function setInjectorProfiler(injectorProfiler) {
  !ngDevMode && throwError('setInjectorProfiler should never be called in production mode');
  if (injectorProfiler !== null) {
    if (!injectorProfilerCallbacks.includes(injectorProfiler)) {
      injectorProfilerCallbacks.push(injectorProfiler);
    }
    return () => removeProfiler(injectorProfiler);
  } else {
    injectorProfilerCallbacks.length = 0;
    return NOOP_PROFILER_REMOVAL;
  }
}
function injectorProfiler(event) {
  !ngDevMode && throwError('Injector profiler should never be called in production mode');
  for (let i = 0; i < injectorProfilerCallbacks.length; i++) {
    const injectorProfilerCallback = injectorProfilerCallbacks[i];
    injectorProfilerCallback(event);
  }
}
function emitProviderConfiguredEvent(eventProvider, isViewProvider = false) {
  !ngDevMode && throwError('Injector profiler should never be called in production mode');
  let token;
  if (typeof eventProvider === 'function') {
    token = eventProvider;
  } else if (eventProvider instanceof InjectionToken) {
    token = eventProvider;
  } else {
    token = resolveForwardRef(eventProvider.provide);
  }
  let provider = eventProvider;
  if (eventProvider instanceof InjectionToken) {
    provider = eventProvider.ɵprov || eventProvider;
  }
  injectorProfiler({
    type: 2,
    context: getInjectorProfilerContext(),
    providerRecord: {
      token,
      provider,
      isViewProvider
    }
  });
}
function emitInjectorToCreateInstanceEvent(token) {
  !ngDevMode && throwError('Injector profiler should never be called in production mode');
  injectorProfiler({
    type: 5,
    context: getInjectorProfilerContext(),
    token: token
  });
}
function emitInstanceCreatedByInjectorEvent(instance) {
  !ngDevMode && throwError('Injector profiler should never be called in production mode');
  injectorProfiler({
    type: 1,
    context: getInjectorProfilerContext(),
    instance: {
      value: instance
    }
  });
}
function emitInjectEvent(token, value, flags) {
  !ngDevMode && throwError('Injector profiler should never be called in production mode');
  injectorProfiler({
    type: 0,
    context: getInjectorProfilerContext(),
    service: {
      token,
      value,
      flags
    }
  });
}
function emitEffectCreatedEvent(effect) {
  !ngDevMode && throwError('Injector profiler should never be called in production mode');
  injectorProfiler({
    type: 3,
    context: getInjectorProfilerContext(),
    effect
  });
}
function emitAfterRenderEffectPhaseCreatedEvent(effectPhase) {
  !ngDevMode && throwError('Injector profiler should never be called in production mode');
  injectorProfiler({
    type: 4,
    context: getInjectorProfilerContext(),
    effectPhase
  });
}
function runInInjectorProfilerContext(injector, token, callback) {
  !ngDevMode && throwError('runInInjectorProfilerContext should never be called in production mode');
  const prevInjectContext = setInjectorProfilerContext({
    injector,
    token
  });
  try {
    callback();
  } finally {
    setInjectorProfilerContext(prevInjectContext);
  }
}
function isEnvironmentProviders(value) {
  return value && !!value.ɵproviders;
}
const NG_COMP_DEF = getClosureSafeProperty({
  ɵcmp: getClosureSafeProperty
});
const NG_DIR_DEF = getClosureSafeProperty({
  ɵdir: getClosureSafeProperty
});
const NG_PIPE_DEF = getClosureSafeProperty({
  ɵpipe: getClosureSafeProperty
});
const NG_MOD_DEF = getClosureSafeProperty({
  ɵmod: getClosureSafeProperty
});
const NG_FACTORY_DEF = getClosureSafeProperty({
  ɵfac: getClosureSafeProperty
});
const NG_ELEMENT_ID = getClosureSafeProperty({
  __NG_ELEMENT_ID__: getClosureSafeProperty
});
const NG_ENV_ID = getClosureSafeProperty({
  __NG_ENV_ID__: getClosureSafeProperty
});
function getNgModuleDef(type) {
  return type[NG_MOD_DEF] || null;
}
function getNgModuleDefOrThrow(type) {
  const ngModuleDef = getNgModuleDef(type);
  if (!ngModuleDef) {
    throw new RuntimeError(915, (typeof ngDevMode === 'undefined' || ngDevMode) && `Type ${stringify(type)} does not have 'ɵmod' property.`);
  }
  return ngModuleDef;
}
function getComponentDef(type) {
  return type[NG_COMP_DEF] || null;
}
function getDirectiveDefOrThrow(type) {
  const def = getDirectiveDef(type);
  if (!def) {
    throw new RuntimeError(916, (typeof ngDevMode === 'undefined' || ngDevMode) && `Type ${stringify(type)} does not have 'ɵdir' property.`);
  }
  return def;
}
function getDirectiveDef(type) {
  return type[NG_DIR_DEF] || null;
}
function getPipeDef(type) {
  return type[NG_PIPE_DEF] || null;
}
function isStandalone(type) {
  const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);
  return def !== null && def.standalone;
}
function renderStringify(value) {
  if (typeof value === 'string') return value;
  if (value == null) return '';
  return String(value);
}
function stringifyForError(value) {
  if (typeof value === 'function') return value.name || value.toString();
  if (typeof value === 'object' && value != null && typeof value.type === 'function') {
    return value.type.name || value.type.toString();
  }
  return renderStringify(value);
}
function debugStringifyTypeForError(type) {
  const componentDef = getComponentDef(type);
  if (componentDef !== null && componentDef.debugInfo) {
    return stringifyTypeFromDebugInfo(componentDef.debugInfo);
  }
  return stringifyForError(type);
}
function stringifyTypeFromDebugInfo(debugInfo) {
  if (!debugInfo.filePath || !debugInfo.lineNumber) {
    return debugInfo.className;
  } else {
    return `${debugInfo.className} (at ${debugInfo.filePath}:${debugInfo.lineNumber})`;
  }
}
const NG_RUNTIME_ERROR_CODE = getClosureSafeProperty({
  'ngErrorCode': getClosureSafeProperty
});
const NG_RUNTIME_ERROR_MESSAGE = getClosureSafeProperty({
  'ngErrorMessage': getClosureSafeProperty
});
const NG_TOKEN_PATH = getClosureSafeProperty({
  'ngTokenPath': getClosureSafeProperty
});
function cyclicDependencyError(token, path) {
  const message = ngDevMode ? `Circular dependency detected for \`${token}\`.` : '';
  return createRuntimeError(message, -200, path);
}
function cyclicDependencyErrorWithDetails(token, path) {
  return augmentRuntimeError(cyclicDependencyError(token, path), null);
}
function throwMixedMultiProviderError() {
  throw new Error(`Cannot mix multi providers and regular providers`);
}
function throwInvalidProviderError(ngModuleType, providers, provider) {
  if (ngModuleType && providers) {
    const providerDetail = providers.map(v => v == provider ? '?' + provider + '?' : '...');
    throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(', ')}]`);
  } else if (isEnvironmentProviders(provider)) {
    if (provider.ɵfromNgModule) {
      throw new RuntimeError(207, `Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers.`);
    } else {
      throw new RuntimeError(207, `Invalid providers present in a non-environment injector. 'EnvironmentProviders' can't be used for component providers.`);
    }
  } else {
    throw new Error('Invalid provider');
  }
}
function throwProviderNotFoundError(token, injectorName) {
  const errorMessage = ngDevMode && `No provider for ${stringifyForError(token)} found${injectorName ? ` in ${injectorName}` : ''}`;
  throw new RuntimeError(-201, errorMessage);
}
function prependTokenToDependencyPath(error, token) {
  error[NG_TOKEN_PATH] ??= [];
  const currentPath = error[NG_TOKEN_PATH];
  let pathStr;
  if (typeof token === 'object' && 'multi' in token && token?.multi === true) {
    assertDefined(token.provide, 'Token with multi: true should have a provide property');
    pathStr = stringifyForError(token.provide);
  } else {
    pathStr = stringifyForError(token);
  }
  if (currentPath[0] !== pathStr) {
    error[NG_TOKEN_PATH].unshift(pathStr);
  }
}
function augmentRuntimeError(error, source) {
  const tokenPath = error[NG_TOKEN_PATH];
  const errorCode = error[NG_RUNTIME_ERROR_CODE];
  const message = error[NG_RUNTIME_ERROR_MESSAGE] || error.message;
  error.message = formatErrorMessage(message, errorCode, tokenPath, source);
  return error;
}
function createRuntimeError(message, code, path) {
  const error = new RuntimeError(code, message);
  error[NG_RUNTIME_ERROR_CODE] = code;
  error[NG_RUNTIME_ERROR_MESSAGE] = message;
  if (path) {
    error[NG_TOKEN_PATH] = path;
  }
  return error;
}
function getRuntimeErrorCode(error) {
  return error[NG_RUNTIME_ERROR_CODE];
}
function formatErrorMessage(text, code, path = [], source = null) {
  let pathDetails = '';
  if (path && path.length > 1) {
    pathDetails = ` Path: ${path.join(' -> ')}.`;
  }
  const sourceDetails = source ? ` Source: ${source}.` : '';
  return formatRuntimeError(code, `${text}${sourceDetails}${pathDetails}`);
}
let _injectImplementation;
function getInjectImplementation() {
  return _injectImplementation;
}
function setInjectImplementation(impl) {
  const previous = _injectImplementation;
  _injectImplementation = impl;
  return previous;
}
function injectRootLimpMode(token, notFoundValue, flags) {
  const injectableDef = getInjectableDef(token);
  if (injectableDef && injectableDef.providedIn == 'root') {
    return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() : injectableDef.value;
  }
  if (flags & 8) return null;
  if (notFoundValue !== undefined) return notFoundValue;
  throwProviderNotFoundError(token, 'Injector');
}
function assertInjectImplementationNotEqual(fn) {
  ngDevMode && assertNotEqual(_injectImplementation, fn, 'Calling ɵɵinject would cause infinite recursion');
}
const _THROW_IF_NOT_FOUND = {};
const THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
const DI_DECORATOR_FLAG = '__NG_DI_FLAG__';
class RetrievingInjector {
  injector;
  constructor(injector) {
    this.injector = injector;
  }
  retrieve(token, options) {
    const flags = convertToBitFlags(options) || 0;
    try {
      return this.injector.get(token, flags & 8 ? null : THROW_IF_NOT_FOUND, flags);
    } catch (e) {
      if ((0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__.isNotFound)(e)) {
        return e;
      }
      throw e;
    }
  }
}
function injectInjectorOnly(token, flags = 0) {
  const currentInjector = (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__.getCurrentInjector)();
  if (currentInjector === undefined) {
    throw new RuntimeError(-203, ngDevMode && `The \`${stringify(token)}\` token injection failed. \`inject()\` function must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with \`runInInjectionContext\`.`);
  } else if (currentInjector === null) {
    return injectRootLimpMode(token, undefined, flags);
  } else {
    const options = convertToInjectOptions(flags);
    const value = currentInjector.retrieve(token, options);
    ngDevMode && emitInjectEvent(token, value, flags);
    if ((0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__.isNotFound)(value)) {
      if (options.optional) {
        return null;
      }
      throw value;
    }
    return value;
  }
}
function ɵɵinject(token, flags = 0) {
  return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);
}
function ɵɵinvalidFactoryDep(index) {
  throw new RuntimeError(202, ngDevMode && `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.
This can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.

Please check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`);
}
function inject(token, options) {
  return ɵɵinject(token, convertToBitFlags(options));
}
function convertToBitFlags(flags) {
  if (typeof flags === 'undefined' || typeof flags === 'number') {
    return flags;
  }
  return 0 | (flags.optional && 8) | (flags.host && 1) | (flags.self && 2) | (flags.skipSelf && 4);
}
function convertToInjectOptions(flags) {
  return {
    optional: !!(flags & 8),
    host: !!(flags & 1),
    self: !!(flags & 2),
    skipSelf: !!(flags & 4)
  };
}
function injectArgs(types) {
  const args = [];
  for (let i = 0; i < types.length; i++) {
    const arg = resolveForwardRef(types[i]);
    if (Array.isArray(arg)) {
      if (arg.length === 0) {
        throw new RuntimeError(900, ngDevMode && 'Arguments array must have arguments.');
      }
      let type = undefined;
      let flags = 0;
      for (let j = 0; j < arg.length; j++) {
        const meta = arg[j];
        const flag = getInjectFlag(meta);
        if (typeof flag === 'number') {
          if (flag === -1) {
            type = meta.token;
          } else {
            flags |= flag;
          }
        } else {
          type = meta;
        }
      }
      args.push(ɵɵinject(type, flags));
    } else {
      args.push(ɵɵinject(arg));
    }
  }
  return args;
}
function attachInjectFlag(decorator, flag) {
  decorator[DI_DECORATOR_FLAG] = flag;
  decorator.prototype[DI_DECORATOR_FLAG] = flag;
  return decorator;
}
function getInjectFlag(token) {
  return token[DI_DECORATOR_FLAG];
}
function getFactoryDef(type, throwNotFound) {
  const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);
  if (!hasFactoryDef && throwNotFound === true && ngDevMode) {
    throw new Error(`Type ${stringify(type)} does not have 'ɵfac' property.`);
  }
  return hasFactoryDef ? type[NG_FACTORY_DEF] : null;
}
function arrayEquals(a, b, identityAccessor) {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    let valueA = a[i];
    let valueB = b[i];
    if (identityAccessor) {
      valueA = identityAccessor(valueA);
      valueB = identityAccessor(valueB);
    }
    if (valueB !== valueA) {
      return false;
    }
  }
  return true;
}
function flatten(list) {
  return list.flat(Number.POSITIVE_INFINITY);
}
function deepForEach(input, fn) {
  input.forEach(value => Array.isArray(value) ? deepForEach(value, fn) : fn(value));
}
function addToArray(arr, index, value) {
  if (index >= arr.length) {
    arr.push(value);
  } else {
    arr.splice(index, 0, value);
  }
}
function removeFromArray(arr, index) {
  if (index >= arr.length - 1) {
    return arr.pop();
  } else {
    return arr.splice(index, 1)[0];
  }
}
function newArray(size, value) {
  const list = [];
  for (let i = 0; i < size; i++) {
    list.push(value);
  }
  return list;
}
function arraySplice(array, index, count) {
  const length = array.length - count;
  while (index < length) {
    array[index] = array[index + count];
    index++;
  }
  while (count--) {
    array.pop();
  }
}
function arrayInsert2(array, index, value1, value2) {
  ngDevMode && assertLessThanOrEqual(index, array.length, "Can't insert past array end.");
  let end = array.length;
  if (end == index) {
    array.push(value1, value2);
  } else if (end === 1) {
    array.push(value2, array[0]);
    array[0] = value1;
  } else {
    end--;
    array.push(array[end - 1], array[end]);
    while (end > index) {
      const previousEnd = end - 2;
      array[end] = array[previousEnd];
      end--;
    }
    array[index] = value1;
    array[index + 1] = value2;
  }
}
function keyValueArraySet(keyValueArray, key, value) {
  let index = keyValueArrayIndexOf(keyValueArray, key);
  if (index >= 0) {
    keyValueArray[index | 1] = value;
  } else {
    index = ~index;
    arrayInsert2(keyValueArray, index, key, value);
  }
  return index;
}
function keyValueArrayGet(keyValueArray, key) {
  const index = keyValueArrayIndexOf(keyValueArray, key);
  if (index >= 0) {
    return keyValueArray[index | 1];
  }
  return undefined;
}
function keyValueArrayIndexOf(keyValueArray, key) {
  return _arrayIndexOfSorted(keyValueArray, key, 1);
}
function _arrayIndexOfSorted(array, value, shift) {
  ngDevMode && assertEqual(Array.isArray(array), true, 'Expecting an array');
  let start = 0;
  let end = array.length >> shift;
  while (end !== start) {
    const middle = start + (end - start >> 1);
    const current = array[middle << shift];
    if (value === current) {
      return middle << shift;
    } else if (current > value) {
      end = middle;
    } else {
      start = middle + 1;
    }
  }
  return ~(end << shift);
}
const EMPTY_OBJ = {};
const EMPTY_ARRAY = [];
if ((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode()) {
  Object.freeze(EMPTY_OBJ);
  Object.freeze(EMPTY_ARRAY);
}
const ENVIRONMENT_INITIALIZER = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'ENVIRONMENT_INITIALIZER' : '');
const INJECTOR$1 = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'INJECTOR' : '', -1);
const INJECTOR_DEF_TYPES = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'INJECTOR_DEF_TYPES' : '');
class NullInjector {
  get(token, notFoundValue = THROW_IF_NOT_FOUND) {
    if (notFoundValue === THROW_IF_NOT_FOUND) {
      const message = ngDevMode ? `No provider found for \`${stringify(token)}\`.` : '';
      const error = createRuntimeError(message, -201);
      error.name = 'ɵNotFound';
      throw error;
    }
    return notFoundValue;
  }
}
function makeEnvironmentProviders(providers) {
  return {
    ɵproviders: providers
  };
}
function provideEnvironmentInitializer(initializerFn) {
  return makeEnvironmentProviders([{
    provide: ENVIRONMENT_INITIALIZER,
    multi: true,
    useValue: initializerFn
  }]);
}
function importProvidersFrom(...sources) {
  return {
    ɵproviders: internalImportProvidersFrom(true, sources),
    ɵfromNgModule: true
  };
}
function internalImportProvidersFrom(checkForStandaloneCmp, ...sources) {
  const providersOut = [];
  const dedup = new Set();
  let injectorTypesWithProviders;
  const collectProviders = provider => {
    providersOut.push(provider);
  };
  deepForEach(sources, source => {
    if ((typeof ngDevMode === 'undefined' || ngDevMode) && checkForStandaloneCmp) {
      const cmpDef = getComponentDef(source);
      if (cmpDef?.standalone) {
        throw new RuntimeError(800, `Importing providers supports NgModule or ModuleWithProviders but got a standalone component "${stringifyForError(source)}"`);
      }
    }
    const internalSource = source;
    if (walkProviderTree(internalSource, collectProviders, [], dedup)) {
      injectorTypesWithProviders ||= [];
      injectorTypesWithProviders.push(internalSource);
    }
  });
  if (injectorTypesWithProviders !== undefined) {
    processInjectorTypesWithProviders(injectorTypesWithProviders, collectProviders);
  }
  return providersOut;
}
function processInjectorTypesWithProviders(typesWithProviders, visitor) {
  for (let i = 0; i < typesWithProviders.length; i++) {
    const {
      ngModule,
      providers
    } = typesWithProviders[i];
    deepForEachProvider(providers, provider => {
      ngDevMode && validateProvider(provider, providers || EMPTY_ARRAY, ngModule);
      visitor(provider, ngModule);
    });
  }
}
function walkProviderTree(container, visitor, parents, dedup) {
  container = resolveForwardRef(container);
  if (!container) return false;
  let defType = null;
  let injDef = getInjectorDef(container);
  const cmpDef = !injDef && getComponentDef(container);
  if (!injDef && !cmpDef) {
    const ngModule = container.ngModule;
    injDef = getInjectorDef(ngModule);
    if (injDef) {
      defType = ngModule;
    } else {
      return false;
    }
  } else if (cmpDef && !cmpDef.standalone) {
    return false;
  } else {
    defType = container;
  }
  if (ngDevMode && parents.indexOf(defType) !== -1) {
    const defName = stringify(defType);
    const path = parents.map(stringify).concat(defName);
    throw cyclicDependencyErrorWithDetails(defName, path);
  }
  const isDuplicate = dedup.has(defType);
  if (cmpDef) {
    if (isDuplicate) {
      return false;
    }
    dedup.add(defType);
    if (cmpDef.dependencies) {
      const deps = typeof cmpDef.dependencies === 'function' ? cmpDef.dependencies() : cmpDef.dependencies;
      for (const dep of deps) {
        walkProviderTree(dep, visitor, parents, dedup);
      }
    }
  } else if (injDef) {
    if (injDef.imports != null && !isDuplicate) {
      ngDevMode && parents.push(defType);
      dedup.add(defType);
      let importTypesWithProviders;
      try {
        deepForEach(injDef.imports, imported => {
          if (walkProviderTree(imported, visitor, parents, dedup)) {
            importTypesWithProviders ||= [];
            importTypesWithProviders.push(imported);
          }
        });
      } finally {
        ngDevMode && parents.pop();
      }
      if (importTypesWithProviders !== undefined) {
        processInjectorTypesWithProviders(importTypesWithProviders, visitor);
      }
    }
    if (!isDuplicate) {
      const factory = getFactoryDef(defType) || (() => new defType());
      visitor({
        provide: defType,
        useFactory: factory,
        deps: EMPTY_ARRAY
      }, defType);
      visitor({
        provide: INJECTOR_DEF_TYPES,
        useValue: defType,
        multi: true
      }, defType);
      visitor({
        provide: ENVIRONMENT_INITIALIZER,
        useValue: () => ɵɵinject(defType),
        multi: true
      }, defType);
    }
    const defProviders = injDef.providers;
    if (defProviders != null && !isDuplicate) {
      const injectorType = container;
      deepForEachProvider(defProviders, provider => {
        ngDevMode && validateProvider(provider, defProviders, injectorType);
        visitor(provider, injectorType);
      });
    }
  } else {
    return false;
  }
  return defType !== container && container.providers !== undefined;
}
function validateProvider(provider, providers, containerType) {
  if (isTypeProvider(provider) || isValueProvider(provider) || isFactoryProvider(provider) || isExistingProvider(provider)) {
    return;
  }
  const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
  if (!classRef) {
    throwInvalidProviderError(containerType, providers, provider);
  }
}
function deepForEachProvider(providers, fn) {
  for (let provider of providers) {
    if (isEnvironmentProviders(provider)) {
      provider = provider.ɵproviders;
    }
    if (Array.isArray(provider)) {
      deepForEachProvider(provider, fn);
    } else {
      fn(provider);
    }
  }
}
const USE_VALUE = getClosureSafeProperty({
  provide: String,
  useValue: getClosureSafeProperty
});
function isValueProvider(value) {
  return value !== null && typeof value == 'object' && USE_VALUE in value;
}
function isExistingProvider(value) {
  return !!(value && value.useExisting);
}
function isFactoryProvider(value) {
  return !!(value && value.useFactory);
}
function isTypeProvider(value) {
  return typeof value === 'function';
}
function isClassProvider(value) {
  return !!value.useClass;
}
const INJECTOR_SCOPE = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Set Injector scope.' : '');
const NOT_YET = {};
const CIRCULAR = {};
let NULL_INJECTOR = undefined;
function getNullInjector() {
  if (NULL_INJECTOR === undefined) {
    NULL_INJECTOR = new NullInjector();
  }
  return NULL_INJECTOR;
}
class EnvironmentInjector {}
class R3Injector extends EnvironmentInjector {
  parent;
  source;
  scopes;
  records = new Map();
  _ngOnDestroyHooks = new Set();
  _onDestroyHooks = [];
  get destroyed() {
    return this._destroyed;
  }
  _destroyed = false;
  injectorDefTypes;
  constructor(providers, parent, source, scopes) {
    super();
    this.parent = parent;
    this.source = source;
    this.scopes = scopes;
    forEachSingleProvider(providers, provider => this.processProvider(provider));
    this.records.set(INJECTOR$1, makeRecord(undefined, this));
    if (scopes.has('environment')) {
      this.records.set(EnvironmentInjector, makeRecord(undefined, this));
    }
    const record = this.records.get(INJECTOR_SCOPE);
    if (record != null && typeof record.value === 'string') {
      this.scopes.add(record.value);
    }
    this.injectorDefTypes = new Set(this.get(INJECTOR_DEF_TYPES, EMPTY_ARRAY, {
      self: true
    }));
  }
  retrieve(token, options) {
    const flags = convertToBitFlags(options) || 0;
    try {
      return this.get(token, THROW_IF_NOT_FOUND, flags);
    } catch (e) {
      if ((0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__.isNotFound)(e)) {
        return e;
      }
      throw e;
    }
  }
  destroy() {
    assertNotDestroyed(this);
    this._destroyed = true;
    const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.setActiveConsumer)(null);
    try {
      for (const service of this._ngOnDestroyHooks) {
        service.ngOnDestroy();
      }
      const onDestroyHooks = this._onDestroyHooks;
      this._onDestroyHooks = [];
      for (const hook of onDestroyHooks) {
        hook();
      }
    } finally {
      this.records.clear();
      this._ngOnDestroyHooks.clear();
      this.injectorDefTypes.clear();
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.setActiveConsumer)(prevConsumer);
    }
  }
  onDestroy(callback) {
    assertNotDestroyed(this);
    this._onDestroyHooks.push(callback);
    return () => this.removeOnDestroy(callback);
  }
  runInContext(fn) {
    assertNotDestroyed(this);
    const previousInjector = (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__.setCurrentInjector)(this);
    const previousInjectImplementation = setInjectImplementation(undefined);
    let prevInjectContext;
    if (ngDevMode) {
      prevInjectContext = setInjectorProfilerContext({
        injector: this,
        token: null
      });
    }
    try {
      return fn();
    } finally {
      (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__.setCurrentInjector)(previousInjector);
      setInjectImplementation(previousInjectImplementation);
      ngDevMode && setInjectorProfilerContext(prevInjectContext);
    }
  }
  get(token, notFoundValue = THROW_IF_NOT_FOUND, options) {
    assertNotDestroyed(this);
    if (token.hasOwnProperty(NG_ENV_ID)) {
      return token[NG_ENV_ID](this);
    }
    const flags = convertToBitFlags(options);
    let prevInjectContext;
    if (ngDevMode) {
      prevInjectContext = setInjectorProfilerContext({
        injector: this,
        token: token
      });
    }
    const previousInjector = (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__.setCurrentInjector)(this);
    const previousInjectImplementation = setInjectImplementation(undefined);
    try {
      if (!(flags & 4)) {
        let record = this.records.get(token);
        if (record === undefined) {
          const def = couldBeInjectableType(token) && getInjectableDef(token);
          if (def && this.injectableDefInScope(def)) {
            if (ngDevMode) {
              runInInjectorProfilerContext(this, token, () => {
                emitProviderConfiguredEvent(token);
              });
            }
            record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);
          } else {
            record = null;
          }
          this.records.set(token, record);
        }
        if (record != null) {
          return this.hydrate(token, record, flags);
        }
      }
      const nextInjector = !(flags & 2) ? this.parent : getNullInjector();
      notFoundValue = flags & 8 && notFoundValue === THROW_IF_NOT_FOUND ? null : notFoundValue;
      return nextInjector.get(token, notFoundValue);
    } catch (error) {
      const errorCode = getRuntimeErrorCode(error);
      if (errorCode === -200 || errorCode === -201) {
        if (ngDevMode) {
          prependTokenToDependencyPath(error, token);
          if (previousInjector) {
            throw error;
          } else {
            throw augmentRuntimeError(error, this.source);
          }
        } else {
          throw new RuntimeError(errorCode, null);
        }
      } else {
        throw error;
      }
    } finally {
      setInjectImplementation(previousInjectImplementation);
      (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__.setCurrentInjector)(previousInjector);
      ngDevMode && setInjectorProfilerContext(prevInjectContext);
    }
  }
  resolveInjectorInitializers() {
    const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.setActiveConsumer)(null);
    const previousInjector = (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__.setCurrentInjector)(this);
    const previousInjectImplementation = setInjectImplementation(undefined);
    let prevInjectContext;
    if (ngDevMode) {
      prevInjectContext = setInjectorProfilerContext({
        injector: this,
        token: null
      });
    }
    try {
      const initializers = this.get(ENVIRONMENT_INITIALIZER, EMPTY_ARRAY, {
        self: true
      });
      if (ngDevMode && !Array.isArray(initializers)) {
        throw new RuntimeError(-209, 'Unexpected type of the `ENVIRONMENT_INITIALIZER` token value ' + `(expected an array, but got ${typeof initializers}). ` + 'Please check that the `ENVIRONMENT_INITIALIZER` token is configured as a ' + '`multi: true` provider.');
      }
      for (const initializer of initializers) {
        initializer();
      }
    } finally {
      (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__.setCurrentInjector)(previousInjector);
      setInjectImplementation(previousInjectImplementation);
      ngDevMode && setInjectorProfilerContext(prevInjectContext);
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.setActiveConsumer)(prevConsumer);
    }
  }
  toString() {
    const tokens = [];
    const records = this.records;
    for (const token of records.keys()) {
      tokens.push(stringify(token));
    }
    return `R3Injector[${tokens.join(', ')}]`;
  }
  processProvider(provider) {
    provider = resolveForwardRef(provider);
    let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide);
    const record = providerToRecord(provider);
    if (ngDevMode) {
      runInInjectorProfilerContext(this, token, () => {
        if (isValueProvider(provider)) {
          emitInjectorToCreateInstanceEvent(token);
          emitInstanceCreatedByInjectorEvent(provider.useValue);
        }
        emitProviderConfiguredEvent(provider);
      });
    }
    if (!isTypeProvider(provider) && provider.multi === true) {
      let multiRecord = this.records.get(token);
      if (multiRecord) {
        if (ngDevMode && multiRecord.multi === undefined) {
          throwMixedMultiProviderError();
        }
      } else {
        multiRecord = makeRecord(undefined, NOT_YET, true);
        multiRecord.factory = () => injectArgs(multiRecord.multi);
        this.records.set(token, multiRecord);
      }
      token = provider;
      multiRecord.multi.push(provider);
    } else {
      if (ngDevMode) {
        const existing = this.records.get(token);
        if (existing && existing.multi !== undefined) {
          throwMixedMultiProviderError();
        }
      }
    }
    this.records.set(token, record);
  }
  hydrate(token, record, flags) {
    const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.setActiveConsumer)(null);
    try {
      if (record.value === CIRCULAR) {
        throw cyclicDependencyError(stringify(token));
      } else if (record.value === NOT_YET) {
        record.value = CIRCULAR;
        if (ngDevMode) {
          runInInjectorProfilerContext(this, token, () => {
            emitInjectorToCreateInstanceEvent(token);
            record.value = record.factory(undefined, flags);
            emitInstanceCreatedByInjectorEvent(record.value);
          });
        } else {
          record.value = record.factory(undefined, flags);
        }
      }
      if (typeof record.value === 'object' && record.value && hasOnDestroy(record.value)) {
        this._ngOnDestroyHooks.add(record.value);
      }
      return record.value;
    } finally {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.setActiveConsumer)(prevConsumer);
    }
  }
  injectableDefInScope(def) {
    if (!def.providedIn) {
      return false;
    }
    const providedIn = resolveForwardRef(def.providedIn);
    if (typeof providedIn === 'string') {
      return providedIn === 'any' || this.scopes.has(providedIn);
    } else {
      return this.injectorDefTypes.has(providedIn);
    }
  }
  removeOnDestroy(callback) {
    const destroyCBIdx = this._onDestroyHooks.indexOf(callback);
    if (destroyCBIdx !== -1) {
      this._onDestroyHooks.splice(destroyCBIdx, 1);
    }
  }
}
function injectableDefOrInjectorDefFactory(token) {
  const injectableDef = getInjectableDef(token);
  const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);
  if (factory !== null) {
    return factory;
  }
  if (token instanceof InjectionToken) {
    throw new RuntimeError(204, ngDevMode && `Token ${stringify(token)} is missing a ɵprov definition.`);
  }
  if (token instanceof Function) {
    return getUndecoratedInjectableFactory(token);
  }
  throw new RuntimeError(204, ngDevMode && 'unreachable');
}
function getUndecoratedInjectableFactory(token) {
  const paramLength = token.length;
  if (paramLength > 0) {
    throw new RuntimeError(204, ngDevMode && `Can't resolve all parameters for ${stringify(token)}: (${newArray(paramLength, '?').join(', ')}).`);
  }
  const inheritedInjectableDef = getInheritedInjectableDef(token);
  if (inheritedInjectableDef !== null) {
    return () => inheritedInjectableDef.factory(token);
  } else {
    return () => new token();
  }
}
function providerToRecord(provider) {
  if (isValueProvider(provider)) {
    return makeRecord(undefined, provider.useValue);
  } else {
    const factory = providerToFactory(provider);
    return makeRecord(factory, NOT_YET);
  }
}
function providerToFactory(provider, ngModuleType, providers) {
  let factory = undefined;
  if (ngDevMode && isEnvironmentProviders(provider)) {
    throwInvalidProviderError(undefined, providers, provider);
  }
  if (isTypeProvider(provider)) {
    const unwrappedProvider = resolveForwardRef(provider);
    return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);
  } else {
    if (isValueProvider(provider)) {
      factory = () => resolveForwardRef(provider.useValue);
    } else if (isFactoryProvider(provider)) {
      factory = () => provider.useFactory(...injectArgs(provider.deps || []));
    } else if (isExistingProvider(provider)) {
      factory = (_, flags) => ɵɵinject(resolveForwardRef(provider.useExisting), flags !== undefined && flags & 8 ? 8 : undefined);
    } else {
      const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
      if (ngDevMode && !classRef) {
        throwInvalidProviderError(ngModuleType, providers, provider);
      }
      if (hasDeps(provider)) {
        factory = () => new classRef(...injectArgs(provider.deps));
      } else {
        return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);
      }
    }
  }
  return factory;
}
function assertNotDestroyed(injector) {
  if (injector.destroyed) {
    throw new RuntimeError(205, ngDevMode && 'Injector has already been destroyed.');
  }
}
function makeRecord(factory, value, multi = false) {
  return {
    factory: factory,
    value: value,
    multi: multi ? [] : undefined
  };
}
function hasDeps(value) {
  return !!value.deps;
}
function hasOnDestroy(value) {
  return value !== null && typeof value === 'object' && typeof value.ngOnDestroy === 'function';
}
function couldBeInjectableType(value) {
  return typeof value === 'function' || typeof value === 'object' && value.ngMetadataName === 'InjectionToken';
}
function forEachSingleProvider(providers, fn) {
  for (const provider of providers) {
    if (Array.isArray(provider)) {
      forEachSingleProvider(provider, fn);
    } else if (provider && isEnvironmentProviders(provider)) {
      forEachSingleProvider(provider.ɵproviders, fn);
    } else {
      fn(provider);
    }
  }
}
function runInInjectionContext(injector, fn) {
  let internalInjector;
  if (injector instanceof R3Injector) {
    assertNotDestroyed(injector);
    internalInjector = injector;
  } else {
    internalInjector = new RetrievingInjector(injector);
  }
  let prevInjectorProfilerContext;
  if (ngDevMode) {
    prevInjectorProfilerContext = setInjectorProfilerContext({
      injector,
      token: null
    });
  }
  const prevInjector = (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__.setCurrentInjector)(internalInjector);
  const previousInjectImplementation = setInjectImplementation(undefined);
  try {
    return fn();
  } finally {
    (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__.setCurrentInjector)(prevInjector);
    ngDevMode && setInjectorProfilerContext(prevInjectorProfilerContext);
    setInjectImplementation(previousInjectImplementation);
  }
}
function isInInjectionContext() {
  return getInjectImplementation() !== undefined || (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__.getCurrentInjector)() != null;
}
function assertInInjectionContext(debugFn) {
  if (!isInInjectionContext()) {
    throw new RuntimeError(-203, ngDevMode && debugFn.name + '() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext`');
  }
}
const HOST = 0;
const TVIEW = 1;
const FLAGS = 2;
const PARENT = 3;
const NEXT = 4;
const T_HOST = 5;
const HYDRATION = 6;
const CLEANUP = 7;
const CONTEXT = 8;
const INJECTOR = 9;
const ENVIRONMENT = 10;
const RENDERER = 11;
const CHILD_HEAD = 12;
const CHILD_TAIL = 13;
const DECLARATION_VIEW = 14;
const DECLARATION_COMPONENT_VIEW = 15;
const DECLARATION_LCONTAINER = 16;
const PREORDER_HOOK_FLAGS = 17;
const QUERIES = 18;
const ID = 19;
const EMBEDDED_VIEW_INJECTOR = 20;
const ON_DESTROY_HOOKS = 21;
const EFFECTS_TO_SCHEDULE = 22;
const EFFECTS = 23;
const REACTIVE_TEMPLATE_CONSUMER = 24;
const AFTER_RENDER_SEQUENCES_TO_ADD = 25;
const ANIMATIONS = 26;
const HEADER_OFFSET = 27;
const TYPE = 1;
const DEHYDRATED_VIEWS = 6;
const NATIVE = 7;
const VIEW_REFS = 8;
const MOVED_VIEWS = 9;
const CONTAINER_HEADER_OFFSET = 10;
function isLView(value) {
  return Array.isArray(value) && typeof value[TYPE] === 'object';
}
function isLContainer(value) {
  return Array.isArray(value) && value[TYPE] === true;
}
function isContentQueryHost(tNode) {
  return (tNode.flags & 4) !== 0;
}
function isComponentHost(tNode) {
  return tNode.componentOffset > -1;
}
function isDirectiveHost(tNode) {
  return (tNode.flags & 1) === 1;
}
function isComponentDef(def) {
  return !!def.template;
}
function isRootView(target) {
  return (target[FLAGS] & 512) !== 0;
}
function isProjectionTNode(tNode) {
  return (tNode.type & 16) === 16;
}
function hasI18n(lView) {
  return (lView[FLAGS] & 32) === 32;
}
function isDestroyed(lView) {
  return (lView[FLAGS] & 256) === 256;
}
function assertTNodeForLView(tNode, lView) {
  assertTNodeForTView(tNode, lView[TVIEW]);
}
function assertTNodeCreationIndex(lView, index) {
  const adjustedIndex = index + HEADER_OFFSET;
  assertIndexInRange(lView, adjustedIndex);
  assertLessThan(adjustedIndex, lView[TVIEW].bindingStartIndex, 'TNodes should be created before any bindings');
}
function assertTNodeForTView(tNode, tView) {
  assertTNode(tNode);
  const tData = tView.data;
  for (let i = HEADER_OFFSET; i < tData.length; i++) {
    if (tData[i] === tNode) {
      return;
    }
  }
  throwError('This TNode does not belong to this TView.');
}
function assertTNode(tNode) {
  assertDefined(tNode, 'TNode must be defined');
  if (!(tNode && typeof tNode === 'object' && tNode.hasOwnProperty('directiveStylingLast'))) {
    throwError('Not of type TNode, got: ' + tNode);
  }
}
function assertTIcu(tIcu) {
  assertDefined(tIcu, 'Expected TIcu to be defined');
  if (!(typeof tIcu.currentCaseLViewIndex === 'number')) {
    throwError('Object is not of TIcu type.');
  }
}
function assertComponentType(actual, msg = "Type passed in is not ComponentType, it does not have 'ɵcmp' property.") {
  if (!getComponentDef(actual)) {
    throwError(msg);
  }
}
function assertNgModuleType(actual, msg = "Type passed in is not NgModuleType, it does not have 'ɵmod' property.") {
  if (!getNgModuleDef(actual)) {
    throwError(msg);
  }
}
function assertHasParent(tNode) {
  assertDefined(tNode, 'currentTNode should exist!');
  assertDefined(tNode.parent, 'currentTNode should have a parent');
}
function assertLContainer(value) {
  assertDefined(value, 'LContainer must be defined');
  assertEqual(isLContainer(value), true, 'Expecting LContainer');
}
function assertLViewOrUndefined(value) {
  value && assertEqual(isLView(value), true, 'Expecting LView or undefined or null');
}
function assertLView(value) {
  assertDefined(value, 'LView must be defined');
  assertEqual(isLView(value), true, 'Expecting LView');
}
function assertFirstCreatePass(tView, errMessage) {
  assertEqual(tView.firstCreatePass, true, errMessage || 'Should only be called in first create pass.');
}
function assertFirstUpdatePass(tView, errMessage) {
  assertEqual(tView.firstUpdatePass, true, 'Should only be called in first update pass.');
}
function assertDirectiveDef(obj) {
  if (obj.type === undefined || obj.selectors == undefined || obj.inputs === undefined) {
    throwError(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);
  }
}
function assertIndexInDeclRange(tView, index) {
  assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);
}
function assertIndexInExpandoRange(lView, index) {
  const tView = lView[1];
  assertBetween(tView.expandoStartIndex, lView.length, index);
}
function assertBetween(lower, upper, index) {
  if (!(lower <= index && index < upper)) {
    throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);
  }
}
function assertProjectionSlots(lView, errMessage) {
  assertDefined(lView[DECLARATION_COMPONENT_VIEW], 'Component views should exist.');
  assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, 'Components with projection nodes (<ng-content>) must have projection slots defined.');
}
function assertParentView(lView, errMessage) {
  assertDefined(lView, "Component views should always have a parent view (component's host view)");
}
function assertNodeInjector(lView, injectorIndex) {
  assertIndexInExpandoRange(lView, injectorIndex);
  assertIndexInExpandoRange(lView, injectorIndex + 8);
  assertNumber(lView[injectorIndex + 0], 'injectorIndex should point to a bloom filter');
  assertNumber(lView[injectorIndex + 1], 'injectorIndex should point to a bloom filter');
  assertNumber(lView[injectorIndex + 2], 'injectorIndex should point to a bloom filter');
  assertNumber(lView[injectorIndex + 3], 'injectorIndex should point to a bloom filter');
  assertNumber(lView[injectorIndex + 4], 'injectorIndex should point to a bloom filter');
  assertNumber(lView[injectorIndex + 5], 'injectorIndex should point to a bloom filter');
  assertNumber(lView[injectorIndex + 6], 'injectorIndex should point to a bloom filter');
  assertNumber(lView[injectorIndex + 7], 'injectorIndex should point to a bloom filter');
  assertNumber(lView[injectorIndex + 8], 'injectorIndex should point to parent injector');
}
const SVG_NAMESPACE = 'svg';
const MATH_ML_NAMESPACE = 'math';
function unwrapRNode(value) {
  while (Array.isArray(value)) {
    value = value[HOST];
  }
  return value;
}
function unwrapLView(value) {
  while (Array.isArray(value)) {
    if (typeof value[TYPE] === 'object') return value;
    value = value[HOST];
  }
  return null;
}
function getNativeByIndex(index, lView) {
  ngDevMode && assertIndexInRange(lView, index);
  ngDevMode && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Expected to be past HEADER_OFFSET');
  return unwrapRNode(lView[index]);
}
function getNativeByTNode(tNode, lView) {
  ngDevMode && assertTNodeForLView(tNode, lView);
  ngDevMode && assertIndexInRange(lView, tNode.index);
  const node = unwrapRNode(lView[tNode.index]);
  return node;
}
function getNativeByTNodeOrNull(tNode, lView) {
  const index = tNode === null ? -1 : tNode.index;
  if (index !== -1) {
    ngDevMode && assertTNodeForLView(tNode, lView);
    const node = unwrapRNode(lView[index]);
    return node;
  }
  return null;
}
function getTNode(tView, index) {
  ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');
  ngDevMode && assertLessThan(index, tView.data.length, 'wrong index for TNode');
  const tNode = tView.data[index];
  ngDevMode && tNode !== null && assertTNode(tNode);
  return tNode;
}
function load(view, index) {
  ngDevMode && assertIndexInRange(view, index);
  return view[index];
}
function store(tView, lView, index, value) {
  if (index >= tView.data.length) {
    tView.data[index] = null;
    tView.blueprint[index] = null;
  }
  lView[index] = value;
}
function getComponentLViewByIndex(nodeIndex, hostView) {
  ngDevMode && assertIndexInRange(hostView, nodeIndex);
  const slotValue = hostView[nodeIndex];
  const lView = isLView(slotValue) ? slotValue : slotValue[HOST];
  return lView;
}
function isCreationMode(view) {
  return (view[FLAGS] & 4) === 4;
}
function viewAttachedToChangeDetector(view) {
  return (view[FLAGS] & 128) === 128;
}
function viewAttachedToContainer(view) {
  return isLContainer(view[PARENT]);
}
function getConstant(consts, index) {
  if (index === null || index === undefined) return null;
  ngDevMode && assertIndexInRange(consts, index);
  return consts[index];
}
function resetPreOrderHookFlags(lView) {
  lView[PREORDER_HOOK_FLAGS] = 0;
}
function markViewForRefresh(lView) {
  if (lView[FLAGS] & 1024) {
    return;
  }
  lView[FLAGS] |= 1024;
  if (viewAttachedToChangeDetector(lView)) {
    markAncestorsForTraversal(lView);
  }
}
function walkUpViews(nestingLevel, currentView) {
  while (nestingLevel > 0) {
    ngDevMode && assertDefined(currentView[DECLARATION_VIEW], 'Declaration view should be defined if nesting level is greater than 0.');
    currentView = currentView[DECLARATION_VIEW];
    nestingLevel--;
  }
  return currentView;
}
function requiresRefreshOrTraversal(lView) {
  return !!(lView[FLAGS] & (1024 | 8192) || lView[REACTIVE_TEMPLATE_CONSUMER]?.dirty);
}
function updateAncestorTraversalFlagsOnAttach(lView) {
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(8);
  if (lView[FLAGS] & 64) {
    lView[FLAGS] |= 1024;
  }
  if (requiresRefreshOrTraversal(lView)) {
    markAncestorsForTraversal(lView);
  }
}
function markAncestorsForTraversal(lView) {
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(0);
  let parent = getLViewParent(lView);
  while (parent !== null) {
    if (parent[FLAGS] & 8192) {
      break;
    }
    parent[FLAGS] |= 8192;
    if (!viewAttachedToChangeDetector(parent)) {
      break;
    }
    parent = getLViewParent(parent);
  }
}
function storeLViewOnDestroy(lView, onDestroyCallback) {
  if (isDestroyed(lView)) {
    throw new RuntimeError(911, ngDevMode && 'View has already been destroyed.');
  }
  if (lView[ON_DESTROY_HOOKS] === null) {
    lView[ON_DESTROY_HOOKS] = [];
  }
  lView[ON_DESTROY_HOOKS].push(onDestroyCallback);
}
function removeLViewOnDestroy(lView, onDestroyCallback) {
  if (lView[ON_DESTROY_HOOKS] === null) return;
  const destroyCBIdx = lView[ON_DESTROY_HOOKS].indexOf(onDestroyCallback);
  if (destroyCBIdx !== -1) {
    lView[ON_DESTROY_HOOKS].splice(destroyCBIdx, 1);
  }
}
function getLViewParent(lView) {
  ngDevMode && assertLView(lView);
  const parent = lView[PARENT];
  return isLContainer(parent) ? parent[PARENT] : parent;
}
function getOrCreateLViewCleanup(view) {
  return view[CLEANUP] ??= [];
}
function getOrCreateTViewCleanup(tView) {
  return tView.cleanup ??= [];
}
function storeCleanupWithContext(tView, lView, context, cleanupFn) {
  const lCleanup = getOrCreateLViewCleanup(lView);
  ngDevMode && assertDefined(context, 'Cleanup context is mandatory when registering framework-level destroy hooks');
  lCleanup.push(context);
  if (tView.firstCreatePass) {
    getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);
  } else {
    if (ngDevMode) {
      Object.freeze(getOrCreateTViewCleanup(tView));
    }
  }
}
const instructionState = {
  lFrame: createLFrame(null),
  bindingsEnabled: true,
  skipHydrationRootTNode: null
};
var CheckNoChangesMode;
(function (CheckNoChangesMode) {
  CheckNoChangesMode[CheckNoChangesMode["Off"] = 0] = "Off";
  CheckNoChangesMode[CheckNoChangesMode["Exhaustive"] = 1] = "Exhaustive";
  CheckNoChangesMode[CheckNoChangesMode["OnlyDirtyViews"] = 2] = "OnlyDirtyViews";
})(CheckNoChangesMode || (CheckNoChangesMode = {}));
let _checkNoChangesMode = 0;
let _isRefreshingViews = false;
function getElementDepthCount() {
  return instructionState.lFrame.elementDepthCount;
}
function increaseElementDepthCount() {
  instructionState.lFrame.elementDepthCount++;
}
function decreaseElementDepthCount() {
  instructionState.lFrame.elementDepthCount--;
}
function getBindingsEnabled() {
  return instructionState.bindingsEnabled;
}
function isInSkipHydrationBlock() {
  return instructionState.skipHydrationRootTNode !== null;
}
function isSkipHydrationRootTNode(tNode) {
  return instructionState.skipHydrationRootTNode === tNode;
}
function ɵɵenableBindings() {
  instructionState.bindingsEnabled = true;
}
function enterSkipHydrationBlock(tNode) {
  instructionState.skipHydrationRootTNode = tNode;
}
function ɵɵdisableBindings() {
  instructionState.bindingsEnabled = false;
}
function leaveSkipHydrationBlock() {
  instructionState.skipHydrationRootTNode = null;
}
function getLView() {
  return instructionState.lFrame.lView;
}
function getTView() {
  return instructionState.lFrame.tView;
}
function ɵɵrestoreView(viewToRestore) {
  instructionState.lFrame.contextLView = viewToRestore;
  return viewToRestore[CONTEXT];
}
function ɵɵresetView(value) {
  instructionState.lFrame.contextLView = null;
  return value;
}
function getCurrentTNode() {
  let currentTNode = getCurrentTNodePlaceholderOk();
  while (currentTNode !== null && currentTNode.type === 64) {
    currentTNode = currentTNode.parent;
  }
  return currentTNode;
}
function getCurrentTNodePlaceholderOk() {
  return instructionState.lFrame.currentTNode;
}
function getCurrentParentTNode() {
  const lFrame = instructionState.lFrame;
  const currentTNode = lFrame.currentTNode;
  return lFrame.isParent ? currentTNode : currentTNode.parent;
}
function setCurrentTNode(tNode, isParent) {
  ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);
  const lFrame = instructionState.lFrame;
  lFrame.currentTNode = tNode;
  lFrame.isParent = isParent;
}
function isCurrentTNodeParent() {
  return instructionState.lFrame.isParent;
}
function setCurrentTNodeAsNotParent() {
  instructionState.lFrame.isParent = false;
}
function getContextLView() {
  const contextLView = instructionState.lFrame.contextLView;
  ngDevMode && assertDefined(contextLView, 'contextLView must be defined.');
  return contextLView;
}
function isInCheckNoChangesMode() {
  !ngDevMode && throwError('Must never be called in production mode');
  return _checkNoChangesMode !== CheckNoChangesMode.Off;
}
function isExhaustiveCheckNoChanges() {
  !ngDevMode && throwError('Must never be called in production mode');
  return _checkNoChangesMode === CheckNoChangesMode.Exhaustive;
}
function setIsInCheckNoChangesMode(mode) {
  !ngDevMode && throwError('Must never be called in production mode');
  _checkNoChangesMode = mode;
}
function isRefreshingViews() {
  return _isRefreshingViews;
}
function setIsRefreshingViews(mode) {
  const prev = _isRefreshingViews;
  _isRefreshingViews = mode;
  return prev;
}
function getBindingRoot() {
  const lFrame = instructionState.lFrame;
  let index = lFrame.bindingRootIndex;
  if (index === -1) {
    index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;
  }
  return index;
}
function getBindingIndex() {
  return instructionState.lFrame.bindingIndex;
}
function setBindingIndex(value) {
  return instructionState.lFrame.bindingIndex = value;
}
function nextBindingIndex() {
  return instructionState.lFrame.bindingIndex++;
}
function incrementBindingIndex(count) {
  const lFrame = instructionState.lFrame;
  const index = lFrame.bindingIndex;
  lFrame.bindingIndex = lFrame.bindingIndex + count;
  return index;
}
function isInI18nBlock() {
  return instructionState.lFrame.inI18n;
}
function setInI18nBlock(isInI18nBlock) {
  instructionState.lFrame.inI18n = isInI18nBlock;
}
function setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {
  const lFrame = instructionState.lFrame;
  lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;
  setCurrentDirectiveIndex(currentDirectiveIndex);
}
function getCurrentDirectiveIndex() {
  return instructionState.lFrame.currentDirectiveIndex;
}
function setCurrentDirectiveIndex(currentDirectiveIndex) {
  instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;
}
function getCurrentDirectiveDef(tData) {
  const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;
  return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];
}
function getCurrentQueryIndex() {
  return instructionState.lFrame.currentQueryIndex;
}
function setCurrentQueryIndex(value) {
  instructionState.lFrame.currentQueryIndex = value;
}
function getDeclarationTNode(lView) {
  const tView = lView[TVIEW];
  if (tView.type === 2) {
    ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');
    return tView.declTNode;
  }
  if (tView.type === 1) {
    return lView[T_HOST];
  }
  return null;
}
function enterDI(lView, tNode, flags) {
  ngDevMode && assertLViewOrUndefined(lView);
  if (flags & 4) {
    ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);
    let parentTNode = tNode;
    let parentLView = lView;
    while (true) {
      ngDevMode && assertDefined(parentTNode, 'Parent TNode should be defined');
      parentTNode = parentTNode.parent;
      if (parentTNode === null && !(flags & 1)) {
        parentTNode = getDeclarationTNode(parentLView);
        if (parentTNode === null) break;
        ngDevMode && assertDefined(parentLView, 'Parent LView should be defined');
        parentLView = parentLView[DECLARATION_VIEW];
        if (parentTNode.type & (2 | 8)) {
          break;
        }
      } else {
        break;
      }
    }
    if (parentTNode === null) {
      return false;
    } else {
      tNode = parentTNode;
      lView = parentLView;
    }
  }
  ngDevMode && assertTNodeForLView(tNode, lView);
  const lFrame = instructionState.lFrame = allocLFrame();
  lFrame.currentTNode = tNode;
  lFrame.lView = lView;
  return true;
}
function enterView(newView) {
  ngDevMode && assertNotEqual(newView[0], newView[1], '????');
  ngDevMode && assertLViewOrUndefined(newView);
  const newLFrame = allocLFrame();
  if (ngDevMode) {
    assertEqual(newLFrame.isParent, true, 'Expected clean LFrame');
    assertEqual(newLFrame.lView, null, 'Expected clean LFrame');
    assertEqual(newLFrame.tView, null, 'Expected clean LFrame');
    assertEqual(newLFrame.selectedIndex, -1, 'Expected clean LFrame');
    assertEqual(newLFrame.elementDepthCount, 0, 'Expected clean LFrame');
    assertEqual(newLFrame.currentDirectiveIndex, -1, 'Expected clean LFrame');
    assertEqual(newLFrame.currentNamespace, null, 'Expected clean LFrame');
    assertEqual(newLFrame.bindingRootIndex, -1, 'Expected clean LFrame');
    assertEqual(newLFrame.currentQueryIndex, 0, 'Expected clean LFrame');
  }
  const tView = newView[TVIEW];
  instructionState.lFrame = newLFrame;
  ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);
  newLFrame.currentTNode = tView.firstChild;
  newLFrame.lView = newView;
  newLFrame.tView = tView;
  newLFrame.contextLView = newView;
  newLFrame.bindingIndex = tView.bindingStartIndex;
  newLFrame.inI18n = false;
}
function allocLFrame() {
  const currentLFrame = instructionState.lFrame;
  const childLFrame = currentLFrame === null ? null : currentLFrame.child;
  const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;
  return newLFrame;
}
function createLFrame(parent) {
  const lFrame = {
    currentTNode: null,
    isParent: true,
    lView: null,
    tView: null,
    selectedIndex: -1,
    contextLView: null,
    elementDepthCount: 0,
    currentNamespace: null,
    currentDirectiveIndex: -1,
    bindingRootIndex: -1,
    bindingIndex: -1,
    currentQueryIndex: 0,
    parent: parent,
    child: null,
    inI18n: false
  };
  parent !== null && (parent.child = lFrame);
  return lFrame;
}
function leaveViewLight() {
  const oldLFrame = instructionState.lFrame;
  instructionState.lFrame = oldLFrame.parent;
  oldLFrame.currentTNode = null;
  oldLFrame.lView = null;
  return oldLFrame;
}
const leaveDI = leaveViewLight;
function leaveView() {
  const oldLFrame = leaveViewLight();
  oldLFrame.isParent = true;
  oldLFrame.tView = null;
  oldLFrame.selectedIndex = -1;
  oldLFrame.contextLView = null;
  oldLFrame.elementDepthCount = 0;
  oldLFrame.currentDirectiveIndex = -1;
  oldLFrame.currentNamespace = null;
  oldLFrame.bindingRootIndex = -1;
  oldLFrame.bindingIndex = -1;
  oldLFrame.currentQueryIndex = 0;
}
function nextContextImpl(level) {
  const contextLView = instructionState.lFrame.contextLView = walkUpViews(level, instructionState.lFrame.contextLView);
  return contextLView[CONTEXT];
}
function getSelectedIndex() {
  return instructionState.lFrame.selectedIndex;
}
function setSelectedIndex(index) {
  ngDevMode && index !== -1 && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Index must be past HEADER_OFFSET (or -1).');
  ngDevMode && assertLessThan(index, instructionState.lFrame.lView.length, "Can't set index passed end of LView");
  instructionState.lFrame.selectedIndex = index;
}
function getSelectedTNode() {
  const lFrame = instructionState.lFrame;
  return getTNode(lFrame.tView, lFrame.selectedIndex);
}
function ɵɵnamespaceSVG() {
  instructionState.lFrame.currentNamespace = SVG_NAMESPACE;
}
function ɵɵnamespaceMathML() {
  instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;
}
function ɵɵnamespaceHTML() {
  namespaceHTMLInternal();
}
function namespaceHTMLInternal() {
  instructionState.lFrame.currentNamespace = null;
}
function getNamespace() {
  return instructionState.lFrame.currentNamespace;
}
let _wasLastNodeCreated = true;
function wasLastNodeCreated() {
  return _wasLastNodeCreated;
}
function lastNodeWasCreated(flag) {
  _wasLastNodeCreated = flag;
}
function createInjector(defType, parent = null, additionalProviders = null, name) {
  const injector = createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);
  injector.resolveInjectorInitializers();
  return injector;
}
function createInjectorWithoutInjectorInstances(defType, parent = null, additionalProviders = null, name, scopes = new Set()) {
  const providers = [additionalProviders || EMPTY_ARRAY, importProvidersFrom(defType)];
  name = name || (typeof defType === 'object' ? undefined : stringify(defType));
  return new R3Injector(providers, parent || getNullInjector(), name || null, scopes);
}
class Injector {
  static THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;
  static NULL = new NullInjector();
  static create(options, parent) {
    if (Array.isArray(options)) {
      return createInjector({
        name: ''
      }, parent, options, '');
    } else {
      const name = options.name ?? '';
      return createInjector({
        name
      }, options.parent, options.providers, name);
    }
  }
  static ɵprov = /* @__PURE__ */
  ɵɵdefineInjectable({
    token: Injector,
    providedIn: 'any',
    factory: () => ɵɵinject(INJECTOR$1)
  });
  static __NG_ELEMENT_ID__ = -1;
}
const DOCUMENT = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'DocumentToken' : '');
class DestroyRef {
  static __NG_ELEMENT_ID__ = injectDestroyRef;
  static __NG_ENV_ID__ = injector => injector;
}
class NodeInjectorDestroyRef extends DestroyRef {
  _lView;
  constructor(_lView) {
    super();
    this._lView = _lView;
  }
  get destroyed() {
    return isDestroyed(this._lView);
  }
  onDestroy(callback) {
    const lView = this._lView;
    storeLViewOnDestroy(lView, callback);
    return () => removeLViewOnDestroy(lView, callback);
  }
}
function injectDestroyRef() {
  return new NodeInjectorDestroyRef(getLView());
}
const SCHEDULE_IN_ROOT_ZONE_DEFAULT = false;
class PendingTasksInternal {
  taskId = 0;
  pendingTasks = new Set();
  destroyed = false;
  pendingTask = new rxjs__WEBPACK_IMPORTED_MODULE_3__.BehaviorSubject(false);
  get hasPendingTasks() {
    return this.destroyed ? false : this.pendingTask.value;
  }
  get hasPendingTasksObservable() {
    if (this.destroyed) {
      return new rxjs__WEBPACK_IMPORTED_MODULE_1__.Observable(subscriber => {
        subscriber.next(false);
        subscriber.complete();
      });
    }
    return this.pendingTask;
  }
  add() {
    if (!this.hasPendingTasks && !this.destroyed) {
      this.pendingTask.next(true);
    }
    const taskId = this.taskId++;
    this.pendingTasks.add(taskId);
    return taskId;
  }
  has(taskId) {
    return this.pendingTasks.has(taskId);
  }
  remove(taskId) {
    this.pendingTasks.delete(taskId);
    if (this.pendingTasks.size === 0 && this.hasPendingTasks) {
      this.pendingTask.next(false);
    }
  }
  ngOnDestroy() {
    this.pendingTasks.clear();
    if (this.hasPendingTasks) {
      this.pendingTask.next(false);
    }
    this.destroyed = true;
    this.pendingTask.unsubscribe();
  }
  static ɵprov = /* @__PURE__ */
  ɵɵdefineInjectable({
    token: PendingTasksInternal,
    providedIn: 'root',
    factory: () => new PendingTasksInternal()
  });
}
class EventEmitter_ extends rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject {
  __isAsync;
  destroyRef = undefined;
  pendingTasks = undefined;
  constructor(isAsync = false) {
    super();
    this.__isAsync = isAsync;
    if (isInInjectionContext()) {
      this.destroyRef = inject(DestroyRef, {
        optional: true
      }) ?? undefined;
      this.pendingTasks = inject(PendingTasksInternal, {
        optional: true
      }) ?? undefined;
    }
  }
  emit(value) {
    const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.setActiveConsumer)(null);
    try {
      super.next(value);
    } finally {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.setActiveConsumer)(prevConsumer);
    }
  }
  subscribe(observerOrNext, error, complete) {
    let nextFn = observerOrNext;
    let errorFn = error || (() => null);
    let completeFn = complete;
    if (observerOrNext && typeof observerOrNext === 'object') {
      const observer = observerOrNext;
      nextFn = observer.next?.bind(observer);
      errorFn = observer.error?.bind(observer);
      completeFn = observer.complete?.bind(observer);
    }
    if (this.__isAsync) {
      errorFn = this.wrapInTimeout(errorFn);
      if (nextFn) {
        nextFn = this.wrapInTimeout(nextFn);
      }
      if (completeFn) {
        completeFn = this.wrapInTimeout(completeFn);
      }
    }
    const sink = super.subscribe({
      next: nextFn,
      error: errorFn,
      complete: completeFn
    });
    if (observerOrNext instanceof rxjs__WEBPACK_IMPORTED_MODULE_4__.Subscription) {
      observerOrNext.add(sink);
    }
    return sink;
  }
  wrapInTimeout(fn) {
    return value => {
      const taskId = this.pendingTasks?.add();
      setTimeout(() => {
        try {
          fn(value);
        } finally {
          if (taskId !== undefined) {
            this.pendingTasks?.remove(taskId);
          }
        }
      });
    };
  }
}
const EventEmitter = EventEmitter_;
function noop(...args) {}
function scheduleCallbackWithRafRace(callback) {
  let timeoutId;
  let animationFrameId;
  function cleanup() {
    callback = noop;
    try {
      if (animationFrameId !== undefined && typeof cancelAnimationFrame === 'function') {
        cancelAnimationFrame(animationFrameId);
      }
      if (timeoutId !== undefined) {
        clearTimeout(timeoutId);
      }
    } catch {}
  }
  timeoutId = setTimeout(() => {
    callback();
    cleanup();
  });
  if (typeof requestAnimationFrame === 'function') {
    animationFrameId = requestAnimationFrame(() => {
      callback();
      cleanup();
    });
  }
  return () => cleanup();
}
function scheduleCallbackWithMicrotask(callback) {
  queueMicrotask(() => callback());
  return () => {
    callback = noop;
  };
}
class AsyncStackTaggingZoneSpec {
  createTask;
  constructor(namePrefix, consoleAsyncStackTaggingImpl = console) {
    this.name = 'asyncStackTagging for ' + namePrefix;
    this.createTask = consoleAsyncStackTaggingImpl?.createTask ?? (() => null);
  }
  name;
  onScheduleTask(delegate, _current, target, task) {
    task.consoleTask = this.createTask(`Zone - ${task.source || task.type}`);
    return delegate.scheduleTask(target, task);
  }
  onInvokeTask(delegate, _currentZone, targetZone, task, applyThis, applyArgs) {
    let ret;
    if (task.consoleTask) {
      ret = task.consoleTask.run(() => delegate.invokeTask(targetZone, task, applyThis, applyArgs));
    } else {
      ret = delegate.invokeTask(targetZone, task, applyThis, applyArgs);
    }
    return ret;
  }
}
const isAngularZoneProperty = 'isAngularZone';
const angularZoneInstanceIdProperty = isAngularZoneProperty + '_ID';
let ngZoneInstanceId = 0;
class NgZone {
  hasPendingMacrotasks = false;
  hasPendingMicrotasks = false;
  isStable = true;
  onUnstable = new EventEmitter(false);
  onMicrotaskEmpty = new EventEmitter(false);
  onStable = new EventEmitter(false);
  onError = new EventEmitter(false);
  constructor(options) {
    const {
      enableLongStackTrace = false,
      shouldCoalesceEventChangeDetection = false,
      shouldCoalesceRunChangeDetection = false,
      scheduleInRootZone = SCHEDULE_IN_ROOT_ZONE_DEFAULT
    } = options;
    if (typeof Zone == 'undefined') {
      throw new RuntimeError(908, ngDevMode && `In this configuration Angular requires Zone.js`);
    }
    Zone.assertZonePatched();
    const self = this;
    self._nesting = 0;
    self._outer = self._inner = Zone.current;
    if (ngDevMode) {
      self._inner = self._inner.fork(new AsyncStackTaggingZoneSpec('Angular'));
    }
    if (Zone['TaskTrackingZoneSpec']) {
      self._inner = self._inner.fork(new Zone['TaskTrackingZoneSpec']());
    }
    if (enableLongStackTrace && Zone['longStackTraceZoneSpec']) {
      self._inner = self._inner.fork(Zone['longStackTraceZoneSpec']);
    }
    self.shouldCoalesceEventChangeDetection = !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;
    self.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;
    self.callbackScheduled = false;
    self.scheduleInRootZone = scheduleInRootZone;
    forkInnerZoneWithAngularBehavior(self);
  }
  static isInAngularZone() {
    return typeof Zone !== 'undefined' && Zone.current.get(isAngularZoneProperty) === true;
  }
  static assertInAngularZone() {
    if (!NgZone.isInAngularZone()) {
      throw new RuntimeError(909, ngDevMode && 'Expected to be in Angular Zone, but it is not!');
    }
  }
  static assertNotInAngularZone() {
    if (NgZone.isInAngularZone()) {
      throw new RuntimeError(909, ngDevMode && 'Expected to not be in Angular Zone, but it is!');
    }
  }
  run(fn, applyThis, applyArgs) {
    return this._inner.run(fn, applyThis, applyArgs);
  }
  runTask(fn, applyThis, applyArgs, name) {
    const zone = this._inner;
    const task = zone.scheduleEventTask('NgZoneEvent: ' + name, fn, EMPTY_PAYLOAD, noop, noop);
    try {
      return zone.runTask(task, applyThis, applyArgs);
    } finally {
      zone.cancelTask(task);
    }
  }
  runGuarded(fn, applyThis, applyArgs) {
    return this._inner.runGuarded(fn, applyThis, applyArgs);
  }
  runOutsideAngular(fn) {
    return this._outer.run(fn);
  }
}
const EMPTY_PAYLOAD = {};
function checkStable(zone) {
  if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {
    try {
      zone._nesting++;
      zone.onMicrotaskEmpty.emit(null);
    } finally {
      zone._nesting--;
      if (!zone.hasPendingMicrotasks) {
        try {
          zone.runOutsideAngular(() => zone.onStable.emit(null));
        } finally {
          zone.isStable = true;
        }
      }
    }
  }
}
function delayChangeDetectionForEvents(zone) {
  if (zone.isCheckStableRunning || zone.callbackScheduled) {
    return;
  }
  zone.callbackScheduled = true;
  function scheduleCheckStable() {
    scheduleCallbackWithRafRace(() => {
      zone.callbackScheduled = false;
      updateMicroTaskStatus(zone);
      zone.isCheckStableRunning = true;
      checkStable(zone);
      zone.isCheckStableRunning = false;
    });
  }
  if (zone.scheduleInRootZone) {
    Zone.root.run(() => {
      scheduleCheckStable();
    });
  } else {
    zone._outer.run(() => {
      scheduleCheckStable();
    });
  }
  updateMicroTaskStatus(zone);
}
function forkInnerZoneWithAngularBehavior(zone) {
  const delayChangeDetectionForEventsDelegate = () => {
    delayChangeDetectionForEvents(zone);
  };
  const instanceId = ngZoneInstanceId++;
  zone._inner = zone._inner.fork({
    name: 'angular',
    properties: {
      [isAngularZoneProperty]: true,
      [angularZoneInstanceIdProperty]: instanceId,
      [angularZoneInstanceIdProperty + instanceId]: true
    },
    onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {
      if (shouldBeIgnoredByZone(applyArgs)) {
        return delegate.invokeTask(target, task, applyThis, applyArgs);
      }
      try {
        onEnter(zone);
        return delegate.invokeTask(target, task, applyThis, applyArgs);
      } finally {
        if (zone.shouldCoalesceEventChangeDetection && task.type === 'eventTask' || zone.shouldCoalesceRunChangeDetection) {
          delayChangeDetectionForEventsDelegate();
        }
        onLeave(zone);
      }
    },
    onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {
      try {
        onEnter(zone);
        return delegate.invoke(target, callback, applyThis, applyArgs, source);
      } finally {
        if (zone.shouldCoalesceRunChangeDetection && !zone.callbackScheduled && !isSchedulerTick(applyArgs)) {
          delayChangeDetectionForEventsDelegate();
        }
        onLeave(zone);
      }
    },
    onHasTask: (delegate, current, target, hasTaskState) => {
      delegate.hasTask(target, hasTaskState);
      if (current === target) {
        if (hasTaskState.change == 'microTask') {
          zone._hasPendingMicrotasks = hasTaskState.microTask;
          updateMicroTaskStatus(zone);
          checkStable(zone);
        } else if (hasTaskState.change == 'macroTask') {
          zone.hasPendingMacrotasks = hasTaskState.macroTask;
        }
      }
    },
    onHandleError: (delegate, current, target, error) => {
      delegate.handleError(target, error);
      zone.runOutsideAngular(() => zone.onError.emit(error));
      return false;
    }
  });
}
function updateMicroTaskStatus(zone) {
  if (zone._hasPendingMicrotasks || (zone.shouldCoalesceEventChangeDetection || zone.shouldCoalesceRunChangeDetection) && zone.callbackScheduled === true) {
    zone.hasPendingMicrotasks = true;
  } else {
    zone.hasPendingMicrotasks = false;
  }
}
function onEnter(zone) {
  zone._nesting++;
  if (zone.isStable) {
    zone.isStable = false;
    zone.onUnstable.emit(null);
  }
}
function onLeave(zone) {
  zone._nesting--;
  checkStable(zone);
}
class NoopNgZone {
  hasPendingMicrotasks = false;
  hasPendingMacrotasks = false;
  isStable = true;
  onUnstable = new EventEmitter();
  onMicrotaskEmpty = new EventEmitter();
  onStable = new EventEmitter();
  onError = new EventEmitter();
  run(fn, applyThis, applyArgs) {
    return fn.apply(applyThis, applyArgs);
  }
  runGuarded(fn, applyThis, applyArgs) {
    return fn.apply(applyThis, applyArgs);
  }
  runOutsideAngular(fn) {
    return fn();
  }
  runTask(fn, applyThis, applyArgs, name) {
    return fn.apply(applyThis, applyArgs);
  }
}
function shouldBeIgnoredByZone(applyArgs) {
  return hasApplyArgsData(applyArgs, '__ignore_ng_zone__');
}
function isSchedulerTick(applyArgs) {
  return hasApplyArgsData(applyArgs, '__scheduler_tick__');
}
function hasApplyArgsData(applyArgs, key) {
  if (!Array.isArray(applyArgs)) {
    return false;
  }
  if (applyArgs.length !== 1) {
    return false;
  }
  return applyArgs[0]?.data?.[key] === true;
}
class ErrorHandler {
  _console = console;
  handleError(error) {
    this._console.error('ERROR', error);
  }
}
const INTERNAL_APPLICATION_ERROR_HANDLER = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'internal error handler' : '', {
  factory: () => {
    const zone = inject(NgZone);
    const injector = inject(EnvironmentInjector);
    let userErrorHandler;
    return e => {
      zone.runOutsideAngular(() => {
        if (injector.destroyed && !userErrorHandler) {
          setTimeout(() => {
            throw e;
          });
        } else {
          userErrorHandler ??= injector.get(ErrorHandler);
          userErrorHandler.handleError(e);
        }
      });
    };
  }
});
const errorHandlerEnvironmentInitializer = {
  provide: ENVIRONMENT_INITIALIZER,
  useValue: () => {
    const handler = inject(ErrorHandler, {
      optional: true
    });
    if ((typeof ngDevMode === 'undefined' || ngDevMode) && handler === null) {
      throw new RuntimeError(402, `A required Injectable was not found in the dependency injection tree. ` + 'If you are bootstrapping an NgModule, make sure that the `BrowserModule` is imported.');
    }
  },
  multi: true
};
const globalErrorListeners = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'GlobalErrorListeners' : '', {
  factory: () => {
    if (typeof ngServerMode !== 'undefined' && ngServerMode) {
      return;
    }
    const window = inject(DOCUMENT).defaultView;
    if (!window) {
      return;
    }
    const errorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);
    const rejectionListener = e => {
      errorHandler(e.reason);
      e.preventDefault();
    };
    const errorListener = e => {
      if (e.error) {
        errorHandler(e.error);
      } else {
        errorHandler(new Error(ngDevMode ? `An ErrorEvent with no error occurred. See Error.cause for details: ${e.message}` : e.message, {
          cause: e
        }));
      }
      e.preventDefault();
    };
    const setupEventListeners = () => {
      window.addEventListener('unhandledrejection', rejectionListener);
      window.addEventListener('error', errorListener);
    };
    if (typeof Zone !== 'undefined') {
      Zone.root.run(setupEventListeners);
    } else {
      setupEventListeners();
    }
    inject(DestroyRef).onDestroy(() => {
      window.removeEventListener('error', errorListener);
      window.removeEventListener('unhandledrejection', rejectionListener);
    });
  }
});
function provideBrowserGlobalErrorListeners() {
  return makeEnvironmentProviders([provideEnvironmentInitializer(() => void inject(globalErrorListeners))]);
}
function ɵunwrapWritableSignal(value) {
  return null;
}
function signal(initialValue, options) {
  const [get, set, update] = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.createSignal)(initialValue, options?.equal);
  const signalFn = get;
  const node = signalFn[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.SIGNAL];
  signalFn.set = set;
  signalFn.update = update;
  signalFn.asReadonly = signalAsReadonlyFn.bind(signalFn);
  if (ngDevMode) {
    signalFn.toString = () => `[Signal: ${signalFn()}]`;
    node.debugName = options?.debugName;
  }
  return signalFn;
}
function signalAsReadonlyFn() {
  const node = this[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.SIGNAL];
  if (node.readonlyFn === undefined) {
    const readonlyFn = () => this();
    readonlyFn[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.SIGNAL] = node;
    node.readonlyFn = readonlyFn;
  }
  return node.readonlyFn;
}
function assertNotInReactiveContext(debugFn, extraContext) {
  if ((0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getActiveConsumer)() !== null) {
    throw new RuntimeError(-602, ngDevMode && `${debugFn.name}() cannot be called from within a reactive context.${extraContext ? ` ${extraContext}` : ''}`);
  }
}
class ViewContext {
  view;
  node;
  constructor(view, node) {
    this.view = view;
    this.node = node;
  }
  static __NG_ELEMENT_ID__ = injectViewContext;
}
function injectViewContext() {
  return new ViewContext(getLView(), getCurrentTNode());
}
class ChangeDetectionScheduler {}
const ZONELESS_ENABLED = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'Zoneless enabled' : '', {
  factory: () => true
});
const PROVIDED_ZONELESS = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'Zoneless provided' : '', {
  factory: () => false
});
const SCHEDULE_IN_ROOT_ZONE = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'run changes outside zone in root' : '');
class PendingTasks {
  internalPendingTasks = inject(PendingTasksInternal);
  scheduler = inject(ChangeDetectionScheduler);
  errorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);
  add() {
    const taskId = this.internalPendingTasks.add();
    return () => {
      if (!this.internalPendingTasks.has(taskId)) {
        return;
      }
      this.scheduler.notify(11);
      this.internalPendingTasks.remove(taskId);
    };
  }
  run(fn) {
    const removeTask = this.add();
    fn().catch(this.errorHandler).finally(removeTask);
  }
  static ɵprov = /* @__PURE__ */
  ɵɵdefineInjectable({
    token: PendingTasks,
    providedIn: 'root',
    factory: () => new PendingTasks()
  });
}
class EffectScheduler {
  static ɵprov = /* @__PURE__ */
  ɵɵdefineInjectable({
    token: EffectScheduler,
    providedIn: 'root',
    factory: () => new ZoneAwareEffectScheduler()
  });
}
class ZoneAwareEffectScheduler {
  dirtyEffectCount = 0;
  queues = new Map();
  add(handle) {
    this.enqueue(handle);
    this.schedule(handle);
  }
  schedule(handle) {
    if (!handle.dirty) {
      return;
    }
    this.dirtyEffectCount++;
  }
  remove(handle) {
    const zone = handle.zone;
    const queue = this.queues.get(zone);
    if (!queue.has(handle)) {
      return;
    }
    queue.delete(handle);
    if (handle.dirty) {
      this.dirtyEffectCount--;
    }
  }
  enqueue(handle) {
    const zone = handle.zone;
    if (!this.queues.has(zone)) {
      this.queues.set(zone, new Set());
    }
    const queue = this.queues.get(zone);
    if (queue.has(handle)) {
      return;
    }
    queue.add(handle);
  }
  flush() {
    while (this.dirtyEffectCount > 0) {
      let ranOneEffect = false;
      for (const [zone, queue] of this.queues) {
        if (zone === null) {
          ranOneEffect ||= this.flushQueue(queue);
        } else {
          ranOneEffect ||= zone.run(() => this.flushQueue(queue));
        }
      }
      if (!ranOneEffect) {
        this.dirtyEffectCount = 0;
      }
    }
  }
  flushQueue(queue) {
    let ranOneEffect = false;
    for (const handle of queue) {
      if (!handle.dirty) {
        continue;
      }
      this.dirtyEffectCount--;
      ranOneEffect = true;
      handle.run();
    }
    return ranOneEffect;
  }
}
class EffectRefImpl {
  [_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.SIGNAL];
  constructor(node) {
    this[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.SIGNAL] = node;
  }
  destroy() {
    this[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.SIGNAL].destroy();
  }
}
function effect(effectFn, options) {
  ngDevMode && assertNotInReactiveContext(effect, 'Call `effect` outside of a reactive context. For example, schedule the ' + 'effect inside the component constructor.');
  if (ngDevMode && !options?.injector) {
    assertInInjectionContext(effect);
  }
  if (ngDevMode && options?.allowSignalWrites !== undefined) {
    console.warn(`The 'allowSignalWrites' flag is deprecated and no longer impacts effect() (writes are always allowed)`);
  }
  const injector = options?.injector ?? inject(Injector);
  let destroyRef = options?.manualCleanup !== true ? injector.get(DestroyRef) : null;
  let node;
  const viewContext = injector.get(ViewContext, null, {
    optional: true
  });
  const notifier = injector.get(ChangeDetectionScheduler);
  if (viewContext !== null) {
    node = createViewEffect(viewContext.view, notifier, effectFn);
    if (destroyRef instanceof NodeInjectorDestroyRef && destroyRef._lView === viewContext.view) {
      destroyRef = null;
    }
  } else {
    node = createRootEffect(effectFn, injector.get(EffectScheduler), notifier);
  }
  node.injector = injector;
  if (destroyRef !== null) {
    node.onDestroyFns = [destroyRef.onDestroy(() => node.destroy())];
  }
  const effectRef = new EffectRefImpl(node);
  if (ngDevMode) {
    node.debugName = options?.debugName ?? '';
    const prevInjectorProfilerContext = setInjectorProfilerContext({
      injector,
      token: null
    });
    try {
      emitEffectCreatedEvent(effectRef);
    } finally {
      setInjectorProfilerContext(prevInjectorProfilerContext);
    }
  }
  return effectRef;
}
const EFFECT_NODE = /* @__PURE__ */(() => ({
  ..._effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.BASE_EFFECT_NODE,
  cleanupFns: undefined,
  zone: null,
  onDestroyFns: null,
  run() {
    if (ngDevMode && (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isInNotificationPhase)()) {
      throw new Error(`Schedulers cannot synchronously execute watches while scheduling.`);
    }
    const prevRefreshingViews = setIsRefreshingViews(false);
    try {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.runEffect)(this);
    } finally {
      setIsRefreshingViews(prevRefreshingViews);
    }
  },
  cleanup() {
    if (!this.cleanupFns?.length) {
      return;
    }
    const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.setActiveConsumer)(null);
    try {
      while (this.cleanupFns.length) {
        this.cleanupFns.pop()();
      }
    } finally {
      this.cleanupFns = [];
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.setActiveConsumer)(prevConsumer);
    }
  }
}))();
const ROOT_EFFECT_NODE = /* @__PURE__ */(() => ({
  ...EFFECT_NODE,
  consumerMarkedDirty() {
    this.scheduler.schedule(this);
    this.notifier.notify(12);
  },
  destroy() {
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.consumerDestroy)(this);
    if (this.onDestroyFns !== null) {
      for (const fn of this.onDestroyFns) {
        fn();
      }
    }
    this.cleanup();
    this.scheduler.remove(this);
  }
}))();
const VIEW_EFFECT_NODE = /* @__PURE__ */(() => ({
  ...EFFECT_NODE,
  consumerMarkedDirty() {
    this.view[FLAGS] |= 8192;
    markAncestorsForTraversal(this.view);
    this.notifier.notify(13);
  },
  destroy() {
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.consumerDestroy)(this);
    if (this.onDestroyFns !== null) {
      for (const fn of this.onDestroyFns) {
        fn();
      }
    }
    this.cleanup();
    this.view[EFFECTS]?.delete(this);
  }
}))();
function createViewEffect(view, notifier, fn) {
  const node = Object.create(VIEW_EFFECT_NODE);
  node.view = view;
  node.zone = typeof Zone !== 'undefined' ? Zone.current : null;
  node.notifier = notifier;
  node.fn = createEffectFn(node, fn);
  view[EFFECTS] ??= new Set();
  view[EFFECTS].add(node);
  node.consumerMarkedDirty(node);
  return node;
}
function createRootEffect(fn, scheduler, notifier) {
  const node = Object.create(ROOT_EFFECT_NODE);
  node.fn = createEffectFn(node, fn);
  node.scheduler = scheduler;
  node.notifier = notifier;
  node.zone = typeof Zone !== 'undefined' ? Zone.current : null;
  node.scheduler.add(node);
  node.notifier.notify(12);
  return node;
}
function createEffectFn(node, fn) {
  return () => {
    fn(cleanupFn => (node.cleanupFns ??= []).push(cleanupFn));
  };
}
function untracked(nonReactiveReadsFn) {
  return (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.untracked)(nonReactiveReadsFn);
}


/***/ }),

/***/ 197:
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/operators/throwIfEmpty.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   throwIfEmpty: () => (/* binding */ throwIfEmpty)
/* harmony export */ });
/* harmony import */ var _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/EmptyError */ 5815);
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/lift */ 8419);
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OperatorSubscriber */ 3943);



function throwIfEmpty(errorFactory = defaultErrorFactory) {
  return (0,_util_lift__WEBPACK_IMPORTED_MODULE_1__.operate)((source, subscriber) => {
    let hasValue = false;
    source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__.createOperatorSubscriber)(subscriber, value => {
      hasValue = true;
      subscriber.next(value);
    }, () => hasValue ? subscriber.complete() : subscriber.error(errorFactory())));
  });
}
function defaultErrorFactory() {
  return new _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__.EmptyError();
}

/***/ }),

/***/ 302:
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/operators/concatAll.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   concatAll: () => (/* binding */ concatAll)
/* harmony export */ });
/* harmony import */ var _mergeAll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mergeAll */ 8310);

function concatAll() {
  return (0,_mergeAll__WEBPACK_IMPORTED_MODULE_0__.mergeAll)(1);
}

/***/ }),

/***/ 399:
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/scheduled/scheduleObservable.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   scheduleObservable: () => (/* binding */ scheduleObservable)
/* harmony export */ });
/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observable/innerFrom */ 5829);
/* harmony import */ var _operators_observeOn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../operators/observeOn */ 7328);
/* harmony import */ var _operators_subscribeOn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../operators/subscribeOn */ 1584);



function scheduleObservable(input, scheduler) {
  return (0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_0__.innerFrom)(input).pipe((0,_operators_subscribeOn__WEBPACK_IMPORTED_MODULE_2__.subscribeOn)(scheduler), (0,_operators_observeOn__WEBPACK_IMPORTED_MODULE_1__.observeOn)(scheduler));
}

/***/ }),

/***/ 476:
/*!**********************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@angular+core@21.0.5_@angular+compiler@21.0.5_rxjs@7.8.2_zone.js@0.16.0/node_modules/@angular/core/fesm2022/_effect-chunk.mjs ***!
  \**********************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BASE_EFFECT_NODE: () => (/* binding */ BASE_EFFECT_NODE),
/* harmony export */   COMPUTING: () => (/* binding */ COMPUTING),
/* harmony export */   ERRORED: () => (/* binding */ ERRORED),
/* harmony export */   REACTIVE_NODE: () => (/* binding */ REACTIVE_NODE),
/* harmony export */   SIGNAL: () => (/* binding */ SIGNAL),
/* harmony export */   SIGNAL_NODE: () => (/* binding */ SIGNAL_NODE),
/* harmony export */   UNSET: () => (/* binding */ UNSET),
/* harmony export */   consumerAfterComputation: () => (/* binding */ consumerAfterComputation),
/* harmony export */   consumerBeforeComputation: () => (/* binding */ consumerBeforeComputation),
/* harmony export */   consumerDestroy: () => (/* binding */ consumerDestroy),
/* harmony export */   consumerMarkDirty: () => (/* binding */ consumerMarkDirty),
/* harmony export */   consumerPollProducersForChange: () => (/* binding */ consumerPollProducersForChange),
/* harmony export */   createComputed: () => (/* binding */ createComputed),
/* harmony export */   createSignal: () => (/* binding */ createSignal),
/* harmony export */   defaultEquals: () => (/* binding */ defaultEquals),
/* harmony export */   finalizeConsumerAfterComputation: () => (/* binding */ finalizeConsumerAfterComputation),
/* harmony export */   getActiveConsumer: () => (/* binding */ getActiveConsumer),
/* harmony export */   isInNotificationPhase: () => (/* binding */ isInNotificationPhase),
/* harmony export */   isReactive: () => (/* binding */ isReactive),
/* harmony export */   producerAccessed: () => (/* binding */ producerAccessed),
/* harmony export */   producerIncrementEpoch: () => (/* binding */ producerIncrementEpoch),
/* harmony export */   producerMarkClean: () => (/* binding */ producerMarkClean),
/* harmony export */   producerNotifyConsumers: () => (/* binding */ producerNotifyConsumers),
/* harmony export */   producerUpdateValueVersion: () => (/* binding */ producerUpdateValueVersion),
/* harmony export */   producerUpdatesAllowed: () => (/* binding */ producerUpdatesAllowed),
/* harmony export */   resetConsumerBeforeComputation: () => (/* binding */ resetConsumerBeforeComputation),
/* harmony export */   runEffect: () => (/* binding */ runEffect),
/* harmony export */   runPostProducerCreatedFn: () => (/* binding */ runPostProducerCreatedFn),
/* harmony export */   runPostSignalSetFn: () => (/* binding */ runPostSignalSetFn),
/* harmony export */   setActiveConsumer: () => (/* binding */ setActiveConsumer),
/* harmony export */   setPostProducerCreatedFn: () => (/* binding */ setPostProducerCreatedFn),
/* harmony export */   setPostSignalSetFn: () => (/* binding */ setPostSignalSetFn),
/* harmony export */   setThrowInvalidWriteToSignalError: () => (/* binding */ setThrowInvalidWriteToSignalError),
/* harmony export */   signalGetFn: () => (/* binding */ signalGetFn),
/* harmony export */   signalSetFn: () => (/* binding */ signalSetFn),
/* harmony export */   signalUpdateFn: () => (/* binding */ signalUpdateFn),
/* harmony export */   untracked: () => (/* binding */ untracked)
/* harmony export */ });
/**
 * @license Angular v21.0.5
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */

let activeConsumer = null;
let inNotificationPhase = false;
let epoch = 1;
let postProducerCreatedFn = null;
const SIGNAL = /* @__PURE__ */Symbol('SIGNAL');
function setActiveConsumer(consumer) {
  const prev = activeConsumer;
  activeConsumer = consumer;
  return prev;
}
function getActiveConsumer() {
  return activeConsumer;
}
function isInNotificationPhase() {
  return inNotificationPhase;
}
function isReactive(value) {
  return value[SIGNAL] !== undefined;
}
const REACTIVE_NODE = {
  version: 0,
  lastCleanEpoch: 0,
  dirty: false,
  producers: undefined,
  producersTail: undefined,
  consumers: undefined,
  consumersTail: undefined,
  recomputing: false,
  consumerAllowSignalWrites: false,
  consumerIsAlwaysLive: false,
  kind: 'unknown',
  producerMustRecompute: () => false,
  producerRecomputeValue: () => {},
  consumerMarkedDirty: () => {},
  consumerOnSignalRead: () => {}
};
function producerAccessed(node) {
  if (inNotificationPhase) {
    throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? `Assertion error: signal read during notification phase` : '');
  }
  if (activeConsumer === null) {
    return;
  }
  activeConsumer.consumerOnSignalRead(node);
  const prevProducerLink = activeConsumer.producersTail;
  if (prevProducerLink !== undefined && prevProducerLink.producer === node) {
    return;
  }
  let nextProducerLink = undefined;
  const isRecomputing = activeConsumer.recomputing;
  if (isRecomputing) {
    nextProducerLink = prevProducerLink !== undefined ? prevProducerLink.nextProducer : activeConsumer.producers;
    if (nextProducerLink !== undefined && nextProducerLink.producer === node) {
      activeConsumer.producersTail = nextProducerLink;
      nextProducerLink.lastReadVersion = node.version;
      return;
    }
  }
  const prevConsumerLink = node.consumersTail;
  if (prevConsumerLink !== undefined && prevConsumerLink.consumer === activeConsumer && (!isRecomputing || isValidLink(prevConsumerLink, activeConsumer))) {
    return;
  }
  const isLive = consumerIsLive(activeConsumer);
  const newLink = {
    producer: node,
    consumer: activeConsumer,
    nextProducer: nextProducerLink,
    prevConsumer: prevConsumerLink,
    lastReadVersion: node.version,
    nextConsumer: undefined
  };
  activeConsumer.producersTail = newLink;
  if (prevProducerLink !== undefined) {
    prevProducerLink.nextProducer = newLink;
  } else {
    activeConsumer.producers = newLink;
  }
  if (isLive) {
    producerAddLiveConsumer(node, newLink);
  }
}
function producerIncrementEpoch() {
  epoch++;
}
function producerUpdateValueVersion(node) {
  if (consumerIsLive(node) && !node.dirty) {
    return;
  }
  if (!node.dirty && node.lastCleanEpoch === epoch) {
    return;
  }
  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {
    producerMarkClean(node);
    return;
  }
  node.producerRecomputeValue(node);
  producerMarkClean(node);
}
function producerNotifyConsumers(node) {
  if (node.consumers === undefined) {
    return;
  }
  const prev = inNotificationPhase;
  inNotificationPhase = true;
  try {
    for (let link = node.consumers; link !== undefined; link = link.nextConsumer) {
      const consumer = link.consumer;
      if (!consumer.dirty) {
        consumerMarkDirty(consumer);
      }
    }
  } finally {
    inNotificationPhase = prev;
  }
}
function producerUpdatesAllowed() {
  return activeConsumer?.consumerAllowSignalWrites !== false;
}
function consumerMarkDirty(node) {
  node.dirty = true;
  producerNotifyConsumers(node);
  node.consumerMarkedDirty?.(node);
}
function producerMarkClean(node) {
  node.dirty = false;
  node.lastCleanEpoch = epoch;
}
function consumerBeforeComputation(node) {
  if (node) resetConsumerBeforeComputation(node);
  return setActiveConsumer(node);
}
function resetConsumerBeforeComputation(node) {
  node.producersTail = undefined;
  node.recomputing = true;
}
function consumerAfterComputation(node, prevConsumer) {
  setActiveConsumer(prevConsumer);
  if (node) finalizeConsumerAfterComputation(node);
}
function finalizeConsumerAfterComputation(node) {
  node.recomputing = false;
  const producersTail = node.producersTail;
  let toRemove = producersTail !== undefined ? producersTail.nextProducer : node.producers;
  if (toRemove !== undefined) {
    if (consumerIsLive(node)) {
      do {
        toRemove = producerRemoveLiveConsumerLink(toRemove);
      } while (toRemove !== undefined);
    }
    if (producersTail !== undefined) {
      producersTail.nextProducer = undefined;
    } else {
      node.producers = undefined;
    }
  }
}
function consumerPollProducersForChange(node) {
  for (let link = node.producers; link !== undefined; link = link.nextProducer) {
    const producer = link.producer;
    const seenVersion = link.lastReadVersion;
    if (seenVersion !== producer.version) {
      return true;
    }
    producerUpdateValueVersion(producer);
    if (seenVersion !== producer.version) {
      return true;
    }
  }
  return false;
}
function consumerDestroy(node) {
  if (consumerIsLive(node)) {
    let link = node.producers;
    while (link !== undefined) {
      link = producerRemoveLiveConsumerLink(link);
    }
  }
  node.producers = undefined;
  node.producersTail = undefined;
  node.consumers = undefined;
  node.consumersTail = undefined;
}
function producerAddLiveConsumer(node, link) {
  const consumersTail = node.consumersTail;
  const wasLive = consumerIsLive(node);
  if (consumersTail !== undefined) {
    link.nextConsumer = consumersTail.nextConsumer;
    consumersTail.nextConsumer = link;
  } else {
    link.nextConsumer = undefined;
    node.consumers = link;
  }
  link.prevConsumer = consumersTail;
  node.consumersTail = link;
  if (!wasLive) {
    for (let link = node.producers; link !== undefined; link = link.nextProducer) {
      producerAddLiveConsumer(link.producer, link);
    }
  }
}
function producerRemoveLiveConsumerLink(link) {
  const producer = link.producer;
  const nextProducer = link.nextProducer;
  const nextConsumer = link.nextConsumer;
  const prevConsumer = link.prevConsumer;
  link.nextConsumer = undefined;
  link.prevConsumer = undefined;
  if (nextConsumer !== undefined) {
    nextConsumer.prevConsumer = prevConsumer;
  } else {
    producer.consumersTail = prevConsumer;
  }
  if (prevConsumer !== undefined) {
    prevConsumer.nextConsumer = nextConsumer;
  } else {
    producer.consumers = nextConsumer;
    if (!consumerIsLive(producer)) {
      let producerLink = producer.producers;
      while (producerLink !== undefined) {
        producerLink = producerRemoveLiveConsumerLink(producerLink);
      }
    }
  }
  return nextProducer;
}
function consumerIsLive(node) {
  return node.consumerIsAlwaysLive || node.consumers !== undefined;
}
function runPostProducerCreatedFn(node) {
  postProducerCreatedFn?.(node);
}
function setPostProducerCreatedFn(fn) {
  const prev = postProducerCreatedFn;
  postProducerCreatedFn = fn;
  return prev;
}
function isValidLink(checkLink, consumer) {
  const producersTail = consumer.producersTail;
  if (producersTail !== undefined) {
    let link = consumer.producers;
    do {
      if (link === checkLink) {
        return true;
      }
      if (link === producersTail) {
        break;
      }
      link = link.nextProducer;
    } while (link !== undefined);
  }
  return false;
}
function defaultEquals(a, b) {
  return Object.is(a, b);
}
function createComputed(computation, equal) {
  const node = Object.create(COMPUTED_NODE);
  node.computation = computation;
  if (equal !== undefined) {
    node.equal = equal;
  }
  const computed = () => {
    producerUpdateValueVersion(node);
    producerAccessed(node);
    if (node.value === ERRORED) {
      throw node.error;
    }
    return node.value;
  };
  computed[SIGNAL] = node;
  if (typeof ngDevMode !== 'undefined' && ngDevMode) {
    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';
    computed.toString = () => `[Computed${debugName}: ${node.value}]`;
  }
  runPostProducerCreatedFn(node);
  return computed;
}
const UNSET = /* @__PURE__ */Symbol('UNSET');
const COMPUTING = /* @__PURE__ */Symbol('COMPUTING');
const ERRORED = /* @__PURE__ */Symbol('ERRORED');
const COMPUTED_NODE = /* @__PURE__ */(() => {
  return {
    ...REACTIVE_NODE,
    value: UNSET,
    dirty: true,
    error: null,
    equal: defaultEquals,
    kind: 'computed',
    producerMustRecompute(node) {
      return node.value === UNSET || node.value === COMPUTING;
    },
    producerRecomputeValue(node) {
      if (node.value === COMPUTING) {
        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');
      }
      const oldValue = node.value;
      node.value = COMPUTING;
      const prevConsumer = consumerBeforeComputation(node);
      let newValue;
      let wasEqual = false;
      try {
        newValue = node.computation();
        setActiveConsumer(null);
        wasEqual = oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED && node.equal(oldValue, newValue);
      } catch (err) {
        newValue = ERRORED;
        node.error = err;
      } finally {
        consumerAfterComputation(node, prevConsumer);
      }
      if (wasEqual) {
        node.value = oldValue;
        return;
      }
      node.value = newValue;
      node.version++;
    }
  };
})();
function defaultThrowError() {
  throw new Error();
}
let throwInvalidWriteToSignalErrorFn = defaultThrowError;
function throwInvalidWriteToSignalError(node) {
  throwInvalidWriteToSignalErrorFn(node);
}
function setThrowInvalidWriteToSignalError(fn) {
  throwInvalidWriteToSignalErrorFn = fn;
}
let postSignalSetFn = null;
function createSignal(initialValue, equal) {
  const node = Object.create(SIGNAL_NODE);
  node.value = initialValue;
  if (equal !== undefined) {
    node.equal = equal;
  }
  const getter = () => signalGetFn(node);
  getter[SIGNAL] = node;
  if (typeof ngDevMode !== 'undefined' && ngDevMode) {
    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';
    getter.toString = () => `[Signal${debugName}: ${node.value}]`;
  }
  runPostProducerCreatedFn(node);
  const set = newValue => signalSetFn(node, newValue);
  const update = updateFn => signalUpdateFn(node, updateFn);
  return [getter, set, update];
}
function setPostSignalSetFn(fn) {
  const prev = postSignalSetFn;
  postSignalSetFn = fn;
  return prev;
}
function signalGetFn(node) {
  producerAccessed(node);
  return node.value;
}
function signalSetFn(node, newValue) {
  if (!producerUpdatesAllowed()) {
    throwInvalidWriteToSignalError(node);
  }
  if (!node.equal(node.value, newValue)) {
    node.value = newValue;
    signalValueChanged(node);
  }
}
function signalUpdateFn(node, updater) {
  if (!producerUpdatesAllowed()) {
    throwInvalidWriteToSignalError(node);
  }
  signalSetFn(node, updater(node.value));
}
function runPostSignalSetFn(node) {
  postSignalSetFn?.(node);
}
const SIGNAL_NODE = /* @__PURE__ */(() => {
  return {
    ...REACTIVE_NODE,
    equal: defaultEquals,
    value: undefined,
    kind: 'signal'
  };
})();
function signalValueChanged(node) {
  node.version++;
  producerIncrementEpoch();
  producerNotifyConsumers(node);
  postSignalSetFn?.(node);
}
function untracked(nonReactiveReadsFn) {
  const prevConsumer = setActiveConsumer(null);
  try {
    return nonReactiveReadsFn();
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
const BASE_EFFECT_NODE = /* @__PURE__ */(() => ({
  ...REACTIVE_NODE,
  consumerIsAlwaysLive: true,
  consumerAllowSignalWrites: true,
  dirty: true,
  kind: 'effect'
}))();
function runEffect(node) {
  node.dirty = false;
  if (node.version > 0 && !consumerPollProducersForChange(node)) {
    return;
  }
  node.version++;
  const prevNode = consumerBeforeComputation(node);
  try {
    node.cleanup();
    node.fn();
  } finally {
    consumerAfterComputation(node, prevNode);
  }
}


/***/ }),

/***/ 518:
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/util/ObjectUnsubscribedError.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ObjectUnsubscribedError: () => (/* binding */ ObjectUnsubscribedError)
/* harmony export */ });
/* harmony import */ var _createErrorClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createErrorClass */ 8192);

const ObjectUnsubscribedError = (0,_createErrorClass__WEBPACK_IMPORTED_MODULE_0__.createErrorClass)(_super => function ObjectUnsubscribedErrorImpl() {
  _super(this);
  this.name = 'ObjectUnsubscribedError';
  this.message = 'object unsubscribed';
});

/***/ }),

/***/ 519:
/*!************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@angular+platform-browser@21.0.5_@angular+animations@21.0.5_@angular+common@21.0.5_@angular+core@21.0.5/node_modules/@angular/platform-browser/fesm2022/_dom_renderer-chunk.mjs ***!
  \************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DomEventsPlugin: () => (/* binding */ DomEventsPlugin),
/* harmony export */   DomRendererFactory2: () => (/* binding */ DomRendererFactory2),
/* harmony export */   EVENT_MANAGER_PLUGINS: () => (/* binding */ EVENT_MANAGER_PLUGINS),
/* harmony export */   EventManager: () => (/* binding */ EventManager),
/* harmony export */   EventManagerPlugin: () => (/* binding */ EventManagerPlugin),
/* harmony export */   REMOVE_STYLES_ON_COMPONENT_DESTROY: () => (/* binding */ REMOVE_STYLES_ON_COMPONENT_DESTROY),
/* harmony export */   SharedStylesHost: () => (/* binding */ SharedStylesHost)
/* harmony export */ });
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ 64);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ 8021);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ 7367);
/**
 * @license Angular v21.0.5
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */




class EventManagerPlugin {
  _doc;
  constructor(_doc) {
    this._doc = _doc;
  }
  manager;
}
class DomEventsPlugin extends EventManagerPlugin {
  constructor(doc) {
    super(doc);
  }
  supports(eventName) {
    return true;
  }
  addEventListener(element, eventName, handler, options) {
    element.addEventListener(eventName, handler, options);
    return () => this.removeEventListener(element, eventName, handler, options);
  }
  removeEventListener(target, eventName, callback, options) {
    return target.removeEventListener(eventName, callback, options);
  }
  static ɵfac = function DomEventsPlugin_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || DomEventsPlugin)(_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT));
  };
  static ɵprov = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: DomEventsPlugin,
    factory: DomEventsPlugin.ɵfac
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata(DomEventsPlugin, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Injectable
  }], () => [{
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
      args: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT]
    }]
  }], null);
})();
const EVENT_MANAGER_PLUGINS = new _angular_common__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'EventManagerPlugins' : '');
class EventManager {
  _zone;
  _plugins;
  _eventNameToPlugin = new Map();
  constructor(plugins, _zone) {
    this._zone = _zone;
    plugins.forEach(plugin => {
      plugin.manager = this;
    });
    const otherPlugins = plugins.filter(p => !(p instanceof DomEventsPlugin));
    this._plugins = otherPlugins.slice().reverse();
    const domEventPlugin = plugins.find(p => p instanceof DomEventsPlugin);
    if (domEventPlugin) {
      this._plugins.push(domEventPlugin);
    }
  }
  addEventListener(element, eventName, handler, options) {
    const plugin = this._findPluginFor(eventName);
    return plugin.addEventListener(element, eventName, handler, options);
  }
  getZone() {
    return this._zone;
  }
  _findPluginFor(eventName) {
    let plugin = this._eventNameToPlugin.get(eventName);
    if (plugin) {
      return plugin;
    }
    const plugins = this._plugins;
    plugin = plugins.find(plugin => plugin.supports(eventName));
    if (!plugin) {
      throw new _angular_common__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(5101, (typeof ngDevMode === 'undefined' || ngDevMode) && `No event manager plugin found for event ${eventName}`);
    }
    this._eventNameToPlugin.set(eventName, plugin);
    return plugin;
  }
  static ɵfac = function EventManager_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || EventManager)(_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](EVENT_MANAGER_PLUGINS), _angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵprov = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: EventManager,
    factory: EventManager.ɵfac
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata(EventManager, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Injectable
  }], () => [{
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
      args: [EVENT_MANAGER_PLUGINS]
    }]
  }, {
    type: _angular_common__WEBPACK_IMPORTED_MODULE_0__.NgZone
  }], null);
})();
const APP_ID_ATTRIBUTE_NAME = 'ng-app-id';
function removeElements(elements) {
  for (const element of elements) {
    element.remove();
  }
}
function createStyleElement(style, doc) {
  const styleElement = doc.createElement('style');
  styleElement.textContent = style;
  return styleElement;
}
function addServerStyles(doc, appId, inline, external) {
  const elements = doc.head?.querySelectorAll(`style[${APP_ID_ATTRIBUTE_NAME}="${appId}"],link[${APP_ID_ATTRIBUTE_NAME}="${appId}"]`);
  if (elements) {
    for (const styleElement of elements) {
      styleElement.removeAttribute(APP_ID_ATTRIBUTE_NAME);
      if (styleElement instanceof HTMLLinkElement) {
        external.set(styleElement.href.slice(styleElement.href.lastIndexOf('/') + 1), {
          usage: 0,
          elements: [styleElement]
        });
      } else if (styleElement.textContent) {
        inline.set(styleElement.textContent, {
          usage: 0,
          elements: [styleElement]
        });
      }
    }
  }
}
function createLinkElement(url, doc) {
  const linkElement = doc.createElement('link');
  linkElement.setAttribute('rel', 'stylesheet');
  linkElement.setAttribute('href', url);
  return linkElement;
}
class SharedStylesHost {
  doc;
  appId;
  nonce;
  inline = new Map();
  external = new Map();
  hosts = new Set();
  constructor(doc, appId, nonce, platformId = {}) {
    this.doc = doc;
    this.appId = appId;
    this.nonce = nonce;
    addServerStyles(doc, appId, this.inline, this.external);
    this.hosts.add(doc.head);
  }
  addStyles(styles, urls) {
    for (const value of styles) {
      this.addUsage(value, this.inline, createStyleElement);
    }
    urls?.forEach(value => this.addUsage(value, this.external, createLinkElement));
  }
  removeStyles(styles, urls) {
    for (const value of styles) {
      this.removeUsage(value, this.inline);
    }
    urls?.forEach(value => this.removeUsage(value, this.external));
  }
  addUsage(value, usages, creator) {
    const record = usages.get(value);
    if (record) {
      if ((typeof ngDevMode === 'undefined' || ngDevMode) && record.usage === 0) {
        record.elements.forEach(element => element.setAttribute('ng-style-reused', ''));
      }
      record.usage++;
    } else {
      usages.set(value, {
        usage: 1,
        elements: [...this.hosts].map(host => this.addElement(host, creator(value, this.doc)))
      });
    }
  }
  removeUsage(value, usages) {
    const record = usages.get(value);
    if (record) {
      record.usage--;
      if (record.usage <= 0) {
        removeElements(record.elements);
        usages.delete(value);
      }
    }
  }
  ngOnDestroy() {
    for (const [, {
      elements
    }] of [...this.inline, ...this.external]) {
      removeElements(elements);
    }
    this.hosts.clear();
  }
  addHost(hostNode) {
    this.hosts.add(hostNode);
    for (const [style, {
      elements
    }] of this.inline) {
      elements.push(this.addElement(hostNode, createStyleElement(style, this.doc)));
    }
    for (const [url, {
      elements
    }] of this.external) {
      elements.push(this.addElement(hostNode, createLinkElement(url, this.doc)));
    }
  }
  removeHost(hostNode) {
    this.hosts.delete(hostNode);
  }
  addElement(host, element) {
    if (this.nonce) {
      element.setAttribute('nonce', this.nonce);
    }
    if (typeof ngServerMode !== 'undefined' && ngServerMode) {
      element.setAttribute(APP_ID_ATTRIBUTE_NAME, this.appId);
    }
    return host.appendChild(element);
  }
  static ɵfac = function SharedStylesHost_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || SharedStylesHost)(_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT), _angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__.APP_ID), _angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__.CSP_NONCE, 8), _angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__.PLATFORM_ID));
  };
  static ɵprov = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: SharedStylesHost,
    factory: SharedStylesHost.ɵfac
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata(SharedStylesHost, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Injectable
  }], () => [{
    type: Document,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
      args: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT]
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
      args: [_angular_core__WEBPACK_IMPORTED_MODULE_2__.APP_ID]
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
      args: [_angular_core__WEBPACK_IMPORTED_MODULE_2__.CSP_NONCE]
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Optional
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
      args: [_angular_core__WEBPACK_IMPORTED_MODULE_2__.PLATFORM_ID]
    }]
  }], null);
})();
const NAMESPACE_URIS = {
  'svg': 'http://www.w3.org/2000/svg',
  'xhtml': 'http://www.w3.org/1999/xhtml',
  'xlink': 'http://www.w3.org/1999/xlink',
  'xml': 'http://www.w3.org/XML/1998/namespace',
  'xmlns': 'http://www.w3.org/2000/xmlns/',
  'math': 'http://www.w3.org/1998/Math/MathML'
};
const COMPONENT_REGEX = /%COMP%/g;
const SOURCEMAP_URL_REGEXP = /\/\*#\s*sourceMappingURL=(.+?)\s*\*\//;
const PROTOCOL_REGEXP = /^https?:/;
const COMPONENT_VARIABLE = '%COMP%';
const HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;
const CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;
const REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT = true;
const REMOVE_STYLES_ON_COMPONENT_DESTROY = new _angular_common__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'RemoveStylesOnCompDestroy' : '', {
  factory: () => REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT
});
function shimContentAttribute(componentShortId) {
  return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);
}
function shimHostAttribute(componentShortId) {
  return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);
}
function shimStylesContent(compId, styles) {
  return styles.map(s => s.replace(COMPONENT_REGEX, compId));
}
function addBaseHrefToCssSourceMap(baseHref, styles) {
  if (!baseHref) {
    return styles;
  }
  const absoluteBaseHrefUrl = new URL(baseHref, 'http://localhost');
  return styles.map(cssContent => {
    if (!cssContent.includes('sourceMappingURL=')) {
      return cssContent;
    }
    return cssContent.replace(SOURCEMAP_URL_REGEXP, (_, sourceMapUrl) => {
      if (sourceMapUrl[0] === '/' || sourceMapUrl.startsWith('data:') || PROTOCOL_REGEXP.test(sourceMapUrl)) {
        return `/*# sourceMappingURL=${sourceMapUrl} */`;
      }
      const {
        pathname: resolvedSourceMapUrl
      } = new URL(sourceMapUrl, absoluteBaseHrefUrl);
      return `/*# sourceMappingURL=${resolvedSourceMapUrl} */`;
    });
  });
}
class DomRendererFactory2 {
  eventManager;
  sharedStylesHost;
  appId;
  removeStylesOnCompDestroy;
  doc;
  ngZone;
  nonce;
  tracingService;
  rendererByCompId = new Map();
  defaultRenderer;
  platformIsServer;
  constructor(eventManager, sharedStylesHost, appId, removeStylesOnCompDestroy, doc, ngZone, nonce = null, tracingService = null) {
    this.eventManager = eventManager;
    this.sharedStylesHost = sharedStylesHost;
    this.appId = appId;
    this.removeStylesOnCompDestroy = removeStylesOnCompDestroy;
    this.doc = doc;
    this.ngZone = ngZone;
    this.nonce = nonce;
    this.tracingService = tracingService;
    this.platformIsServer = typeof ngServerMode !== 'undefined' && ngServerMode;
    this.defaultRenderer = new DefaultDomRenderer2(eventManager, doc, ngZone, this.platformIsServer, this.tracingService);
  }
  createRenderer(element, type) {
    if (!element || !type) {
      return this.defaultRenderer;
    }
    if (typeof ngServerMode !== 'undefined' && ngServerMode && (type.encapsulation === _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewEncapsulation.ShadowDom || type.encapsulation === _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewEncapsulation.ExperimentalIsolatedShadowDom)) {
      type = {
        ...type,
        encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewEncapsulation.Emulated
      };
    }
    const renderer = this.getOrCreateRenderer(element, type);
    if (renderer instanceof EmulatedEncapsulationDomRenderer2) {
      renderer.applyToHost(element);
    } else if (renderer instanceof NoneEncapsulationDomRenderer) {
      renderer.applyStyles();
    }
    return renderer;
  }
  getOrCreateRenderer(element, type) {
    const rendererByCompId = this.rendererByCompId;
    let renderer = rendererByCompId.get(type.id);
    if (!renderer) {
      const doc = this.doc;
      const ngZone = this.ngZone;
      const eventManager = this.eventManager;
      const sharedStylesHost = this.sharedStylesHost;
      const removeStylesOnCompDestroy = this.removeStylesOnCompDestroy;
      const platformIsServer = this.platformIsServer;
      const tracingService = this.tracingService;
      switch (type.encapsulation) {
        case _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewEncapsulation.Emulated:
          renderer = new EmulatedEncapsulationDomRenderer2(eventManager, sharedStylesHost, type, this.appId, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, tracingService);
          break;
        case _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewEncapsulation.ShadowDom:
          return new ShadowDomRenderer(eventManager, element, type, doc, ngZone, this.nonce, platformIsServer, tracingService, sharedStylesHost);
        case _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewEncapsulation.ExperimentalIsolatedShadowDom:
          return new ShadowDomRenderer(eventManager, element, type, doc, ngZone, this.nonce, platformIsServer, tracingService);
        default:
          renderer = new NoneEncapsulationDomRenderer(eventManager, sharedStylesHost, type, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, tracingService);
          break;
      }
      rendererByCompId.set(type.id, renderer);
    }
    return renderer;
  }
  ngOnDestroy() {
    this.rendererByCompId.clear();
  }
  componentReplaced(componentId) {
    this.rendererByCompId.delete(componentId);
  }
  static ɵfac = function DomRendererFactory2_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || DomRendererFactory2)(_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](EventManager), _angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](SharedStylesHost), _angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__.APP_ID), _angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](REMOVE_STYLES_ON_COMPONENT_DESTROY), _angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT), _angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__.NgZone), _angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__.CSP_NONCE), _angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__.TracingService, 8));
  };
  static ɵprov = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: DomRendererFactory2,
    factory: DomRendererFactory2.ɵfac
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata(DomRendererFactory2, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Injectable
  }], () => [{
    type: EventManager
  }, {
    type: SharedStylesHost
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
      args: [_angular_core__WEBPACK_IMPORTED_MODULE_2__.APP_ID]
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
      args: [REMOVE_STYLES_ON_COMPONENT_DESTROY]
    }]
  }, {
    type: Document,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
      args: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT]
    }]
  }, {
    type: _angular_common__WEBPACK_IMPORTED_MODULE_0__.NgZone
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
      args: [_angular_core__WEBPACK_IMPORTED_MODULE_2__.CSP_NONCE]
    }]
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.TracingService,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
      args: [_angular_core__WEBPACK_IMPORTED_MODULE_2__.TracingService]
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Optional
    }]
  }], null);
})();
class DefaultDomRenderer2 {
  eventManager;
  doc;
  ngZone;
  platformIsServer;
  tracingService;
  data = Object.create(null);
  throwOnSyntheticProps = true;
  constructor(eventManager, doc, ngZone, platformIsServer, tracingService) {
    this.eventManager = eventManager;
    this.doc = doc;
    this.ngZone = ngZone;
    this.platformIsServer = platformIsServer;
    this.tracingService = tracingService;
  }
  destroy() {}
  destroyNode = null;
  createElement(name, namespace) {
    if (namespace) {
      return this.doc.createElementNS(NAMESPACE_URIS[namespace] || namespace, name);
    }
    return this.doc.createElement(name);
  }
  createComment(value) {
    return this.doc.createComment(value);
  }
  createText(value) {
    return this.doc.createTextNode(value);
  }
  appendChild(parent, newChild) {
    const targetParent = isTemplateNode(parent) ? parent.content : parent;
    targetParent.appendChild(newChild);
  }
  insertBefore(parent, newChild, refChild) {
    if (parent) {
      const targetParent = isTemplateNode(parent) ? parent.content : parent;
      targetParent.insertBefore(newChild, refChild);
    }
  }
  removeChild(_parent, oldChild) {
    oldChild.remove();
  }
  selectRootElement(selectorOrNode, preserveContent) {
    let el = typeof selectorOrNode === 'string' ? this.doc.querySelector(selectorOrNode) : selectorOrNode;
    if (!el) {
      throw new _angular_common__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(-5104, (typeof ngDevMode === 'undefined' || ngDevMode) && `The selector "${selectorOrNode}" did not match any elements`);
    }
    if (!preserveContent) {
      el.textContent = '';
    }
    return el;
  }
  parentNode(node) {
    return node.parentNode;
  }
  nextSibling(node) {
    return node.nextSibling;
  }
  setAttribute(el, name, value, namespace) {
    if (namespace) {
      name = namespace + ':' + name;
      const namespaceUri = NAMESPACE_URIS[namespace];
      if (namespaceUri) {
        el.setAttributeNS(namespaceUri, name, value);
      } else {
        el.setAttribute(name, value);
      }
    } else {
      el.setAttribute(name, value);
    }
  }
  removeAttribute(el, name, namespace) {
    if (namespace) {
      const namespaceUri = NAMESPACE_URIS[namespace];
      if (namespaceUri) {
        el.removeAttributeNS(namespaceUri, name);
      } else {
        el.removeAttribute(`${namespace}:${name}`);
      }
    } else {
      el.removeAttribute(name);
    }
  }
  addClass(el, name) {
    el.classList.add(name);
  }
  removeClass(el, name) {
    el.classList.remove(name);
  }
  setStyle(el, style, value, flags) {
    if (flags & (_angular_core__WEBPACK_IMPORTED_MODULE_2__.RendererStyleFlags2.DashCase | _angular_core__WEBPACK_IMPORTED_MODULE_2__.RendererStyleFlags2.Important)) {
      el.style.setProperty(style, value, flags & _angular_core__WEBPACK_IMPORTED_MODULE_2__.RendererStyleFlags2.Important ? 'important' : '');
    } else {
      el.style[style] = value;
    }
  }
  removeStyle(el, style, flags) {
    if (flags & _angular_core__WEBPACK_IMPORTED_MODULE_2__.RendererStyleFlags2.DashCase) {
      el.style.removeProperty(style);
    } else {
      el.style[style] = '';
    }
  }
  setProperty(el, name, value) {
    if (el == null) {
      return;
    }
    (typeof ngDevMode === 'undefined' || ngDevMode) && this.throwOnSyntheticProps && checkNoSyntheticProp(name, 'property');
    el[name] = value;
  }
  setValue(node, value) {
    node.nodeValue = value;
  }
  listen(target, event, callback, options) {
    (typeof ngDevMode === 'undefined' || ngDevMode) && this.throwOnSyntheticProps && checkNoSyntheticProp(event, 'listener');
    if (typeof target === 'string') {
      target = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.getDOM)().getGlobalEventTarget(this.doc, target);
      if (!target) {
        throw new _angular_common__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(5102, (typeof ngDevMode === 'undefined' || ngDevMode) && `Unsupported event target ${target} for event ${event}`);
      }
    }
    let wrappedCallback = this.decoratePreventDefault(callback);
    if (this.tracingService?.wrapEventListener) {
      wrappedCallback = this.tracingService.wrapEventListener(target, event, wrappedCallback);
    }
    return this.eventManager.addEventListener(target, event, wrappedCallback, options);
  }
  decoratePreventDefault(eventHandler) {
    return event => {
      if (event === '__ngUnwrap__') {
        return eventHandler;
      }
      const allowDefaultBehavior = typeof ngServerMode !== 'undefined' && ngServerMode ? this.ngZone.runGuarded(() => eventHandler(event)) : eventHandler(event);
      if (allowDefaultBehavior === false) {
        event.preventDefault();
      }
      return undefined;
    };
  }
}
const AT_CHARCODE = (() => '@'.charCodeAt(0))();
function checkNoSyntheticProp(name, nameKind) {
  if (name.charCodeAt(0) === AT_CHARCODE) {
    throw new _angular_common__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(5105, `Unexpected synthetic ${nameKind} ${name} found. Please make sure that:
  - Make sure \`provideAnimationsAsync()\`, \`provideAnimations()\` or \`provideNoopAnimations()\` call was added to a list of providers used to bootstrap an application.
  - There is a corresponding animation configuration named \`${name}\` defined in the \`animations\` field of the \`@Component\` decorator (see https://angular.dev/api/core/Component#animations).`);
  }
}
function isTemplateNode(node) {
  return node.tagName === 'TEMPLATE' && node.content !== undefined;
}
class ShadowDomRenderer extends DefaultDomRenderer2 {
  hostEl;
  sharedStylesHost;
  shadowRoot;
  constructor(eventManager, hostEl, component, doc, ngZone, nonce, platformIsServer, tracingService, sharedStylesHost) {
    super(eventManager, doc, ngZone, platformIsServer, tracingService);
    this.hostEl = hostEl;
    this.sharedStylesHost = sharedStylesHost;
    this.shadowRoot = hostEl.attachShadow({
      mode: 'open'
    });
    if (this.sharedStylesHost) {
      this.sharedStylesHost.addHost(this.shadowRoot);
    }
    let styles = component.styles;
    if (ngDevMode) {
      const baseHref = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.getDOM)().getBaseHref(doc) ?? '';
      styles = addBaseHrefToCssSourceMap(baseHref, styles);
    }
    styles = shimStylesContent(component.id, styles);
    for (const style of styles) {
      const styleEl = document.createElement('style');
      if (nonce) {
        styleEl.setAttribute('nonce', nonce);
      }
      styleEl.textContent = style;
      this.shadowRoot.appendChild(styleEl);
    }
    const styleUrls = component.getExternalStyles?.();
    if (styleUrls) {
      for (const styleUrl of styleUrls) {
        const linkEl = createLinkElement(styleUrl, doc);
        if (nonce) {
          linkEl.setAttribute('nonce', nonce);
        }
        this.shadowRoot.appendChild(linkEl);
      }
    }
  }
  nodeOrShadowRoot(node) {
    return node === this.hostEl ? this.shadowRoot : node;
  }
  appendChild(parent, newChild) {
    return super.appendChild(this.nodeOrShadowRoot(parent), newChild);
  }
  insertBefore(parent, newChild, refChild) {
    return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild);
  }
  removeChild(_parent, oldChild) {
    return super.removeChild(null, oldChild);
  }
  parentNode(node) {
    return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));
  }
  destroy() {
    if (this.sharedStylesHost) {
      this.sharedStylesHost.removeHost(this.shadowRoot);
    }
  }
}
class NoneEncapsulationDomRenderer extends DefaultDomRenderer2 {
  sharedStylesHost;
  removeStylesOnCompDestroy;
  styles;
  styleUrls;
  constructor(eventManager, sharedStylesHost, component, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, tracingService, compId) {
    super(eventManager, doc, ngZone, platformIsServer, tracingService);
    this.sharedStylesHost = sharedStylesHost;
    this.removeStylesOnCompDestroy = removeStylesOnCompDestroy;
    let styles = component.styles;
    if (ngDevMode) {
      const baseHref = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.getDOM)().getBaseHref(doc) ?? '';
      styles = addBaseHrefToCssSourceMap(baseHref, styles);
    }
    this.styles = compId ? shimStylesContent(compId, styles) : styles;
    this.styleUrls = component.getExternalStyles?.(compId);
  }
  applyStyles() {
    this.sharedStylesHost.addStyles(this.styles, this.styleUrls);
  }
  destroy() {
    if (!this.removeStylesOnCompDestroy) {
      return;
    }
    if (_angular_core__WEBPACK_IMPORTED_MODULE_2__.allLeavingAnimations.size === 0) {
      this.sharedStylesHost.removeStyles(this.styles, this.styleUrls);
    }
  }
}
class EmulatedEncapsulationDomRenderer2 extends NoneEncapsulationDomRenderer {
  contentAttr;
  hostAttr;
  constructor(eventManager, sharedStylesHost, component, appId, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, tracingService) {
    const compId = appId + '-' + component.id;
    super(eventManager, sharedStylesHost, component, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, tracingService, compId);
    this.contentAttr = shimContentAttribute(compId);
    this.hostAttr = shimHostAttribute(compId);
  }
  applyToHost(element) {
    this.applyStyles();
    this.setAttribute(element, this.hostAttr, '');
  }
  createElement(parent, name) {
    const el = super.createElement(parent, name);
    super.setAttribute(el, this.contentAttr, '');
    return el;
  }
}


/***/ }),

/***/ 552:
/*!**********************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@angular+core@21.0.5_@angular+compiler@21.0.5_rxjs@7.8.2_zone.js@0.16.0/node_modules/@angular/core/fesm2022/primitives-event-dispatch.mjs ***!
  \**********************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Attribute: () => (/* reexport safe */ _attribute_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.Attribute),
/* harmony export */   EventContract: () => (/* binding */ EventContract),
/* harmony export */   EventContractContainer: () => (/* binding */ EventContractContainer),
/* harmony export */   EventDispatcher: () => (/* binding */ EventDispatcher),
/* harmony export */   EventInfoWrapper: () => (/* binding */ EventInfoWrapper),
/* harmony export */   EventPhase: () => (/* binding */ EventPhase),
/* harmony export */   bootstrapAppScopedEarlyEventContract: () => (/* binding */ bootstrapAppScopedEarlyEventContract),
/* harmony export */   clearAppScopedEarlyEventContract: () => (/* binding */ clearAppScopedEarlyEventContract),
/* harmony export */   getActionCache: () => (/* binding */ getDefaulted),
/* harmony export */   getAppScopedQueuedEventInfos: () => (/* binding */ getAppScopedQueuedEventInfos),
/* harmony export */   isCaptureEventType: () => (/* binding */ isCaptureEventType),
/* harmony export */   isEarlyEventType: () => (/* binding */ isEarlyEventType),
/* harmony export */   registerAppScopedDispatcher: () => (/* binding */ registerAppScopedDispatcher),
/* harmony export */   registerDispatcher: () => (/* binding */ registerDispatcher$1),
/* harmony export */   removeAllAppScopedEventListeners: () => (/* binding */ removeAllAppScopedEventListeners)
/* harmony export */ });
/* harmony import */ var _attribute_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_attribute-chunk.mjs */ 5877);
/**
 * @license Angular v21.0.5
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */


const Property = {
  JSACTION: '__jsaction',
  OWNER: '__owner'
};
const parseCache = {};
function get(element) {
  return element[Property.JSACTION];
}
function getDefaulted(element) {
  const cache = get(element) ?? {};
  set(element, cache);
  return cache;
}
function set(element, actionMap) {
  element[Property.JSACTION] = actionMap;
}
function getParsed(text) {
  return parseCache[text];
}
function setParsed(text, parsed) {
  parseCache[text] = parsed;
}
const EventType = {
  AUXCLICK: 'auxclick',
  CHANGE: 'change',
  CLICK: 'click',
  CLICKMOD: 'clickmod',
  CLICKONLY: 'clickonly',
  DBLCLICK: 'dblclick',
  FOCUS: 'focus',
  FOCUSIN: 'focusin',
  BLUR: 'blur',
  FOCUSOUT: 'focusout',
  SUBMIT: 'submit',
  KEYDOWN: 'keydown',
  KEYPRESS: 'keypress',
  KEYUP: 'keyup',
  MOUSEUP: 'mouseup',
  MOUSEDOWN: 'mousedown',
  MOUSEOVER: 'mouseover',
  MOUSEOUT: 'mouseout',
  MOUSEENTER: 'mouseenter',
  MOUSELEAVE: 'mouseleave',
  MOUSEMOVE: 'mousemove',
  POINTERUP: 'pointerup',
  POINTERDOWN: 'pointerdown',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERMOVE: 'pointermove',
  POINTERCANCEL: 'pointercancel',
  GOTPOINTERCAPTURE: 'gotpointercapture',
  LOSTPOINTERCAPTURE: 'lostpointercapture',
  ERROR: 'error',
  LOAD: 'load',
  UNLOAD: 'unload',
  TOUCHSTART: 'touchstart',
  TOUCHEND: 'touchend',
  TOUCHMOVE: 'touchmove',
  INPUT: 'input',
  SCROLL: 'scroll',
  TOGGLE: 'toggle',
  CUSTOM: '_custom'
};
const MOUSE_SPECIAL_EVENT_TYPES = [EventType.MOUSEENTER, EventType.MOUSELEAVE, 'pointerenter', 'pointerleave'];
const BUBBLE_EVENT_TYPES = [EventType.CLICK, EventType.DBLCLICK, EventType.FOCUSIN, EventType.FOCUSOUT, EventType.KEYDOWN, EventType.KEYUP, EventType.KEYPRESS, EventType.MOUSEOVER, EventType.MOUSEOUT, EventType.SUBMIT, EventType.TOUCHSTART, EventType.TOUCHEND, EventType.TOUCHMOVE, 'touchcancel', 'auxclick', 'change', 'compositionstart', 'compositionupdate', 'compositionend', 'beforeinput', 'input', 'select', 'copy', 'cut', 'paste', 'mousedown', 'mouseup', 'wheel', 'contextmenu', 'dragover', 'dragenter', 'dragleave', 'drop', 'dragstart', 'dragend', 'pointerdown', 'pointermove', 'pointerup', 'pointercancel', 'pointerover', 'pointerout', 'gotpointercapture', 'lostpointercapture', 'ended', 'loadedmetadata', 'pagehide', 'pageshow', 'visibilitychange', 'beforematch'];
const CAPTURE_EVENT_TYPES = [EventType.FOCUS, EventType.BLUR, EventType.ERROR, EventType.LOAD, EventType.TOGGLE];
const isCaptureEventType = eventType => CAPTURE_EVENT_TYPES.indexOf(eventType) >= 0;
const EARLY_EVENT_TYPES = BUBBLE_EVENT_TYPES.concat(CAPTURE_EVENT_TYPES);
const isEarlyEventType = eventType => EARLY_EVENT_TYPES.indexOf(eventType) >= 0;
function getBrowserEventType(eventType) {
  if (eventType === EventType.MOUSEENTER) {
    return EventType.MOUSEOVER;
  } else if (eventType === EventType.MOUSELEAVE) {
    return EventType.MOUSEOUT;
  } else if (eventType === EventType.POINTERENTER) {
    return EventType.POINTEROVER;
  } else if (eventType === EventType.POINTERLEAVE) {
    return EventType.POINTEROUT;
  }
  return eventType;
}
function addEventListener(element, eventType, handler, passive) {
  let capture = false;
  if (isCaptureEventType(eventType)) {
    capture = true;
  }
  const options = typeof passive === 'boolean' ? {
    capture,
    passive
  } : capture;
  element.addEventListener(eventType, handler, options);
  return {
    eventType,
    handler,
    capture,
    passive
  };
}
function removeEventListener(element, info) {
  if (element.removeEventListener) {
    const options = typeof info.passive === 'boolean' ? {
      capture: info.capture
    } : info.capture;
    element.removeEventListener(info.eventType, info.handler, options);
  } else if (element.detachEvent) {
    element.detachEvent(`on${info.eventType}`, info.handler);
  }
}
function preventDefault(e) {
  e.preventDefault ? e.preventDefault() : e.returnValue = false;
}
let isMac = typeof navigator !== 'undefined' && /Macintosh/.test(navigator.userAgent);
function isMiddleClick(e) {
  return e.which === 2 || e.which == null && e.button === 4;
}
function isModifiedClickEvent(e) {
  return isMac && e.metaKey || !isMac && e.ctrlKey || isMiddleClick(e) || e.shiftKey;
}
function isMouseSpecialEvent(e, type, element) {
  const related = e.relatedTarget;
  return (e.type === EventType.MOUSEOVER && type === EventType.MOUSEENTER || e.type === EventType.MOUSEOUT && type === EventType.MOUSELEAVE || e.type === EventType.POINTEROVER && type === EventType.POINTERENTER || e.type === EventType.POINTEROUT && type === EventType.POINTERLEAVE) && (!related || related !== element && !element.contains(related));
}
function createMouseSpecialEvent(e, target) {
  const copy = {};
  for (const property in e) {
    if (property === 'srcElement' || property === 'target') {
      continue;
    }
    const key = property;
    const value = e[key];
    if (typeof value === 'function') {
      continue;
    }
    copy[key] = value;
  }
  if (e.type === EventType.MOUSEOVER) {
    copy['type'] = EventType.MOUSEENTER;
  } else if (e.type === EventType.MOUSEOUT) {
    copy['type'] = EventType.MOUSELEAVE;
  } else if (e.type === EventType.POINTEROVER) {
    copy['type'] = EventType.POINTERENTER;
  } else {
    copy['type'] = EventType.POINTERLEAVE;
  }
  copy['target'] = copy['srcElement'] = target;
  copy['bubbles'] = false;
  copy['_originalEvent'] = e;
  return copy;
}
const isIos = typeof navigator !== 'undefined' && /iPhone|iPad|iPod/.test(navigator.userAgent);
class EventContractContainer {
  element;
  handlerInfos = [];
  constructor(element) {
    this.element = element;
  }
  addEventListener(eventType, getHandler, passive) {
    if (isIos) {
      this.element.style.cursor = 'pointer';
    }
    this.handlerInfos.push(addEventListener(this.element, eventType, getHandler(this.element), passive));
  }
  cleanUp() {
    for (let i = 0; i < this.handlerInfos.length; i++) {
      removeEventListener(this.element, this.handlerInfos[i]);
    }
    this.handlerInfos = [];
  }
}
const Char = {
  NAMESPACE_ACTION_SEPARATOR: '.',
  EVENT_ACTION_SEPARATOR: ':'
};
function getEventType(eventInfo) {
  return eventInfo.eventType;
}
function setEventType(eventInfo, eventType) {
  eventInfo.eventType = eventType;
}
function getEvent(eventInfo) {
  return eventInfo.event;
}
function setEvent(eventInfo, event) {
  eventInfo.event = event;
}
function getTargetElement(eventInfo) {
  return eventInfo.targetElement;
}
function setTargetElement(eventInfo, targetElement) {
  eventInfo.targetElement = targetElement;
}
function getContainer(eventInfo) {
  return eventInfo.eic;
}
function setContainer(eventInfo, container) {
  eventInfo.eic = container;
}
function getTimestamp(eventInfo) {
  return eventInfo.timeStamp;
}
function setTimestamp(eventInfo, timestamp) {
  eventInfo.timeStamp = timestamp;
}
function getAction(eventInfo) {
  return eventInfo.eia;
}
function setAction(eventInfo, actionName, actionElement) {
  eventInfo.eia = [actionName, actionElement];
}
function unsetAction(eventInfo) {
  eventInfo.eia = undefined;
}
function getActionElement(actionInfo) {
  return actionInfo[1];
}
function getIsReplay(eventInfo) {
  return eventInfo.eirp;
}
function setIsReplay(eventInfo, replay) {
  eventInfo.eirp = replay;
}
function getResolved(eventInfo) {
  return eventInfo.eir;
}
function setResolved(eventInfo, resolved) {
  eventInfo.eir = resolved;
}
function cloneEventInfo(eventInfo) {
  return {
    eventType: eventInfo.eventType,
    event: eventInfo.event,
    targetElement: eventInfo.targetElement,
    eic: eventInfo.eic,
    eia: eventInfo.eia,
    timeStamp: eventInfo.timeStamp,
    eirp: eventInfo.eirp,
    eiack: eventInfo.eiack,
    eir: eventInfo.eir
  };
}
function createEventInfoFromParameters(eventType, event, targetElement, container, timestamp, action, isReplay, a11yClickKey) {
  return {
    eventType,
    event,
    targetElement,
    eic: container,
    timeStamp: timestamp,
    eia: action,
    eirp: isReplay,
    eiack: a11yClickKey
  };
}
class EventInfoWrapper {
  eventInfo;
  constructor(eventInfo) {
    this.eventInfo = eventInfo;
  }
  getEventType() {
    return getEventType(this.eventInfo);
  }
  setEventType(eventType) {
    setEventType(this.eventInfo, eventType);
  }
  getEvent() {
    return getEvent(this.eventInfo);
  }
  setEvent(event) {
    setEvent(this.eventInfo, event);
  }
  getTargetElement() {
    return getTargetElement(this.eventInfo);
  }
  setTargetElement(targetElement) {
    setTargetElement(this.eventInfo, targetElement);
  }
  getContainer() {
    return getContainer(this.eventInfo);
  }
  setContainer(container) {
    setContainer(this.eventInfo, container);
  }
  getTimestamp() {
    return getTimestamp(this.eventInfo);
  }
  setTimestamp(timestamp) {
    setTimestamp(this.eventInfo, timestamp);
  }
  getAction() {
    const action = getAction(this.eventInfo);
    if (!action) return undefined;
    return {
      name: action[0],
      element: action[1]
    };
  }
  setAction(action) {
    if (!action) {
      unsetAction(this.eventInfo);
      return;
    }
    setAction(this.eventInfo, action.name, action.element);
  }
  getIsReplay() {
    return getIsReplay(this.eventInfo);
  }
  setIsReplay(replay) {
    setIsReplay(this.eventInfo, replay);
  }
  getResolved() {
    return getResolved(this.eventInfo);
  }
  setResolved(resolved) {
    setResolved(this.eventInfo, resolved);
  }
  clone() {
    return new EventInfoWrapper(cloneEventInfo(this.eventInfo));
  }
}
const EMPTY_ACTION_MAP = {};
const REGEXP_SEMICOLON = /\s*;\s*/;
const DEFAULT_EVENT_TYPE = EventType.CLICK;
class ActionResolver {
  a11yClickSupport = false;
  clickModSupport = true;
  syntheticMouseEventSupport;
  updateEventInfoForA11yClick = undefined;
  preventDefaultForA11yClick = undefined;
  populateClickOnlyAction = undefined;
  constructor({
    syntheticMouseEventSupport = false,
    clickModSupport = true
  } = {}) {
    this.syntheticMouseEventSupport = syntheticMouseEventSupport;
    this.clickModSupport = clickModSupport;
  }
  resolveEventType(eventInfo) {
    if (this.clickModSupport && getEventType(eventInfo) === EventType.CLICK && isModifiedClickEvent(getEvent(eventInfo))) {
      setEventType(eventInfo, EventType.CLICKMOD);
    } else if (this.a11yClickSupport) {
      this.updateEventInfoForA11yClick(eventInfo);
    }
  }
  resolveAction(eventInfo) {
    if (getResolved(eventInfo)) {
      return;
    }
    this.populateAction(eventInfo, getTargetElement(eventInfo));
    setResolved(eventInfo, true);
  }
  resolveParentAction(eventInfo) {
    const action = getAction(eventInfo);
    const actionElement = action && getActionElement(action);
    unsetAction(eventInfo);
    const parentNode = actionElement && this.getParentNode(actionElement);
    if (!parentNode) {
      return;
    }
    this.populateAction(eventInfo, parentNode);
  }
  populateAction(eventInfo, currentTarget) {
    let actionElement = currentTarget;
    while (actionElement && actionElement !== getContainer(eventInfo)) {
      if (actionElement.nodeType === Node.ELEMENT_NODE) {
        this.populateActionOnElement(actionElement, eventInfo);
      }
      if (getAction(eventInfo)) {
        break;
      }
      actionElement = this.getParentNode(actionElement);
    }
    const action = getAction(eventInfo);
    if (!action) {
      return;
    }
    if (this.a11yClickSupport) {
      this.preventDefaultForA11yClick(eventInfo);
    }
    if (this.syntheticMouseEventSupport) {
      if (getEventType(eventInfo) === EventType.MOUSEENTER || getEventType(eventInfo) === EventType.MOUSELEAVE || getEventType(eventInfo) === EventType.POINTERENTER || getEventType(eventInfo) === EventType.POINTERLEAVE) {
        if (isMouseSpecialEvent(getEvent(eventInfo), getEventType(eventInfo), getActionElement(action))) {
          const copiedEvent = createMouseSpecialEvent(getEvent(eventInfo), getActionElement(action));
          setEvent(eventInfo, copiedEvent);
          setTargetElement(eventInfo, getActionElement(action));
        } else {
          unsetAction(eventInfo);
        }
      }
    }
  }
  getParentNode(element) {
    const owner = element[Property.OWNER];
    if (owner) {
      return owner;
    }
    const parentNode = element.parentNode;
    if (parentNode?.nodeName === '#document-fragment') {
      return parentNode?.host ?? null;
    }
    return parentNode;
  }
  populateActionOnElement(actionElement, eventInfo) {
    const actionMap = this.parseActions(actionElement);
    const actionName = actionMap[getEventType(eventInfo)];
    if (actionName !== undefined) {
      setAction(eventInfo, actionName, actionElement);
    }
    if (this.a11yClickSupport) {
      this.populateClickOnlyAction(actionElement, eventInfo, actionMap);
    }
  }
  parseActions(actionElement) {
    let actionMap = get(actionElement);
    if (!actionMap) {
      const jsactionAttribute = actionElement.getAttribute(_attribute_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.Attribute.JSACTION);
      if (!jsactionAttribute) {
        actionMap = EMPTY_ACTION_MAP;
        set(actionElement, actionMap);
      } else {
        actionMap = getParsed(jsactionAttribute);
        if (!actionMap) {
          actionMap = {};
          const values = jsactionAttribute.split(REGEXP_SEMICOLON);
          for (let idx = 0; idx < values.length; idx++) {
            const value = values[idx];
            if (!value) {
              continue;
            }
            const colon = value.indexOf(Char.EVENT_ACTION_SEPARATOR);
            const hasColon = colon !== -1;
            const type = hasColon ? value.substr(0, colon).trim() : DEFAULT_EVENT_TYPE;
            const action = hasColon ? value.substr(colon + 1).trim() : value;
            actionMap[type] = action;
          }
          setParsed(jsactionAttribute, actionMap);
        }
        set(actionElement, actionMap);
      }
    }
    return actionMap;
  }
  addA11yClickSupport(updateEventInfoForA11yClick, preventDefaultForA11yClick, populateClickOnlyAction) {
    this.a11yClickSupport = true;
    this.updateEventInfoForA11yClick = updateEventInfoForA11yClick;
    this.preventDefaultForA11yClick = preventDefaultForA11yClick;
    this.populateClickOnlyAction = populateClickOnlyAction;
  }
}
var Restriction;
(function (Restriction) {
  Restriction[Restriction["I_AM_THE_JSACTION_FRAMEWORK"] = 0] = "I_AM_THE_JSACTION_FRAMEWORK";
})(Restriction || (Restriction = {}));
class Dispatcher {
  dispatchDelegate;
  actionResolver;
  eventReplayer;
  eventReplayScheduled = false;
  replayEventInfoWrappers = [];
  constructor(dispatchDelegate, {
    actionResolver,
    eventReplayer
  } = {}) {
    this.dispatchDelegate = dispatchDelegate;
    this.actionResolver = actionResolver;
    this.eventReplayer = eventReplayer;
  }
  dispatch(eventInfo) {
    const eventInfoWrapper = new EventInfoWrapper(eventInfo);
    this.actionResolver?.resolveEventType(eventInfo);
    this.actionResolver?.resolveAction(eventInfo);
    const action = eventInfoWrapper.getAction();
    if (action && shouldPreventDefaultBeforeDispatching(action.element, eventInfoWrapper)) {
      preventDefault(eventInfoWrapper.getEvent());
    }
    if (this.eventReplayer && eventInfoWrapper.getIsReplay()) {
      this.scheduleEventInfoWrapperReplay(eventInfoWrapper);
      return;
    }
    this.dispatchDelegate(eventInfoWrapper);
  }
  scheduleEventInfoWrapperReplay(eventInfoWrapper) {
    this.replayEventInfoWrappers.push(eventInfoWrapper);
    if (this.eventReplayScheduled) {
      return;
    }
    this.eventReplayScheduled = true;
    Promise.resolve().then(() => {
      this.eventReplayScheduled = false;
      this.eventReplayer(this.replayEventInfoWrappers);
    });
  }
}
function shouldPreventDefaultBeforeDispatching(actionElement, eventInfoWrapper) {
  return actionElement.tagName === 'A' && (eventInfoWrapper.getEventType() === EventType.CLICK || eventInfoWrapper.getEventType() === EventType.CLICKMOD);
}
const PROPAGATION_STOPPED_SYMBOL = /* @__PURE__ */Symbol.for('propagationStopped');
const EventPhase = {
  REPLAY: 101
};
const PREVENT_DEFAULT_ERROR_MESSAGE_DETAILS = ' Because event replay occurs after browser dispatch, `preventDefault` would have no ' + 'effect. You can check whether an event is being replayed by accessing the event phase: ' + '`event.eventPhase === EventPhase.REPLAY`.';
const PREVENT_DEFAULT_ERROR_MESSAGE = `\`preventDefault\` called during event replay.`;
const COMPOSED_PATH_ERROR_MESSAGE_DETAILS = ' Because event replay occurs after browser ' + 'dispatch, `composedPath()` will be empty. Iterate parent nodes from `event.target` or ' + '`event.currentTarget` if you need to check elements in the event path.';
const COMPOSED_PATH_ERROR_MESSAGE = `\`composedPath\` called during event replay.`;
class EventDispatcher {
  dispatchDelegate;
  clickModSupport;
  actionResolver;
  dispatcher;
  constructor(dispatchDelegate, clickModSupport = true) {
    this.dispatchDelegate = dispatchDelegate;
    this.clickModSupport = clickModSupport;
    this.actionResolver = new ActionResolver({
      clickModSupport
    });
    this.dispatcher = new Dispatcher(eventInfoWrapper => {
      this.dispatchToDelegate(eventInfoWrapper);
    }, {
      actionResolver: this.actionResolver
    });
  }
  dispatch(eventInfo) {
    this.dispatcher.dispatch(eventInfo);
  }
  dispatchToDelegate(eventInfoWrapper) {
    if (eventInfoWrapper.getIsReplay()) {
      prepareEventForReplay(eventInfoWrapper);
    }
    prepareEventForBubbling(eventInfoWrapper);
    while (eventInfoWrapper.getAction()) {
      prepareEventForDispatch(eventInfoWrapper);
      if (isCaptureEventType(eventInfoWrapper.getEventType()) && eventInfoWrapper.getAction().element !== eventInfoWrapper.getTargetElement()) {
        return;
      }
      this.dispatchDelegate(eventInfoWrapper.getEvent(), eventInfoWrapper.getAction().name);
      if (propagationStopped(eventInfoWrapper)) {
        return;
      }
      this.actionResolver.resolveParentAction(eventInfoWrapper.eventInfo);
    }
  }
}
function prepareEventForBubbling(eventInfoWrapper) {
  const event = eventInfoWrapper.getEvent();
  const originalStopPropagation = eventInfoWrapper.getEvent().stopPropagation.bind(event);
  const stopPropagation = () => {
    event[PROPAGATION_STOPPED_SYMBOL] = true;
    originalStopPropagation();
  };
  patchEventInstance(event, 'stopPropagation', stopPropagation);
  patchEventInstance(event, 'stopImmediatePropagation', stopPropagation);
}
function propagationStopped(eventInfoWrapper) {
  const event = eventInfoWrapper.getEvent();
  return !!event[PROPAGATION_STOPPED_SYMBOL];
}
function prepareEventForReplay(eventInfoWrapper) {
  const event = eventInfoWrapper.getEvent();
  const target = eventInfoWrapper.getTargetElement();
  const originalPreventDefault = event.preventDefault.bind(event);
  patchEventInstance(event, 'target', target);
  patchEventInstance(event, 'eventPhase', EventPhase.REPLAY);
  patchEventInstance(event, 'preventDefault', () => {
    originalPreventDefault();
    throw new Error(PREVENT_DEFAULT_ERROR_MESSAGE + (ngDevMode ? PREVENT_DEFAULT_ERROR_MESSAGE_DETAILS : ''));
  });
  patchEventInstance(event, 'composedPath', () => {
    throw new Error(COMPOSED_PATH_ERROR_MESSAGE + (ngDevMode ? COMPOSED_PATH_ERROR_MESSAGE_DETAILS : ''));
  });
}
function prepareEventForDispatch(eventInfoWrapper) {
  const event = eventInfoWrapper.getEvent();
  const currentTarget = eventInfoWrapper.getAction()?.element;
  if (currentTarget) {
    patchEventInstance(event, 'currentTarget', currentTarget, {
      configurable: true
    });
  }
}
function patchEventInstance(event, property, value, {
  configurable = false
} = {}) {
  Object.defineProperty(event, property, {
    value,
    configurable
  });
}
function registerDispatcher$1(eventContract, dispatcher) {
  eventContract.ecrd(eventInfo => {
    dispatcher.dispatch(eventInfo);
  }, Restriction.I_AM_THE_JSACTION_FRAMEWORK);
}
function createEarlyJsactionData(container) {
  const q = [];
  const d = eventInfo => {
    q.push(eventInfo);
  };
  const h = event => {
    d(createEventInfoFromParameters(event.type, event, event.target, container, Date.now()));
  };
  return {
    c: container,
    q,
    et: [],
    etc: [],
    d,
    h
  };
}
function addEvents(earlyJsactionData, types, capture) {
  for (let i = 0; i < types.length; i++) {
    const eventType = types[i];
    const eventTypes = capture ? earlyJsactionData.etc : earlyJsactionData.et;
    eventTypes.push(eventType);
    earlyJsactionData.c.addEventListener(eventType, earlyJsactionData.h, capture);
  }
}
function getQueuedEventInfos(earlyJsactionData) {
  return earlyJsactionData?.q ?? [];
}
function registerDispatcher(earlyJsactionData, dispatcher) {
  if (!earlyJsactionData) {
    return;
  }
  earlyJsactionData.d = dispatcher;
}
function removeAllEventListeners(earlyJsactionData) {
  if (!earlyJsactionData) {
    return;
  }
  removeEventListeners(earlyJsactionData.c, earlyJsactionData.et, earlyJsactionData.h);
  removeEventListeners(earlyJsactionData.c, earlyJsactionData.etc, earlyJsactionData.h, true);
}
function removeEventListeners(container, eventTypes, earlyEventHandler, capture) {
  for (let i = 0; i < eventTypes.length; i++) {
    container.removeEventListener(eventTypes[i], earlyEventHandler, capture);
  }
}
const MOUSE_SPECIAL_SUPPORT = false;
class EventContract {
  static MOUSE_SPECIAL_SUPPORT = MOUSE_SPECIAL_SUPPORT;
  containerManager;
  eventHandlers = {};
  browserEventTypeToExtraEventTypes = {};
  dispatcher = null;
  queuedEventInfos = [];
  constructor(containerManager) {
    this.containerManager = containerManager;
  }
  handleEvent(eventType, event, container) {
    const eventInfo = createEventInfoFromParameters(eventType, event, event.target, container, Date.now());
    this.handleEventInfo(eventInfo);
  }
  handleEventInfo(eventInfo) {
    if (!this.dispatcher) {
      setIsReplay(eventInfo, true);
      this.queuedEventInfos?.push(eventInfo);
      return;
    }
    this.dispatcher(eventInfo);
  }
  addEvent(eventType, prefixedEventType, passive) {
    if (eventType in this.eventHandlers || !this.containerManager) {
      return;
    }
    if (!EventContract.MOUSE_SPECIAL_SUPPORT && MOUSE_SPECIAL_EVENT_TYPES.indexOf(eventType) >= 0) {
      return;
    }
    const eventHandler = (eventType, event, container) => {
      this.handleEvent(eventType, event, container);
    };
    this.eventHandlers[eventType] = eventHandler;
    const browserEventType = getBrowserEventType(prefixedEventType || eventType);
    if (browserEventType !== eventType) {
      const eventTypes = this.browserEventTypeToExtraEventTypes[browserEventType] || [];
      eventTypes.push(eventType);
      this.browserEventTypeToExtraEventTypes[browserEventType] = eventTypes;
    }
    this.containerManager.addEventListener(browserEventType, element => {
      return event => {
        eventHandler(eventType, event, element);
      };
    }, passive);
  }
  replayEarlyEvents(earlyJsactionData = window._ejsa) {
    if (!earlyJsactionData) {
      return;
    }
    this.replayEarlyEventInfos(earlyJsactionData.q);
    removeAllEventListeners(earlyJsactionData);
    delete window._ejsa;
  }
  replayEarlyEventInfos(earlyEventInfos) {
    for (let i = 0; i < earlyEventInfos.length; i++) {
      const earlyEventInfo = earlyEventInfos[i];
      const eventTypes = this.getEventTypesForBrowserEventType(earlyEventInfo.eventType);
      for (let j = 0; j < eventTypes.length; j++) {
        const eventInfo = cloneEventInfo(earlyEventInfo);
        setEventType(eventInfo, eventTypes[j]);
        this.handleEventInfo(eventInfo);
      }
    }
  }
  getEventTypesForBrowserEventType(browserEventType) {
    const eventTypes = [];
    if (this.eventHandlers[browserEventType]) {
      eventTypes.push(browserEventType);
    }
    if (this.browserEventTypeToExtraEventTypes[browserEventType]) {
      eventTypes.push(...this.browserEventTypeToExtraEventTypes[browserEventType]);
    }
    return eventTypes;
  }
  handler(eventType) {
    return this.eventHandlers[eventType];
  }
  cleanUp() {
    this.containerManager?.cleanUp();
    this.containerManager = null;
    this.eventHandlers = {};
    this.browserEventTypeToExtraEventTypes = {};
    this.dispatcher = null;
    this.queuedEventInfos = [];
  }
  registerDispatcher(dispatcher, restriction) {
    this.ecrd(dispatcher, restriction);
  }
  ecrd(dispatcher, restriction) {
    this.dispatcher = dispatcher;
    if (this.queuedEventInfos?.length) {
      for (let i = 0; i < this.queuedEventInfos.length; i++) {
        this.handleEventInfo(this.queuedEventInfos[i]);
      }
      this.queuedEventInfos = null;
    }
  }
}
function bootstrapAppScopedEarlyEventContract(container, appId, bubbleEventTypes, captureEventTypes, dataContainer = window) {
  const earlyJsactionData = createEarlyJsactionData(container);
  if (!dataContainer._ejsas) {
    dataContainer._ejsas = {};
  }
  dataContainer._ejsas[appId] = earlyJsactionData;
  addEvents(earlyJsactionData, bubbleEventTypes);
  addEvents(earlyJsactionData, captureEventTypes, true);
}
function getAppScopedQueuedEventInfos(appId, dataContainer = window) {
  return getQueuedEventInfos(dataContainer._ejsas?.[appId]);
}
function registerAppScopedDispatcher(restriction, appId, dispatcher, dataContainer = window) {
  registerDispatcher(dataContainer._ejsas?.[appId], dispatcher);
}
function removeAllAppScopedEventListeners(appId, dataContainer = window) {
  removeAllEventListeners(dataContainer._ejsas?.[appId]);
}
function clearAppScopedEarlyEventContract(appId, dataContainer = window) {
  if (!dataContainer._ejsas) {
    return;
  }
  dataContainer._ejsas[appId] = undefined;
}


/***/ }),

/***/ 629:
/*!****************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@angular+forms@21.0.5_@angular+common@21.0.5_@angular+core@21.0.5_@angular+platform-browser@2_ju3dvhnmyg4fnnrs7p7sekkcxm/node_modules/@angular/forms/fesm2022/forms.mjs ***!
  \****************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractControl: () => (/* binding */ AbstractControl),
/* harmony export */   AbstractControlDirective: () => (/* binding */ AbstractControlDirective),
/* harmony export */   AbstractFormDirective: () => (/* binding */ AbstractFormDirective),
/* harmony export */   AbstractFormGroupDirective: () => (/* binding */ AbstractFormGroupDirective),
/* harmony export */   COMPOSITION_BUFFER_MODE: () => (/* binding */ COMPOSITION_BUFFER_MODE),
/* harmony export */   CheckboxControlValueAccessor: () => (/* binding */ CheckboxControlValueAccessor),
/* harmony export */   CheckboxRequiredValidator: () => (/* binding */ CheckboxRequiredValidator),
/* harmony export */   ControlContainer: () => (/* binding */ ControlContainer),
/* harmony export */   ControlEvent: () => (/* binding */ ControlEvent),
/* harmony export */   DefaultValueAccessor: () => (/* binding */ DefaultValueAccessor),
/* harmony export */   EmailValidator: () => (/* binding */ EmailValidator),
/* harmony export */   FormArray: () => (/* binding */ FormArray),
/* harmony export */   FormArrayDirective: () => (/* binding */ FormArrayDirective),
/* harmony export */   FormArrayName: () => (/* binding */ FormArrayName),
/* harmony export */   FormBuilder: () => (/* binding */ FormBuilder),
/* harmony export */   FormControl: () => (/* binding */ FormControl),
/* harmony export */   FormControlDirective: () => (/* binding */ FormControlDirective),
/* harmony export */   FormControlName: () => (/* binding */ FormControlName),
/* harmony export */   FormGroup: () => (/* binding */ FormGroup),
/* harmony export */   FormGroupDirective: () => (/* binding */ FormGroupDirective),
/* harmony export */   FormGroupName: () => (/* binding */ FormGroupName),
/* harmony export */   FormRecord: () => (/* binding */ FormRecord),
/* harmony export */   FormResetEvent: () => (/* binding */ FormResetEvent),
/* harmony export */   FormSubmittedEvent: () => (/* binding */ FormSubmittedEvent),
/* harmony export */   FormsModule: () => (/* binding */ FormsModule),
/* harmony export */   MaxLengthValidator: () => (/* binding */ MaxLengthValidator),
/* harmony export */   MaxValidator: () => (/* binding */ MaxValidator),
/* harmony export */   MinLengthValidator: () => (/* binding */ MinLengthValidator),
/* harmony export */   MinValidator: () => (/* binding */ MinValidator),
/* harmony export */   NG_ASYNC_VALIDATORS: () => (/* binding */ NG_ASYNC_VALIDATORS),
/* harmony export */   NG_VALIDATORS: () => (/* binding */ NG_VALIDATORS),
/* harmony export */   NG_VALUE_ACCESSOR: () => (/* binding */ NG_VALUE_ACCESSOR),
/* harmony export */   NgControl: () => (/* binding */ NgControl),
/* harmony export */   NgControlStatus: () => (/* binding */ NgControlStatus),
/* harmony export */   NgControlStatusGroup: () => (/* binding */ NgControlStatusGroup),
/* harmony export */   NgForm: () => (/* binding */ NgForm),
/* harmony export */   NgModel: () => (/* binding */ NgModel),
/* harmony export */   NgModelGroup: () => (/* binding */ NgModelGroup),
/* harmony export */   NgSelectOption: () => (/* binding */ NgSelectOption),
/* harmony export */   NonNullableFormBuilder: () => (/* binding */ NonNullableFormBuilder),
/* harmony export */   NumberValueAccessor: () => (/* binding */ NumberValueAccessor),
/* harmony export */   PatternValidator: () => (/* binding */ PatternValidator),
/* harmony export */   PristineChangeEvent: () => (/* binding */ PristineChangeEvent),
/* harmony export */   RadioControlValueAccessor: () => (/* binding */ RadioControlValueAccessor),
/* harmony export */   RangeValueAccessor: () => (/* binding */ RangeValueAccessor),
/* harmony export */   ReactiveFormsModule: () => (/* binding */ ReactiveFormsModule),
/* harmony export */   RequiredValidator: () => (/* binding */ RequiredValidator),
/* harmony export */   SelectControlValueAccessor: () => (/* binding */ SelectControlValueAccessor),
/* harmony export */   SelectMultipleControlValueAccessor: () => (/* binding */ SelectMultipleControlValueAccessor),
/* harmony export */   StatusChangeEvent: () => (/* binding */ StatusChangeEvent),
/* harmony export */   TouchedChangeEvent: () => (/* binding */ TouchedChangeEvent),
/* harmony export */   UntypedFormArray: () => (/* binding */ UntypedFormArray),
/* harmony export */   UntypedFormBuilder: () => (/* binding */ UntypedFormBuilder),
/* harmony export */   UntypedFormControl: () => (/* binding */ UntypedFormControl),
/* harmony export */   UntypedFormGroup: () => (/* binding */ UntypedFormGroup),
/* harmony export */   VERSION: () => (/* binding */ VERSION),
/* harmony export */   Validators: () => (/* binding */ Validators),
/* harmony export */   ValueChangeEvent: () => (/* binding */ ValueChangeEvent),
/* harmony export */   isFormArray: () => (/* binding */ isFormArray),
/* harmony export */   isFormControl: () => (/* binding */ isFormControl),
/* harmony export */   isFormGroup: () => (/* binding */ isFormGroup),
/* harmony export */   isFormRecord: () => (/* binding */ isFormRecord),
/* harmony export */   "ɵInternalFormsSharedModule": () => (/* binding */ ɵInternalFormsSharedModule),
/* harmony export */   "ɵNgNoValidate": () => (/* binding */ ɵNgNoValidate),
/* harmony export */   "ɵNgSelectMultipleOption": () => (/* binding */ ɵNgSelectMultipleOption)
/* harmony export */ });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ 64);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ 7367);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ 8357);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/core */ 3863);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/common */ 8021);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs */ 1171);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ 4897);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs */ 7909);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs/operators */ 4063);
/**
 * @license Angular v21.0.5
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */






class BaseControlValueAccessor {
  _renderer;
  _elementRef;
  onChange = _ => {};
  onTouched = () => {};
  constructor(_renderer, _elementRef) {
    this._renderer = _renderer;
    this._elementRef = _elementRef;
  }
  setProperty(key, value) {
    this._renderer.setProperty(this._elementRef.nativeElement, key, value);
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  setDisabledState(isDisabled) {
    this.setProperty('disabled', isDisabled);
  }
  static ɵfac = function BaseControlValueAccessor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || BaseControlValueAccessor)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.Renderer2), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: BaseControlValueAccessor
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(BaseControlValueAccessor, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive
  }], () => [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Renderer2
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef
  }], null);
})();
class BuiltInControlValueAccessor extends BaseControlValueAccessor {
  static ɵfac = /* @__PURE__ */(() => {
    let ɵBuiltInControlValueAccessor_BaseFactory;
    return function BuiltInControlValueAccessor_Factory(__ngFactoryType__) {
      return (ɵBuiltInControlValueAccessor_BaseFactory || (ɵBuiltInControlValueAccessor_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵgetInheritedFactory"](BuiltInControlValueAccessor)))(__ngFactoryType__ || BuiltInControlValueAccessor);
    };
  })();
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: BuiltInControlValueAccessor,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(BuiltInControlValueAccessor, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive
  }], null, null);
})();
const NG_VALUE_ACCESSOR = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'NgValueAccessor' : '');
const CHECKBOX_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => CheckboxControlValueAccessor),
  multi: true
};
class CheckboxControlValueAccessor extends BuiltInControlValueAccessor {
  writeValue(value) {
    this.setProperty('checked', value);
  }
  static ɵfac = /* @__PURE__ */(() => {
    let ɵCheckboxControlValueAccessor_BaseFactory;
    return function CheckboxControlValueAccessor_Factory(__ngFactoryType__) {
      return (ɵCheckboxControlValueAccessor_BaseFactory || (ɵCheckboxControlValueAccessor_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵgetInheritedFactory"](CheckboxControlValueAccessor)))(__ngFactoryType__ || CheckboxControlValueAccessor);
    };
  })();
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: CheckboxControlValueAccessor,
    selectors: [["input", "type", "checkbox", "formControlName", ""], ["input", "type", "checkbox", "formControl", ""], ["input", "type", "checkbox", "ngModel", ""]],
    hostBindings: function CheckboxControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵlistener"]("change", function CheckboxControlValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target.checked);
        })("blur", function CheckboxControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    standalone: false,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵProvidersFeature"]([CHECKBOX_VALUE_ACCESSOR]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(CheckboxControlValueAccessor, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: 'input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]',
      host: {
        '(change)': 'onChange($any($event.target).checked)',
        '(blur)': 'onTouched()'
      },
      providers: [CHECKBOX_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, null);
})();
const DEFAULT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => DefaultValueAccessor),
  multi: true
};
function _isAndroid() {
  const userAgent = (0,_angular_common__WEBPACK_IMPORTED_MODULE_4__.getDOM)() ? (0,_angular_common__WEBPACK_IMPORTED_MODULE_4__.getDOM)().getUserAgent() : '';
  return /android (\d+)/.test(userAgent.toLowerCase());
}
const COMPOSITION_BUFFER_MODE = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'CompositionEventMode' : '');
class DefaultValueAccessor extends BaseControlValueAccessor {
  _compositionMode;
  _composing = false;
  constructor(renderer, elementRef, _compositionMode) {
    super(renderer, elementRef);
    this._compositionMode = _compositionMode;
    if (this._compositionMode == null) {
      this._compositionMode = !_isAndroid();
    }
  }
  writeValue(value) {
    const normalizedValue = value == null ? '' : value;
    this.setProperty('value', normalizedValue);
  }
  _handleInput(value) {
    if (!this._compositionMode || this._compositionMode && !this._composing) {
      this.onChange(value);
    }
  }
  _compositionStart() {
    this._composing = true;
  }
  _compositionEnd(value) {
    this._composing = false;
    this._compositionMode && this.onChange(value);
  }
  static ɵfac = function DefaultValueAccessor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || DefaultValueAccessor)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.Renderer2), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](COMPOSITION_BUFFER_MODE, 8));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: DefaultValueAccessor,
    selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]],
    hostBindings: function DefaultValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵlistener"]("input", function DefaultValueAccessor_input_HostBindingHandler($event) {
          return ctx._handleInput($event.target.value);
        })("blur", function DefaultValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        })("compositionstart", function DefaultValueAccessor_compositionstart_HostBindingHandler() {
          return ctx._compositionStart();
        })("compositionend", function DefaultValueAccessor_compositionend_HostBindingHandler($event) {
          return ctx._compositionEnd($event.target.value);
        });
      }
    },
    standalone: false,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵProvidersFeature"]([DEFAULT_VALUE_ACCESSOR]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(DefaultValueAccessor, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: 'input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]',
      host: {
        '(input)': '_handleInput($any($event.target).value)',
        '(blur)': 'onTouched()',
        '(compositionstart)': '_compositionStart()',
        '(compositionend)': '_compositionEnd($any($event.target).value)'
      },
      providers: [DEFAULT_VALUE_ACCESSOR],
      standalone: false
    }]
  }], () => [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Renderer2
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [COMPOSITION_BUFFER_MODE]
    }]
  }], null);
})();
function isEmptyInputValue(value) {
  return value == null || lengthOrSize(value) === 0;
}
function lengthOrSize(value) {
  if (value == null) {
    return null;
  } else if (Array.isArray(value) || typeof value === 'string') {
    return value.length;
  } else if (value instanceof Set) {
    return value.size;
  }
  return null;
}
const NG_VALIDATORS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'NgValidators' : '');
const NG_ASYNC_VALIDATORS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'NgAsyncValidators' : '');
const EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
class Validators {
  static min(min) {
    return minValidator(min);
  }
  static max(max) {
    return maxValidator(max);
  }
  static required(control) {
    return requiredValidator(control);
  }
  static requiredTrue(control) {
    return requiredTrueValidator(control);
  }
  static email(control) {
    return emailValidator(control);
  }
  static minLength(minLength) {
    return minLengthValidator(minLength);
  }
  static maxLength(maxLength) {
    return maxLengthValidator(maxLength);
  }
  static pattern(pattern) {
    return patternValidator(pattern);
  }
  static nullValidator(control) {
    return nullValidator();
  }
  static compose(validators) {
    return compose(validators);
  }
  static composeAsync(validators) {
    return composeAsync(validators);
  }
}
function minValidator(min) {
  return control => {
    if (control.value == null || min == null) {
      return null;
    }
    const value = parseFloat(control.value);
    return !isNaN(value) && value < min ? {
      'min': {
        'min': min,
        'actual': control.value
      }
    } : null;
  };
}
function maxValidator(max) {
  return control => {
    if (control.value == null || max == null) {
      return null;
    }
    const value = parseFloat(control.value);
    return !isNaN(value) && value > max ? {
      'max': {
        'max': max,
        'actual': control.value
      }
    } : null;
  };
}
function requiredValidator(control) {
  return isEmptyInputValue(control.value) ? {
    'required': true
  } : null;
}
function requiredTrueValidator(control) {
  return control.value === true ? null : {
    'required': true
  };
}
function emailValidator(control) {
  if (isEmptyInputValue(control.value)) {
    return null;
  }
  return EMAIL_REGEXP.test(control.value) ? null : {
    'email': true
  };
}
function minLengthValidator(minLength) {
  return control => {
    const length = control.value?.length ?? lengthOrSize(control.value);
    if (length === null || length === 0) {
      return null;
    }
    return length < minLength ? {
      'minlength': {
        'requiredLength': minLength,
        'actualLength': length
      }
    } : null;
  };
}
function maxLengthValidator(maxLength) {
  return control => {
    const length = control.value?.length ?? lengthOrSize(control.value);
    if (length !== null && length > maxLength) {
      return {
        'maxlength': {
          'requiredLength': maxLength,
          'actualLength': length
        }
      };
    }
    return null;
  };
}
function patternValidator(pattern) {
  if (!pattern) return nullValidator;
  let regex;
  let regexStr;
  if (typeof pattern === 'string') {
    regexStr = '';
    if (pattern.charAt(0) !== '^') regexStr += '^';
    regexStr += pattern;
    if (pattern.charAt(pattern.length - 1) !== '$') regexStr += '$';
    regex = new RegExp(regexStr);
  } else {
    regexStr = pattern.toString();
    regex = pattern;
  }
  return control => {
    if (isEmptyInputValue(control.value)) {
      return null;
    }
    const value = control.value;
    return regex.test(value) ? null : {
      'pattern': {
        'requiredPattern': regexStr,
        'actualValue': value
      }
    };
  };
}
function nullValidator(control) {
  return null;
}
function isPresent(o) {
  return o != null;
}
function toObservable(value) {
  const obs = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.isPromise)(value) ? (0,rxjs__WEBPACK_IMPORTED_MODULE_7__.from)(value) : value;
  if ((typeof ngDevMode === 'undefined' || ngDevMode) && !(0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.isSubscribable)(obs)) {
    let errorMessage = `Expected async validator to return Promise or Observable.`;
    if (typeof value === 'object') {
      errorMessage += ' Are you using a synchronous validator where an async validator is expected?';
    }
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(-1101, errorMessage);
  }
  return obs;
}
function mergeErrors(arrayOfErrors) {
  let res = {};
  arrayOfErrors.forEach(errors => {
    res = errors != null ? {
      ...res,
      ...errors
    } : res;
  });
  return Object.keys(res).length === 0 ? null : res;
}
function executeValidators(control, validators) {
  return validators.map(validator => validator(control));
}
function isValidatorFn(validator) {
  return !validator.validate;
}
function normalizeValidators(validators) {
  return validators.map(validator => {
    return isValidatorFn(validator) ? validator : c => validator.validate(c);
  });
}
function compose(validators) {
  if (!validators) return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0) return null;
  return function (control) {
    return mergeErrors(executeValidators(control, presentValidators));
  };
}
function composeValidators(validators) {
  return validators != null ? compose(normalizeValidators(validators)) : null;
}
function composeAsync(validators) {
  if (!validators) return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0) return null;
  return function (control) {
    const observables = executeValidators(control, presentValidators).map(toObservable);
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.forkJoin)(observables).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.map)(mergeErrors));
  };
}
function composeAsyncValidators(validators) {
  return validators != null ? composeAsync(normalizeValidators(validators)) : null;
}
function mergeValidators(controlValidators, dirValidator) {
  if (controlValidators === null) return [dirValidator];
  return Array.isArray(controlValidators) ? [...controlValidators, dirValidator] : [controlValidators, dirValidator];
}
function getControlValidators(control) {
  return control._rawValidators;
}
function getControlAsyncValidators(control) {
  return control._rawAsyncValidators;
}
function makeValidatorsArray(validators) {
  if (!validators) return [];
  return Array.isArray(validators) ? validators : [validators];
}
function hasValidator(validators, validator) {
  return Array.isArray(validators) ? validators.includes(validator) : validators === validator;
}
function addValidators(validators, currentValidators) {
  const current = makeValidatorsArray(currentValidators);
  const validatorsToAdd = makeValidatorsArray(validators);
  validatorsToAdd.forEach(v => {
    if (!hasValidator(current, v)) {
      current.push(v);
    }
  });
  return current;
}
function removeValidators(validators, currentValidators) {
  return makeValidatorsArray(currentValidators).filter(v => !hasValidator(validators, v));
}
class AbstractControlDirective {
  get value() {
    return this.control ? this.control.value : null;
  }
  get valid() {
    return this.control ? this.control.valid : null;
  }
  get invalid() {
    return this.control ? this.control.invalid : null;
  }
  get pending() {
    return this.control ? this.control.pending : null;
  }
  get disabled() {
    return this.control ? this.control.disabled : null;
  }
  get enabled() {
    return this.control ? this.control.enabled : null;
  }
  get errors() {
    return this.control ? this.control.errors : null;
  }
  get pristine() {
    return this.control ? this.control.pristine : null;
  }
  get dirty() {
    return this.control ? this.control.dirty : null;
  }
  get touched() {
    return this.control ? this.control.touched : null;
  }
  get status() {
    return this.control ? this.control.status : null;
  }
  get untouched() {
    return this.control ? this.control.untouched : null;
  }
  get statusChanges() {
    return this.control ? this.control.statusChanges : null;
  }
  get valueChanges() {
    return this.control ? this.control.valueChanges : null;
  }
  get path() {
    return null;
  }
  _composedValidatorFn;
  _composedAsyncValidatorFn;
  _rawValidators = [];
  _rawAsyncValidators = [];
  _setValidators(validators) {
    this._rawValidators = validators || [];
    this._composedValidatorFn = composeValidators(this._rawValidators);
  }
  _setAsyncValidators(validators) {
    this._rawAsyncValidators = validators || [];
    this._composedAsyncValidatorFn = composeAsyncValidators(this._rawAsyncValidators);
  }
  get validator() {
    return this._composedValidatorFn || null;
  }
  get asyncValidator() {
    return this._composedAsyncValidatorFn || null;
  }
  _onDestroyCallbacks = [];
  _registerOnDestroy(fn) {
    this._onDestroyCallbacks.push(fn);
  }
  _invokeOnDestroyCallbacks() {
    this._onDestroyCallbacks.forEach(fn => fn());
    this._onDestroyCallbacks = [];
  }
  reset(value = undefined) {
    if (this.control) this.control.reset(value);
  }
  hasError(errorCode, path) {
    return this.control ? this.control.hasError(errorCode, path) : false;
  }
  getError(errorCode, path) {
    return this.control ? this.control.getError(errorCode, path) : null;
  }
}
class ControlContainer extends AbstractControlDirective {
  name;
  get formDirective() {
    return null;
  }
  get path() {
    return null;
  }
}
class NgControl extends AbstractControlDirective {
  _parent = null;
  name = null;
  valueAccessor = null;
}
class AbstractControlStatus {
  _cd;
  constructor(cd) {
    this._cd = cd;
  }
  get isTouched() {
    this._cd?.control?._touched?.();
    return !!this._cd?.control?.touched;
  }
  get isUntouched() {
    return !!this._cd?.control?.untouched;
  }
  get isPristine() {
    this._cd?.control?._pristine?.();
    return !!this._cd?.control?.pristine;
  }
  get isDirty() {
    return !!this._cd?.control?.dirty;
  }
  get isValid() {
    this._cd?.control?._status?.();
    return !!this._cd?.control?.valid;
  }
  get isInvalid() {
    return !!this._cd?.control?.invalid;
  }
  get isPending() {
    return !!this._cd?.control?.pending;
  }
  get isSubmitted() {
    this._cd?._submitted?.();
    return !!this._cd?.submitted;
  }
}
const ngControlStatusHost = {
  '[class.ng-untouched]': 'isUntouched',
  '[class.ng-touched]': 'isTouched',
  '[class.ng-pristine]': 'isPristine',
  '[class.ng-dirty]': 'isDirty',
  '[class.ng-valid]': 'isValid',
  '[class.ng-invalid]': 'isInvalid',
  '[class.ng-pending]': 'isPending'
};
class NgControlStatus extends AbstractControlStatus {
  constructor(cd) {
    super(cd);
  }
  static ɵfac = function NgControlStatus_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || NgControlStatus)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](NgControl, 2));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: NgControlStatus,
    selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]],
    hostVars: 14,
    hostBindings: function NgControlStatus_HostBindings(rf, ctx) {
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵclassProp"]("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending);
      }
    },
    standalone: false,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(NgControlStatus, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[formControlName],[ngModel],[formControl]',
      host: ngControlStatusHost,
      standalone: false
    }]
  }], () => [{
    type: NgControl,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Self
    }]
  }], null);
})();
class NgControlStatusGroup extends AbstractControlStatus {
  constructor(cd) {
    super(cd);
  }
  static ɵfac = function NgControlStatusGroup_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || NgControlStatusGroup)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](ControlContainer, 10));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: NgControlStatusGroup,
    selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["", "formArray", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]],
    hostVars: 16,
    hostBindings: function NgControlStatusGroup_HostBindings(rf, ctx) {
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵclassProp"]("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending)("ng-submitted", ctx.isSubmitted);
      }
    },
    standalone: false,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(NgControlStatusGroup, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[formGroupName],[formArrayName],[ngModelGroup],[formGroup],[formArray],form:not([ngNoForm]),[ngForm]',
      host: {
        ...ngControlStatusHost,
        '[class.ng-submitted]': 'isSubmitted'
      },
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Self
    }]
  }], null);
})();
const formControlNameExample = `
  <div [formGroup]="myGroup">
    <input formControlName="firstName">
  </div>

  In your class:

  this.myGroup = new FormGroup({
      firstName: new FormControl()
  });`;
const formGroupNameExample = `
  <div [formGroup]="myGroup">
      <div formGroupName="person">
        <input formControlName="firstName">
      </div>
  </div>

  In your class:

  this.myGroup = new FormGroup({
      person: new FormGroup({ firstName: new FormControl() })
  });`;
const formArrayNameExample = `
  <div [formGroup]="myGroup">
    <div formArrayName="cities">
      <div *ngFor="let city of cityArray.controls; index as i">
        <input [formControlName]="i">
      </div>
    </div>
  </div>

  In your class:

  this.cityArray = new FormArray([new FormControl('SF')]);
  this.myGroup = new FormGroup({
    cities: this.cityArray
  });`;
const ngModelGroupExample = `
  <form>
      <div ngModelGroup="person">
        <input [(ngModel)]="person.name" name="firstName">
      </div>
  </form>`;
const ngModelWithFormGroupExample = `
  <div [formGroup]="myGroup">
      <input formControlName="firstName">
      <input [(ngModel)]="showMoreControls" [ngModelOptions]="{standalone: true}">
  </div>
`;
function controlParentException(nameOrIndex) {
  return new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(1050, `formControlName must be used with a parent formGroup or formArray directive. You'll want to add a formGroup/formArray
      directive and pass it an existing FormGroup/FormArray instance (you can create one in your class).

      ${describeFormControl(nameOrIndex)}

    Example:

    ${formControlNameExample}`);
}
function describeFormControl(nameOrIndex) {
  if (nameOrIndex == null || nameOrIndex === '') {
    return '';
  }
  const valueType = typeof nameOrIndex === 'string' ? 'name' : 'index';
  return `Affected Form Control ${valueType}: "${nameOrIndex}"`;
}
function ngModelGroupException() {
  return new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(1051, `formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents
      that also have a "form" prefix: formGroupName, formArrayName, or formGroup.

      Option 1:  Update the parent to be formGroupName (reactive form strategy)

      ${formGroupNameExample}

      Option 2: Use ngModel instead of formControlName (template-driven strategy)

      ${ngModelGroupExample}`);
}
function missingFormException() {
  return new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(1052, `formGroup expects a FormGroup instance. Please pass one in.

      Example:

      ${formControlNameExample}`);
}
function groupParentException() {
  return new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(1053, `formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup
    directive and pass it an existing FormGroup instance (you can create one in your class).

    Example:

    ${formGroupNameExample}`);
}
function arrayParentException() {
  return new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(1054, `formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

      Example:

      ${formArrayNameExample}`);
}
const disabledAttrWarning = `
  It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true
  when you set up this control in your component class, the disabled attribute will actually be set in the DOM for
  you. We recommend using this approach to avoid 'changed after checked' errors.

  Example:
  // Specify the \`disabled\` property at control creation time:
  form = new FormGroup({
    first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),
    last: new FormControl('Drew', Validators.required)
  });

  // Controls can also be enabled/disabled after creation:
  form.get('first')?.enable();
  form.get('last')?.disable();
`;
const asyncValidatorsDroppedWithOptsWarning = `
  It looks like you're constructing using a FormControl with both an options argument and an
  async validators argument. Mixing these arguments will cause your async validators to be dropped.
  You should either put all your validators in the options object, or in separate validators
  arguments. For example:

  // Using validators arguments
  fc = new FormControl(42, Validators.required, myAsyncValidator);

  // Using AbstractControlOptions
  fc = new FormControl(42, {validators: Validators.required, asyncValidators: myAV});

  // Do NOT mix them: async validators will be dropped!
  fc = new FormControl(42, {validators: Validators.required}, /* Oops! */ myAsyncValidator);
`;
function ngModelWarning(directiveName) {
  return `
  It looks like you're using ngModel on the same form field as ${directiveName}.
  Support for using the ngModel input property and ngModelChange event with
  reactive form directives has been deprecated in Angular v6 and will be removed
  in a future version of Angular.

  For more information on this, see our API docs here:
  https://angular.io/api/forms/${directiveName === 'formControl' ? 'FormControlDirective' : 'FormControlName'}#use-with-ngmodel
  `;
}
function describeKey(isFormGroup, key) {
  return isFormGroup ? `with name: '${key}'` : `at index: ${key}`;
}
function noControlsError(isFormGroup) {
  return `
    There are no form controls registered with this ${isFormGroup ? 'group' : 'array'} yet. If you're using ngModel,
    you may want to check next tick (e.g. use setTimeout).
  `;
}
function missingControlError(isFormGroup, key) {
  return `Cannot find form control ${describeKey(isFormGroup, key)}`;
}
function missingControlValueError(isFormGroup, key) {
  return `Must supply a value for form control ${describeKey(isFormGroup, key)}`;
}
const VALID = 'VALID';
const INVALID = 'INVALID';
const PENDING = 'PENDING';
const DISABLED = 'DISABLED';
class ControlEvent {}
class ValueChangeEvent extends ControlEvent {
  value;
  source;
  constructor(value, source) {
    super();
    this.value = value;
    this.source = source;
  }
}
class PristineChangeEvent extends ControlEvent {
  pristine;
  source;
  constructor(pristine, source) {
    super();
    this.pristine = pristine;
    this.source = source;
  }
}
class TouchedChangeEvent extends ControlEvent {
  touched;
  source;
  constructor(touched, source) {
    super();
    this.touched = touched;
    this.source = source;
  }
}
class StatusChangeEvent extends ControlEvent {
  status;
  source;
  constructor(status, source) {
    super();
    this.status = status;
    this.source = source;
  }
}
class FormSubmittedEvent extends ControlEvent {
  source;
  constructor(source) {
    super();
    this.source = source;
  }
}
class FormResetEvent extends ControlEvent {
  source;
  constructor(source) {
    super();
    this.source = source;
  }
}
function pickValidators(validatorOrOpts) {
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.validators : validatorOrOpts) || null;
}
function coerceToValidator(validator) {
  return Array.isArray(validator) ? composeValidators(validator) : validator || null;
}
function pickAsyncValidators(asyncValidator, validatorOrOpts) {
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
    if (isOptionsObj(validatorOrOpts) && asyncValidator) {
      console.warn(asyncValidatorsDroppedWithOptsWarning);
    }
  }
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.asyncValidators : asyncValidator) || null;
}
function coerceToAsyncValidator(asyncValidator) {
  return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator || null;
}
function isOptionsObj(validatorOrOpts) {
  return validatorOrOpts != null && !Array.isArray(validatorOrOpts) && typeof validatorOrOpts === 'object';
}
function assertControlPresent(parent, isGroup, key) {
  const controls = parent.controls;
  const collection = isGroup ? Object.keys(controls) : controls;
  if (!collection.length) {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(1000, typeof ngDevMode === 'undefined' || ngDevMode ? noControlsError(isGroup) : '');
  }
  if (!controls[key]) {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(1001, typeof ngDevMode === 'undefined' || ngDevMode ? missingControlError(isGroup, key) : '');
  }
}
function assertAllValuesPresent(control, isGroup, value) {
  control._forEachChild((_, key) => {
    if (value[key] === undefined) {
      throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(1002, typeof ngDevMode === 'undefined' || ngDevMode ? missingControlValueError(isGroup, key) : '');
    }
  });
}
class AbstractControl {
  _pendingDirty = false;
  _hasOwnPendingAsyncValidator = null;
  _pendingTouched = false;
  _onCollectionChange = () => {};
  _updateOn;
  _parent = null;
  _asyncValidationSubscription;
  _composedValidatorFn;
  _composedAsyncValidatorFn;
  _rawValidators;
  _rawAsyncValidators;
  value;
  constructor(validators, asyncValidators) {
    this._assignValidators(validators);
    this._assignAsyncValidators(asyncValidators);
  }
  get validator() {
    return this._composedValidatorFn;
  }
  set validator(validatorFn) {
    this._rawValidators = this._composedValidatorFn = validatorFn;
  }
  get asyncValidator() {
    return this._composedAsyncValidatorFn;
  }
  set asyncValidator(asyncValidatorFn) {
    this._rawAsyncValidators = this._composedAsyncValidatorFn = asyncValidatorFn;
  }
  get parent() {
    return this._parent;
  }
  get status() {
    return (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.untracked)(this.statusReactive);
  }
  set status(v) {
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.untracked)(() => this.statusReactive.set(v));
  }
  _status = (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.computed)(() => this.statusReactive(), ...(ngDevMode ? [{
    debugName: "_status"
  }] : []));
  statusReactive = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.signal)(undefined, ...(ngDevMode ? [{
    debugName: "statusReactive"
  }] : []));
  get valid() {
    return this.status === VALID;
  }
  get invalid() {
    return this.status === INVALID;
  }
  get pending() {
    return this.status == PENDING;
  }
  get disabled() {
    return this.status === DISABLED;
  }
  get enabled() {
    return this.status !== DISABLED;
  }
  errors;
  get pristine() {
    return (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.untracked)(this.pristineReactive);
  }
  set pristine(v) {
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.untracked)(() => this.pristineReactive.set(v));
  }
  _pristine = (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.computed)(() => this.pristineReactive(), ...(ngDevMode ? [{
    debugName: "_pristine"
  }] : []));
  pristineReactive = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.signal)(true, ...(ngDevMode ? [{
    debugName: "pristineReactive"
  }] : []));
  get dirty() {
    return !this.pristine;
  }
  get touched() {
    return (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.untracked)(this.touchedReactive);
  }
  set touched(v) {
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.untracked)(() => this.touchedReactive.set(v));
  }
  _touched = (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.computed)(() => this.touchedReactive(), ...(ngDevMode ? [{
    debugName: "_touched"
  }] : []));
  touchedReactive = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.signal)(false, ...(ngDevMode ? [{
    debugName: "touchedReactive"
  }] : []));
  get untouched() {
    return !this.touched;
  }
  _events = new rxjs__WEBPACK_IMPORTED_MODULE_5__.Subject();
  events = this._events.asObservable();
  valueChanges;
  statusChanges;
  get updateOn() {
    return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : 'change';
  }
  setValidators(validators) {
    this._assignValidators(validators);
  }
  setAsyncValidators(validators) {
    this._assignAsyncValidators(validators);
  }
  addValidators(validators) {
    this.setValidators(addValidators(validators, this._rawValidators));
  }
  addAsyncValidators(validators) {
    this.setAsyncValidators(addValidators(validators, this._rawAsyncValidators));
  }
  removeValidators(validators) {
    this.setValidators(removeValidators(validators, this._rawValidators));
  }
  removeAsyncValidators(validators) {
    this.setAsyncValidators(removeValidators(validators, this._rawAsyncValidators));
  }
  hasValidator(validator) {
    return hasValidator(this._rawValidators, validator);
  }
  hasAsyncValidator(validator) {
    return hasValidator(this._rawAsyncValidators, validator);
  }
  clearValidators() {
    this.validator = null;
  }
  clearAsyncValidators() {
    this.asyncValidator = null;
  }
  markAsTouched(opts = {}) {
    const changed = this.touched === false;
    this.touched = true;
    const sourceControl = opts.sourceControl ?? this;
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsTouched({
        ...opts,
        sourceControl
      });
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new TouchedChangeEvent(true, sourceControl));
    }
  }
  markAllAsDirty(opts = {}) {
    this.markAsDirty({
      onlySelf: true,
      emitEvent: opts.emitEvent,
      sourceControl: this
    });
    this._forEachChild(control => control.markAllAsDirty(opts));
  }
  markAllAsTouched(opts = {}) {
    this.markAsTouched({
      onlySelf: true,
      emitEvent: opts.emitEvent,
      sourceControl: this
    });
    this._forEachChild(control => control.markAllAsTouched(opts));
  }
  markAsUntouched(opts = {}) {
    const changed = this.touched === true;
    this.touched = false;
    this._pendingTouched = false;
    const sourceControl = opts.sourceControl ?? this;
    this._forEachChild(control => {
      control.markAsUntouched({
        onlySelf: true,
        emitEvent: opts.emitEvent,
        sourceControl
      });
    });
    if (this._parent && !opts.onlySelf) {
      this._parent._updateTouched(opts, sourceControl);
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new TouchedChangeEvent(false, sourceControl));
    }
  }
  markAsDirty(opts = {}) {
    const changed = this.pristine === true;
    this.pristine = false;
    const sourceControl = opts.sourceControl ?? this;
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsDirty({
        ...opts,
        sourceControl
      });
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new PristineChangeEvent(false, sourceControl));
    }
  }
  markAsPristine(opts = {}) {
    const changed = this.pristine === false;
    this.pristine = true;
    this._pendingDirty = false;
    const sourceControl = opts.sourceControl ?? this;
    this._forEachChild(control => {
      control.markAsPristine({
        onlySelf: true,
        emitEvent: opts.emitEvent
      });
    });
    if (this._parent && !opts.onlySelf) {
      this._parent._updatePristine(opts, sourceControl);
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new PristineChangeEvent(true, sourceControl));
    }
  }
  markAsPending(opts = {}) {
    this.status = PENDING;
    const sourceControl = opts.sourceControl ?? this;
    if (opts.emitEvent !== false) {
      this._events.next(new StatusChangeEvent(this.status, sourceControl));
      this.statusChanges.emit(this.status);
    }
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsPending({
        ...opts,
        sourceControl
      });
    }
  }
  disable(opts = {}) {
    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
    this.status = DISABLED;
    this.errors = null;
    this._forEachChild(control => {
      control.disable({
        ...opts,
        onlySelf: true
      });
    });
    this._updateValue();
    const sourceControl = opts.sourceControl ?? this;
    if (opts.emitEvent !== false) {
      this._events.next(new ValueChangeEvent(this.value, sourceControl));
      this._events.next(new StatusChangeEvent(this.status, sourceControl));
      this.valueChanges.emit(this.value);
      this.statusChanges.emit(this.status);
    }
    this._updateAncestors({
      ...opts,
      skipPristineCheck
    }, this);
    this._onDisabledChange.forEach(changeFn => changeFn(true));
  }
  enable(opts = {}) {
    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
    this.status = VALID;
    this._forEachChild(control => {
      control.enable({
        ...opts,
        onlySelf: true
      });
    });
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: opts.emitEvent
    });
    this._updateAncestors({
      ...opts,
      skipPristineCheck
    }, this);
    this._onDisabledChange.forEach(changeFn => changeFn(false));
  }
  _updateAncestors(opts, sourceControl) {
    if (this._parent && !opts.onlySelf) {
      this._parent.updateValueAndValidity(opts);
      if (!opts.skipPristineCheck) {
        this._parent._updatePristine({}, sourceControl);
      }
      this._parent._updateTouched({}, sourceControl);
    }
  }
  setParent(parent) {
    this._parent = parent;
  }
  getRawValue() {
    return this.value;
  }
  updateValueAndValidity(opts = {}) {
    this._setInitialStatus();
    this._updateValue();
    if (this.enabled) {
      const shouldHaveEmitted = this._cancelExistingSubscription();
      this.errors = this._runValidator();
      this.status = this._calculateStatus();
      if (this.status === VALID || this.status === PENDING) {
        this._runAsyncValidator(shouldHaveEmitted, opts.emitEvent);
      }
    }
    const sourceControl = opts.sourceControl ?? this;
    if (opts.emitEvent !== false) {
      this._events.next(new ValueChangeEvent(this.value, sourceControl));
      this._events.next(new StatusChangeEvent(this.status, sourceControl));
      this.valueChanges.emit(this.value);
      this.statusChanges.emit(this.status);
    }
    if (this._parent && !opts.onlySelf) {
      this._parent.updateValueAndValidity({
        ...opts,
        sourceControl
      });
    }
  }
  _updateTreeValidity(opts = {
    emitEvent: true
  }) {
    this._forEachChild(ctrl => ctrl._updateTreeValidity(opts));
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: opts.emitEvent
    });
  }
  _setInitialStatus() {
    this.status = this._allControlsDisabled() ? DISABLED : VALID;
  }
  _runValidator() {
    return this.validator ? this.validator(this) : null;
  }
  _runAsyncValidator(shouldHaveEmitted, emitEvent) {
    if (this.asyncValidator) {
      this.status = PENDING;
      this._hasOwnPendingAsyncValidator = {
        emitEvent: emitEvent !== false,
        shouldHaveEmitted: shouldHaveEmitted !== false
      };
      const obs = toObservable(this.asyncValidator(this));
      this._asyncValidationSubscription = obs.subscribe(errors => {
        this._hasOwnPendingAsyncValidator = null;
        this.setErrors(errors, {
          emitEvent,
          shouldHaveEmitted
        });
      });
    }
  }
  _cancelExistingSubscription() {
    if (this._asyncValidationSubscription) {
      this._asyncValidationSubscription.unsubscribe();
      const shouldHaveEmitted = (this._hasOwnPendingAsyncValidator?.emitEvent || this._hasOwnPendingAsyncValidator?.shouldHaveEmitted) ?? false;
      this._hasOwnPendingAsyncValidator = null;
      return shouldHaveEmitted;
    }
    return false;
  }
  setErrors(errors, opts = {}) {
    this.errors = errors;
    this._updateControlsErrors(opts.emitEvent !== false, this, opts.shouldHaveEmitted);
  }
  get(path) {
    let currPath = path;
    if (currPath == null) return null;
    if (!Array.isArray(currPath)) currPath = currPath.split('.');
    if (currPath.length === 0) return null;
    return currPath.reduce((control, name) => control && control._find(name), this);
  }
  getError(errorCode, path) {
    const control = path ? this.get(path) : this;
    return control && control.errors ? control.errors[errorCode] : null;
  }
  hasError(errorCode, path) {
    return !!this.getError(errorCode, path);
  }
  get root() {
    let x = this;
    while (x._parent) {
      x = x._parent;
    }
    return x;
  }
  _updateControlsErrors(emitEvent, changedControl, shouldHaveEmitted) {
    this.status = this._calculateStatus();
    if (emitEvent) {
      this.statusChanges.emit(this.status);
    }
    if (emitEvent || shouldHaveEmitted) {
      this._events.next(new StatusChangeEvent(this.status, changedControl));
    }
    if (this._parent) {
      this._parent._updateControlsErrors(emitEvent, changedControl, shouldHaveEmitted);
    }
  }
  _initObservables() {
    this.valueChanges = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    this.statusChanges = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
  }
  _calculateStatus() {
    if (this._allControlsDisabled()) return DISABLED;
    if (this.errors) return INVALID;
    if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING)) return PENDING;
    if (this._anyControlsHaveStatus(INVALID)) return INVALID;
    return VALID;
  }
  _anyControlsHaveStatus(status) {
    return this._anyControls(control => control.status === status);
  }
  _anyControlsDirty() {
    return this._anyControls(control => control.dirty);
  }
  _anyControlsTouched() {
    return this._anyControls(control => control.touched);
  }
  _updatePristine(opts, changedControl) {
    const newPristine = !this._anyControlsDirty();
    const changed = this.pristine !== newPristine;
    this.pristine = newPristine;
    if (this._parent && !opts.onlySelf) {
      this._parent._updatePristine(opts, changedControl);
    }
    if (changed) {
      this._events.next(new PristineChangeEvent(this.pristine, changedControl));
    }
  }
  _updateTouched(opts = {}, changedControl) {
    this.touched = this._anyControlsTouched();
    this._events.next(new TouchedChangeEvent(this.touched, changedControl));
    if (this._parent && !opts.onlySelf) {
      this._parent._updateTouched(opts, changedControl);
    }
  }
  _onDisabledChange = [];
  _registerOnCollectionChange(fn) {
    this._onCollectionChange = fn;
  }
  _setUpdateStrategy(opts) {
    if (isOptionsObj(opts) && opts.updateOn != null) {
      this._updateOn = opts.updateOn;
    }
  }
  _parentMarkedDirty(onlySelf) {
    const parentDirty = this._parent && this._parent.dirty;
    return !onlySelf && !!parentDirty && !this._parent._anyControlsDirty();
  }
  _find(name) {
    return null;
  }
  _assignValidators(validators) {
    this._rawValidators = Array.isArray(validators) ? validators.slice() : validators;
    this._composedValidatorFn = coerceToValidator(this._rawValidators);
  }
  _assignAsyncValidators(validators) {
    this._rawAsyncValidators = Array.isArray(validators) ? validators.slice() : validators;
    this._composedAsyncValidatorFn = coerceToAsyncValidator(this._rawAsyncValidators);
  }
}
class FormGroup extends AbstractControl {
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    (typeof ngDevMode === 'undefined' || ngDevMode) && validateFormGroupControls(controls);
    this.controls = controls;
    this._initObservables();
    this._setUpdateStrategy(validatorOrOpts);
    this._setUpControls();
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: !!this.asyncValidator
    });
  }
  controls;
  registerControl(name, control) {
    if (this.controls[name]) return this.controls[name];
    this.controls[name] = control;
    control.setParent(this);
    control._registerOnCollectionChange(this._onCollectionChange);
    return control;
  }
  addControl(name, control, options = {}) {
    this.registerControl(name, control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  removeControl(name, options = {}) {
    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {});
    delete this.controls[name];
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  setControl(name, control, options = {}) {
    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {});
    delete this.controls[name];
    if (control) this.registerControl(name, control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  contains(controlName) {
    return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;
  }
  setValue(value, options = {}) {
    assertAllValuesPresent(this, true, value);
    Object.keys(value).forEach(name => {
      assertControlPresent(this, true, name);
      this.controls[name].setValue(value[name], {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this.updateValueAndValidity(options);
  }
  patchValue(value, options = {}) {
    if (value == null) return;
    Object.keys(value).forEach(name => {
      const control = this.controls[name];
      if (control) {
        control.patchValue(value[name], {
          onlySelf: true,
          emitEvent: options.emitEvent
        });
      }
    });
    this.updateValueAndValidity(options);
  }
  reset(value = {}, options = {}) {
    this._forEachChild((control, name) => {
      control.reset(value ? value[name] : null, {
        ...options,
        onlySelf: true
      });
    });
    this._updatePristine(options, this);
    this._updateTouched(options, this);
    this.updateValueAndValidity(options);
    if (options?.emitEvent !== false) {
      this._events.next(new FormResetEvent(this));
    }
  }
  getRawValue() {
    return this._reduceChildren({}, (acc, control, name) => {
      acc[name] = control.getRawValue();
      return acc;
    });
  }
  _syncPendingControls() {
    let subtreeUpdated = this._reduceChildren(false, (updated, child) => {
      return child._syncPendingControls() ? true : updated;
    });
    if (subtreeUpdated) this.updateValueAndValidity({
      onlySelf: true
    });
    return subtreeUpdated;
  }
  _forEachChild(cb) {
    Object.keys(this.controls).forEach(key => {
      const control = this.controls[key];
      control && cb(control, key);
    });
  }
  _setUpControls() {
    this._forEachChild(control => {
      control.setParent(this);
      control._registerOnCollectionChange(this._onCollectionChange);
    });
  }
  _updateValue() {
    this.value = this._reduceValue();
  }
  _anyControls(condition) {
    for (const [controlName, control] of Object.entries(this.controls)) {
      if (this.contains(controlName) && condition(control)) {
        return true;
      }
    }
    return false;
  }
  _reduceValue() {
    let acc = {};
    return this._reduceChildren(acc, (acc, control, name) => {
      if (control.enabled || this.disabled) {
        acc[name] = control.value;
      }
      return acc;
    });
  }
  _reduceChildren(initValue, fn) {
    let res = initValue;
    this._forEachChild((control, name) => {
      res = fn(res, control, name);
    });
    return res;
  }
  _allControlsDisabled() {
    for (const controlName of Object.keys(this.controls)) {
      if (this.controls[controlName].enabled) {
        return false;
      }
    }
    return Object.keys(this.controls).length > 0 || this.disabled;
  }
  _find(name) {
    return this.controls.hasOwnProperty(name) ? this.controls[name] : null;
  }
}
function validateFormGroupControls(controls) {
  const invalidKeys = Object.keys(controls).filter(key => key.includes('.'));
  if (invalidKeys.length > 0) {
    console.warn(`FormGroup keys cannot include \`.\`, please replace the keys for: ${invalidKeys.join(',')}.`);
  }
}
const UntypedFormGroup = FormGroup;
const isFormGroup = control => control instanceof FormGroup;
class FormRecord extends FormGroup {}
const isFormRecord = control => control instanceof FormRecord;
const CALL_SET_DISABLED_STATE = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'CallSetDisabledState' : '', {
  factory: () => setDisabledStateDefault
});
const setDisabledStateDefault = 'always';
function controlPath(name, parent) {
  return [...parent.path, name];
}
function setUpControl(control, dir, callSetDisabledState = setDisabledStateDefault) {
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
    if (!control) _throwError(dir, 'Cannot find control with');
    if (!dir.valueAccessor) _throwMissingValueAccessorError(dir);
  }
  setUpValidators(control, dir);
  dir.valueAccessor.writeValue(control.value);
  if (control.disabled || callSetDisabledState === 'always') {
    dir.valueAccessor.setDisabledState?.(control.disabled);
  }
  setUpViewChangePipeline(control, dir);
  setUpModelChangePipeline(control, dir);
  setUpBlurPipeline(control, dir);
  setUpDisabledChangeHandler(control, dir);
}
function cleanUpControl(control, dir, validateControlPresenceOnChange = true) {
  const noop = () => {
    if (validateControlPresenceOnChange && (typeof ngDevMode === 'undefined' || ngDevMode)) {
      _noControlError(dir);
    }
  };
  if (dir.valueAccessor) {
    dir.valueAccessor.registerOnChange(noop);
    dir.valueAccessor.registerOnTouched(noop);
  }
  cleanUpValidators(control, dir);
  if (control) {
    dir._invokeOnDestroyCallbacks();
    control._registerOnCollectionChange(() => {});
  }
}
function registerOnValidatorChange(validators, onChange) {
  validators.forEach(validator => {
    if (validator.registerOnValidatorChange) validator.registerOnValidatorChange(onChange);
  });
}
function setUpDisabledChangeHandler(control, dir) {
  if (dir.valueAccessor.setDisabledState) {
    const onDisabledChange = isDisabled => {
      dir.valueAccessor.setDisabledState(isDisabled);
    };
    control.registerOnDisabledChange(onDisabledChange);
    dir._registerOnDestroy(() => {
      control._unregisterOnDisabledChange(onDisabledChange);
    });
  }
}
function setUpValidators(control, dir) {
  const validators = getControlValidators(control);
  if (dir.validator !== null) {
    control.setValidators(mergeValidators(validators, dir.validator));
  } else if (typeof validators === 'function') {
    control.setValidators([validators]);
  }
  const asyncValidators = getControlAsyncValidators(control);
  if (dir.asyncValidator !== null) {
    control.setAsyncValidators(mergeValidators(asyncValidators, dir.asyncValidator));
  } else if (typeof asyncValidators === 'function') {
    control.setAsyncValidators([asyncValidators]);
  }
  const onValidatorChange = () => control.updateValueAndValidity();
  registerOnValidatorChange(dir._rawValidators, onValidatorChange);
  registerOnValidatorChange(dir._rawAsyncValidators, onValidatorChange);
}
function cleanUpValidators(control, dir) {
  let isControlUpdated = false;
  if (control !== null) {
    if (dir.validator !== null) {
      const validators = getControlValidators(control);
      if (Array.isArray(validators) && validators.length > 0) {
        const updatedValidators = validators.filter(validator => validator !== dir.validator);
        if (updatedValidators.length !== validators.length) {
          isControlUpdated = true;
          control.setValidators(updatedValidators);
        }
      }
    }
    if (dir.asyncValidator !== null) {
      const asyncValidators = getControlAsyncValidators(control);
      if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {
        const updatedAsyncValidators = asyncValidators.filter(asyncValidator => asyncValidator !== dir.asyncValidator);
        if (updatedAsyncValidators.length !== asyncValidators.length) {
          isControlUpdated = true;
          control.setAsyncValidators(updatedAsyncValidators);
        }
      }
    }
  }
  const noop = () => {};
  registerOnValidatorChange(dir._rawValidators, noop);
  registerOnValidatorChange(dir._rawAsyncValidators, noop);
  return isControlUpdated;
}
function setUpViewChangePipeline(control, dir) {
  dir.valueAccessor.registerOnChange(newValue => {
    control._pendingValue = newValue;
    control._pendingChange = true;
    control._pendingDirty = true;
    if (control.updateOn === 'change') updateControl(control, dir);
  });
}
function setUpBlurPipeline(control, dir) {
  dir.valueAccessor.registerOnTouched(() => {
    control._pendingTouched = true;
    if (control.updateOn === 'blur' && control._pendingChange) updateControl(control, dir);
    if (control.updateOn !== 'submit') control.markAsTouched();
  });
}
function updateControl(control, dir) {
  if (control._pendingDirty) control.markAsDirty();
  control.setValue(control._pendingValue, {
    emitModelToViewChange: false
  });
  dir.viewToModelUpdate(control._pendingValue);
  control._pendingChange = false;
}
function setUpModelChangePipeline(control, dir) {
  const onChange = (newValue, emitModelEvent) => {
    dir.valueAccessor.writeValue(newValue);
    if (emitModelEvent) dir.viewToModelUpdate(newValue);
  };
  control.registerOnChange(onChange);
  dir._registerOnDestroy(() => {
    control._unregisterOnChange(onChange);
  });
}
function setUpFormContainer(control, dir) {
  if (control == null && (typeof ngDevMode === 'undefined' || ngDevMode)) _throwError(dir, 'Cannot find control with');
  setUpValidators(control, dir);
}
function cleanUpFormContainer(control, dir) {
  return cleanUpValidators(control, dir);
}
function _noControlError(dir) {
  return _throwError(dir, 'There is no FormControl instance attached to form control element with');
}
function _throwError(dir, message) {
  const messageEnd = _describeControlLocation(dir);
  throw new Error(`${message} ${messageEnd}`);
}
function _describeControlLocation(dir) {
  const path = dir.path;
  if (path && path.length > 1) return `path: '${path.join(' -> ')}'`;
  if (path?.[0]) return `name: '${path}'`;
  return 'unspecified name attribute';
}
function _throwMissingValueAccessorError(dir) {
  const loc = _describeControlLocation(dir);
  throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(-1203, `No value accessor for form control ${loc}.`);
}
function _throwInvalidValueAccessorError(dir) {
  const loc = _describeControlLocation(dir);
  throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(1200, `Value accessor was not provided as an array for form control with ${loc}. ` + `Check that the \`NG_VALUE_ACCESSOR\` token is configured as a \`multi: true\` provider.`);
}
function isPropertyUpdated(changes, viewModel) {
  if (!changes.hasOwnProperty('model')) return false;
  const change = changes['model'];
  if (change.isFirstChange()) return true;
  return !Object.is(viewModel, change.currentValue);
}
function isBuiltInAccessor(valueAccessor) {
  return Object.getPrototypeOf(valueAccessor.constructor) === BuiltInControlValueAccessor;
}
function syncPendingControls(form, directives) {
  form._syncPendingControls();
  directives.forEach(dir => {
    const control = dir.control;
    if (control.updateOn === 'submit' && control._pendingChange) {
      dir.viewToModelUpdate(control._pendingValue);
      control._pendingChange = false;
    }
  });
}
function selectValueAccessor(dir, valueAccessors) {
  if (!valueAccessors) return null;
  if (!Array.isArray(valueAccessors) && (typeof ngDevMode === 'undefined' || ngDevMode)) _throwInvalidValueAccessorError(dir);
  let defaultAccessor = undefined;
  let builtinAccessor = undefined;
  let customAccessor = undefined;
  valueAccessors.forEach(v => {
    if (v.constructor === DefaultValueAccessor) {
      defaultAccessor = v;
    } else if (isBuiltInAccessor(v)) {
      if (builtinAccessor && (typeof ngDevMode === 'undefined' || ngDevMode)) _throwError(dir, 'More than one built-in value accessor matches form control with');
      builtinAccessor = v;
    } else {
      if (customAccessor && (typeof ngDevMode === 'undefined' || ngDevMode)) _throwError(dir, 'More than one custom value accessor matches form control with');
      customAccessor = v;
    }
  });
  if (customAccessor) return customAccessor;
  if (builtinAccessor) return builtinAccessor;
  if (defaultAccessor) return defaultAccessor;
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
    _throwError(dir, 'No valid value accessor for form control with');
  }
  return null;
}
function removeListItem$1(list, el) {
  const index = list.indexOf(el);
  if (index > -1) list.splice(index, 1);
}
function _ngModelWarning(name, type, instance, warningConfig) {
  if (warningConfig === 'never') return;
  if ((warningConfig === null || warningConfig === 'once') && !type._ngModelWarningSentOnce || warningConfig === 'always' && !instance._ngModelWarningSent) {
    console.warn(ngModelWarning(name));
    type._ngModelWarningSentOnce = true;
    instance._ngModelWarningSent = true;
  }
}
const formDirectiveProvider$2 = {
  provide: ControlContainer,
  useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => NgForm)
};
const resolvedPromise$1 = (() => Promise.resolve())();
class NgForm extends ControlContainer {
  callSetDisabledState;
  get submitted() {
    return (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.untracked)(this.submittedReactive);
  }
  _submitted = (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.computed)(() => this.submittedReactive(), ...(ngDevMode ? [{
    debugName: "_submitted"
  }] : []));
  submittedReactive = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.signal)(false, ...(ngDevMode ? [{
    debugName: "submittedReactive"
  }] : []));
  _directives = new Set();
  form;
  ngSubmit = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
  options;
  constructor(validators, asyncValidators, callSetDisabledState) {
    super();
    this.callSetDisabledState = callSetDisabledState;
    this.form = new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));
  }
  ngAfterViewInit() {
    this._setUpdateStrategy();
  }
  get formDirective() {
    return this;
  }
  get control() {
    return this.form;
  }
  get path() {
    return [];
  }
  get controls() {
    return this.form.controls;
  }
  addControl(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      dir.control = container.registerControl(dir.name, dir.control);
      setUpControl(dir.control, dir, this.callSetDisabledState);
      dir.control.updateValueAndValidity({
        emitEvent: false
      });
      this._directives.add(dir);
    });
  }
  getControl(dir) {
    return this.form.get(dir.path);
  }
  removeControl(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      if (container) {
        container.removeControl(dir.name);
      }
      this._directives.delete(dir);
    });
  }
  addFormGroup(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      const group = new FormGroup({});
      setUpFormContainer(group, dir);
      container.registerControl(dir.name, group);
      group.updateValueAndValidity({
        emitEvent: false
      });
    });
  }
  removeFormGroup(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      if (container) {
        container.removeControl(dir.name);
      }
    });
  }
  getFormGroup(dir) {
    return this.form.get(dir.path);
  }
  updateModel(dir, value) {
    resolvedPromise$1.then(() => {
      const ctrl = this.form.get(dir.path);
      ctrl.setValue(value);
    });
  }
  setValue(value) {
    this.control.setValue(value);
  }
  onSubmit($event) {
    this.submittedReactive.set(true);
    syncPendingControls(this.form, this._directives);
    this.ngSubmit.emit($event);
    this.form._events.next(new FormSubmittedEvent(this.control));
    return $event?.target?.method === 'dialog';
  }
  onReset() {
    this.resetForm();
  }
  resetForm(value = undefined) {
    this.form.reset(value);
    this.submittedReactive.set(false);
  }
  _setUpdateStrategy() {
    if (this.options && this.options.updateOn != null) {
      this.form._updateOn = this.options.updateOn;
    }
  }
  _findContainer(path) {
    path.pop();
    return path.length ? this.form.get(path) : this.form;
  }
  static ɵfac = function NgForm_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || NgForm)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](NG_VALIDATORS, 10), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](NG_ASYNC_VALIDATORS, 10), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](CALL_SET_DISABLED_STATE, 8));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: NgForm,
    selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", "", 3, "formArray", ""], ["ng-form"], ["", "ngForm", ""]],
    hostBindings: function NgForm_HostBindings(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵlistener"]("submit", function NgForm_submit_HostBindingHandler($event) {
          return ctx.onSubmit($event);
        })("reset", function NgForm_reset_HostBindingHandler() {
          return ctx.onReset();
        });
      }
    },
    inputs: {
      options: [0, "ngFormOptions", "options"]
    },
    outputs: {
      ngSubmit: "ngSubmit"
    },
    exportAs: ["ngForm"],
    standalone: false,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵProvidersFeature"]([formDirectiveProvider$2]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(NgForm, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: 'form:not([ngNoForm]):not([formGroup]):not([formArray]),ng-form,[ngForm]',
      providers: [formDirectiveProvider$2],
      host: {
        '(submit)': 'onSubmit($event)',
        '(reset)': 'onReset()'
      },
      outputs: ['ngSubmit'],
      exportAs: 'ngForm',
      standalone: false
    }]
  }], () => [{
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Self
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Self
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    options: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,
      args: ['ngFormOptions']
    }]
  });
})();
function removeListItem(list, el) {
  const index = list.indexOf(el);
  if (index > -1) list.splice(index, 1);
}
function isFormControlState(formState) {
  return typeof formState === 'object' && formState !== null && Object.keys(formState).length === 2 && 'value' in formState && 'disabled' in formState;
}
const FormControl = class FormControl extends AbstractControl {
  defaultValue = null;
  _onChange = [];
  _pendingValue;
  _pendingChange = false;
  constructor(formState = null, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    this._applyFormState(formState);
    this._setUpdateStrategy(validatorOrOpts);
    this._initObservables();
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: !!this.asyncValidator
    });
    if (isOptionsObj(validatorOrOpts) && (validatorOrOpts.nonNullable || validatorOrOpts.initialValueIsDefault)) {
      if (isFormControlState(formState)) {
        this.defaultValue = formState.value;
      } else {
        this.defaultValue = formState;
      }
    }
  }
  setValue(value, options = {}) {
    this.value = this._pendingValue = value;
    if (this._onChange.length && options.emitModelToViewChange !== false) {
      this._onChange.forEach(changeFn => changeFn(this.value, options.emitViewToModelChange !== false));
    }
    this.updateValueAndValidity(options);
  }
  patchValue(value, options = {}) {
    this.setValue(value, options);
  }
  reset(formState = this.defaultValue, options = {}) {
    this._applyFormState(formState);
    this.markAsPristine(options);
    this.markAsUntouched(options);
    this.setValue(this.value, options);
    if (options.overwriteDefaultValue) {
      this.defaultValue = this.value;
    }
    this._pendingChange = false;
    if (options?.emitEvent !== false) {
      this._events.next(new FormResetEvent(this));
    }
  }
  _updateValue() {}
  _anyControls(condition) {
    return false;
  }
  _allControlsDisabled() {
    return this.disabled;
  }
  registerOnChange(fn) {
    this._onChange.push(fn);
  }
  _unregisterOnChange(fn) {
    removeListItem(this._onChange, fn);
  }
  registerOnDisabledChange(fn) {
    this._onDisabledChange.push(fn);
  }
  _unregisterOnDisabledChange(fn) {
    removeListItem(this._onDisabledChange, fn);
  }
  _forEachChild(cb) {}
  _syncPendingControls() {
    if (this.updateOn === 'submit') {
      if (this._pendingDirty) this.markAsDirty();
      if (this._pendingTouched) this.markAsTouched();
      if (this._pendingChange) {
        this.setValue(this._pendingValue, {
          onlySelf: true,
          emitModelToViewChange: false
        });
        return true;
      }
    }
    return false;
  }
  _applyFormState(formState) {
    if (isFormControlState(formState)) {
      this.value = this._pendingValue = formState.value;
      formState.disabled ? this.disable({
        onlySelf: true,
        emitEvent: false
      }) : this.enable({
        onlySelf: true,
        emitEvent: false
      });
    } else {
      this.value = this._pendingValue = formState;
    }
  }
};
const UntypedFormControl = FormControl;
const isFormControl = control => control instanceof FormControl;
class AbstractFormGroupDirective extends ControlContainer {
  _parent;
  ngOnInit() {
    this._checkParentType();
    this.formDirective.addFormGroup(this);
  }
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeFormGroup(this);
    }
  }
  get control() {
    return this.formDirective.getFormGroup(this);
  }
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  _checkParentType() {}
  static ɵfac = /* @__PURE__ */(() => {
    let ɵAbstractFormGroupDirective_BaseFactory;
    return function AbstractFormGroupDirective_Factory(__ngFactoryType__) {
      return (ɵAbstractFormGroupDirective_BaseFactory || (ɵAbstractFormGroupDirective_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵgetInheritedFactory"](AbstractFormGroupDirective)))(__ngFactoryType__ || AbstractFormGroupDirective);
    };
  })();
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: AbstractFormGroupDirective,
    standalone: false,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(AbstractFormGroupDirective, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      standalone: false
    }]
  }], null, null);
})();
function modelParentException() {
  return new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(1350, `
    ngModel cannot be used to register form controls with a parent formGroup directive.  Try using
    formGroup's partner directive "formControlName" instead.  Example:

    ${formControlNameExample}

    Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:

    Example:

    ${ngModelWithFormGroupExample}`);
}
function formGroupNameException() {
  return new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(1351, `
    ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.

    Option 1: Use formControlName instead of ngModel (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):

    ${ngModelGroupExample}`);
}
function missingNameException() {
  return new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(1352, `If ngModel is used within a form tag, either the name attribute must be set or the form
    control must be defined as 'standalone' in ngModelOptions.

    Example 1: <input [(ngModel)]="person.firstName" name="first">
    Example 2: <input [(ngModel)]="person.firstName" [ngModelOptions]="{standalone: true}">`);
}
function modelGroupParentException() {
  return new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(1353, `
    ngModelGroup cannot be used with a parent formGroup directive.

    Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):

    ${ngModelGroupExample}`);
}
const modelGroupProvider = {
  provide: ControlContainer,
  useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => NgModelGroup)
};
class NgModelGroup extends AbstractFormGroupDirective {
  name = '';
  constructor(parent, validators, asyncValidators) {
    super();
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  _checkParentType() {
    if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm) && (typeof ngDevMode === 'undefined' || ngDevMode)) {
      throw modelGroupParentException();
    }
  }
  static ɵfac = function NgModelGroup_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || NgModelGroup)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](ControlContainer, 5), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](NG_VALIDATORS, 10), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](NG_ASYNC_VALIDATORS, 10));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: NgModelGroup,
    selectors: [["", "ngModelGroup", ""]],
    inputs: {
      name: [0, "ngModelGroup", "name"]
    },
    exportAs: ["ngModelGroup"],
    standalone: false,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵProvidersFeature"]([modelGroupProvider]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(NgModelGroup, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[ngModelGroup]',
      providers: [modelGroupProvider],
      exportAs: 'ngModelGroup',
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Host
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.SkipSelf
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Self
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Self
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,
      args: ['ngModelGroup']
    }]
  });
})();
const formControlBinding$1 = {
  provide: NgControl,
  useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => NgModel)
};
const resolvedPromise = (() => Promise.resolve())();
class NgModel extends NgControl {
  _changeDetectorRef;
  callSetDisabledState;
  control = new FormControl();
  static ngAcceptInputType_isDisabled;
  _registered = false;
  viewModel;
  name = '';
  isDisabled;
  model;
  options;
  update = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
  constructor(parent, validators, asyncValidators, valueAccessors, _changeDetectorRef, callSetDisabledState) {
    super();
    this._changeDetectorRef = _changeDetectorRef;
    this.callSetDisabledState = callSetDisabledState;
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  ngOnChanges(changes) {
    this._checkForErrors();
    if (!this._registered || 'name' in changes) {
      if (this._registered) {
        this._checkName();
        if (this.formDirective) {
          const oldName = changes['name'].previousValue;
          this.formDirective.removeControl({
            name: oldName,
            path: this._getPath(oldName)
          });
        }
      }
      this._setUpControl();
    }
    if ('isDisabled' in changes) {
      this._updateDisabled(changes);
    }
    if (isPropertyUpdated(changes, this.viewModel)) {
      this._updateValue(this.model);
      this.viewModel = this.model;
    }
  }
  ngOnDestroy() {
    this.formDirective && this.formDirective.removeControl(this);
  }
  get path() {
    return this._getPath(this.name);
  }
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  _setUpControl() {
    this._setUpdateStrategy();
    this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this);
    this._registered = true;
  }
  _setUpdateStrategy() {
    if (this.options && this.options.updateOn != null) {
      this.control._updateOn = this.options.updateOn;
    }
  }
  _isStandalone() {
    return !this._parent || !!(this.options && this.options.standalone);
  }
  _setUpStandalone() {
    setUpControl(this.control, this, this.callSetDisabledState);
    this.control.updateValueAndValidity({
      emitEvent: false
    });
  }
  _checkForErrors() {
    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !this._isStandalone()) {
      checkParentType$1(this._parent);
    }
    this._checkName();
  }
  _checkName() {
    if (this.options && this.options.name) this.name = this.options.name;
    if (!this._isStandalone() && !this.name && (typeof ngDevMode === 'undefined' || ngDevMode)) {
      throw missingNameException();
    }
  }
  _updateValue(value) {
    resolvedPromise.then(() => {
      this.control.setValue(value, {
        emitViewToModelChange: false
      });
      this._changeDetectorRef?.markForCheck();
    });
  }
  _updateDisabled(changes) {
    const disabledValue = changes['isDisabled'].currentValue;
    const isDisabled = disabledValue !== 0 && (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.booleanAttribute)(disabledValue);
    resolvedPromise.then(() => {
      if (isDisabled && !this.control.disabled) {
        this.control.disable();
      } else if (!isDisabled && this.control.disabled) {
        this.control.enable();
      }
      this._changeDetectorRef?.markForCheck();
    });
  }
  _getPath(controlName) {
    return this._parent ? controlPath(controlName, this._parent) : [controlName];
  }
  static ɵfac = function NgModel_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || NgModel)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](ControlContainer, 9), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](NG_VALIDATORS, 10), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](NG_ASYNC_VALIDATORS, 10), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](NG_VALUE_ACCESSOR, 10), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectorRef, 8), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](CALL_SET_DISABLED_STATE, 8));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: NgModel,
    selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]],
    inputs: {
      name: "name",
      isDisabled: [0, "disabled", "isDisabled"],
      model: [0, "ngModel", "model"],
      options: [0, "ngModelOptions", "options"]
    },
    outputs: {
      update: "ngModelChange"
    },
    exportAs: ["ngModel"],
    standalone: false,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵProvidersFeature"]([formControlBinding$1]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"], _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵNgOnChangesFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(NgModel, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[ngModel]:not([formControlName]):not([formControl])',
      providers: [formControlBinding$1],
      exportAs: 'ngModel',
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Host
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Self
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Self
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Self
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectorRef,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [_angular_core__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectorRef]
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    name: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    isDisabled: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,
      args: ['disabled']
    }],
    model: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,
      args: ['ngModel']
    }],
    options: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,
      args: ['ngModelOptions']
    }],
    update: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Output,
      args: ['ngModelChange']
    }]
  });
})();
function checkParentType$1(parent) {
  if (!(parent instanceof NgModelGroup) && parent instanceof AbstractFormGroupDirective) {
    throw formGroupNameException();
  } else if (!(parent instanceof NgModelGroup) && !(parent instanceof NgForm)) {
    throw modelParentException();
  }
}
class ɵNgNoValidate {
  static ɵfac = function ɵNgNoValidate_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || ɵNgNoValidate)();
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: ɵNgNoValidate,
    selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]],
    hostAttrs: ["novalidate", ""],
    standalone: false
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(ɵNgNoValidate, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: 'form:not([ngNoForm]):not([ngNativeValidate])',
      host: {
        'novalidate': ''
      },
      standalone: false
    }]
  }], null, null);
})();
const NUMBER_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => NumberValueAccessor),
  multi: true
};
class NumberValueAccessor extends BuiltInControlValueAccessor {
  writeValue(value) {
    const normalizedValue = value == null ? '' : value;
    this.setProperty('value', normalizedValue);
  }
  registerOnChange(fn) {
    this.onChange = value => {
      fn(value == '' ? null : parseFloat(value));
    };
  }
  static ɵfac = /* @__PURE__ */(() => {
    let ɵNumberValueAccessor_BaseFactory;
    return function NumberValueAccessor_Factory(__ngFactoryType__) {
      return (ɵNumberValueAccessor_BaseFactory || (ɵNumberValueAccessor_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵgetInheritedFactory"](NumberValueAccessor)))(__ngFactoryType__ || NumberValueAccessor);
    };
  })();
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: NumberValueAccessor,
    selectors: [["input", "type", "number", "formControlName", ""], ["input", "type", "number", "formControl", ""], ["input", "type", "number", "ngModel", ""]],
    hostBindings: function NumberValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵlistener"]("input", function NumberValueAccessor_input_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("blur", function NumberValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    standalone: false,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵProvidersFeature"]([NUMBER_VALUE_ACCESSOR]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(NumberValueAccessor, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: 'input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]',
      host: {
        '(input)': 'onChange($any($event.target).value)',
        '(blur)': 'onTouched()'
      },
      providers: [NUMBER_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, null);
})();
const RADIO_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => RadioControlValueAccessor),
  multi: true
};
function throwNameError() {
  throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(1202, `
      If you define both a name and a formControlName attribute on your radio button, their values
      must match. Ex: <input type="radio" formControlName="food" name="food">
    `);
}
class RadioControlRegistry {
  _accessors = [];
  add(control, accessor) {
    this._accessors.push([control, accessor]);
  }
  remove(accessor) {
    for (let i = this._accessors.length - 1; i >= 0; --i) {
      if (this._accessors[i][1] === accessor) {
        this._accessors.splice(i, 1);
        return;
      }
    }
  }
  select(accessor) {
    this._accessors.forEach(c => {
      if (this._isSameGroup(c, accessor) && c[1] !== accessor) {
        c[1].fireUncheck(accessor.value);
      }
    });
  }
  _isSameGroup(controlPair, accessor) {
    if (!controlPair[0].control) return false;
    return controlPair[0]._parent === accessor._control._parent && controlPair[1].name === accessor.name;
  }
  static ɵfac = function RadioControlRegistry_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || RadioControlRegistry)();
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: RadioControlRegistry,
    factory: RadioControlRegistry.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(RadioControlRegistry, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], null, null);
})();
class RadioControlValueAccessor extends BuiltInControlValueAccessor {
  _registry;
  _injector;
  _state;
  _control;
  _fn;
  setDisabledStateFired = false;
  onChange = () => {};
  name;
  formControlName;
  value;
  callSetDisabledState = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(CALL_SET_DISABLED_STATE, {
    optional: true
  }) ?? setDisabledStateDefault;
  constructor(renderer, elementRef, _registry, _injector) {
    super(renderer, elementRef);
    this._registry = _registry;
    this._injector = _injector;
  }
  ngOnInit() {
    this._control = this._injector.get(NgControl);
    this._checkName();
    this._registry.add(this._control, this);
  }
  ngOnDestroy() {
    this._registry.remove(this);
  }
  writeValue(value) {
    this._state = value === this.value;
    this.setProperty('checked', this._state);
  }
  registerOnChange(fn) {
    this._fn = fn;
    this.onChange = () => {
      fn(this.value);
      this._registry.select(this);
    };
  }
  setDisabledState(isDisabled) {
    if (this.setDisabledStateFired || isDisabled || this.callSetDisabledState === 'whenDisabledForLegacyCode') {
      this.setProperty('disabled', isDisabled);
    }
    this.setDisabledStateFired = true;
  }
  fireUncheck(value) {
    this.writeValue(value);
  }
  _checkName() {
    if (this.name && this.formControlName && this.name !== this.formControlName && (typeof ngDevMode === 'undefined' || ngDevMode)) {
      throwNameError();
    }
    if (!this.name && this.formControlName) this.name = this.formControlName;
  }
  static ɵfac = function RadioControlValueAccessor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || RadioControlValueAccessor)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.Renderer2), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](RadioControlRegistry), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.Injector));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: RadioControlValueAccessor,
    selectors: [["input", "type", "radio", "formControlName", ""], ["input", "type", "radio", "formControl", ""], ["input", "type", "radio", "ngModel", ""]],
    hostBindings: function RadioControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵlistener"]("change", function RadioControlValueAccessor_change_HostBindingHandler() {
          return ctx.onChange();
        })("blur", function RadioControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    inputs: {
      name: "name",
      formControlName: "formControlName",
      value: "value"
    },
    standalone: false,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵProvidersFeature"]([RADIO_VALUE_ACCESSOR]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(RadioControlValueAccessor, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: 'input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]',
      host: {
        '(change)': 'onChange()',
        '(blur)': 'onTouched()'
      },
      providers: [RADIO_VALUE_ACCESSOR],
      standalone: false
    }]
  }], () => [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Renderer2
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef
  }, {
    type: RadioControlRegistry
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injector
  }], {
    name: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    formControlName: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    value: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }]
  });
})();
const RANGE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => RangeValueAccessor),
  multi: true
};
class RangeValueAccessor extends BuiltInControlValueAccessor {
  writeValue(value) {
    this.setProperty('value', parseFloat(value));
  }
  registerOnChange(fn) {
    this.onChange = value => {
      fn(value == '' ? null : parseFloat(value));
    };
  }
  static ɵfac = /* @__PURE__ */(() => {
    let ɵRangeValueAccessor_BaseFactory;
    return function RangeValueAccessor_Factory(__ngFactoryType__) {
      return (ɵRangeValueAccessor_BaseFactory || (ɵRangeValueAccessor_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵgetInheritedFactory"](RangeValueAccessor)))(__ngFactoryType__ || RangeValueAccessor);
    };
  })();
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: RangeValueAccessor,
    selectors: [["input", "type", "range", "formControlName", ""], ["input", "type", "range", "formControl", ""], ["input", "type", "range", "ngModel", ""]],
    hostBindings: function RangeValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵlistener"]("change", function RangeValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("input", function RangeValueAccessor_input_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("blur", function RangeValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    standalone: false,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵProvidersFeature"]([RANGE_VALUE_ACCESSOR]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(RangeValueAccessor, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: 'input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]',
      host: {
        '(change)': 'onChange($any($event.target).value)',
        '(input)': 'onChange($any($event.target).value)',
        '(blur)': 'onTouched()'
      },
      providers: [RANGE_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, null);
})();
class FormArray extends AbstractControl {
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    this.controls = controls;
    this._initObservables();
    this._setUpdateStrategy(validatorOrOpts);
    this._setUpControls();
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: !!this.asyncValidator
    });
  }
  controls;
  at(index) {
    return this.controls[this._adjustIndex(index)];
  }
  push(control, options = {}) {
    if (Array.isArray(control)) {
      control.forEach(ctrl => {
        this.controls.push(ctrl);
        this._registerControl(ctrl);
      });
    } else {
      this.controls.push(control);
      this._registerControl(control);
    }
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  insert(index, control, options = {}) {
    this.controls.splice(index, 0, control);
    this._registerControl(control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  removeAt(index, options = {}) {
    let adjustedIndex = this._adjustIndex(index);
    if (adjustedIndex < 0) adjustedIndex = 0;
    if (this.controls[adjustedIndex]) this.controls[adjustedIndex]._registerOnCollectionChange(() => {});
    this.controls.splice(adjustedIndex, 1);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  setControl(index, control, options = {}) {
    let adjustedIndex = this._adjustIndex(index);
    if (adjustedIndex < 0) adjustedIndex = 0;
    if (this.controls[adjustedIndex]) this.controls[adjustedIndex]._registerOnCollectionChange(() => {});
    this.controls.splice(adjustedIndex, 1);
    if (control) {
      this.controls.splice(adjustedIndex, 0, control);
      this._registerControl(control);
    }
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  get length() {
    return this.controls.length;
  }
  setValue(value, options = {}) {
    assertAllValuesPresent(this, false, value);
    value.forEach((newValue, index) => {
      assertControlPresent(this, false, index);
      this.at(index).setValue(newValue, {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this.updateValueAndValidity(options);
  }
  patchValue(value, options = {}) {
    if (value == null) return;
    value.forEach((newValue, index) => {
      if (this.at(index)) {
        this.at(index).patchValue(newValue, {
          onlySelf: true,
          emitEvent: options.emitEvent
        });
      }
    });
    this.updateValueAndValidity(options);
  }
  reset(value = [], options = {}) {
    this._forEachChild((control, index) => {
      control.reset(value[index], {
        ...options,
        onlySelf: true
      });
    });
    this._updatePristine(options, this);
    this._updateTouched(options, this);
    this.updateValueAndValidity(options);
    if (options?.emitEvent !== false) {
      this._events.next(new FormResetEvent(this));
    }
  }
  getRawValue() {
    return this.controls.map(control => control.getRawValue());
  }
  clear(options = {}) {
    if (this.controls.length < 1) return;
    this._forEachChild(control => control._registerOnCollectionChange(() => {}));
    this.controls.splice(0);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  _adjustIndex(index) {
    return index < 0 ? index + this.length : index;
  }
  _syncPendingControls() {
    let subtreeUpdated = this.controls.reduce((updated, child) => {
      return child._syncPendingControls() ? true : updated;
    }, false);
    if (subtreeUpdated) this.updateValueAndValidity({
      onlySelf: true
    });
    return subtreeUpdated;
  }
  _forEachChild(cb) {
    this.controls.forEach((control, index) => {
      cb(control, index);
    });
  }
  _updateValue() {
    this.value = this.controls.filter(control => control.enabled || this.disabled).map(control => control.value);
  }
  _anyControls(condition) {
    return this.controls.some(control => control.enabled && condition(control));
  }
  _setUpControls() {
    this._forEachChild(control => this._registerControl(control));
  }
  _allControlsDisabled() {
    for (const control of this.controls) {
      if (control.enabled) return false;
    }
    return this.controls.length > 0 || this.disabled;
  }
  _registerControl(control) {
    control.setParent(this);
    control._registerOnCollectionChange(this._onCollectionChange);
  }
  _find(name) {
    return this.at(name) ?? null;
  }
}
const UntypedFormArray = FormArray;
const isFormArray = control => control instanceof FormArray;
class AbstractFormDirective extends ControlContainer {
  callSetDisabledState;
  get submitted() {
    return (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.untracked)(this._submittedReactive);
  }
  set submitted(value) {
    this._submittedReactive.set(value);
  }
  _submitted = (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.computed)(() => this._submittedReactive(), ...(ngDevMode ? [{
    debugName: "_submitted"
  }] : []));
  _submittedReactive = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.signal)(false, ...(ngDevMode ? [{
    debugName: "_submittedReactive"
  }] : []));
  _oldForm;
  _onCollectionChange = () => this._updateDomValue();
  directives = [];
  constructor(validators, asyncValidators, callSetDisabledState) {
    super();
    this.callSetDisabledState = callSetDisabledState;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  ngOnChanges(changes) {
    this.onChanges(changes);
  }
  ngOnDestroy() {
    this.onDestroy();
  }
  onChanges(changes) {
    this._checkFormPresent();
    if (changes.hasOwnProperty('form')) {
      this._updateValidators();
      this._updateDomValue();
      this._updateRegistrations();
      this._oldForm = this.form;
    }
  }
  onDestroy() {
    if (this.form) {
      cleanUpValidators(this.form, this);
      if (this.form._onCollectionChange === this._onCollectionChange) {
        this.form._registerOnCollectionChange(() => {});
      }
    }
  }
  get formDirective() {
    return this;
  }
  get path() {
    return [];
  }
  addControl(dir) {
    const ctrl = this.form.get(dir.path);
    setUpControl(ctrl, dir, this.callSetDisabledState);
    ctrl.updateValueAndValidity({
      emitEvent: false
    });
    this.directives.push(dir);
    return ctrl;
  }
  getControl(dir) {
    return this.form.get(dir.path);
  }
  removeControl(dir) {
    cleanUpControl(dir.control || null, dir, false);
    removeListItem$1(this.directives, dir);
  }
  addFormGroup(dir) {
    this._setUpFormContainer(dir);
  }
  removeFormGroup(dir) {
    this._cleanUpFormContainer(dir);
  }
  getFormGroup(dir) {
    return this.form.get(dir.path);
  }
  getFormArray(dir) {
    return this.form.get(dir.path);
  }
  addFormArray(dir) {
    this._setUpFormContainer(dir);
  }
  removeFormArray(dir) {
    this._cleanUpFormContainer(dir);
  }
  updateModel(dir, value) {
    const ctrl = this.form.get(dir.path);
    ctrl.setValue(value);
  }
  onReset() {
    this.resetForm();
  }
  resetForm(value = undefined, options = {}) {
    this.form.reset(value, options);
    this._submittedReactive.set(false);
  }
  onSubmit($event) {
    this.submitted = true;
    syncPendingControls(this.form, this.directives);
    this.ngSubmit.emit($event);
    this.form._events.next(new FormSubmittedEvent(this.control));
    return $event?.target?.method === 'dialog';
  }
  _updateDomValue() {
    this.directives.forEach(dir => {
      const oldCtrl = dir.control;
      const newCtrl = this.form.get(dir.path);
      if (oldCtrl !== newCtrl) {
        cleanUpControl(oldCtrl || null, dir);
        if (isFormControl(newCtrl)) {
          setUpControl(newCtrl, dir, this.callSetDisabledState);
          dir.control = newCtrl;
        }
      }
    });
    this.form._updateTreeValidity({
      emitEvent: false
    });
  }
  _setUpFormContainer(dir) {
    const ctrl = this.form.get(dir.path);
    setUpFormContainer(ctrl, dir);
    ctrl.updateValueAndValidity({
      emitEvent: false
    });
  }
  _cleanUpFormContainer(dir) {
    if (this.form) {
      const ctrl = this.form.get(dir.path);
      if (ctrl) {
        const isControlUpdated = cleanUpFormContainer(ctrl, dir);
        if (isControlUpdated) {
          ctrl.updateValueAndValidity({
            emitEvent: false
          });
        }
      }
    }
  }
  _updateRegistrations() {
    this.form._registerOnCollectionChange(this._onCollectionChange);
    if (this._oldForm) {
      this._oldForm._registerOnCollectionChange(() => {});
    }
  }
  _updateValidators() {
    setUpValidators(this.form, this);
    if (this._oldForm) {
      cleanUpValidators(this._oldForm, this);
    }
  }
  _checkFormPresent() {
    if (!this.form && (typeof ngDevMode === 'undefined' || ngDevMode)) {
      throw missingFormException();
    }
  }
  static ɵfac = function AbstractFormDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || AbstractFormDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](NG_VALIDATORS, 10), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](NG_ASYNC_VALIDATORS, 10), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](CALL_SET_DISABLED_STATE, 8));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: AbstractFormDirective,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"], _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵNgOnChangesFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(AbstractFormDirective, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive
  }], () => [{
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Self
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Self
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], null);
})();
const formDirectiveProvider$1 = {
  provide: ControlContainer,
  useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => FormArrayDirective)
};
class FormArrayDirective extends AbstractFormDirective {
  form = null;
  ngSubmit = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
  get control() {
    return this.form;
  }
  static ɵfac = /* @__PURE__ */(() => {
    let ɵFormArrayDirective_BaseFactory;
    return function FormArrayDirective_Factory(__ngFactoryType__) {
      return (ɵFormArrayDirective_BaseFactory || (ɵFormArrayDirective_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵgetInheritedFactory"](FormArrayDirective)))(__ngFactoryType__ || FormArrayDirective);
    };
  })();
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: FormArrayDirective,
    selectors: [["", "formArray", ""]],
    hostBindings: function FormArrayDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵlistener"]("submit", function FormArrayDirective_submit_HostBindingHandler($event) {
          return ctx.onSubmit($event);
        })("reset", function FormArrayDirective_reset_HostBindingHandler() {
          return ctx.onReset();
        });
      }
    },
    inputs: {
      form: [0, "formArray", "form"]
    },
    outputs: {
      ngSubmit: "ngSubmit"
    },
    exportAs: ["ngForm"],
    standalone: false,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵProvidersFeature"]([formDirectiveProvider$1]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(FormArrayDirective, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[formArray]',
      providers: [formDirectiveProvider$1],
      host: {
        '(submit)': 'onSubmit($event)',
        '(reset)': 'onReset()'
      },
      exportAs: 'ngForm',
      standalone: false
    }]
  }], null, {
    form: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,
      args: ['formArray']
    }],
    ngSubmit: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Output
    }]
  });
})();
const NG_MODEL_WITH_FORM_CONTROL_WARNING = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'NgModelWithFormControlWarning' : '');
const formControlBinding = {
  provide: NgControl,
  useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => FormControlDirective)
};
class FormControlDirective extends NgControl {
  _ngModelWarningConfig;
  callSetDisabledState;
  viewModel;
  form;
  set isDisabled(isDisabled) {
    if (typeof ngDevMode === 'undefined' || ngDevMode) {
      console.warn(disabledAttrWarning);
    }
  }
  model;
  update = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
  static _ngModelWarningSentOnce = false;
  _ngModelWarningSent = false;
  constructor(validators, asyncValidators, valueAccessors, _ngModelWarningConfig, callSetDisabledState) {
    super();
    this._ngModelWarningConfig = _ngModelWarningConfig;
    this.callSetDisabledState = callSetDisabledState;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  ngOnChanges(changes) {
    if (this._isControlChanged(changes)) {
      const previousForm = changes['form'].previousValue;
      if (previousForm) {
        cleanUpControl(previousForm, this, false);
      }
      setUpControl(this.form, this, this.callSetDisabledState);
      this.form.updateValueAndValidity({
        emitEvent: false
      });
    }
    if (isPropertyUpdated(changes, this.viewModel)) {
      if (typeof ngDevMode === 'undefined' || ngDevMode) {
        _ngModelWarning('formControl', FormControlDirective, this, this._ngModelWarningConfig);
      }
      this.form.setValue(this.model);
      this.viewModel = this.model;
    }
  }
  ngOnDestroy() {
    if (this.form) {
      cleanUpControl(this.form, this, false);
    }
  }
  get path() {
    return [];
  }
  get control() {
    return this.form;
  }
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  _isControlChanged(changes) {
    return changes.hasOwnProperty('form');
  }
  static ɵfac = function FormControlDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || FormControlDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](NG_VALIDATORS, 10), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](NG_ASYNC_VALIDATORS, 10), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](NG_VALUE_ACCESSOR, 10), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](NG_MODEL_WITH_FORM_CONTROL_WARNING, 8), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](CALL_SET_DISABLED_STATE, 8));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: FormControlDirective,
    selectors: [["", "formControl", ""]],
    inputs: {
      form: [0, "formControl", "form"],
      isDisabled: [0, "disabled", "isDisabled"],
      model: [0, "ngModel", "model"]
    },
    outputs: {
      update: "ngModelChange"
    },
    exportAs: ["ngForm"],
    standalone: false,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵProvidersFeature"]([formControlBinding]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"], _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵNgOnChangesFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(FormControlDirective, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[formControl]',
      providers: [formControlBinding],
      exportAs: 'ngForm',
      standalone: false
    }]
  }], () => [{
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Self
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Self
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Self
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    form: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,
      args: ['formControl']
    }],
    isDisabled: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,
      args: ['disabled']
    }],
    model: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,
      args: ['ngModel']
    }],
    update: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Output,
      args: ['ngModelChange']
    }]
  });
})();
const formGroupNameProvider = {
  provide: ControlContainer,
  useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => FormGroupName)
};
class FormGroupName extends AbstractFormGroupDirective {
  name = null;
  constructor(parent, validators, asyncValidators) {
    super();
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  _checkParentType() {
    if (hasInvalidParent(this._parent) && (typeof ngDevMode === 'undefined' || ngDevMode)) {
      throw groupParentException();
    }
  }
  static ɵfac = function FormGroupName_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || FormGroupName)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](ControlContainer, 13), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](NG_VALIDATORS, 10), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](NG_ASYNC_VALIDATORS, 10));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: FormGroupName,
    selectors: [["", "formGroupName", ""]],
    inputs: {
      name: [0, "formGroupName", "name"]
    },
    standalone: false,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵProvidersFeature"]([formGroupNameProvider]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(FormGroupName, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[formGroupName]',
      providers: [formGroupNameProvider],
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Host
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.SkipSelf
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Self
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Self
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,
      args: ['formGroupName']
    }]
  });
})();
const formArrayNameProvider = {
  provide: ControlContainer,
  useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => FormArrayName)
};
class FormArrayName extends ControlContainer {
  _parent;
  name = null;
  constructor(parent, validators, asyncValidators) {
    super();
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  ngOnInit() {
    if (hasInvalidParent(this._parent) && (typeof ngDevMode === 'undefined' || ngDevMode)) {
      throw arrayParentException();
    }
    this.formDirective.addFormArray(this);
  }
  ngOnDestroy() {
    this.formDirective?.removeFormArray(this);
  }
  get control() {
    return this.formDirective.getFormArray(this);
  }
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  static ɵfac = function FormArrayName_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || FormArrayName)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](ControlContainer, 13), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](NG_VALIDATORS, 10), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](NG_ASYNC_VALIDATORS, 10));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: FormArrayName,
    selectors: [["", "formArrayName", ""]],
    inputs: {
      name: [0, "formArrayName", "name"]
    },
    standalone: false,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵProvidersFeature"]([formArrayNameProvider]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(FormArrayName, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[formArrayName]',
      providers: [formArrayNameProvider],
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Host
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.SkipSelf
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Self
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Self
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,
      args: ['formArrayName']
    }]
  });
})();
function hasInvalidParent(parent) {
  return !(parent instanceof FormGroupName) && !(parent instanceof AbstractFormDirective) && !(parent instanceof FormArrayName);
}
const controlNameBinding = {
  provide: NgControl,
  useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => FormControlName)
};
class FormControlName extends NgControl {
  _ngModelWarningConfig;
  _added = false;
  viewModel;
  control;
  name = null;
  set isDisabled(isDisabled) {
    if (typeof ngDevMode === 'undefined' || ngDevMode) {
      console.warn(disabledAttrWarning);
    }
  }
  model;
  update = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
  static _ngModelWarningSentOnce = false;
  _ngModelWarningSent = false;
  constructor(parent, validators, asyncValidators, valueAccessors, _ngModelWarningConfig) {
    super();
    this._ngModelWarningConfig = _ngModelWarningConfig;
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  ngOnChanges(changes) {
    if (!this._added) this._setUpControl();
    if (isPropertyUpdated(changes, this.viewModel)) {
      if (typeof ngDevMode === 'undefined' || ngDevMode) {
        _ngModelWarning('formControlName', FormControlName, this, this._ngModelWarningConfig);
      }
      this.viewModel = this.model;
      this.formDirective.updateModel(this, this.model);
    }
  }
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeControl(this);
    }
  }
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  _setUpControl() {
    if (typeof ngDevMode === 'undefined' || ngDevMode) {
      checkParentType(this._parent, this.name);
    }
    this.control = this.formDirective.addControl(this);
    this._added = true;
  }
  static ɵfac = function FormControlName_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || FormControlName)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](ControlContainer, 13), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](NG_VALIDATORS, 10), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](NG_ASYNC_VALIDATORS, 10), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](NG_VALUE_ACCESSOR, 10), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](NG_MODEL_WITH_FORM_CONTROL_WARNING, 8));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: FormControlName,
    selectors: [["", "formControlName", ""]],
    inputs: {
      name: [0, "formControlName", "name"],
      isDisabled: [0, "disabled", "isDisabled"],
      model: [0, "ngModel", "model"]
    },
    outputs: {
      update: "ngModelChange"
    },
    standalone: false,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵProvidersFeature"]([controlNameBinding]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"], _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵNgOnChangesFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(FormControlName, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[formControlName]',
      providers: [controlNameBinding],
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Host
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.SkipSelf
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Self
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Self
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Self
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
    }]
  }], {
    name: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,
      args: ['formControlName']
    }],
    isDisabled: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,
      args: ['disabled']
    }],
    model: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,
      args: ['ngModel']
    }],
    update: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Output,
      args: ['ngModelChange']
    }]
  });
})();
function checkParentType(parent, name) {
  if (!(parent instanceof FormGroupName) && parent instanceof AbstractFormGroupDirective) {
    throw ngModelGroupException();
  } else if (!(parent instanceof FormGroupName) && !(parent instanceof AbstractFormDirective) && !(parent instanceof FormArrayName)) {
    throw controlParentException(name);
  }
}
const formDirectiveProvider = {
  provide: ControlContainer,
  useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => FormGroupDirective)
};
class FormGroupDirective extends AbstractFormDirective {
  form = null;
  ngSubmit = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
  get control() {
    return this.form;
  }
  static ɵfac = /* @__PURE__ */(() => {
    let ɵFormGroupDirective_BaseFactory;
    return function FormGroupDirective_Factory(__ngFactoryType__) {
      return (ɵFormGroupDirective_BaseFactory || (ɵFormGroupDirective_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵgetInheritedFactory"](FormGroupDirective)))(__ngFactoryType__ || FormGroupDirective);
    };
  })();
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: FormGroupDirective,
    selectors: [["", "formGroup", ""]],
    hostBindings: function FormGroupDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵlistener"]("submit", function FormGroupDirective_submit_HostBindingHandler($event) {
          return ctx.onSubmit($event);
        })("reset", function FormGroupDirective_reset_HostBindingHandler() {
          return ctx.onReset();
        });
      }
    },
    inputs: {
      form: [0, "formGroup", "form"]
    },
    outputs: {
      ngSubmit: "ngSubmit"
    },
    exportAs: ["ngForm"],
    standalone: false,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵProvidersFeature"]([formDirectiveProvider]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(FormGroupDirective, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[formGroup]',
      providers: [formDirectiveProvider],
      host: {
        '(submit)': 'onSubmit($event)',
        '(reset)': 'onReset()'
      },
      exportAs: 'ngForm',
      standalone: false
    }]
  }], null, {
    form: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,
      args: ['formGroup']
    }],
    ngSubmit: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Output
    }]
  });
})();
const SELECT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => SelectControlValueAccessor),
  multi: true
};
function _buildValueString$1(id, value) {
  if (id == null) return `${value}`;
  if (value && typeof value === 'object') value = 'Object';
  return `${id}: ${value}`.slice(0, 50);
}
function _extractId$1(valueString) {
  return valueString.split(':')[0];
}
class SelectControlValueAccessor extends BuiltInControlValueAccessor {
  value;
  _optionMap = new Map();
  _idCounter = 0;
  set compareWith(fn) {
    if (typeof fn !== 'function' && (typeof ngDevMode === 'undefined' || ngDevMode)) {
      throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
    }
    this._compareWith = fn;
  }
  _compareWith = Object.is;
  appRefInjector = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.ApplicationRef).injector;
  destroyRef = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.DestroyRef);
  cdr = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectorRef);
  _queuedWrite = false;
  _writeValueAfterRender() {
    if (this._queuedWrite || this.appRefInjector.destroyed) {
      return;
    }
    this._queuedWrite = true;
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.afterNextRender)({
      write: () => {
        if (this.destroyRef.destroyed) {
          return;
        }
        this._queuedWrite = false;
        this.writeValue(this.value);
      }
    }, {
      injector: this.appRefInjector
    });
  }
  writeValue(value) {
    this.cdr.markForCheck();
    this.value = value;
    const id = this._getOptionId(value);
    const valueString = _buildValueString$1(id, value);
    this.setProperty('value', valueString);
  }
  registerOnChange(fn) {
    this.onChange = valueString => {
      this.value = this._getOptionValue(valueString);
      fn(this.value);
    };
  }
  _registerOption() {
    return (this._idCounter++).toString();
  }
  _getOptionId(value) {
    for (const id of this._optionMap.keys()) {
      if (this._compareWith(this._optionMap.get(id), value)) return id;
    }
    return null;
  }
  _getOptionValue(valueString) {
    const id = _extractId$1(valueString);
    return this._optionMap.has(id) ? this._optionMap.get(id) : valueString;
  }
  static ɵfac = /* @__PURE__ */(() => {
    let ɵSelectControlValueAccessor_BaseFactory;
    return function SelectControlValueAccessor_Factory(__ngFactoryType__) {
      return (ɵSelectControlValueAccessor_BaseFactory || (ɵSelectControlValueAccessor_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵgetInheritedFactory"](SelectControlValueAccessor)))(__ngFactoryType__ || SelectControlValueAccessor);
    };
  })();
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: SelectControlValueAccessor,
    selectors: [["select", "formControlName", "", 3, "multiple", ""], ["select", "formControl", "", 3, "multiple", ""], ["select", "ngModel", "", 3, "multiple", ""]],
    hostBindings: function SelectControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵlistener"]("change", function SelectControlValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("blur", function SelectControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    inputs: {
      compareWith: "compareWith"
    },
    standalone: false,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵProvidersFeature"]([SELECT_VALUE_ACCESSOR]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(SelectControlValueAccessor, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: 'select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]',
      host: {
        '(change)': 'onChange($any($event.target).value)',
        '(blur)': 'onTouched()'
      },
      providers: [SELECT_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, {
    compareWith: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }]
  });
})();
class NgSelectOption {
  _element;
  _renderer;
  _select;
  id;
  constructor(_element, _renderer, _select) {
    this._element = _element;
    this._renderer = _renderer;
    this._select = _select;
    if (this._select) this.id = this._select._registerOption();
  }
  set ngValue(value) {
    if (this._select == null) return;
    this._select._optionMap.set(this.id, value);
    this._setElementValue(_buildValueString$1(this.id, value));
    this._select._writeValueAfterRender();
  }
  set value(value) {
    this._setElementValue(value);
    if (this._select) this._select._writeValueAfterRender();
  }
  _setElementValue(value) {
    this._renderer.setProperty(this._element.nativeElement, 'value', value);
  }
  ngOnDestroy() {
    if (this._select) {
      this._select._optionMap.delete(this.id);
      this._select._writeValueAfterRender();
    }
  }
  static ɵfac = function NgSelectOption_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || NgSelectOption)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.Renderer2), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](SelectControlValueAccessor, 9));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: NgSelectOption,
    selectors: [["option"]],
    inputs: {
      ngValue: "ngValue",
      value: "value"
    },
    standalone: false
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(NgSelectOption, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: 'option',
      standalone: false
    }]
  }], () => [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Renderer2
  }, {
    type: SelectControlValueAccessor,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Host
    }]
  }], {
    ngValue: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,
      args: ['ngValue']
    }],
    value: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,
      args: ['value']
    }]
  });
})();
const SELECT_MULTIPLE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => SelectMultipleControlValueAccessor),
  multi: true
};
function _buildValueString(id, value) {
  if (id == null) return `${value}`;
  if (typeof value === 'string') value = `'${value}'`;
  if (value && typeof value === 'object') value = 'Object';
  return `${id}: ${value}`.slice(0, 50);
}
function _extractId(valueString) {
  return valueString.split(':')[0];
}
class SelectMultipleControlValueAccessor extends BuiltInControlValueAccessor {
  value;
  _optionMap = new Map();
  _idCounter = 0;
  set compareWith(fn) {
    if (typeof fn !== 'function' && (typeof ngDevMode === 'undefined' || ngDevMode)) {
      throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
    }
    this._compareWith = fn;
  }
  _compareWith = Object.is;
  writeValue(value) {
    this.value = value;
    let optionSelectedStateSetter;
    if (Array.isArray(value)) {
      const ids = value.map(v => this._getOptionId(v));
      optionSelectedStateSetter = (opt, o) => {
        opt._setSelected(ids.indexOf(o.toString()) > -1);
      };
    } else {
      optionSelectedStateSetter = (opt, o) => {
        opt._setSelected(false);
      };
    }
    this._optionMap.forEach(optionSelectedStateSetter);
  }
  registerOnChange(fn) {
    this.onChange = element => {
      const selected = [];
      const selectedOptions = element.selectedOptions;
      if (selectedOptions !== undefined) {
        const options = selectedOptions;
        for (let i = 0; i < options.length; i++) {
          const opt = options[i];
          const val = this._getOptionValue(opt.value);
          selected.push(val);
        }
      } else {
        const options = element.options;
        for (let i = 0; i < options.length; i++) {
          const opt = options[i];
          if (opt.selected) {
            const val = this._getOptionValue(opt.value);
            selected.push(val);
          }
        }
      }
      this.value = selected;
      fn(selected);
    };
  }
  _registerOption(value) {
    const id = (this._idCounter++).toString();
    this._optionMap.set(id, value);
    return id;
  }
  _getOptionId(value) {
    for (const id of this._optionMap.keys()) {
      if (this._compareWith(this._optionMap.get(id)._value, value)) return id;
    }
    return null;
  }
  _getOptionValue(valueString) {
    const id = _extractId(valueString);
    return this._optionMap.has(id) ? this._optionMap.get(id)._value : valueString;
  }
  static ɵfac = /* @__PURE__ */(() => {
    let ɵSelectMultipleControlValueAccessor_BaseFactory;
    return function SelectMultipleControlValueAccessor_Factory(__ngFactoryType__) {
      return (ɵSelectMultipleControlValueAccessor_BaseFactory || (ɵSelectMultipleControlValueAccessor_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵgetInheritedFactory"](SelectMultipleControlValueAccessor)))(__ngFactoryType__ || SelectMultipleControlValueAccessor);
    };
  })();
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: SelectMultipleControlValueAccessor,
    selectors: [["select", "multiple", "", "formControlName", ""], ["select", "multiple", "", "formControl", ""], ["select", "multiple", "", "ngModel", ""]],
    hostBindings: function SelectMultipleControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵlistener"]("change", function SelectMultipleControlValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target);
        })("blur", function SelectMultipleControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    inputs: {
      compareWith: "compareWith"
    },
    standalone: false,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵProvidersFeature"]([SELECT_MULTIPLE_VALUE_ACCESSOR]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(SelectMultipleControlValueAccessor, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: 'select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]',
      host: {
        '(change)': 'onChange($event.target)',
        '(blur)': 'onTouched()'
      },
      providers: [SELECT_MULTIPLE_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, {
    compareWith: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }]
  });
})();
class ɵNgSelectMultipleOption {
  _element;
  _renderer;
  _select;
  id;
  _value;
  constructor(_element, _renderer, _select) {
    this._element = _element;
    this._renderer = _renderer;
    this._select = _select;
    if (this._select) {
      this.id = this._select._registerOption(this);
    }
  }
  set ngValue(value) {
    if (this._select == null) return;
    this._value = value;
    this._setElementValue(_buildValueString(this.id, value));
    this._select.writeValue(this._select.value);
  }
  set value(value) {
    if (this._select) {
      this._value = value;
      this._setElementValue(_buildValueString(this.id, value));
      this._select.writeValue(this._select.value);
    } else {
      this._setElementValue(value);
    }
  }
  _setElementValue(value) {
    this._renderer.setProperty(this._element.nativeElement, 'value', value);
  }
  _setSelected(selected) {
    this._renderer.setProperty(this._element.nativeElement, 'selected', selected);
  }
  ngOnDestroy() {
    if (this._select) {
      this._select._optionMap.delete(this.id);
      this._select.writeValue(this._select.value);
    }
  }
  static ɵfac = function ɵNgSelectMultipleOption_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || ɵNgSelectMultipleOption)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.Renderer2), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](SelectMultipleControlValueAccessor, 9));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: ɵNgSelectMultipleOption,
    selectors: [["option"]],
    inputs: {
      ngValue: "ngValue",
      value: "value"
    },
    standalone: false
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(ɵNgSelectMultipleOption, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: 'option',
      standalone: false
    }]
  }], () => [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Renderer2
  }, {
    type: SelectMultipleControlValueAccessor,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Host
    }]
  }], {
    ngValue: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,
      args: ['ngValue']
    }],
    value: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,
      args: ['value']
    }]
  });
})();
function toInteger(value) {
  return typeof value === 'number' ? value : parseInt(value, 10);
}
function toFloat(value) {
  return typeof value === 'number' ? value : parseFloat(value);
}
class AbstractValidatorDirective {
  _validator = nullValidator;
  _onChange;
  _enabled;
  ngOnChanges(changes) {
    if (this.inputName in changes) {
      const input = this.normalizeInput(changes[this.inputName].currentValue);
      this._enabled = this.enabled(input);
      this._validator = this._enabled ? this.createValidator(input) : nullValidator;
      if (this._onChange) {
        this._onChange();
      }
    }
  }
  validate(control) {
    return this._validator(control);
  }
  registerOnValidatorChange(fn) {
    this._onChange = fn;
  }
  enabled(input) {
    return input != null;
  }
  static ɵfac = function AbstractValidatorDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || AbstractValidatorDirective)();
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: AbstractValidatorDirective,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵNgOnChangesFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(AbstractValidatorDirective, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive
  }], null, null);
})();
const MAX_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => MaxValidator),
  multi: true
};
class MaxValidator extends AbstractValidatorDirective {
  max;
  inputName = 'max';
  normalizeInput = input => toFloat(input);
  createValidator = max => maxValidator(max);
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMaxValidator_BaseFactory;
    return function MaxValidator_Factory(__ngFactoryType__) {
      return (ɵMaxValidator_BaseFactory || (ɵMaxValidator_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵgetInheritedFactory"](MaxValidator)))(__ngFactoryType__ || MaxValidator);
    };
  })();
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: MaxValidator,
    selectors: [["input", "type", "number", "max", "", "formControlName", ""], ["input", "type", "number", "max", "", "formControl", ""], ["input", "type", "number", "max", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MaxValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵattribute"]("max", ctx._enabled ? ctx.max : null);
      }
    },
    inputs: {
      max: "max"
    },
    standalone: false,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵProvidersFeature"]([MAX_VALIDATOR]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(MaxValidator, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: 'input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]',
      providers: [MAX_VALIDATOR],
      host: {
        '[attr.max]': '_enabled ? max : null'
      },
      standalone: false
    }]
  }], null, {
    max: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }]
  });
})();
const MIN_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => MinValidator),
  multi: true
};
class MinValidator extends AbstractValidatorDirective {
  min;
  inputName = 'min';
  normalizeInput = input => toFloat(input);
  createValidator = min => minValidator(min);
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMinValidator_BaseFactory;
    return function MinValidator_Factory(__ngFactoryType__) {
      return (ɵMinValidator_BaseFactory || (ɵMinValidator_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵgetInheritedFactory"](MinValidator)))(__ngFactoryType__ || MinValidator);
    };
  })();
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: MinValidator,
    selectors: [["input", "type", "number", "min", "", "formControlName", ""], ["input", "type", "number", "min", "", "formControl", ""], ["input", "type", "number", "min", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MinValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵattribute"]("min", ctx._enabled ? ctx.min : null);
      }
    },
    inputs: {
      min: "min"
    },
    standalone: false,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵProvidersFeature"]([MIN_VALIDATOR]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(MinValidator, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: 'input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]',
      providers: [MIN_VALIDATOR],
      host: {
        '[attr.min]': '_enabled ? min : null'
      },
      standalone: false
    }]
  }], null, {
    min: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }]
  });
})();
const REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => RequiredValidator),
  multi: true
};
const CHECKBOX_REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => CheckboxRequiredValidator),
  multi: true
};
class RequiredValidator extends AbstractValidatorDirective {
  required;
  inputName = 'required';
  normalizeInput = _angular_core__WEBPACK_IMPORTED_MODULE_2__.booleanAttribute;
  createValidator = input => requiredValidator;
  enabled(input) {
    return input;
  }
  static ɵfac = /* @__PURE__ */(() => {
    let ɵRequiredValidator_BaseFactory;
    return function RequiredValidator_Factory(__ngFactoryType__) {
      return (ɵRequiredValidator_BaseFactory || (ɵRequiredValidator_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵgetInheritedFactory"](RequiredValidator)))(__ngFactoryType__ || RequiredValidator);
    };
  })();
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: RequiredValidator,
    selectors: [["", "required", "", "formControlName", "", 3, "type", "checkbox"], ["", "required", "", "formControl", "", 3, "type", "checkbox"], ["", "required", "", "ngModel", "", 3, "type", "checkbox"]],
    hostVars: 1,
    hostBindings: function RequiredValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵattribute"]("required", ctx._enabled ? "" : null);
      }
    },
    inputs: {
      required: "required"
    },
    standalone: false,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵProvidersFeature"]([REQUIRED_VALIDATOR]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(RequiredValidator, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: ':not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]',
      providers: [REQUIRED_VALIDATOR],
      host: {
        '[attr.required]': '_enabled ? "" : null'
      },
      standalone: false
    }]
  }], null, {
    required: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }]
  });
})();
class CheckboxRequiredValidator extends RequiredValidator {
  createValidator = input => requiredTrueValidator;
  static ɵfac = /* @__PURE__ */(() => {
    let ɵCheckboxRequiredValidator_BaseFactory;
    return function CheckboxRequiredValidator_Factory(__ngFactoryType__) {
      return (ɵCheckboxRequiredValidator_BaseFactory || (ɵCheckboxRequiredValidator_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵgetInheritedFactory"](CheckboxRequiredValidator)))(__ngFactoryType__ || CheckboxRequiredValidator);
    };
  })();
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: CheckboxRequiredValidator,
    selectors: [["input", "type", "checkbox", "required", "", "formControlName", ""], ["input", "type", "checkbox", "required", "", "formControl", ""], ["input", "type", "checkbox", "required", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function CheckboxRequiredValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵattribute"]("required", ctx._enabled ? "" : null);
      }
    },
    standalone: false,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵProvidersFeature"]([CHECKBOX_REQUIRED_VALIDATOR]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(CheckboxRequiredValidator, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: 'input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]',
      providers: [CHECKBOX_REQUIRED_VALIDATOR],
      host: {
        '[attr.required]': '_enabled ? "" : null'
      },
      standalone: false
    }]
  }], null, null);
})();
const EMAIL_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => EmailValidator),
  multi: true
};
class EmailValidator extends AbstractValidatorDirective {
  email;
  inputName = 'email';
  normalizeInput = _angular_core__WEBPACK_IMPORTED_MODULE_2__.booleanAttribute;
  createValidator = input => emailValidator;
  enabled(input) {
    return input;
  }
  static ɵfac = /* @__PURE__ */(() => {
    let ɵEmailValidator_BaseFactory;
    return function EmailValidator_Factory(__ngFactoryType__) {
      return (ɵEmailValidator_BaseFactory || (ɵEmailValidator_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵgetInheritedFactory"](EmailValidator)))(__ngFactoryType__ || EmailValidator);
    };
  })();
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: EmailValidator,
    selectors: [["", "email", "", "formControlName", ""], ["", "email", "", "formControl", ""], ["", "email", "", "ngModel", ""]],
    inputs: {
      email: "email"
    },
    standalone: false,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵProvidersFeature"]([EMAIL_VALIDATOR]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(EmailValidator, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[email][formControlName],[email][formControl],[email][ngModel]',
      providers: [EMAIL_VALIDATOR],
      standalone: false
    }]
  }], null, {
    email: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }]
  });
})();
const MIN_LENGTH_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => MinLengthValidator),
  multi: true
};
class MinLengthValidator extends AbstractValidatorDirective {
  minlength;
  inputName = 'minlength';
  normalizeInput = input => toInteger(input);
  createValidator = minlength => minLengthValidator(minlength);
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMinLengthValidator_BaseFactory;
    return function MinLengthValidator_Factory(__ngFactoryType__) {
      return (ɵMinLengthValidator_BaseFactory || (ɵMinLengthValidator_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵgetInheritedFactory"](MinLengthValidator)))(__ngFactoryType__ || MinLengthValidator);
    };
  })();
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: MinLengthValidator,
    selectors: [["", "minlength", "", "formControlName", ""], ["", "minlength", "", "formControl", ""], ["", "minlength", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MinLengthValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵattribute"]("minlength", ctx._enabled ? ctx.minlength : null);
      }
    },
    inputs: {
      minlength: "minlength"
    },
    standalone: false,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵProvidersFeature"]([MIN_LENGTH_VALIDATOR]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(MinLengthValidator, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[minlength][formControlName],[minlength][formControl],[minlength][ngModel]',
      providers: [MIN_LENGTH_VALIDATOR],
      host: {
        '[attr.minlength]': '_enabled ? minlength : null'
      },
      standalone: false
    }]
  }], null, {
    minlength: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }]
  });
})();
const MAX_LENGTH_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => MaxLengthValidator),
  multi: true
};
class MaxLengthValidator extends AbstractValidatorDirective {
  maxlength;
  inputName = 'maxlength';
  normalizeInput = input => toInteger(input);
  createValidator = maxlength => maxLengthValidator(maxlength);
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMaxLengthValidator_BaseFactory;
    return function MaxLengthValidator_Factory(__ngFactoryType__) {
      return (ɵMaxLengthValidator_BaseFactory || (ɵMaxLengthValidator_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵgetInheritedFactory"](MaxLengthValidator)))(__ngFactoryType__ || MaxLengthValidator);
    };
  })();
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: MaxLengthValidator,
    selectors: [["", "maxlength", "", "formControlName", ""], ["", "maxlength", "", "formControl", ""], ["", "maxlength", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MaxLengthValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵattribute"]("maxlength", ctx._enabled ? ctx.maxlength : null);
      }
    },
    inputs: {
      maxlength: "maxlength"
    },
    standalone: false,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵProvidersFeature"]([MAX_LENGTH_VALIDATOR]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(MaxLengthValidator, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]',
      providers: [MAX_LENGTH_VALIDATOR],
      host: {
        '[attr.maxlength]': '_enabled ? maxlength : null'
      },
      standalone: false
    }]
  }], null, {
    maxlength: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }]
  });
})();
const PATTERN_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => PatternValidator),
  multi: true
};
class PatternValidator extends AbstractValidatorDirective {
  pattern;
  inputName = 'pattern';
  normalizeInput = input => input;
  createValidator = input => patternValidator(input);
  static ɵfac = /* @__PURE__ */(() => {
    let ɵPatternValidator_BaseFactory;
    return function PatternValidator_Factory(__ngFactoryType__) {
      return (ɵPatternValidator_BaseFactory || (ɵPatternValidator_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵgetInheritedFactory"](PatternValidator)))(__ngFactoryType__ || PatternValidator);
    };
  })();
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: PatternValidator,
    selectors: [["", "pattern", "", "formControlName", ""], ["", "pattern", "", "formControl", ""], ["", "pattern", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function PatternValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵattribute"]("pattern", ctx._enabled ? ctx.pattern : null);
      }
    },
    inputs: {
      pattern: "pattern"
    },
    standalone: false,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵProvidersFeature"]([PATTERN_VALIDATOR]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵInheritDefinitionFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(PatternValidator, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[pattern][formControlName],[pattern][formControl],[pattern][ngModel]',
      providers: [PATTERN_VALIDATOR],
      host: {
        '[attr.pattern]': '_enabled ? pattern : null'
      },
      standalone: false
    }]
  }], null, {
    pattern: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }]
  });
})();
const SHARED_FORM_DIRECTIVES = [ɵNgNoValidate, NgSelectOption, ɵNgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator];
const TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];
const REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormArrayDirective, FormControlName, FormGroupName, FormArrayName];
class ɵInternalFormsSharedModule {
  static ɵfac = function ɵInternalFormsSharedModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || ɵInternalFormsSharedModule)();
  };
  static ɵmod = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
    type: ɵInternalFormsSharedModule
  });
  static ɵinj = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({});
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(ɵInternalFormsSharedModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgModule,
    args: [{
      declarations: SHARED_FORM_DIRECTIVES,
      exports: SHARED_FORM_DIRECTIVES
    }]
  }], null, null);
})();
function isAbstractControlOptions(options) {
  return !!options && (options.asyncValidators !== undefined || options.validators !== undefined || options.updateOn !== undefined);
}
class FormBuilder {
  useNonNullable = false;
  get nonNullable() {
    const nnfb = new FormBuilder();
    nnfb.useNonNullable = true;
    return nnfb;
  }
  group(controls, options = null) {
    const reducedControls = this._reduceControls(controls);
    let newOptions = {};
    if (isAbstractControlOptions(options)) {
      newOptions = options;
    } else if (options !== null) {
      newOptions.validators = options.validator;
      newOptions.asyncValidators = options.asyncValidator;
    }
    return new FormGroup(reducedControls, newOptions);
  }
  record(controls, options = null) {
    const reducedControls = this._reduceControls(controls);
    return new FormRecord(reducedControls, options);
  }
  control(formState, validatorOrOpts, asyncValidator) {
    let newOptions = {};
    if (!this.useNonNullable) {
      return new FormControl(formState, validatorOrOpts, asyncValidator);
    }
    if (isAbstractControlOptions(validatorOrOpts)) {
      newOptions = validatorOrOpts;
    } else {
      newOptions.validators = validatorOrOpts;
      newOptions.asyncValidators = asyncValidator;
    }
    return new FormControl(formState, {
      ...newOptions,
      nonNullable: true
    });
  }
  array(controls, validatorOrOpts, asyncValidator) {
    const createdControls = controls.map(c => this._createControl(c));
    return new FormArray(createdControls, validatorOrOpts, asyncValidator);
  }
  _reduceControls(controls) {
    const createdControls = {};
    Object.keys(controls).forEach(controlName => {
      createdControls[controlName] = this._createControl(controls[controlName]);
    });
    return createdControls;
  }
  _createControl(controls) {
    if (controls instanceof FormControl) {
      return controls;
    } else if (controls instanceof AbstractControl) {
      return controls;
    } else if (Array.isArray(controls)) {
      const value = controls[0];
      const validator = controls.length > 1 ? controls[1] : null;
      const asyncValidator = controls.length > 2 ? controls[2] : null;
      return this.control(value, validator, asyncValidator);
    } else {
      return this.control(controls);
    }
  }
  static ɵfac = function FormBuilder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || FormBuilder)();
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: FormBuilder,
    factory: FormBuilder.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(FormBuilder, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], null, null);
})();
class NonNullableFormBuilder {
  static ɵfac = function NonNullableFormBuilder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || NonNullableFormBuilder)();
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: NonNullableFormBuilder,
    factory: () => (() => (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(FormBuilder).nonNullable)(),
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(NonNullableFormBuilder, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,
    args: [{
      providedIn: 'root',
      useFactory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(FormBuilder).nonNullable
    }]
  }], null, null);
})();
class UntypedFormBuilder extends FormBuilder {
  group(controlsConfig, options = null) {
    return super.group(controlsConfig, options);
  }
  control(formState, validatorOrOpts, asyncValidator) {
    return super.control(formState, validatorOrOpts, asyncValidator);
  }
  array(controlsConfig, validatorOrOpts, asyncValidator) {
    return super.array(controlsConfig, validatorOrOpts, asyncValidator);
  }
  static ɵfac = /* @__PURE__ */(() => {
    let ɵUntypedFormBuilder_BaseFactory;
    return function UntypedFormBuilder_Factory(__ngFactoryType__) {
      return (ɵUntypedFormBuilder_BaseFactory || (ɵUntypedFormBuilder_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵgetInheritedFactory"](UntypedFormBuilder)))(__ngFactoryType__ || UntypedFormBuilder);
    };
  })();
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: UntypedFormBuilder,
    factory: UntypedFormBuilder.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(UntypedFormBuilder, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], null, null);
})();
const VERSION = /* @__PURE__ */new _angular_core__WEBPACK_IMPORTED_MODULE_0__.Version('21.0.5');
class FormsModule {
  static withConfig(opts) {
    return {
      ngModule: FormsModule,
      providers: [{
        provide: CALL_SET_DISABLED_STATE,
        useValue: opts.callSetDisabledState ?? setDisabledStateDefault
      }]
    };
  }
  static ɵfac = function FormsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || FormsModule)();
  };
  static ɵmod = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
    type: FormsModule
  });
  static ɵinj = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
    imports: [ɵInternalFormsSharedModule]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(FormsModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgModule,
    args: [{
      declarations: TEMPLATE_DRIVEN_DIRECTIVES,
      exports: [ɵInternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]
    }]
  }], null, null);
})();
class ReactiveFormsModule {
  static withConfig(opts) {
    return {
      ngModule: ReactiveFormsModule,
      providers: [{
        provide: NG_MODEL_WITH_FORM_CONTROL_WARNING,
        useValue: opts.warnOnNgModelWithFormControl ?? 'always'
      }, {
        provide: CALL_SET_DISABLED_STATE,
        useValue: opts.callSetDisabledState ?? setDisabledStateDefault
      }]
    };
  }
  static ɵfac = function ReactiveFormsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || ReactiveFormsModule)();
  };
  static ɵmod = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
    type: ReactiveFormsModule
  });
  static ɵinj = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
    imports: [ɵInternalFormsSharedModule]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(ReactiveFormsModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgModule,
    args: [{
      declarations: [REACTIVE_DRIVEN_DIRECTIVES],
      exports: [ɵInternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]
    }]
  }], null, null);
})();


/***/ }),

/***/ 933:
/*!*********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@angular+common@21.0.5_@angular+core@21.0.5_rxjs@7.8.2/node_modules/@angular/common/fesm2022/_location-chunk.mjs ***!
  \*********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   APP_BASE_HREF: () => (/* binding */ APP_BASE_HREF),
/* harmony export */   Location: () => (/* binding */ Location),
/* harmony export */   LocationStrategy: () => (/* binding */ LocationStrategy),
/* harmony export */   PathLocationStrategy: () => (/* binding */ PathLocationStrategy),
/* harmony export */   joinWithSlash: () => (/* binding */ joinWithSlash),
/* harmony export */   normalizeQueryParams: () => (/* binding */ normalizeQueryParams)
/* harmony export */ });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ 64);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ 7367);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ 1171);
/* harmony import */ var _platform_location_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_platform_location-chunk.mjs */ 8021);
/**
 * @license Angular v21.0.5
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */





function joinWithSlash(start, end) {
  if (!start) return end;
  if (!end) return start;
  if (start.endsWith('/')) {
    return end.startsWith('/') ? start + end.slice(1) : start + end;
  }
  return end.startsWith('/') ? start + end : `${start}/${end}`;
}
function stripTrailingSlash(url) {
  const pathEndIdx = url.search(/#|\?|$/);
  return url[pathEndIdx - 1] === '/' ? url.slice(0, pathEndIdx - 1) + url.slice(pathEndIdx) : url;
}
function normalizeQueryParams(params) {
  return params && params[0] !== '?' ? `?${params}` : params;
}
class LocationStrategy {
  historyGo(relativePosition) {
    throw new Error(ngDevMode ? 'Not implemented' : '');
  }
  static ɵfac = function LocationStrategy_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || LocationStrategy)();
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: LocationStrategy,
    factory: () => (() => (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(PathLocationStrategy))(),
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(LocationStrategy, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,
    args: [{
      providedIn: 'root',
      useFactory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(PathLocationStrategy)
    }]
  }], null, null);
})();
const APP_BASE_HREF = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'appBaseHref' : '');
class PathLocationStrategy extends LocationStrategy {
  _platformLocation;
  _baseHref;
  _removeListenerFns = [];
  constructor(_platformLocation, href) {
    super();
    this._platformLocation = _platformLocation;
    this._baseHref = href ?? this._platformLocation.getBaseHrefFromDOM() ?? (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT).location?.origin ?? '';
  }
  ngOnDestroy() {
    while (this._removeListenerFns.length) {
      this._removeListenerFns.pop()();
    }
  }
  onPopState(fn) {
    this._removeListenerFns.push(this._platformLocation.onPopState(fn), this._platformLocation.onHashChange(fn));
  }
  getBaseHref() {
    return this._baseHref;
  }
  prepareExternalUrl(internal) {
    return joinWithSlash(this._baseHref, internal);
  }
  path(includeHash = false) {
    const pathname = this._platformLocation.pathname + normalizeQueryParams(this._platformLocation.search);
    const hash = this._platformLocation.hash;
    return hash && includeHash ? `${pathname}${hash}` : pathname;
  }
  pushState(state, title, url, queryParams) {
    const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
    this._platformLocation.pushState(state, title, externalUrl);
  }
  replaceState(state, title, url, queryParams) {
    const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
    this._platformLocation.replaceState(state, title, externalUrl);
  }
  forward() {
    this._platformLocation.forward();
  }
  back() {
    this._platformLocation.back();
  }
  getState() {
    return this._platformLocation.getState();
  }
  historyGo(relativePosition = 0) {
    this._platformLocation.historyGo?.(relativePosition);
  }
  static ɵfac = function PathLocationStrategy_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || PathLocationStrategy)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_platform_location_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.PlatformLocation), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](APP_BASE_HREF, 8));
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: PathLocationStrategy,
    factory: PathLocationStrategy.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(PathLocationStrategy, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], () => [{
    type: _platform_location_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.PlatformLocation
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [APP_BASE_HREF]
    }]
  }], null);
})();
class Location {
  _subject = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
  _basePath;
  _locationStrategy;
  _urlChangeListeners = [];
  _urlChangeSubscription = null;
  constructor(locationStrategy) {
    this._locationStrategy = locationStrategy;
    const baseHref = this._locationStrategy.getBaseHref();
    this._basePath = _stripOrigin(stripTrailingSlash(_stripIndexHtml(baseHref)));
    this._locationStrategy.onPopState(ev => {
      this._subject.next({
        'url': this.path(true),
        'pop': true,
        'state': ev.state,
        'type': ev.type
      });
    });
  }
  ngOnDestroy() {
    this._urlChangeSubscription?.unsubscribe();
    this._urlChangeListeners = [];
  }
  path(includeHash = false) {
    return this.normalize(this._locationStrategy.path(includeHash));
  }
  getState() {
    return this._locationStrategy.getState();
  }
  isCurrentPathEqualTo(path, query = '') {
    return this.path() == this.normalize(path + normalizeQueryParams(query));
  }
  normalize(url) {
    return Location.stripTrailingSlash(_stripBasePath(this._basePath, _stripIndexHtml(url)));
  }
  prepareExternalUrl(url) {
    if (url && url[0] !== '/') {
      url = '/' + url;
    }
    return this._locationStrategy.prepareExternalUrl(url);
  }
  go(path, query = '', state = null) {
    this._locationStrategy.pushState(state, '', path, query);
    this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state);
  }
  replaceState(path, query = '', state = null) {
    this._locationStrategy.replaceState(state, '', path, query);
    this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state);
  }
  forward() {
    this._locationStrategy.forward();
  }
  back() {
    this._locationStrategy.back();
  }
  historyGo(relativePosition = 0) {
    this._locationStrategy.historyGo?.(relativePosition);
  }
  onUrlChange(fn) {
    this._urlChangeListeners.push(fn);
    this._urlChangeSubscription ??= this.subscribe(v => {
      this._notifyUrlChangeListeners(v.url, v.state);
    });
    return () => {
      const fnIndex = this._urlChangeListeners.indexOf(fn);
      this._urlChangeListeners.splice(fnIndex, 1);
      if (this._urlChangeListeners.length === 0) {
        this._urlChangeSubscription?.unsubscribe();
        this._urlChangeSubscription = null;
      }
    };
  }
  _notifyUrlChangeListeners(url = '', state) {
    this._urlChangeListeners.forEach(fn => fn(url, state));
  }
  subscribe(onNext, onThrow, onReturn) {
    return this._subject.subscribe({
      next: onNext,
      error: onThrow ?? undefined,
      complete: onReturn ?? undefined
    });
  }
  static normalizeQueryParams = normalizeQueryParams;
  static joinWithSlash = joinWithSlash;
  static stripTrailingSlash = stripTrailingSlash;
  static ɵfac = function Location_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || Location)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](LocationStrategy));
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: Location,
    factory: () => createLocation(),
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(Location, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,
    args: [{
      providedIn: 'root',
      useFactory: createLocation
    }]
  }], () => [{
    type: LocationStrategy
  }], null);
})();
function createLocation() {
  return new Location((0,_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(LocationStrategy));
}
function _stripBasePath(basePath, url) {
  if (!basePath || !url.startsWith(basePath)) {
    return url;
  }
  const strippedUrl = url.substring(basePath.length);
  if (strippedUrl === '' || ['/', ';', '?', '#'].includes(strippedUrl[0])) {
    return strippedUrl;
  }
  return url;
}
function _stripIndexHtml(url) {
  return url.replace(/\/index.html$/, '');
}
function _stripOrigin(baseHref) {
  const isAbsoluteUrl = new RegExp('^(https?:)?//').test(baseHref);
  if (isAbsoluteUrl) {
    const [, pathname] = baseHref.split(/\/\/[^\/]+/);
    return pathname;
  }
  return baseHref;
}


/***/ }),

/***/ 945:
/*!*************************************************************************!*\
  !*** ./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __addDisposableResource: () => (/* binding */ __addDisposableResource),
/* harmony export */   __assign: () => (/* binding */ __assign),
/* harmony export */   __asyncDelegator: () => (/* binding */ __asyncDelegator),
/* harmony export */   __asyncGenerator: () => (/* binding */ __asyncGenerator),
/* harmony export */   __asyncValues: () => (/* binding */ __asyncValues),
/* harmony export */   __await: () => (/* binding */ __await),
/* harmony export */   __awaiter: () => (/* binding */ __awaiter),
/* harmony export */   __classPrivateFieldGet: () => (/* binding */ __classPrivateFieldGet),
/* harmony export */   __classPrivateFieldIn: () => (/* binding */ __classPrivateFieldIn),
/* harmony export */   __classPrivateFieldSet: () => (/* binding */ __classPrivateFieldSet),
/* harmony export */   __createBinding: () => (/* binding */ __createBinding),
/* harmony export */   __decorate: () => (/* binding */ __decorate),
/* harmony export */   __disposeResources: () => (/* binding */ __disposeResources),
/* harmony export */   __esDecorate: () => (/* binding */ __esDecorate),
/* harmony export */   __exportStar: () => (/* binding */ __exportStar),
/* harmony export */   __extends: () => (/* binding */ __extends),
/* harmony export */   __generator: () => (/* binding */ __generator),
/* harmony export */   __importDefault: () => (/* binding */ __importDefault),
/* harmony export */   __importStar: () => (/* binding */ __importStar),
/* harmony export */   __makeTemplateObject: () => (/* binding */ __makeTemplateObject),
/* harmony export */   __metadata: () => (/* binding */ __metadata),
/* harmony export */   __param: () => (/* binding */ __param),
/* harmony export */   __propKey: () => (/* binding */ __propKey),
/* harmony export */   __read: () => (/* binding */ __read),
/* harmony export */   __rest: () => (/* binding */ __rest),
/* harmony export */   __rewriteRelativeImportExtension: () => (/* binding */ __rewriteRelativeImportExtension),
/* harmony export */   __runInitializers: () => (/* binding */ __runInitializers),
/* harmony export */   __setFunctionName: () => (/* binding */ __setFunctionName),
/* harmony export */   __spread: () => (/* binding */ __spread),
/* harmony export */   __spreadArray: () => (/* binding */ __spreadArray),
/* harmony export */   __spreadArrays: () => (/* binding */ __spreadArrays),
/* harmony export */   __values: () => (/* binding */ __values),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  }
  return __assign.apply(this, arguments);
}

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
          if (result === void 0) continue;
          if (result === null || typeof result !== "object") throw new TypeError("Object expected");
          if (_ = accept(result.get)) descriptor.get = _;
          if (_ = accept(result.set)) descriptor.set = _;
          if (_ = accept(result.init)) initializers.unshift(_);
      }
      else if (_ = accept(result)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
      }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};

function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};

function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
  return r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
  return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};

var ownKeys = function(o) {
  ownKeys = Object.getOwnPropertyNames || function (o) {
    var ar = [];
    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
    return ar;
  };
  return ownKeys(o);
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  __setModuleDefault(result, mod);
  return result;
}

function __importDefault(mod) {
  return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}

function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
    env.stack.push({ value: value, dispose: dispose, async: async });
  }
  else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}

var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
        }
        else s |= 1;
      }
      catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}

function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
      return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : (d + ext + "." + cm.toLowerCase() + "js");
      });
  }
  return path;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension,
});


/***/ }),

/***/ 1038:
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/Subscription.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EMPTY_SUBSCRIPTION: () => (/* binding */ EMPTY_SUBSCRIPTION),
/* harmony export */   Subscription: () => (/* binding */ Subscription),
/* harmony export */   isSubscription: () => (/* binding */ isSubscription)
/* harmony export */ });
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/isFunction */ 4010);
/* harmony import */ var _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/UnsubscriptionError */ 7244);
/* harmony import */ var _util_arrRemove__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/arrRemove */ 7223);



class Subscription {
  constructor(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  unsubscribe() {
    let errors;
    if (!this.closed) {
      this.closed = true;
      const {
        _parentage
      } = this;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          for (const parent of _parentage) {
            parent.remove(this);
          }
        } else {
          _parentage.remove(this);
        }
      }
      const {
        initialTeardown: initialFinalizer
      } = this;
      if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_1__.UnsubscriptionError ? e.errors : [e];
        }
      }
      const {
        _finalizers
      } = this;
      if (_finalizers) {
        this._finalizers = null;
        for (const finalizer of _finalizers) {
          try {
            execFinalizer(finalizer);
          } catch (err) {
            errors = errors !== null && errors !== void 0 ? errors : [];
            if (err instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_1__.UnsubscriptionError) {
              errors = [...errors, ...err.errors];
            } else {
              errors.push(err);
            }
          }
        }
      }
      if (errors) {
        throw new _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_1__.UnsubscriptionError(errors);
      }
    }
  }
  add(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  }
  _hasParent(parent) {
    const {
      _parentage
    } = this;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  }
  _addParent(parent) {
    const {
      _parentage
    } = this;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  }
  _removeParent(parent) {
    const {
      _parentage
    } = this;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      (0,_util_arrRemove__WEBPACK_IMPORTED_MODULE_2__.arrRemove)(_parentage, parent);
    }
  }
  remove(teardown) {
    const {
      _finalizers
    } = this;
    _finalizers && (0,_util_arrRemove__WEBPACK_IMPORTED_MODULE_2__.arrRemove)(_finalizers, teardown);
    if (teardown instanceof Subscription) {
      teardown._removeParent(this);
    }
  }
}
Subscription.EMPTY = (() => {
  const empty = new Subscription();
  empty.closed = true;
  return empty;
})();
const EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && 'closed' in value && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value.remove) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value.add) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

/***/ }),

/***/ 1055:
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/observable/combineLatest.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   combineLatest: () => (/* binding */ combineLatest),
/* harmony export */   combineLatestInit: () => (/* binding */ combineLatestInit)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ 1814);
/* harmony import */ var _util_argsArgArrayOrObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/argsArgArrayOrObject */ 4480);
/* harmony import */ var _from__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./from */ 7909);
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/identity */ 5232);
/* harmony import */ var _util_mapOneOrManyArgs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/mapOneOrManyArgs */ 3875);
/* harmony import */ var _util_args__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/args */ 1683);
/* harmony import */ var _util_createObject__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/createObject */ 4621);
/* harmony import */ var _operators_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../operators/OperatorSubscriber */ 3943);
/* harmony import */ var _util_executeSchedule__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/executeSchedule */ 3494);









function combineLatest(...args) {
  const scheduler = (0,_util_args__WEBPACK_IMPORTED_MODULE_5__.popScheduler)(args);
  const resultSelector = (0,_util_args__WEBPACK_IMPORTED_MODULE_5__.popResultSelector)(args);
  const {
    args: observables,
    keys
  } = (0,_util_argsArgArrayOrObject__WEBPACK_IMPORTED_MODULE_1__.argsArgArrayOrObject)(args);
  if (observables.length === 0) {
    return (0,_from__WEBPACK_IMPORTED_MODULE_2__.from)([], scheduler);
  }
  const result = new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(combineLatestInit(observables, scheduler, keys ? values => (0,_util_createObject__WEBPACK_IMPORTED_MODULE_6__.createObject)(keys, values) : _util_identity__WEBPACK_IMPORTED_MODULE_3__.identity));
  return resultSelector ? result.pipe((0,_util_mapOneOrManyArgs__WEBPACK_IMPORTED_MODULE_4__.mapOneOrManyArgs)(resultSelector)) : result;
}
function combineLatestInit(observables, scheduler, valueTransform = _util_identity__WEBPACK_IMPORTED_MODULE_3__.identity) {
  return subscriber => {
    maybeSchedule(scheduler, () => {
      const {
        length
      } = observables;
      const values = new Array(length);
      let active = length;
      let remainingFirstValues = length;
      for (let i = 0; i < length; i++) {
        maybeSchedule(scheduler, () => {
          const source = (0,_from__WEBPACK_IMPORTED_MODULE_2__.from)(observables[i], scheduler);
          let hasFirstValue = false;
          source.subscribe((0,_operators_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_7__.createOperatorSubscriber)(subscriber, value => {
            values[i] = value;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, () => {
            if (! --active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      }
    }, subscriber);
  };
}
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_8__.executeSchedule)(subscription, scheduler, execute);
  } else {
    execute();
  }
}

/***/ }),

/***/ 1088:
/*!***************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@angular+router@21.0.5_@angular+common@21.0.5_@angular+core@21.0.5_@angular+platform-browser@21.0.5_rxjs@7.8.2/node_modules/@angular/router/fesm2022/_router-chunk.mjs ***!
  \***************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ActivatedRoute: () => (/* binding */ ActivatedRoute),
/* harmony export */   ActivatedRouteSnapshot: () => (/* binding */ ActivatedRouteSnapshot),
/* harmony export */   ActivationEnd: () => (/* binding */ ActivationEnd),
/* harmony export */   ActivationStart: () => (/* binding */ ActivationStart),
/* harmony export */   BaseRouteReuseStrategy: () => (/* binding */ BaseRouteReuseStrategy),
/* harmony export */   CREATE_VIEW_TRANSITION: () => (/* binding */ CREATE_VIEW_TRANSITION),
/* harmony export */   ChildActivationEnd: () => (/* binding */ ChildActivationEnd),
/* harmony export */   ChildActivationStart: () => (/* binding */ ChildActivationStart),
/* harmony export */   ChildrenOutletContexts: () => (/* binding */ ChildrenOutletContexts),
/* harmony export */   DefaultTitleStrategy: () => (/* binding */ DefaultTitleStrategy),
/* harmony export */   DefaultUrlSerializer: () => (/* binding */ DefaultUrlSerializer),
/* harmony export */   EventType: () => (/* binding */ EventType),
/* harmony export */   GuardsCheckEnd: () => (/* binding */ GuardsCheckEnd),
/* harmony export */   GuardsCheckStart: () => (/* binding */ GuardsCheckStart),
/* harmony export */   HistoryStateManager: () => (/* binding */ HistoryStateManager),
/* harmony export */   IMPERATIVE_NAVIGATION: () => (/* binding */ IMPERATIVE_NAVIGATION),
/* harmony export */   INPUT_BINDER: () => (/* binding */ INPUT_BINDER),
/* harmony export */   NAVIGATION_ERROR_HANDLER: () => (/* binding */ NAVIGATION_ERROR_HANDLER),
/* harmony export */   NavigationCancel: () => (/* binding */ NavigationCancel),
/* harmony export */   NavigationCancellationCode: () => (/* binding */ NavigationCancellationCode),
/* harmony export */   NavigationEnd: () => (/* binding */ NavigationEnd),
/* harmony export */   NavigationError: () => (/* binding */ NavigationError),
/* harmony export */   NavigationSkipped: () => (/* binding */ NavigationSkipped),
/* harmony export */   NavigationSkippedCode: () => (/* binding */ NavigationSkippedCode),
/* harmony export */   NavigationStart: () => (/* binding */ NavigationStart),
/* harmony export */   NavigationTransitions: () => (/* binding */ NavigationTransitions),
/* harmony export */   OutletContext: () => (/* binding */ OutletContext),
/* harmony export */   PRIMARY_OUTLET: () => (/* binding */ PRIMARY_OUTLET),
/* harmony export */   ROUTER_CONFIGURATION: () => (/* binding */ ROUTER_CONFIGURATION),
/* harmony export */   ROUTER_OUTLET_DATA: () => (/* binding */ ROUTER_OUTLET_DATA),
/* harmony export */   ROUTES: () => (/* binding */ ROUTES),
/* harmony export */   RedirectCommand: () => (/* binding */ RedirectCommand),
/* harmony export */   ResolveEnd: () => (/* binding */ ResolveEnd),
/* harmony export */   ResolveStart: () => (/* binding */ ResolveStart),
/* harmony export */   RouteConfigLoadEnd: () => (/* binding */ RouteConfigLoadEnd),
/* harmony export */   RouteConfigLoadStart: () => (/* binding */ RouteConfigLoadStart),
/* harmony export */   RouteReuseStrategy: () => (/* binding */ RouteReuseStrategy),
/* harmony export */   RoutedComponentInputBinder: () => (/* binding */ RoutedComponentInputBinder),
/* harmony export */   Router: () => (/* binding */ Router),
/* harmony export */   RouterConfigLoader: () => (/* binding */ RouterConfigLoader),
/* harmony export */   RouterEvent: () => (/* binding */ RouterEvent),
/* harmony export */   RouterOutlet: () => (/* binding */ RouterOutlet),
/* harmony export */   RouterState: () => (/* binding */ RouterState),
/* harmony export */   RouterStateSnapshot: () => (/* binding */ RouterStateSnapshot),
/* harmony export */   RoutesRecognized: () => (/* binding */ RoutesRecognized),
/* harmony export */   Scroll: () => (/* binding */ Scroll),
/* harmony export */   StateManager: () => (/* binding */ StateManager),
/* harmony export */   TitleStrategy: () => (/* binding */ TitleStrategy),
/* harmony export */   UrlHandlingStrategy: () => (/* binding */ UrlHandlingStrategy),
/* harmony export */   UrlSegment: () => (/* binding */ UrlSegment),
/* harmony export */   UrlSegmentGroup: () => (/* binding */ UrlSegmentGroup),
/* harmony export */   UrlSerializer: () => (/* binding */ UrlSerializer),
/* harmony export */   UrlTree: () => (/* binding */ UrlTree),
/* harmony export */   VIEW_TRANSITION_OPTIONS: () => (/* binding */ VIEW_TRANSITION_OPTIONS),
/* harmony export */   afterNextNavigation: () => (/* binding */ afterNextNavigation),
/* harmony export */   convertToParamMap: () => (/* binding */ convertToParamMap),
/* harmony export */   createUrlTreeFromSnapshot: () => (/* binding */ createUrlTreeFromSnapshot),
/* harmony export */   createViewTransition: () => (/* binding */ createViewTransition),
/* harmony export */   defaultUrlMatcher: () => (/* binding */ defaultUrlMatcher),
/* harmony export */   isUrlTree: () => (/* binding */ isUrlTree),
/* harmony export */   loadChildren: () => (/* binding */ loadChildren),
/* harmony export */   provideSometimesSyncRecognize: () => (/* binding */ provideSometimesSyncRecognize),
/* harmony export */   stringifyEvent: () => (/* binding */ stringifyEvent),
/* harmony export */   "ɵEmptyOutletComponent": () => (/* binding */ ɵEmptyOutletComponent)
/* harmony export */ });
/* harmony import */ var C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 3194);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ 64);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ 933);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/core */ 7367);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/core */ 8357);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs */ 1814);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ 1171);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs */ 8277);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs */ 1038);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! rxjs */ 3282);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! rxjs */ 6711);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! rxjs */ 5815);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! rxjs */ 1055);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! rxjs */ 2473);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! rxjs */ 2761);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! rxjs */ 7909);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! rxjs */ 9596);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! rxjs */ 3727);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! rxjs */ 5672);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! rxjs/operators */ 4502);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! rxjs/operators */ 4927);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! rxjs/operators */ 1834);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! rxjs/operators */ 4191);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! rxjs/operators */ 4563);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! rxjs/operators */ 1267);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! rxjs/operators */ 4765);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! rxjs/operators */ 4063);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! rxjs/operators */ 1991);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! rxjs/operators */ 4720);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! rxjs/operators */ 6061);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! rxjs/operators */ 9671);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! rxjs/operators */ 6942);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! rxjs/operators */ 9338);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! rxjs/operators */ 6924);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! rxjs/operators */ 2556);
/* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! @angular/platform-browser */ 7376);

/**
 * @license Angular v21.0.5
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */







const PRIMARY_OUTLET = 'primary';
const RouteTitleKey = /* @__PURE__ */Symbol('RouteTitle');
class ParamsAsMap {
  params;
  constructor(params) {
    this.params = params || {};
  }
  has(name) {
    return Object.prototype.hasOwnProperty.call(this.params, name);
  }
  get(name) {
    if (this.has(name)) {
      const v = this.params[name];
      return Array.isArray(v) ? v[0] : v;
    }
    return null;
  }
  getAll(name) {
    if (this.has(name)) {
      const v = this.params[name];
      return Array.isArray(v) ? v : [v];
    }
    return [];
  }
  get keys() {
    return Object.keys(this.params);
  }
}
function convertToParamMap(params) {
  return new ParamsAsMap(params);
}
function defaultUrlMatcher(segments, segmentGroup, route) {
  const parts = route.path.split('/');
  if (parts.length > segments.length) {
    return null;
  }
  if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || parts.length < segments.length)) {
    return null;
  }
  const posParams = {};
  for (let index = 0; index < parts.length; index++) {
    const part = parts[index];
    const segment = segments[index];
    const isParameter = part[0] === ':';
    if (isParameter) {
      posParams[part.substring(1)] = segment;
    } else if (part !== segment.path) {
      return null;
    }
  }
  return {
    consumed: segments.slice(0, parts.length),
    posParams
  };
}
function firstValueFrom(source) {
  return new Promise((resolve, reject) => {
    source.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_24__.first)()).subscribe({
      next: value => resolve(value),
      error: err => reject(err)
    });
  });
}
function shallowEqualArrays(a, b) {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; ++i) {
    if (!shallowEqual(a[i], b[i])) return false;
  }
  return true;
}
function shallowEqual(a, b) {
  const k1 = a ? getDataKeys(a) : undefined;
  const k2 = b ? getDataKeys(b) : undefined;
  if (!k1 || !k2 || k1.length != k2.length) {
    return false;
  }
  let key;
  for (let i = 0; i < k1.length; i++) {
    key = k1[i];
    if (!equalArraysOrString(a[key], b[key])) {
      return false;
    }
  }
  return true;
}
function getDataKeys(obj) {
  return [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)];
}
function equalArraysOrString(a, b) {
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    const aSorted = [...a].sort();
    const bSorted = [...b].sort();
    return aSorted.every((val, index) => bSorted[index] === val);
  } else {
    return a === b;
  }
}
function last(a) {
  return a.length > 0 ? a[a.length - 1] : null;
}
function wrapIntoObservable(value) {
  if ((0,rxjs__WEBPACK_IMPORTED_MODULE_10__.isObservable)(value)) {
    return value;
  }
  if ((0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.isPromise)(value)) {
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_15__.from)(Promise.resolve(value));
  }
  return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(value);
}
function wrapIntoPromise(value) {
  if ((0,rxjs__WEBPACK_IMPORTED_MODULE_10__.isObservable)(value)) {
    return firstValueFrom(value);
  }
  return Promise.resolve(value);
}
const pathCompareMap = {
  'exact': equalSegmentGroups,
  'subset': containsSegmentGroup
};
const paramCompareMap = {
  'exact': equalParams,
  'subset': containsParams,
  'ignored': () => true
};
function containsTree(container, containee, options) {
  return pathCompareMap[options.paths](container.root, containee.root, options.matrixParams) && paramCompareMap[options.queryParams](container.queryParams, containee.queryParams) && !(options.fragment === 'exact' && container.fragment !== containee.fragment);
}
function equalParams(container, containee) {
  return shallowEqual(container, containee);
}
function equalSegmentGroups(container, containee, matrixParams) {
  if (!equalPath(container.segments, containee.segments)) return false;
  if (!matrixParamsMatch(container.segments, containee.segments, matrixParams)) {
    return false;
  }
  if (container.numberOfChildren !== containee.numberOfChildren) return false;
  for (const c in containee.children) {
    if (!container.children[c]) return false;
    if (!equalSegmentGroups(container.children[c], containee.children[c], matrixParams)) return false;
  }
  return true;
}
function containsParams(container, containee) {
  return Object.keys(containee).length <= Object.keys(container).length && Object.keys(containee).every(key => equalArraysOrString(container[key], containee[key]));
}
function containsSegmentGroup(container, containee, matrixParams) {
  return containsSegmentGroupHelper(container, containee, containee.segments, matrixParams);
}
function containsSegmentGroupHelper(container, containee, containeePaths, matrixParams) {
  if (container.segments.length > containeePaths.length) {
    const current = container.segments.slice(0, containeePaths.length);
    if (!equalPath(current, containeePaths)) return false;
    if (containee.hasChildren()) return false;
    if (!matrixParamsMatch(current, containeePaths, matrixParams)) return false;
    return true;
  } else if (container.segments.length === containeePaths.length) {
    if (!equalPath(container.segments, containeePaths)) return false;
    if (!matrixParamsMatch(container.segments, containeePaths, matrixParams)) return false;
    for (const c in containee.children) {
      if (!container.children[c]) return false;
      if (!containsSegmentGroup(container.children[c], containee.children[c], matrixParams)) {
        return false;
      }
    }
    return true;
  } else {
    const current = containeePaths.slice(0, container.segments.length);
    const next = containeePaths.slice(container.segments.length);
    if (!equalPath(container.segments, current)) return false;
    if (!matrixParamsMatch(container.segments, current, matrixParams)) return false;
    if (!container.children[PRIMARY_OUTLET]) return false;
    return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next, matrixParams);
  }
}
function matrixParamsMatch(containerPaths, containeePaths, options) {
  return containeePaths.every((containeeSegment, i) => {
    return paramCompareMap[options](containerPaths[i].parameters, containeeSegment.parameters);
  });
}
class UrlTree {
  root;
  queryParams;
  fragment;
  _queryParamMap;
  constructor(root = new UrlSegmentGroup([], {}), queryParams = {}, fragment = null) {
    this.root = root;
    this.queryParams = queryParams;
    this.fragment = fragment;
    if (typeof ngDevMode === 'undefined' || ngDevMode) {
      if (root.segments.length > 0) {
        throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4015, 'The root `UrlSegmentGroup` should not contain `segments`. ' + 'Instead, these segments belong in the `children` so they can be associated with a named outlet.');
      }
    }
  }
  get queryParamMap() {
    this._queryParamMap ??= convertToParamMap(this.queryParams);
    return this._queryParamMap;
  }
  toString() {
    return DEFAULT_SERIALIZER.serialize(this);
  }
}
class UrlSegmentGroup {
  segments;
  children;
  parent = null;
  constructor(segments, children) {
    this.segments = segments;
    this.children = children;
    Object.values(children).forEach(v => v.parent = this);
  }
  hasChildren() {
    return this.numberOfChildren > 0;
  }
  get numberOfChildren() {
    return Object.keys(this.children).length;
  }
  toString() {
    return serializePaths(this);
  }
}
class UrlSegment {
  path;
  parameters;
  _parameterMap;
  constructor(path, parameters) {
    this.path = path;
    this.parameters = parameters;
  }
  get parameterMap() {
    this._parameterMap ??= convertToParamMap(this.parameters);
    return this._parameterMap;
  }
  toString() {
    return serializePath(this);
  }
}
function equalSegments(as, bs) {
  return equalPath(as, bs) && as.every((a, i) => shallowEqual(a.parameters, bs[i].parameters));
}
function equalPath(as, bs) {
  if (as.length !== bs.length) return false;
  return as.every((a, i) => a.path === bs[i].path);
}
function mapChildrenIntoArray(segment, fn) {
  let res = [];
  Object.entries(segment.children).forEach(([childOutlet, child]) => {
    if (childOutlet === PRIMARY_OUTLET) {
      res = res.concat(fn(child, childOutlet));
    }
  });
  Object.entries(segment.children).forEach(([childOutlet, child]) => {
    if (childOutlet !== PRIMARY_OUTLET) {
      res = res.concat(fn(child, childOutlet));
    }
  });
  return res;
}
class UrlSerializer {
  static ɵfac = function UrlSerializer_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || UrlSerializer)();
  };
  static ɵprov = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: UrlSerializer,
    factory: () => (() => new DefaultUrlSerializer())(),
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(UrlSerializer, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
    args: [{
      providedIn: 'root',
      useFactory: () => new DefaultUrlSerializer()
    }]
  }], null, null);
})();
class DefaultUrlSerializer {
  parse(url) {
    const p = new UrlParser(url);
    return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());
  }
  serialize(tree) {
    const segment = `/${serializeSegment(tree.root, true)}`;
    const query = serializeQueryParams(tree.queryParams);
    const fragment = typeof tree.fragment === `string` ? `#${encodeUriFragment(tree.fragment)}` : '';
    return `${segment}${query}${fragment}`;
  }
}
const DEFAULT_SERIALIZER = new DefaultUrlSerializer();
function serializePaths(segment) {
  return segment.segments.map(p => serializePath(p)).join('/');
}
function serializeSegment(segment, root) {
  if (!segment.hasChildren()) {
    return serializePaths(segment);
  }
  if (root) {
    const primary = segment.children[PRIMARY_OUTLET] ? serializeSegment(segment.children[PRIMARY_OUTLET], false) : '';
    const children = [];
    Object.entries(segment.children).forEach(([k, v]) => {
      if (k !== PRIMARY_OUTLET) {
        children.push(`${k}:${serializeSegment(v, false)}`);
      }
    });
    return children.length > 0 ? `${primary}(${children.join('//')})` : primary;
  } else {
    const children = mapChildrenIntoArray(segment, (v, k) => {
      if (k === PRIMARY_OUTLET) {
        return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];
      }
      return [`${k}:${serializeSegment(v, false)}`];
    });
    if (Object.keys(segment.children).length === 1 && segment.children[PRIMARY_OUTLET] != null) {
      return `${serializePaths(segment)}/${children[0]}`;
    }
    return `${serializePaths(segment)}/(${children.join('//')})`;
  }
}
function encodeUriString(s) {
  return encodeURIComponent(s).replace(/%40/g, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',');
}
function encodeUriQuery(s) {
  return encodeUriString(s).replace(/%3B/gi, ';');
}
function encodeUriFragment(s) {
  return encodeURI(s);
}
function encodeUriSegment(s) {
  return encodeUriString(s).replace(/\(/g, '%28').replace(/\)/g, '%29').replace(/%26/gi, '&');
}
function decode(s) {
  return decodeURIComponent(s);
}
function decodeQuery(s) {
  return decode(s.replace(/\+/g, '%20'));
}
function serializePath(path) {
  return `${encodeUriSegment(path.path)}${serializeMatrixParams(path.parameters)}`;
}
function serializeMatrixParams(params) {
  return Object.entries(params).map(([key, value]) => `;${encodeUriSegment(key)}=${encodeUriSegment(value)}`).join('');
}
function serializeQueryParams(params) {
  const strParams = Object.entries(params).map(([name, value]) => {
    return Array.isArray(value) ? value.map(v => `${encodeUriQuery(name)}=${encodeUriQuery(v)}`).join('&') : `${encodeUriQuery(name)}=${encodeUriQuery(value)}`;
  }).filter(s => s);
  return strParams.length ? `?${strParams.join('&')}` : '';
}
const SEGMENT_RE = /^[^\/()?;#]+/;
function matchSegments(str) {
  const match = str.match(SEGMENT_RE);
  return match ? match[0] : '';
}
const MATRIX_PARAM_SEGMENT_RE = /^[^\/()?;=#]+/;
function matchMatrixKeySegments(str) {
  const match = str.match(MATRIX_PARAM_SEGMENT_RE);
  return match ? match[0] : '';
}
const QUERY_PARAM_RE = /^[^=?&#]+/;
function matchQueryParams(str) {
  const match = str.match(QUERY_PARAM_RE);
  return match ? match[0] : '';
}
const QUERY_PARAM_VALUE_RE = /^[^&#]+/;
function matchUrlQueryParamValue(str) {
  const match = str.match(QUERY_PARAM_VALUE_RE);
  return match ? match[0] : '';
}
class UrlParser {
  url;
  remaining;
  constructor(url) {
    this.url = url;
    this.remaining = url;
  }
  parseRootSegment() {
    this.consumeOptional('/');
    if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {
      return new UrlSegmentGroup([], {});
    }
    return new UrlSegmentGroup([], this.parseChildren());
  }
  parseQueryParams() {
    const params = {};
    if (this.consumeOptional('?')) {
      do {
        this.parseQueryParam(params);
      } while (this.consumeOptional('&'));
    }
    return params;
  }
  parseFragment() {
    return this.consumeOptional('#') ? decodeURIComponent(this.remaining) : null;
  }
  parseChildren() {
    if (this.remaining === '') {
      return {};
    }
    this.consumeOptional('/');
    const segments = [];
    if (!this.peekStartsWith('(')) {
      segments.push(this.parseSegment());
    }
    while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {
      this.capture('/');
      segments.push(this.parseSegment());
    }
    let children = {};
    if (this.peekStartsWith('/(')) {
      this.capture('/');
      children = this.parseParens(true);
    }
    let res = {};
    if (this.peekStartsWith('(')) {
      res = this.parseParens(false);
    }
    if (segments.length > 0 || Object.keys(children).length > 0) {
      res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);
    }
    return res;
  }
  parseSegment() {
    const path = matchSegments(this.remaining);
    if (path === '' && this.peekStartsWith(';')) {
      throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4009, (typeof ngDevMode === 'undefined' || ngDevMode) && `Empty path url segment cannot have parameters: '${this.remaining}'.`);
    }
    this.capture(path);
    return new UrlSegment(decode(path), this.parseMatrixParams());
  }
  parseMatrixParams() {
    const params = {};
    while (this.consumeOptional(';')) {
      this.parseParam(params);
    }
    return params;
  }
  parseParam(params) {
    const key = matchMatrixKeySegments(this.remaining);
    if (!key) {
      return;
    }
    this.capture(key);
    let value = '';
    if (this.consumeOptional('=')) {
      const valueMatch = matchSegments(this.remaining);
      if (valueMatch) {
        value = valueMatch;
        this.capture(value);
      }
    }
    params[decode(key)] = decode(value);
  }
  parseQueryParam(params) {
    const key = matchQueryParams(this.remaining);
    if (!key) {
      return;
    }
    this.capture(key);
    let value = '';
    if (this.consumeOptional('=')) {
      const valueMatch = matchUrlQueryParamValue(this.remaining);
      if (valueMatch) {
        value = valueMatch;
        this.capture(value);
      }
    }
    const decodedKey = decodeQuery(key);
    const decodedVal = decodeQuery(value);
    if (params.hasOwnProperty(decodedKey)) {
      let currentVal = params[decodedKey];
      if (!Array.isArray(currentVal)) {
        currentVal = [currentVal];
        params[decodedKey] = currentVal;
      }
      currentVal.push(decodedVal);
    } else {
      params[decodedKey] = decodedVal;
    }
  }
  parseParens(allowPrimary) {
    const segments = {};
    this.capture('(');
    while (!this.consumeOptional(')') && this.remaining.length > 0) {
      const path = matchSegments(this.remaining);
      const next = this.remaining[path.length];
      if (next !== '/' && next !== ')' && next !== ';') {
        throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4010, (typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot parse url '${this.url}'`);
      }
      let outletName;
      if (path.indexOf(':') > -1) {
        outletName = path.slice(0, path.indexOf(':'));
        this.capture(outletName);
        this.capture(':');
      } else if (allowPrimary) {
        outletName = PRIMARY_OUTLET;
      }
      const children = this.parseChildren();
      segments[outletName ?? PRIMARY_OUTLET] = Object.keys(children).length === 1 && children[PRIMARY_OUTLET] ? children[PRIMARY_OUTLET] : new UrlSegmentGroup([], children);
      this.consumeOptional('//');
    }
    return segments;
  }
  peekStartsWith(str) {
    return this.remaining.startsWith(str);
  }
  consumeOptional(str) {
    if (this.peekStartsWith(str)) {
      this.remaining = this.remaining.substring(str.length);
      return true;
    }
    return false;
  }
  capture(str) {
    if (!this.consumeOptional(str)) {
      throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4011, (typeof ngDevMode === 'undefined' || ngDevMode) && `Expected "${str}".`);
    }
  }
}
function createRoot(rootCandidate) {
  return rootCandidate.segments.length > 0 ? new UrlSegmentGroup([], {
    [PRIMARY_OUTLET]: rootCandidate
  }) : rootCandidate;
}
function squashSegmentGroup(segmentGroup) {
  const newChildren = {};
  for (const [childOutlet, child] of Object.entries(segmentGroup.children)) {
    const childCandidate = squashSegmentGroup(child);
    if (childOutlet === PRIMARY_OUTLET && childCandidate.segments.length === 0 && childCandidate.hasChildren()) {
      for (const [grandChildOutlet, grandChild] of Object.entries(childCandidate.children)) {
        newChildren[grandChildOutlet] = grandChild;
      }
    } else if (childCandidate.segments.length > 0 || childCandidate.hasChildren()) {
      newChildren[childOutlet] = childCandidate;
    }
  }
  const s = new UrlSegmentGroup(segmentGroup.segments, newChildren);
  return mergeTrivialChildren(s);
}
function mergeTrivialChildren(s) {
  if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {
    const c = s.children[PRIMARY_OUTLET];
    return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);
  }
  return s;
}
function isUrlTree(v) {
  return v instanceof UrlTree;
}
function createUrlTreeFromSnapshot(relativeTo, commands, queryParams = null, fragment = null, urlSerializer = new DefaultUrlSerializer()) {
  const relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeTo);
  return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, queryParams, fragment, urlSerializer);
}
function createSegmentGroupFromRoute(route) {
  let targetGroup;
  function createSegmentGroupFromRouteRecursive(currentRoute) {
    const childOutlets = {};
    for (const childSnapshot of currentRoute.children) {
      const root = createSegmentGroupFromRouteRecursive(childSnapshot);
      childOutlets[childSnapshot.outlet] = root;
    }
    const segmentGroup = new UrlSegmentGroup(currentRoute.url, childOutlets);
    if (currentRoute === route) {
      targetGroup = segmentGroup;
    }
    return segmentGroup;
  }
  const rootCandidate = createSegmentGroupFromRouteRecursive(route.root);
  const rootSegmentGroup = createRoot(rootCandidate);
  return targetGroup ?? rootSegmentGroup;
}
function createUrlTreeFromSegmentGroup(relativeTo, commands, queryParams, fragment, urlSerializer) {
  let root = relativeTo;
  while (root.parent) {
    root = root.parent;
  }
  if (commands.length === 0) {
    return tree(root, root, root, queryParams, fragment, urlSerializer);
  }
  const nav = computeNavigation(commands);
  if (nav.toRoot()) {
    return tree(root, root, new UrlSegmentGroup([], {}), queryParams, fragment, urlSerializer);
  }
  const position = findStartingPositionForTargetGroup(nav, root, relativeTo);
  const newSegmentGroup = position.processChildren ? updateSegmentGroupChildren(position.segmentGroup, position.index, nav.commands) : updateSegmentGroup(position.segmentGroup, position.index, nav.commands);
  return tree(root, position.segmentGroup, newSegmentGroup, queryParams, fragment, urlSerializer);
}
function isMatrixParams(command) {
  return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;
}
function isCommandWithOutlets(command) {
  return typeof command === 'object' && command != null && command.outlets;
}
function normalizeQueryParams(k, v, urlSerializer) {
  k ||= 'ɵ';
  const tree = new UrlTree();
  tree.queryParams = {
    [k]: v
  };
  return urlSerializer.parse(urlSerializer.serialize(tree)).queryParams[k];
}
function tree(oldRoot, oldSegmentGroup, newSegmentGroup, queryParams, fragment, urlSerializer) {
  const qp = {};
  for (const [key, value] of Object.entries(queryParams ?? {})) {
    qp[key] = Array.isArray(value) ? value.map(v => normalizeQueryParams(key, v, urlSerializer)) : normalizeQueryParams(key, value, urlSerializer);
  }
  let rootCandidate;
  if (oldRoot === oldSegmentGroup) {
    rootCandidate = newSegmentGroup;
  } else {
    rootCandidate = replaceSegment(oldRoot, oldSegmentGroup, newSegmentGroup);
  }
  const newRoot = createRoot(squashSegmentGroup(rootCandidate));
  return new UrlTree(newRoot, qp, fragment);
}
function replaceSegment(current, oldSegment, newSegment) {
  const children = {};
  Object.entries(current.children).forEach(([outletName, c]) => {
    if (c === oldSegment) {
      children[outletName] = newSegment;
    } else {
      children[outletName] = replaceSegment(c, oldSegment, newSegment);
    }
  });
  return new UrlSegmentGroup(current.segments, children);
}
class Navigation {
  isAbsolute;
  numberOfDoubleDots;
  commands;
  constructor(isAbsolute, numberOfDoubleDots, commands) {
    this.isAbsolute = isAbsolute;
    this.numberOfDoubleDots = numberOfDoubleDots;
    this.commands = commands;
    if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {
      throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4003, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Root segment cannot have matrix parameters');
    }
    const cmdWithOutlet = commands.find(isCommandWithOutlets);
    if (cmdWithOutlet && cmdWithOutlet !== last(commands)) {
      throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4004, (typeof ngDevMode === 'undefined' || ngDevMode) && '{outlets:{}} has to be the last command');
    }
  }
  toRoot() {
    return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';
  }
}
function computeNavigation(commands) {
  if (typeof commands[0] === 'string' && commands.length === 1 && commands[0] === '/') {
    return new Navigation(true, 0, commands);
  }
  let numberOfDoubleDots = 0;
  let isAbsolute = false;
  const res = commands.reduce((res, cmd, cmdIdx) => {
    if (typeof cmd === 'object' && cmd != null) {
      if (cmd.outlets) {
        const outlets = {};
        Object.entries(cmd.outlets).forEach(([name, commands]) => {
          outlets[name] = typeof commands === 'string' ? commands.split('/') : commands;
        });
        return [...res, {
          outlets
        }];
      }
      if (cmd.segmentPath) {
        return [...res, cmd.segmentPath];
      }
    }
    if (!(typeof cmd === 'string')) {
      return [...res, cmd];
    }
    if (cmdIdx === 0) {
      cmd.split('/').forEach((urlPart, partIndex) => {
        if (partIndex == 0 && urlPart === '.') ;else if (partIndex == 0 && urlPart === '') {
          isAbsolute = true;
        } else if (urlPart === '..') {
          numberOfDoubleDots++;
        } else if (urlPart != '') {
          res.push(urlPart);
        }
      });
      return res;
    }
    return [...res, cmd];
  }, []);
  return new Navigation(isAbsolute, numberOfDoubleDots, res);
}
class Position {
  segmentGroup;
  processChildren;
  index;
  constructor(segmentGroup, processChildren, index) {
    this.segmentGroup = segmentGroup;
    this.processChildren = processChildren;
    this.index = index;
  }
}
function findStartingPositionForTargetGroup(nav, root, target) {
  if (nav.isAbsolute) {
    return new Position(root, true, 0);
  }
  if (!target) {
    return new Position(root, false, NaN);
  }
  if (target.parent === null) {
    return new Position(target, true, 0);
  }
  const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;
  const index = target.segments.length - 1 + modifier;
  return createPositionApplyingDoubleDots(target, index, nav.numberOfDoubleDots);
}
function createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {
  let g = group;
  let ci = index;
  let dd = numberOfDoubleDots;
  while (dd > ci) {
    dd -= ci;
    g = g.parent;
    if (!g) {
      throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4005, (typeof ngDevMode === 'undefined' || ngDevMode) && "Invalid number of '../'");
    }
    ci = g.segments.length;
  }
  return new Position(g, false, ci - dd);
}
function getOutlets(commands) {
  if (isCommandWithOutlets(commands[0])) {
    return commands[0].outlets;
  }
  return {
    [PRIMARY_OUTLET]: commands
  };
}
function updateSegmentGroup(segmentGroup, startIndex, commands) {
  segmentGroup ??= new UrlSegmentGroup([], {});
  if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
    return updateSegmentGroupChildren(segmentGroup, startIndex, commands);
  }
  const m = prefixedWith(segmentGroup, startIndex, commands);
  const slicedCommands = commands.slice(m.commandIndex);
  if (m.match && m.pathIndex < segmentGroup.segments.length) {
    const g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});
    g.children[PRIMARY_OUTLET] = new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);
    return updateSegmentGroupChildren(g, 0, slicedCommands);
  } else if (m.match && slicedCommands.length === 0) {
    return new UrlSegmentGroup(segmentGroup.segments, {});
  } else if (m.match && !segmentGroup.hasChildren()) {
    return createNewSegmentGroup(segmentGroup, startIndex, commands);
  } else if (m.match) {
    return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);
  } else {
    return createNewSegmentGroup(segmentGroup, startIndex, commands);
  }
}
function updateSegmentGroupChildren(segmentGroup, startIndex, commands) {
  if (commands.length === 0) {
    return new UrlSegmentGroup(segmentGroup.segments, {});
  } else {
    const outlets = getOutlets(commands);
    const children = {};
    if (Object.keys(outlets).some(o => o !== PRIMARY_OUTLET) && segmentGroup.children[PRIMARY_OUTLET] && segmentGroup.numberOfChildren === 1 && segmentGroup.children[PRIMARY_OUTLET].segments.length === 0) {
      const childrenOfEmptyChild = updateSegmentGroupChildren(segmentGroup.children[PRIMARY_OUTLET], startIndex, commands);
      return new UrlSegmentGroup(segmentGroup.segments, childrenOfEmptyChild.children);
    }
    Object.entries(outlets).forEach(([outlet, commands]) => {
      if (typeof commands === 'string') {
        commands = [commands];
      }
      if (commands !== null) {
        children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);
      }
    });
    Object.entries(segmentGroup.children).forEach(([childOutlet, child]) => {
      if (outlets[childOutlet] === undefined) {
        children[childOutlet] = child;
      }
    });
    return new UrlSegmentGroup(segmentGroup.segments, children);
  }
}
function prefixedWith(segmentGroup, startIndex, commands) {
  let currentCommandIndex = 0;
  let currentPathIndex = startIndex;
  const noMatch = {
    match: false,
    pathIndex: 0,
    commandIndex: 0
  };
  while (currentPathIndex < segmentGroup.segments.length) {
    if (currentCommandIndex >= commands.length) return noMatch;
    const path = segmentGroup.segments[currentPathIndex];
    const command = commands[currentCommandIndex];
    if (isCommandWithOutlets(command)) {
      break;
    }
    const curr = `${command}`;
    const next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;
    if (currentPathIndex > 0 && curr === undefined) break;
    if (curr && next && typeof next === 'object' && next.outlets === undefined) {
      if (!compare(curr, next, path)) return noMatch;
      currentCommandIndex += 2;
    } else {
      if (!compare(curr, {}, path)) return noMatch;
      currentCommandIndex++;
    }
    currentPathIndex++;
  }
  return {
    match: true,
    pathIndex: currentPathIndex,
    commandIndex: currentCommandIndex
  };
}
function createNewSegmentGroup(segmentGroup, startIndex, commands) {
  const paths = segmentGroup.segments.slice(0, startIndex);
  let i = 0;
  while (i < commands.length) {
    const command = commands[i];
    if (isCommandWithOutlets(command)) {
      const children = createNewSegmentChildren(command.outlets);
      return new UrlSegmentGroup(paths, children);
    }
    if (i === 0 && isMatrixParams(commands[0])) {
      const p = segmentGroup.segments[startIndex];
      paths.push(new UrlSegment(p.path, stringify(commands[0])));
      i++;
      continue;
    }
    const curr = isCommandWithOutlets(command) ? command.outlets[PRIMARY_OUTLET] : `${command}`;
    const next = i < commands.length - 1 ? commands[i + 1] : null;
    if (curr && next && isMatrixParams(next)) {
      paths.push(new UrlSegment(curr, stringify(next)));
      i += 2;
    } else {
      paths.push(new UrlSegment(curr, {}));
      i++;
    }
  }
  return new UrlSegmentGroup(paths, {});
}
function createNewSegmentChildren(outlets) {
  const children = {};
  Object.entries(outlets).forEach(([outlet, commands]) => {
    if (typeof commands === 'string') {
      commands = [commands];
    }
    if (commands !== null) {
      children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);
    }
  });
  return children;
}
function stringify(params) {
  const res = {};
  Object.entries(params).forEach(([k, v]) => res[k] = `${v}`);
  return res;
}
function compare(path, params, segment) {
  return path == segment.path && shallowEqual(params, segment.parameters);
}
const IMPERATIVE_NAVIGATION = 'imperative';
var EventType;
(function (EventType) {
  EventType[EventType["NavigationStart"] = 0] = "NavigationStart";
  EventType[EventType["NavigationEnd"] = 1] = "NavigationEnd";
  EventType[EventType["NavigationCancel"] = 2] = "NavigationCancel";
  EventType[EventType["NavigationError"] = 3] = "NavigationError";
  EventType[EventType["RoutesRecognized"] = 4] = "RoutesRecognized";
  EventType[EventType["ResolveStart"] = 5] = "ResolveStart";
  EventType[EventType["ResolveEnd"] = 6] = "ResolveEnd";
  EventType[EventType["GuardsCheckStart"] = 7] = "GuardsCheckStart";
  EventType[EventType["GuardsCheckEnd"] = 8] = "GuardsCheckEnd";
  EventType[EventType["RouteConfigLoadStart"] = 9] = "RouteConfigLoadStart";
  EventType[EventType["RouteConfigLoadEnd"] = 10] = "RouteConfigLoadEnd";
  EventType[EventType["ChildActivationStart"] = 11] = "ChildActivationStart";
  EventType[EventType["ChildActivationEnd"] = 12] = "ChildActivationEnd";
  EventType[EventType["ActivationStart"] = 13] = "ActivationStart";
  EventType[EventType["ActivationEnd"] = 14] = "ActivationEnd";
  EventType[EventType["Scroll"] = 15] = "Scroll";
  EventType[EventType["NavigationSkipped"] = 16] = "NavigationSkipped";
})(EventType || (EventType = {}));
class RouterEvent {
  id;
  url;
  constructor(id, url) {
    this.id = id;
    this.url = url;
  }
}
class NavigationStart extends RouterEvent {
  type = EventType.NavigationStart;
  navigationTrigger;
  restoredState;
  constructor(id, url, navigationTrigger = 'imperative', restoredState = null) {
    super(id, url);
    this.navigationTrigger = navigationTrigger;
    this.restoredState = restoredState;
  }
  toString() {
    return `NavigationStart(id: ${this.id}, url: '${this.url}')`;
  }
}
class NavigationEnd extends RouterEvent {
  urlAfterRedirects;
  type = EventType.NavigationEnd;
  constructor(id, url, urlAfterRedirects) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
  }
  toString() {
    return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;
  }
}
var NavigationCancellationCode;
(function (NavigationCancellationCode) {
  NavigationCancellationCode[NavigationCancellationCode["Redirect"] = 0] = "Redirect";
  NavigationCancellationCode[NavigationCancellationCode["SupersededByNewNavigation"] = 1] = "SupersededByNewNavigation";
  NavigationCancellationCode[NavigationCancellationCode["NoDataFromResolver"] = 2] = "NoDataFromResolver";
  NavigationCancellationCode[NavigationCancellationCode["GuardRejected"] = 3] = "GuardRejected";
  NavigationCancellationCode[NavigationCancellationCode["Aborted"] = 4] = "Aborted";
})(NavigationCancellationCode || (NavigationCancellationCode = {}));
var NavigationSkippedCode;
(function (NavigationSkippedCode) {
  NavigationSkippedCode[NavigationSkippedCode["IgnoredSameUrlNavigation"] = 0] = "IgnoredSameUrlNavigation";
  NavigationSkippedCode[NavigationSkippedCode["IgnoredByUrlHandlingStrategy"] = 1] = "IgnoredByUrlHandlingStrategy";
})(NavigationSkippedCode || (NavigationSkippedCode = {}));
class NavigationCancel extends RouterEvent {
  reason;
  code;
  type = EventType.NavigationCancel;
  constructor(id, url, reason, code) {
    super(id, url);
    this.reason = reason;
    this.code = code;
  }
  toString() {
    return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;
  }
}
class NavigationSkipped extends RouterEvent {
  reason;
  code;
  type = EventType.NavigationSkipped;
  constructor(id, url, reason, code) {
    super(id, url);
    this.reason = reason;
    this.code = code;
  }
}
class NavigationError extends RouterEvent {
  error;
  target;
  type = EventType.NavigationError;
  constructor(id, url, error, target) {
    super(id, url);
    this.error = error;
    this.target = target;
  }
  toString() {
    return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;
  }
}
class RoutesRecognized extends RouterEvent {
  urlAfterRedirects;
  state;
  type = EventType.RoutesRecognized;
  constructor(id, url, urlAfterRedirects, state) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state;
  }
  toString() {
    return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
  }
}
class GuardsCheckStart extends RouterEvent {
  urlAfterRedirects;
  state;
  type = EventType.GuardsCheckStart;
  constructor(id, url, urlAfterRedirects, state) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state;
  }
  toString() {
    return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
  }
}
class GuardsCheckEnd extends RouterEvent {
  urlAfterRedirects;
  state;
  shouldActivate;
  type = EventType.GuardsCheckEnd;
  constructor(id, url, urlAfterRedirects, state, shouldActivate) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state;
    this.shouldActivate = shouldActivate;
  }
  toString() {
    return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;
  }
}
class ResolveStart extends RouterEvent {
  urlAfterRedirects;
  state;
  type = EventType.ResolveStart;
  constructor(id, url, urlAfterRedirects, state) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state;
  }
  toString() {
    return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
  }
}
class ResolveEnd extends RouterEvent {
  urlAfterRedirects;
  state;
  type = EventType.ResolveEnd;
  constructor(id, url, urlAfterRedirects, state) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state;
  }
  toString() {
    return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
  }
}
class RouteConfigLoadStart {
  route;
  type = EventType.RouteConfigLoadStart;
  constructor(route) {
    this.route = route;
  }
  toString() {
    return `RouteConfigLoadStart(path: ${this.route.path})`;
  }
}
class RouteConfigLoadEnd {
  route;
  type = EventType.RouteConfigLoadEnd;
  constructor(route) {
    this.route = route;
  }
  toString() {
    return `RouteConfigLoadEnd(path: ${this.route.path})`;
  }
}
class ChildActivationStart {
  snapshot;
  type = EventType.ChildActivationStart;
  constructor(snapshot) {
    this.snapshot = snapshot;
  }
  toString() {
    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';
    return `ChildActivationStart(path: '${path}')`;
  }
}
class ChildActivationEnd {
  snapshot;
  type = EventType.ChildActivationEnd;
  constructor(snapshot) {
    this.snapshot = snapshot;
  }
  toString() {
    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';
    return `ChildActivationEnd(path: '${path}')`;
  }
}
class ActivationStart {
  snapshot;
  type = EventType.ActivationStart;
  constructor(snapshot) {
    this.snapshot = snapshot;
  }
  toString() {
    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';
    return `ActivationStart(path: '${path}')`;
  }
}
class ActivationEnd {
  snapshot;
  type = EventType.ActivationEnd;
  constructor(snapshot) {
    this.snapshot = snapshot;
  }
  toString() {
    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';
    return `ActivationEnd(path: '${path}')`;
  }
}
class Scroll {
  routerEvent;
  position;
  anchor;
  type = EventType.Scroll;
  constructor(routerEvent, position, anchor) {
    this.routerEvent = routerEvent;
    this.position = position;
    this.anchor = anchor;
  }
  toString() {
    const pos = this.position ? `${this.position[0]}, ${this.position[1]}` : null;
    return `Scroll(anchor: '${this.anchor}', position: '${pos}')`;
  }
}
class BeforeActivateRoutes {}
class RedirectRequest {
  url;
  navigationBehaviorOptions;
  constructor(url, navigationBehaviorOptions) {
    this.url = url;
    this.navigationBehaviorOptions = navigationBehaviorOptions;
  }
}
function isPublicRouterEvent(e) {
  return !(e instanceof BeforeActivateRoutes) && !(e instanceof RedirectRequest);
}
function stringifyEvent(routerEvent) {
  switch (routerEvent.type) {
    case EventType.ActivationEnd:
      return `ActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;
    case EventType.ActivationStart:
      return `ActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;
    case EventType.ChildActivationEnd:
      return `ChildActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;
    case EventType.ChildActivationStart:
      return `ChildActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;
    case EventType.GuardsCheckEnd:
      return `GuardsCheckEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state}, shouldActivate: ${routerEvent.shouldActivate})`;
    case EventType.GuardsCheckStart:
      return `GuardsCheckStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.NavigationCancel:
      return `NavigationCancel(id: ${routerEvent.id}, url: '${routerEvent.url}')`;
    case EventType.NavigationSkipped:
      return `NavigationSkipped(id: ${routerEvent.id}, url: '${routerEvent.url}')`;
    case EventType.NavigationEnd:
      return `NavigationEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}')`;
    case EventType.NavigationError:
      return `NavigationError(id: ${routerEvent.id}, url: '${routerEvent.url}', error: ${routerEvent.error})`;
    case EventType.NavigationStart:
      return `NavigationStart(id: ${routerEvent.id}, url: '${routerEvent.url}')`;
    case EventType.ResolveEnd:
      return `ResolveEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.ResolveStart:
      return `ResolveStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.RouteConfigLoadEnd:
      return `RouteConfigLoadEnd(path: ${routerEvent.route.path})`;
    case EventType.RouteConfigLoadStart:
      return `RouteConfigLoadStart(path: ${routerEvent.route.path})`;
    case EventType.RoutesRecognized:
      return `RoutesRecognized(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.Scroll:
      const pos = routerEvent.position ? `${routerEvent.position[0]}, ${routerEvent.position[1]}` : null;
      return `Scroll(anchor: '${routerEvent.anchor}', position: '${pos}')`;
  }
}
function getOrCreateRouteInjectorIfNeeded(route, currentInjector) {
  if (route.providers && !route._injector) {
    route._injector = (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.createEnvironmentInjector)(route.providers, currentInjector, `Route: ${route.path}`);
  }
  return route._injector ?? currentInjector;
}
function validateConfig(config, parentPath = '', requireStandaloneComponents = false) {
  for (let i = 0; i < config.length; i++) {
    const route = config[i];
    const fullPath = getFullPath(parentPath, route);
    validateNode(route, fullPath, requireStandaloneComponents);
  }
}
function assertStandalone(fullPath, component) {
  if (component && (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.isNgModule)(component)) {
    throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4014, `Invalid configuration of route '${fullPath}'. You are using 'loadComponent' with a module, ` + `but it must be used with standalone components. Use 'loadChildren' instead.`);
  } else if (component && !(0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.isStandalone)(component)) {
    throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4014, `Invalid configuration of route '${fullPath}'. The component must be standalone.`);
  }
}
function validateNode(route, fullPath, requireStandaloneComponents) {
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
    if (!route) {
      throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4014, `
      Invalid configuration of route '${fullPath}': Encountered undefined route.
      The reason might be an extra comma.

      Example:
      const routes: Routes = [
        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },
        { path: 'dashboard',  component: DashboardComponent },, << two commas
        { path: 'detail/:id', component: HeroDetailComponent }
      ];
    `);
    }
    if (Array.isArray(route)) {
      throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4014, `Invalid configuration of route '${fullPath}': Array cannot be specified`);
    }
    if (!route.redirectTo && !route.component && !route.loadComponent && !route.children && !route.loadChildren && route.outlet && route.outlet !== PRIMARY_OUTLET) {
      throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4014, `Invalid configuration of route '${fullPath}': a componentless route without children or loadChildren cannot have a named outlet set`);
    }
    if (route.redirectTo && route.children) {
      throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and children cannot be used together`);
    }
    if (route.redirectTo && route.loadChildren) {
      throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and loadChildren cannot be used together`);
    }
    if (route.children && route.loadChildren) {
      throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4014, `Invalid configuration of route '${fullPath}': children and loadChildren cannot be used together`);
    }
    if (route.component && route.loadComponent) {
      throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4014, `Invalid configuration of route '${fullPath}': component and loadComponent cannot be used together`);
    }
    if (route.redirectTo) {
      if (route.component || route.loadComponent) {
        throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and component/loadComponent cannot be used together`);
      }
      if (route.canMatch || route.canActivate) {
        throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and ${route.canMatch ? 'canMatch' : 'canActivate'} cannot be used together.` + `Redirects happen before guards are executed.`);
      }
    }
    if (route.path && route.matcher) {
      throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4014, `Invalid configuration of route '${fullPath}': path and matcher cannot be used together`);
    }
    if (route.redirectTo === void 0 && !route.component && !route.loadComponent && !route.children && !route.loadChildren) {
      throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4014, `Invalid configuration of route '${fullPath}'. One of the following must be provided: component, loadComponent, redirectTo, children or loadChildren`);
    }
    if (route.path === void 0 && route.matcher === void 0) {
      throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4014, `Invalid configuration of route '${fullPath}': routes must have either a path or a matcher specified`);
    }
    if (typeof route.path === 'string' && route.path.charAt(0) === '/') {
      throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4014, `Invalid configuration of route '${fullPath}': path cannot start with a slash`);
    }
    if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {
      const exp = `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;
      throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4014, `Invalid configuration of route '{path: "${fullPath}", redirectTo: "${route.redirectTo}"}': please provide 'pathMatch'. ${exp}`);
    }
    if (requireStandaloneComponents) {
      assertStandalone(fullPath, route.component);
    }
  }
  if (route.children) {
    validateConfig(route.children, fullPath, requireStandaloneComponents);
  }
}
function getFullPath(parentPath, currentRoute) {
  if (!currentRoute) {
    return parentPath;
  }
  if (!parentPath && !currentRoute.path) {
    return '';
  } else if (parentPath && !currentRoute.path) {
    return `${parentPath}/`;
  } else if (!parentPath && currentRoute.path) {
    return currentRoute.path;
  } else {
    return `${parentPath}/${currentRoute.path}`;
  }
}
function getOutlet(route) {
  return route.outlet || PRIMARY_OUTLET;
}
function sortByMatchingOutlets(routes, outletName) {
  const sortedConfig = routes.filter(r => getOutlet(r) === outletName);
  sortedConfig.push(...routes.filter(r => getOutlet(r) !== outletName));
  return sortedConfig;
}
function getClosestRouteInjector(snapshot) {
  if (!snapshot) return null;
  if (snapshot.routeConfig?._injector) {
    return snapshot.routeConfig._injector;
  }
  for (let s = snapshot.parent; s; s = s.parent) {
    const route = s.routeConfig;
    if (route?._loadedInjector) return route._loadedInjector;
    if (route?._injector) return route._injector;
  }
  return null;
}
class OutletContext {
  rootInjector;
  outlet = null;
  route = null;
  children;
  attachRef = null;
  get injector() {
    return getClosestRouteInjector(this.route?.snapshot) ?? this.rootInjector;
  }
  constructor(rootInjector) {
    this.rootInjector = rootInjector;
    this.children = new ChildrenOutletContexts(this.rootInjector);
  }
}
class ChildrenOutletContexts {
  rootInjector;
  contexts = new Map();
  constructor(rootInjector) {
    this.rootInjector = rootInjector;
  }
  onChildOutletCreated(childName, outlet) {
    const context = this.getOrCreateContext(childName);
    context.outlet = outlet;
    this.contexts.set(childName, context);
  }
  onChildOutletDestroyed(childName) {
    const context = this.getContext(childName);
    if (context) {
      context.outlet = null;
      context.attachRef = null;
    }
  }
  onOutletDeactivated() {
    const contexts = this.contexts;
    this.contexts = new Map();
    return contexts;
  }
  onOutletReAttached(contexts) {
    this.contexts = contexts;
  }
  getOrCreateContext(childName) {
    let context = this.getContext(childName);
    if (!context) {
      context = new OutletContext(this.rootInjector);
      this.contexts.set(childName, context);
    }
    return context;
  }
  getContext(childName) {
    return this.contexts.get(childName) || null;
  }
  static ɵfac = function ChildrenOutletContexts_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || ChildrenOutletContexts)(_angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_1__.EnvironmentInjector));
  };
  static ɵprov = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: ChildrenOutletContexts,
    factory: ChildrenOutletContexts.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(ChildrenOutletContexts, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], () => [{
    type: _angular_common__WEBPACK_IMPORTED_MODULE_1__.EnvironmentInjector
  }], null);
})();
class Tree {
  _root;
  constructor(root) {
    this._root = root;
  }
  get root() {
    return this._root.value;
  }
  parent(t) {
    const p = this.pathFromRoot(t);
    return p.length > 1 ? p[p.length - 2] : null;
  }
  children(t) {
    const n = findNode(t, this._root);
    return n ? n.children.map(t => t.value) : [];
  }
  firstChild(t) {
    const n = findNode(t, this._root);
    return n && n.children.length > 0 ? n.children[0].value : null;
  }
  siblings(t) {
    const p = findPath(t, this._root);
    if (p.length < 2) return [];
    const c = p[p.length - 2].children.map(c => c.value);
    return c.filter(cc => cc !== t);
  }
  pathFromRoot(t) {
    return findPath(t, this._root).map(s => s.value);
  }
}
function findNode(value, node) {
  if (value === node.value) return node;
  for (const child of node.children) {
    const node = findNode(value, child);
    if (node) return node;
  }
  return null;
}
function findPath(value, node) {
  if (value === node.value) return [node];
  for (const child of node.children) {
    const path = findPath(value, child);
    if (path.length) {
      path.unshift(node);
      return path;
    }
  }
  return [];
}
class TreeNode {
  value;
  children;
  constructor(value, children) {
    this.value = value;
    this.children = children;
  }
  toString() {
    return `TreeNode(${this.value})`;
  }
}
function nodeChildrenAsMap(node) {
  const map = {};
  if (node) {
    node.children.forEach(child => map[child.value.outlet] = child);
  }
  return map;
}
class RouterState extends Tree {
  snapshot;
  constructor(root, snapshot) {
    super(root);
    this.snapshot = snapshot;
    setRouterState(this, root);
  }
  toString() {
    return this.snapshot.toString();
  }
}
function createEmptyState(rootComponent) {
  const snapshot = createEmptyStateSnapshot(rootComponent);
  const emptyUrl = new rxjs__WEBPACK_IMPORTED_MODULE_7__.BehaviorSubject([new UrlSegment('', {})]);
  const emptyParams = new rxjs__WEBPACK_IMPORTED_MODULE_7__.BehaviorSubject({});
  const emptyData = new rxjs__WEBPACK_IMPORTED_MODULE_7__.BehaviorSubject({});
  const emptyQueryParams = new rxjs__WEBPACK_IMPORTED_MODULE_7__.BehaviorSubject({});
  const fragment = new rxjs__WEBPACK_IMPORTED_MODULE_7__.BehaviorSubject('');
  const activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);
  activated.snapshot = snapshot.root;
  return new RouterState(new TreeNode(activated, []), snapshot);
}
function createEmptyStateSnapshot(rootComponent) {
  const emptyParams = {};
  const emptyData = {};
  const emptyQueryParams = {};
  const fragment = '';
  const activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, {});
  return new RouterStateSnapshot('', new TreeNode(activated, []));
}
class ActivatedRoute {
  urlSubject;
  paramsSubject;
  queryParamsSubject;
  fragmentSubject;
  dataSubject;
  outlet;
  component;
  snapshot;
  _futureSnapshot;
  _routerState;
  _paramMap;
  _queryParamMap;
  title;
  url;
  params;
  queryParams;
  fragment;
  data;
  constructor(urlSubject, paramsSubject, queryParamsSubject, fragmentSubject, dataSubject, outlet, component, futureSnapshot) {
    this.urlSubject = urlSubject;
    this.paramsSubject = paramsSubject;
    this.queryParamsSubject = queryParamsSubject;
    this.fragmentSubject = fragmentSubject;
    this.dataSubject = dataSubject;
    this.outlet = outlet;
    this.component = component;
    this._futureSnapshot = futureSnapshot;
    this.title = this.dataSubject?.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.map)(d => d[RouteTitleKey])) ?? (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(undefined);
    this.url = urlSubject;
    this.params = paramsSubject;
    this.queryParams = queryParamsSubject;
    this.fragment = fragmentSubject;
    this.data = dataSubject;
  }
  get routeConfig() {
    return this._futureSnapshot.routeConfig;
  }
  get root() {
    return this._routerState.root;
  }
  get parent() {
    return this._routerState.parent(this);
  }
  get firstChild() {
    return this._routerState.firstChild(this);
  }
  get children() {
    return this._routerState.children(this);
  }
  get pathFromRoot() {
    return this._routerState.pathFromRoot(this);
  }
  get paramMap() {
    this._paramMap ??= this.params.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.map)(p => convertToParamMap(p)));
    return this._paramMap;
  }
  get queryParamMap() {
    this._queryParamMap ??= this.queryParams.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.map)(p => convertToParamMap(p)));
    return this._queryParamMap;
  }
  toString() {
    return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`;
  }
}
function getInherited(route, parent, paramsInheritanceStrategy = 'emptyOnly') {
  let inherited;
  const {
    routeConfig
  } = route;
  if (parent !== null && (paramsInheritanceStrategy === 'always' || routeConfig?.path === '' || !parent.component && !parent.routeConfig?.loadComponent)) {
    inherited = {
      params: {
        ...parent.params,
        ...route.params
      },
      data: {
        ...parent.data,
        ...route.data
      },
      resolve: {
        ...route.data,
        ...parent.data,
        ...routeConfig?.data,
        ...route._resolvedData
      }
    };
  } else {
    inherited = {
      params: {
        ...route.params
      },
      data: {
        ...route.data
      },
      resolve: {
        ...route.data,
        ...(route._resolvedData ?? {})
      }
    };
  }
  if (routeConfig && hasStaticTitle(routeConfig)) {
    inherited.resolve[RouteTitleKey] = routeConfig.title;
  }
  return inherited;
}
class ActivatedRouteSnapshot {
  url;
  params;
  queryParams;
  fragment;
  data;
  outlet;
  component;
  routeConfig;
  _resolve;
  _resolvedData;
  _routerState;
  _paramMap;
  _queryParamMap;
  get title() {
    return this.data?.[RouteTitleKey];
  }
  constructor(url, params, queryParams, fragment, data, outlet, component, routeConfig, resolve) {
    this.url = url;
    this.params = params;
    this.queryParams = queryParams;
    this.fragment = fragment;
    this.data = data;
    this.outlet = outlet;
    this.component = component;
    this.routeConfig = routeConfig;
    this._resolve = resolve;
  }
  get root() {
    return this._routerState.root;
  }
  get parent() {
    return this._routerState.parent(this);
  }
  get firstChild() {
    return this._routerState.firstChild(this);
  }
  get children() {
    return this._routerState.children(this);
  }
  get pathFromRoot() {
    return this._routerState.pathFromRoot(this);
  }
  get paramMap() {
    this._paramMap ??= convertToParamMap(this.params);
    return this._paramMap;
  }
  get queryParamMap() {
    this._queryParamMap ??= convertToParamMap(this.queryParams);
    return this._queryParamMap;
  }
  toString() {
    const url = this.url.map(segment => segment.toString()).join('/');
    const matched = this.routeConfig ? this.routeConfig.path : '';
    return `Route(url:'${url}', path:'${matched}')`;
  }
}
class RouterStateSnapshot extends Tree {
  url;
  constructor(url, root) {
    super(root);
    this.url = url;
    setRouterState(this, root);
  }
  toString() {
    return serializeNode(this._root);
  }
}
function setRouterState(state, node) {
  node.value._routerState = state;
  node.children.forEach(c => setRouterState(state, c));
}
function serializeNode(node) {
  const c = node.children.length > 0 ? ` { ${node.children.map(serializeNode).join(', ')} } ` : '';
  return `${node.value}${c}`;
}
function advanceActivatedRoute(route) {
  if (route.snapshot) {
    const currentSnapshot = route.snapshot;
    const nextSnapshot = route._futureSnapshot;
    route.snapshot = nextSnapshot;
    if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {
      route.queryParamsSubject.next(nextSnapshot.queryParams);
    }
    if (currentSnapshot.fragment !== nextSnapshot.fragment) {
      route.fragmentSubject.next(nextSnapshot.fragment);
    }
    if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {
      route.paramsSubject.next(nextSnapshot.params);
    }
    if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {
      route.urlSubject.next(nextSnapshot.url);
    }
    if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {
      route.dataSubject.next(nextSnapshot.data);
    }
  } else {
    route.snapshot = route._futureSnapshot;
    route.dataSubject.next(route._futureSnapshot.data);
  }
}
function equalParamsAndUrlSegments(a, b) {
  const equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);
  const parentsMismatch = !a.parent !== !b.parent;
  return equalUrlParams && !parentsMismatch && (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent));
}
function hasStaticTitle(config) {
  return typeof config.title === 'string' || config.title === null;
}
const ROUTER_OUTLET_DATA = new _angular_common__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'RouterOutlet data' : '');
class RouterOutlet {
  activated = null;
  get activatedComponentRef() {
    return this.activated;
  }
  _activatedRoute = null;
  name = PRIMARY_OUTLET;
  activateEvents = new _angular_common__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
  deactivateEvents = new _angular_common__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
  attachEvents = new _angular_common__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
  detachEvents = new _angular_common__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
  routerOutletData = (0,_angular_core__WEBPACK_IMPORTED_MODULE_4__.input)(...(ngDevMode ? [undefined, {
    debugName: "routerOutletData"
  }] : []));
  parentContexts = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(ChildrenOutletContexts);
  location = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_3__.ViewContainerRef);
  changeDetector = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_4__.ChangeDetectorRef);
  inputBinder = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(INPUT_BINDER, {
    optional: true
  });
  supportsBindingToComponentInputs = true;
  ngOnChanges(changes) {
    if (changes['name']) {
      const {
        firstChange,
        previousValue
      } = changes['name'];
      if (firstChange) {
        return;
      }
      if (this.isTrackedInParentContexts(previousValue)) {
        this.deactivate();
        this.parentContexts.onChildOutletDestroyed(previousValue);
      }
      this.initializeOutletWithName();
    }
  }
  ngOnDestroy() {
    if (this.isTrackedInParentContexts(this.name)) {
      this.parentContexts.onChildOutletDestroyed(this.name);
    }
    this.inputBinder?.unsubscribeFromRouteData(this);
  }
  isTrackedInParentContexts(outletName) {
    return this.parentContexts.getContext(outletName)?.outlet === this;
  }
  ngOnInit() {
    this.initializeOutletWithName();
  }
  initializeOutletWithName() {
    this.parentContexts.onChildOutletCreated(this.name, this);
    if (this.activated) {
      return;
    }
    const context = this.parentContexts.getContext(this.name);
    if (context?.route) {
      if (context.attachRef) {
        this.attach(context.attachRef, context.route);
      } else {
        this.activateWith(context.route, context.injector);
      }
    }
  }
  get isActivated() {
    return !!this.activated;
  }
  get component() {
    if (!this.activated) throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4012, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated');
    return this.activated.instance;
  }
  get activatedRoute() {
    if (!this.activated) throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4012, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated');
    return this._activatedRoute;
  }
  get activatedRouteData() {
    if (this._activatedRoute) {
      return this._activatedRoute.snapshot.data;
    }
    return {};
  }
  detach() {
    if (!this.activated) throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4012, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated');
    this.location.detach();
    const cmp = this.activated;
    this.activated = null;
    this._activatedRoute = null;
    this.detachEvents.emit(cmp.instance);
    return cmp;
  }
  attach(ref, activatedRoute) {
    this.activated = ref;
    this._activatedRoute = activatedRoute;
    this.location.insert(ref.hostView);
    this.inputBinder?.bindActivatedRouteToOutletComponent(this);
    this.attachEvents.emit(ref.instance);
  }
  deactivate() {
    if (this.activated) {
      const c = this.component;
      this.activated.destroy();
      this.activated = null;
      this._activatedRoute = null;
      this.deactivateEvents.emit(c);
    }
  }
  activateWith(activatedRoute, environmentInjector) {
    if (this.isActivated) {
      throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4013, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Cannot activate an already activated outlet');
    }
    this._activatedRoute = activatedRoute;
    const location = this.location;
    const snapshot = activatedRoute.snapshot;
    const component = snapshot.component;
    const childContexts = this.parentContexts.getOrCreateContext(this.name).children;
    const injector = new OutletInjector(activatedRoute, childContexts, location.injector, this.routerOutletData);
    this.activated = location.createComponent(component, {
      index: location.length,
      injector,
      environmentInjector: environmentInjector
    });
    this.changeDetector.markForCheck();
    this.inputBinder?.bindActivatedRouteToOutletComponent(this);
    this.activateEvents.emit(this.activated.instance);
  }
  static ɵfac = function RouterOutlet_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || RouterOutlet)();
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineDirective"]({
    type: RouterOutlet,
    selectors: [["router-outlet"]],
    inputs: {
      name: "name",
      routerOutletData: [1, "routerOutletData"]
    },
    outputs: {
      activateEvents: "activate",
      deactivateEvents: "deactivate",
      attachEvents: "attach",
      detachEvents: "detach"
    },
    exportAs: ["outlet"],
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵNgOnChangesFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(RouterOutlet, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Directive,
    args: [{
      selector: 'router-outlet',
      exportAs: 'outlet'
    }]
  }], null, {
    name: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input
    }],
    activateEvents: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Output,
      args: ['activate']
    }],
    deactivateEvents: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Output,
      args: ['deactivate']
    }],
    attachEvents: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Output,
      args: ['attach']
    }],
    detachEvents: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Output,
      args: ['detach']
    }],
    routerOutletData: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
      args: [{
        isSignal: true,
        alias: "routerOutletData",
        required: false
      }]
    }]
  });
})();
class OutletInjector {
  route;
  childContexts;
  parent;
  outletData;
  constructor(route, childContexts, parent, outletData) {
    this.route = route;
    this.childContexts = childContexts;
    this.parent = parent;
    this.outletData = outletData;
  }
  get(token, notFoundValue) {
    if (token === ActivatedRoute) {
      return this.route;
    }
    if (token === ChildrenOutletContexts) {
      return this.childContexts;
    }
    if (token === ROUTER_OUTLET_DATA) {
      return this.outletData;
    }
    return this.parent.get(token, notFoundValue);
  }
}
const INPUT_BINDER = new _angular_common__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Router Input Binder' : '');
class RoutedComponentInputBinder {
  outletDataSubscriptions = new Map();
  bindActivatedRouteToOutletComponent(outlet) {
    this.unsubscribeFromRouteData(outlet);
    this.subscribeToRouteData(outlet);
  }
  unsubscribeFromRouteData(outlet) {
    this.outletDataSubscriptions.get(outlet)?.unsubscribe();
    this.outletDataSubscriptions.delete(outlet);
  }
  subscribeToRouteData(outlet) {
    const {
      activatedRoute
    } = outlet;
    const dataSubscription = (0,rxjs__WEBPACK_IMPORTED_MODULE_12__.combineLatest)([activatedRoute.queryParams, activatedRoute.params, activatedRoute.data]).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_30__.switchMap)(([queryParams, params, data], index) => {
      data = {
        ...queryParams,
        ...params,
        ...data
      };
      if (index === 0) {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(data);
      }
      return Promise.resolve(data);
    })).subscribe(data => {
      if (!outlet.isActivated || !outlet.activatedComponentRef || outlet.activatedRoute !== activatedRoute || activatedRoute.component === null) {
        this.unsubscribeFromRouteData(outlet);
        return;
      }
      const mirror = (0,_angular_core__WEBPACK_IMPORTED_MODULE_4__.reflectComponentType)(activatedRoute.component);
      if (!mirror) {
        this.unsubscribeFromRouteData(outlet);
        return;
      }
      for (const {
        templateName
      } of mirror.inputs) {
        outlet.activatedComponentRef.setInput(templateName, data[templateName]);
      }
    });
    this.outletDataSubscriptions.set(outlet, dataSubscription);
  }
  static ɵfac = function RoutedComponentInputBinder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || RoutedComponentInputBinder)();
  };
  static ɵprov = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: RoutedComponentInputBinder,
    factory: RoutedComponentInputBinder.ɵfac
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(RoutedComponentInputBinder, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable
  }], null, null);
})();
class ɵEmptyOutletComponent {
  static ɵfac = function ɵEmptyOutletComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || ɵEmptyOutletComponent)();
  };
  static ɵcmp = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineComponent"]({
    type: ɵEmptyOutletComponent,
    selectors: [["ng-component"]],
    exportAs: ["emptyRouterOutlet"],
    decls: 1,
    vars: 0,
    template: function _EmptyOutletComponent_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵelement"](0, "router-outlet");
      }
    },
    dependencies: [RouterOutlet],
    encapsulation: 2
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(ɵEmptyOutletComponent, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Component,
    args: [{
      template: `<router-outlet/>`,
      imports: [RouterOutlet],
      exportAs: 'emptyRouterOutlet'
    }]
  }], null, null);
})();
function standardizeConfig(r) {
  const children = r.children && r.children.map(standardizeConfig);
  const c = children ? {
    ...r,
    children
  } : {
    ...r
  };
  if (!c.component && !c.loadComponent && (children || c.loadChildren) && c.outlet && c.outlet !== PRIMARY_OUTLET) {
    c.component = ɵEmptyOutletComponent;
  }
  return c;
}
function createRouterState(routeReuseStrategy, curr, prevState) {
  const root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);
  return new RouterState(root, curr);
}
function createNode(routeReuseStrategy, curr, prevState) {
  if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {
    const value = prevState.value;
    value._futureSnapshot = curr.value;
    const children = createOrReuseChildren(routeReuseStrategy, curr, prevState);
    return new TreeNode(value, children);
  } else {
    if (routeReuseStrategy.shouldAttach(curr.value)) {
      const detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);
      if (detachedRouteHandle !== null) {
        const tree = detachedRouteHandle.route;
        tree.value._futureSnapshot = curr.value;
        tree.children = curr.children.map(c => createNode(routeReuseStrategy, c));
        return tree;
      }
    }
    const value = createActivatedRoute(curr.value);
    const children = curr.children.map(c => createNode(routeReuseStrategy, c));
    return new TreeNode(value, children);
  }
}
function createOrReuseChildren(routeReuseStrategy, curr, prevState) {
  return curr.children.map(child => {
    for (const p of prevState.children) {
      if (routeReuseStrategy.shouldReuseRoute(child.value, p.value.snapshot)) {
        return createNode(routeReuseStrategy, child, p);
      }
    }
    return createNode(routeReuseStrategy, child);
  });
}
function createActivatedRoute(c) {
  return new ActivatedRoute(new rxjs__WEBPACK_IMPORTED_MODULE_7__.BehaviorSubject(c.url), new rxjs__WEBPACK_IMPORTED_MODULE_7__.BehaviorSubject(c.params), new rxjs__WEBPACK_IMPORTED_MODULE_7__.BehaviorSubject(c.queryParams), new rxjs__WEBPACK_IMPORTED_MODULE_7__.BehaviorSubject(c.fragment), new rxjs__WEBPACK_IMPORTED_MODULE_7__.BehaviorSubject(c.data), c.outlet, c.component, c);
}
class RedirectCommand {
  redirectTo;
  navigationBehaviorOptions;
  constructor(redirectTo, navigationBehaviorOptions) {
    this.redirectTo = redirectTo;
    this.navigationBehaviorOptions = navigationBehaviorOptions;
  }
}
const NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';
function redirectingNavigationError(urlSerializer, redirect) {
  const {
    redirectTo,
    navigationBehaviorOptions
  } = isUrlTree(redirect) ? {
    redirectTo: redirect,
    navigationBehaviorOptions: undefined
  } : redirect;
  const error = navigationCancelingError(ngDevMode && `Redirecting to "${urlSerializer.serialize(redirectTo)}"`, NavigationCancellationCode.Redirect);
  error.url = redirectTo;
  error.navigationBehaviorOptions = navigationBehaviorOptions;
  return error;
}
function navigationCancelingError(message, code) {
  const error = new Error(`NavigationCancelingError: ${message || ''}`);
  error[NAVIGATION_CANCELING_ERROR] = true;
  error.cancellationCode = code;
  return error;
}
function isRedirectingNavigationCancelingError(error) {
  return isNavigationCancelingError(error) && isUrlTree(error.url);
}
function isNavigationCancelingError(error) {
  return !!error && error[NAVIGATION_CANCELING_ERROR];
}
let warnedAboutUnsupportedInputBinding = false;
const activateRoutes = (rootContexts, routeReuseStrategy, forwardEvent, inputBindingEnabled) => (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.map)(t => {
  new ActivateRoutes(routeReuseStrategy, t.targetRouterState, t.currentRouterState, forwardEvent, inputBindingEnabled).activate(rootContexts);
  return t;
});
class ActivateRoutes {
  routeReuseStrategy;
  futureState;
  currState;
  forwardEvent;
  inputBindingEnabled;
  constructor(routeReuseStrategy, futureState, currState, forwardEvent, inputBindingEnabled) {
    this.routeReuseStrategy = routeReuseStrategy;
    this.futureState = futureState;
    this.currState = currState;
    this.forwardEvent = forwardEvent;
    this.inputBindingEnabled = inputBindingEnabled;
  }
  activate(parentContexts) {
    const futureRoot = this.futureState._root;
    const currRoot = this.currState ? this.currState._root : null;
    this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);
    advanceActivatedRoute(this.futureState.root);
    this.activateChildRoutes(futureRoot, currRoot, parentContexts);
  }
  deactivateChildRoutes(futureNode, currNode, contexts) {
    const children = nodeChildrenAsMap(currNode);
    futureNode.children.forEach(futureChild => {
      const childOutletName = futureChild.value.outlet;
      this.deactivateRoutes(futureChild, children[childOutletName], contexts);
      delete children[childOutletName];
    });
    Object.values(children).forEach(v => {
      this.deactivateRouteAndItsChildren(v, contexts);
    });
  }
  deactivateRoutes(futureNode, currNode, parentContext) {
    const future = futureNode.value;
    const curr = currNode ? currNode.value : null;
    if (future === curr) {
      if (future.component) {
        const context = parentContext.getContext(future.outlet);
        if (context) {
          this.deactivateChildRoutes(futureNode, currNode, context.children);
        }
      } else {
        this.deactivateChildRoutes(futureNode, currNode, parentContext);
      }
    } else {
      if (curr) {
        this.deactivateRouteAndItsChildren(currNode, parentContext);
      }
    }
  }
  deactivateRouteAndItsChildren(route, parentContexts) {
    if (route.value.component && this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {
      this.detachAndStoreRouteSubtree(route, parentContexts);
    } else {
      this.deactivateRouteAndOutlet(route, parentContexts);
    }
  }
  detachAndStoreRouteSubtree(route, parentContexts) {
    const context = parentContexts.getContext(route.value.outlet);
    const contexts = context && route.value.component ? context.children : parentContexts;
    const children = nodeChildrenAsMap(route);
    for (const treeNode of Object.values(children)) {
      this.deactivateRouteAndItsChildren(treeNode, contexts);
    }
    if (context && context.outlet) {
      const componentRef = context.outlet.detach();
      const contexts = context.children.onOutletDeactivated();
      this.routeReuseStrategy.store(route.value.snapshot, {
        componentRef,
        route,
        contexts
      });
    }
  }
  deactivateRouteAndOutlet(route, parentContexts) {
    const context = parentContexts.getContext(route.value.outlet);
    const contexts = context && route.value.component ? context.children : parentContexts;
    const children = nodeChildrenAsMap(route);
    for (const treeNode of Object.values(children)) {
      this.deactivateRouteAndItsChildren(treeNode, contexts);
    }
    if (context) {
      if (context.outlet) {
        context.outlet.deactivate();
        context.children.onOutletDeactivated();
      }
      context.attachRef = null;
      context.route = null;
    }
  }
  activateChildRoutes(futureNode, currNode, contexts) {
    const children = nodeChildrenAsMap(currNode);
    futureNode.children.forEach(c => {
      this.activateRoutes(c, children[c.value.outlet], contexts);
      this.forwardEvent(new ActivationEnd(c.value.snapshot));
    });
    if (futureNode.children.length) {
      this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));
    }
  }
  activateRoutes(futureNode, currNode, parentContexts) {
    const future = futureNode.value;
    const curr = currNode ? currNode.value : null;
    advanceActivatedRoute(future);
    if (future === curr) {
      if (future.component) {
        const context = parentContexts.getOrCreateContext(future.outlet);
        this.activateChildRoutes(futureNode, currNode, context.children);
      } else {
        this.activateChildRoutes(futureNode, currNode, parentContexts);
      }
    } else {
      if (future.component) {
        const context = parentContexts.getOrCreateContext(future.outlet);
        if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {
          const stored = this.routeReuseStrategy.retrieve(future.snapshot);
          this.routeReuseStrategy.store(future.snapshot, null);
          context.children.onOutletReAttached(stored.contexts);
          context.attachRef = stored.componentRef;
          context.route = stored.route.value;
          if (context.outlet) {
            context.outlet.attach(stored.componentRef, stored.route.value);
          }
          advanceActivatedRoute(stored.route.value);
          this.activateChildRoutes(futureNode, null, context.children);
        } else {
          context.attachRef = null;
          context.route = future;
          if (context.outlet) {
            context.outlet.activateWith(future, context.injector);
          }
          this.activateChildRoutes(futureNode, null, context.children);
        }
      } else {
        this.activateChildRoutes(futureNode, null, parentContexts);
      }
    }
    if (typeof ngDevMode === 'undefined' || ngDevMode) {
      const context = parentContexts.getOrCreateContext(future.outlet);
      const outlet = context.outlet;
      if (outlet && this.inputBindingEnabled && !outlet.supportsBindingToComponentInputs && !warnedAboutUnsupportedInputBinding) {
        console.warn(`'withComponentInputBinding' feature is enabled but ` + `this application is using an outlet that may not support binding to component inputs.`);
        warnedAboutUnsupportedInputBinding = true;
      }
    }
  }
}
class CanActivate {
  path;
  route;
  constructor(path) {
    this.path = path;
    this.route = this.path[this.path.length - 1];
  }
}
class CanDeactivate {
  component;
  route;
  constructor(component, route) {
    this.component = component;
    this.route = route;
  }
}
function getAllRouteGuards(future, curr, parentContexts) {
  const futureRoot = future._root;
  const currRoot = curr ? curr._root : null;
  return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);
}
function getCanActivateChild(p) {
  const canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;
  if (!canActivateChild || canActivateChild.length === 0) return null;
  return {
    node: p,
    guards: canActivateChild
  };
}
function getTokenOrFunctionIdentity(tokenOrFunction, injector) {
  const NOT_FOUND = Symbol();
  const result = injector.get(tokenOrFunction, NOT_FOUND);
  if (result === NOT_FOUND) {
    if (typeof tokenOrFunction === 'function' && !(0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.isInjectable)(tokenOrFunction)) {
      return tokenOrFunction;
    } else {
      return injector.get(tokenOrFunction);
    }
  }
  return result;
}
function getChildRouteGuards(futureNode, currNode, contexts, futurePath, checks = {
  canDeactivateChecks: [],
  canActivateChecks: []
}) {
  const prevChildren = nodeChildrenAsMap(currNode);
  futureNode.children.forEach(c => {
    getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);
    delete prevChildren[c.value.outlet];
  });
  Object.entries(prevChildren).forEach(([k, v]) => deactivateRouteAndItsChildren(v, contexts.getContext(k), checks));
  return checks;
}
function getRouteGuards(futureNode, currNode, parentContexts, futurePath, checks = {
  canDeactivateChecks: [],
  canActivateChecks: []
}) {
  const future = futureNode.value;
  const curr = currNode ? currNode.value : null;
  const context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;
  if (curr && future.routeConfig === curr.routeConfig) {
    const shouldRun = shouldRunGuardsAndResolvers(curr, future, future.routeConfig.runGuardsAndResolvers);
    if (shouldRun) {
      checks.canActivateChecks.push(new CanActivate(futurePath));
    } else {
      future.data = curr.data;
      future._resolvedData = curr._resolvedData;
    }
    if (future.component) {
      getChildRouteGuards(futureNode, currNode, context ? context.children : null, futurePath, checks);
    } else {
      getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);
    }
    if (shouldRun && context && context.outlet && context.outlet.isActivated) {
      checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, curr));
    }
  } else {
    if (curr) {
      deactivateRouteAndItsChildren(currNode, context, checks);
    }
    checks.canActivateChecks.push(new CanActivate(futurePath));
    if (future.component) {
      getChildRouteGuards(futureNode, null, context ? context.children : null, futurePath, checks);
    } else {
      getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);
    }
  }
  return checks;
}
function shouldRunGuardsAndResolvers(curr, future, mode) {
  if (typeof mode === 'function') {
    return mode(curr, future);
  }
  switch (mode) {
    case 'pathParamsChange':
      return !equalPath(curr.url, future.url);
    case 'pathParamsOrQueryParamsChange':
      return !equalPath(curr.url, future.url) || !shallowEqual(curr.queryParams, future.queryParams);
    case 'always':
      return true;
    case 'paramsOrQueryParamsChange':
      return !equalParamsAndUrlSegments(curr, future) || !shallowEqual(curr.queryParams, future.queryParams);
    case 'paramsChange':
    default:
      return !equalParamsAndUrlSegments(curr, future);
  }
}
function deactivateRouteAndItsChildren(route, context, checks) {
  const children = nodeChildrenAsMap(route);
  const r = route.value;
  Object.entries(children).forEach(([childName, node]) => {
    if (!r.component) {
      deactivateRouteAndItsChildren(node, context, checks);
    } else if (context) {
      deactivateRouteAndItsChildren(node, context.children.getContext(childName), checks);
    } else {
      deactivateRouteAndItsChildren(node, null, checks);
    }
  });
  if (!r.component) {
    checks.canDeactivateChecks.push(new CanDeactivate(null, r));
  } else if (context && context.outlet && context.outlet.isActivated) {
    checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));
  } else {
    checks.canDeactivateChecks.push(new CanDeactivate(null, r));
  }
}
function isFunction(v) {
  return typeof v === 'function';
}
function isBoolean(v) {
  return typeof v === 'boolean';
}
function isCanLoad(guard) {
  return guard && isFunction(guard.canLoad);
}
function isCanActivate(guard) {
  return guard && isFunction(guard.canActivate);
}
function isCanActivateChild(guard) {
  return guard && isFunction(guard.canActivateChild);
}
function isCanDeactivate(guard) {
  return guard && isFunction(guard.canDeactivate);
}
function isCanMatch(guard) {
  return guard && isFunction(guard.canMatch);
}
function isEmptyError(e) {
  return e instanceof rxjs__WEBPACK_IMPORTED_MODULE_11__.EmptyError || e?.name === 'EmptyError';
}
const INITIAL_VALUE = /* @__PURE__ */Symbol('INITIAL_VALUE');
function prioritizedGuardValue() {
  return (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_30__.switchMap)(obs => {
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_12__.combineLatest)(obs.map(o => o.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_31__.take)(1), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_29__.startWith)(INITIAL_VALUE)))).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.map)(results => {
      for (const result of results) {
        if (result === true) {
          continue;
        } else if (result === INITIAL_VALUE) {
          return INITIAL_VALUE;
        } else if (result === false || isRedirect(result)) {
          return result;
        }
      }
      return true;
    }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.filter)(item => item !== INITIAL_VALUE), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_31__.take)(1));
  });
}
function isRedirect(val) {
  return isUrlTree(val) || val instanceof RedirectCommand;
}
function abortSignalToObservable(signal) {
  if (signal.aborted) {
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(undefined).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_31__.take)(1));
  }
  return new rxjs__WEBPACK_IMPORTED_MODULE_5__.Observable(subscriber => {
    const handler = () => {
      subscriber.next();
      subscriber.complete();
    };
    signal.addEventListener('abort', handler);
    return () => signal.removeEventListener('abort', handler);
  });
}
function takeUntilAbort(signal) {
  return (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_33__.takeUntil)(abortSignalToObservable(signal));
}
function checkGuards(injector, forwardEvent) {
  return (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_27__.mergeMap)(t => {
    const {
      targetSnapshot,
      currentSnapshot,
      guards: {
        canActivateChecks,
        canDeactivateChecks
      }
    } = t;
    if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)({
        ...t,
        guardsResult: true
      });
    }
    return runCanDeactivateChecks(canDeactivateChecks, targetSnapshot, currentSnapshot, injector).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_27__.mergeMap)(canDeactivate => {
      return canDeactivate && isBoolean(canDeactivate) ? runCanActivateChecks(targetSnapshot, canActivateChecks, injector, forwardEvent) : (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(canDeactivate);
    }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.map)(guardsResult => ({
      ...t,
      guardsResult
    })));
  });
}
function runCanDeactivateChecks(checks, futureRSS, currRSS, injector) {
  return (0,rxjs__WEBPACK_IMPORTED_MODULE_15__.from)(checks).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_27__.mergeMap)(check => runCanDeactivate(check.component, check.route, currRSS, futureRSS, injector)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_24__.first)(result => {
    return result !== true;
  }, true));
}
function runCanActivateChecks(futureSnapshot, checks, injector, forwardEvent) {
  return (0,rxjs__WEBPACK_IMPORTED_MODULE_15__.from)(checks).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_20__.concatMap)(check => {
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_13__.concat)(fireChildActivationStart(check.route.parent, forwardEvent), fireActivationStart(check.route, forwardEvent), runCanActivateChild(futureSnapshot, check.path, injector), runCanActivate(futureSnapshot, check.route, injector));
  }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_24__.first)(result => {
    return result !== true;
  }, true));
}
function fireActivationStart(snapshot, forwardEvent) {
  if (snapshot !== null && forwardEvent) {
    forwardEvent(new ActivationStart(snapshot));
  }
  return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(true);
}
function fireChildActivationStart(snapshot, forwardEvent) {
  if (snapshot !== null && forwardEvent) {
    forwardEvent(new ChildActivationStart(snapshot));
  }
  return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(true);
}
function runCanActivate(futureRSS, futureARS, injector) {
  const canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;
  if (!canActivate || canActivate.length === 0) return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(true);
  const canActivateObservables = canActivate.map(canActivate => {
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_14__.defer)(() => {
      const closestInjector = getClosestRouteInjector(futureARS) ?? injector;
      const guard = getTokenOrFunctionIdentity(canActivate, closestInjector);
      const guardVal = isCanActivate(guard) ? guard.canActivate(futureARS, futureRSS) : (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.runInInjectionContext)(closestInjector, () => guard(futureARS, futureRSS));
      return wrapIntoObservable(guardVal).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_24__.first)());
    });
  });
  return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(canActivateObservables).pipe(prioritizedGuardValue());
}
function runCanActivateChild(futureRSS, path, injector) {
  const futureARS = path[path.length - 1];
  const canActivateChildGuards = path.slice(0, path.length - 1).reverse().map(p => getCanActivateChild(p)).filter(_ => _ !== null);
  const canActivateChildGuardsMapped = canActivateChildGuards.map(d => {
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_14__.defer)(() => {
      const guardsMapped = d.guards.map(canActivateChild => {
        const closestInjector = getClosestRouteInjector(d.node) ?? injector;
        const guard = getTokenOrFunctionIdentity(canActivateChild, closestInjector);
        const guardVal = isCanActivateChild(guard) ? guard.canActivateChild(futureARS, futureRSS) : (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.runInInjectionContext)(closestInjector, () => guard(futureARS, futureRSS));
        return wrapIntoObservable(guardVal).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_24__.first)());
      });
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(guardsMapped).pipe(prioritizedGuardValue());
    });
  });
  return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());
}
function runCanDeactivate(component, currARS, currRSS, futureRSS, injector) {
  const canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;
  if (!canDeactivate || canDeactivate.length === 0) return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(true);
  const canDeactivateObservables = canDeactivate.map(c => {
    const closestInjector = getClosestRouteInjector(currARS) ?? injector;
    const guard = getTokenOrFunctionIdentity(c, closestInjector);
    const guardVal = isCanDeactivate(guard) ? guard.canDeactivate(component, currARS, currRSS, futureRSS) : (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.runInInjectionContext)(closestInjector, () => guard(component, currARS, currRSS, futureRSS));
    return wrapIntoObservable(guardVal).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_24__.first)());
  });
  return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(canDeactivateObservables).pipe(prioritizedGuardValue());
}
function runCanLoadGuards(injector, route, segments, urlSerializer, abortSignal) {
  const canLoad = route.canLoad;
  if (canLoad === undefined || canLoad.length === 0) {
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(true);
  }
  const canLoadObservables = canLoad.map(injectionToken => {
    const guard = getTokenOrFunctionIdentity(injectionToken, injector);
    const guardVal = isCanLoad(guard) ? guard.canLoad(route, segments) : (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.runInInjectionContext)(injector, () => guard(route, segments));
    const obs$ = wrapIntoObservable(guardVal);
    return abortSignal ? obs$.pipe(takeUntilAbort(abortSignal)) : obs$;
  });
  return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(canLoadObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));
}
function redirectIfUrlTree(urlSerializer) {
  return (0,rxjs__WEBPACK_IMPORTED_MODULE_9__.pipe)((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_34__.tap)(result => {
    if (typeof result === 'boolean') return;
    throw redirectingNavigationError(urlSerializer, result);
  }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.map)(result => result === true));
}
function runCanMatchGuards(injector, route, segments, urlSerializer, abortSignal) {
  const canMatch = route.canMatch;
  if (!canMatch || canMatch.length === 0) return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(true);
  const canMatchObservables = canMatch.map(injectionToken => {
    const guard = getTokenOrFunctionIdentity(injectionToken, injector);
    const guardVal = isCanMatch(guard) ? guard.canMatch(route, segments) : (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.runInInjectionContext)(injector, () => guard(route, segments));
    let obs$ = wrapIntoObservable(guardVal);
    return abortSignal ? obs$.pipe(takeUntilAbort(abortSignal)) : obs$;
  });
  return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(canMatchObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));
}
let NoMatch$1 = class NoMatch extends Error {
  segmentGroup;
  constructor(segmentGroup) {
    super();
    this.segmentGroup = segmentGroup || null;
    Object.setPrototypeOf(this, NoMatch.prototype);
  }
};
let AbsoluteRedirect$1 = class AbsoluteRedirect extends Error {
  urlTree;
  constructor(urlTree) {
    super();
    this.urlTree = urlTree;
    Object.setPrototypeOf(this, AbsoluteRedirect.prototype);
  }
};
function namedOutletsRedirect$1(redirectTo) {
  throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4000, (typeof ngDevMode === 'undefined' || ngDevMode) && `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`);
}
function canLoadFails$1(route) {
  throw navigationCancelingError((typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot load children because the guard of the route "path: '${route.path}'" returned false`, NavigationCancellationCode.GuardRejected);
}
let ApplyRedirects$1 = class ApplyRedirects {
  urlSerializer;
  urlTree;
  constructor(urlSerializer, urlTree) {
    this.urlSerializer = urlSerializer;
    this.urlTree = urlTree;
  }
  lineralizeSegments(route, urlTree) {
    return (0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      let res = [];
      let c = urlTree.root;
      while (true) {
        res = res.concat(c.segments);
        if (c.numberOfChildren === 0) {
          return res;
        }
        if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {
          throw namedOutletsRedirect$1(`${route.redirectTo}`);
        }
        c = c.children[PRIMARY_OUTLET];
      }
    })();
  }
  applyRedirectCommands(segments, redirectTo, posParams, currentSnapshot, injector) {
    var _this = this;
    return (0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const redirect = yield getRedirectResult$1(redirectTo, currentSnapshot, injector);
      if (redirect instanceof UrlTree) {
        throw new AbsoluteRedirect$1(redirect);
      }
      const newTree = _this.applyRedirectCreateUrlTree(redirect, _this.urlSerializer.parse(redirect), segments, posParams);
      if (redirect[0] === '/') {
        throw new AbsoluteRedirect$1(newTree);
      }
      return newTree;
    })();
  }
  applyRedirectCreateUrlTree(redirectTo, urlTree, segments, posParams) {
    const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);
    return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);
  }
  createQueryParams(redirectToParams, actualParams) {
    const res = {};
    Object.entries(redirectToParams).forEach(([k, v]) => {
      const copySourceValue = typeof v === 'string' && v[0] === ':';
      if (copySourceValue) {
        const sourceName = v.substring(1);
        res[k] = actualParams[sourceName];
      } else {
        res[k] = v;
      }
    });
    return res;
  }
  createSegmentGroup(redirectTo, group, segments, posParams) {
    const updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);
    let children = {};
    Object.entries(group.children).forEach(([name, child]) => {
      children[name] = this.createSegmentGroup(redirectTo, child, segments, posParams);
    });
    return new UrlSegmentGroup(updatedSegments, children);
  }
  createSegments(redirectTo, redirectToSegments, actualSegments, posParams) {
    return redirectToSegments.map(s => s.path[0] === ':' ? this.findPosParam(redirectTo, s, posParams) : this.findOrReturn(s, actualSegments));
  }
  findPosParam(redirectTo, redirectToUrlSegment, posParams) {
    const pos = posParams[redirectToUrlSegment.path.substring(1)];
    if (!pos) throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4001, (typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`);
    return pos;
  }
  findOrReturn(redirectToUrlSegment, actualSegments) {
    let idx = 0;
    for (const s of actualSegments) {
      if (s.path === redirectToUrlSegment.path) {
        actualSegments.splice(idx);
        return s;
      }
      idx++;
    }
    return redirectToUrlSegment;
  }
};
function getRedirectResult$1(redirectTo, currentSnapshot, injector) {
  if (typeof redirectTo === 'string') {
    return Promise.resolve(redirectTo);
  }
  const redirectToFn = redirectTo;
  const {
    queryParams,
    fragment,
    routeConfig,
    url,
    outlet,
    params,
    data,
    title
  } = currentSnapshot;
  return firstValueFrom(wrapIntoObservable((0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.runInInjectionContext)(injector, () => redirectToFn({
    params,
    data,
    queryParams,
    fragment,
    routeConfig,
    url,
    outlet,
    title
  }))));
}
const noMatch$1 = {
  matched: false,
  consumedSegments: [],
  remainingSegments: [],
  parameters: {},
  positionalParamSegments: {}
};
function matchWithChecks(segmentGroup, route, segments, injector, urlSerializer, abortSignal) {
  const result = match(segmentGroup, route, segments);
  if (!result.matched) {
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(result);
  }
  injector = getOrCreateRouteInjectorIfNeeded(route, injector);
  return runCanMatchGuards(injector, route, segments, urlSerializer, abortSignal).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.map)(v => v === true ? result : {
    ...noMatch$1
  }));
}
function match(segmentGroup, route, segments) {
  if (route.path === '**') {
    return createWildcardMatchResult(segments);
  }
  if (route.path === '') {
    if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {
      return {
        ...noMatch$1
      };
    }
    return {
      matched: true,
      consumedSegments: [],
      remainingSegments: segments,
      parameters: {},
      positionalParamSegments: {}
    };
  }
  const matcher = route.matcher || defaultUrlMatcher;
  const res = matcher(segments, segmentGroup, route);
  if (!res) return {
    ...noMatch$1
  };
  const posParams = {};
  Object.entries(res.posParams ?? {}).forEach(([k, v]) => {
    posParams[k] = v.path;
  });
  const parameters = res.consumed.length > 0 ? {
    ...posParams,
    ...res.consumed[res.consumed.length - 1].parameters
  } : posParams;
  return {
    matched: true,
    consumedSegments: res.consumed,
    remainingSegments: segments.slice(res.consumed.length),
    parameters,
    positionalParamSegments: res.posParams ?? {}
  };
}
function createWildcardMatchResult(segments) {
  return {
    matched: true,
    parameters: segments.length > 0 ? last(segments).parameters : {},
    consumedSegments: segments,
    remainingSegments: [],
    positionalParamSegments: {}
  };
}
function split(segmentGroup, consumedSegments, slicedSegments, config) {
  if (slicedSegments.length > 0 && containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {
    const s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));
    return {
      segmentGroup: s,
      slicedSegments: []
    };
  }
  if (slicedSegments.length === 0 && containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {
    const s = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));
    return {
      segmentGroup: s,
      slicedSegments
    };
  }
  const s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);
  return {
    segmentGroup: s,
    slicedSegments
  };
}
function addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {
  const res = {};
  for (const r of routes) {
    if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {
      const s = new UrlSegmentGroup([], {});
      res[getOutlet(r)] = s;
    }
  }
  return {
    ...children,
    ...res
  };
}
function createChildrenForEmptyPaths(routes, primarySegment) {
  const res = {};
  res[PRIMARY_OUTLET] = primarySegment;
  for (const r of routes) {
    if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {
      const s = new UrlSegmentGroup([], {});
      res[getOutlet(r)] = s;
    }
  }
  return res;
}
function containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {
  return routes.some(r => emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet(r) !== PRIMARY_OUTLET);
}
function containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {
  return routes.some(r => emptyPathMatch(segmentGroup, slicedSegments, r));
}
function emptyPathMatch(segmentGroup, slicedSegments, r) {
  if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {
    return false;
  }
  return r.path === '';
}
function noLeftoversInUrl(segmentGroup, segments, outlet) {
  return segments.length === 0 && !segmentGroup.children[outlet];
}
let NoLeftoversInUrl$1 = class NoLeftoversInUrl {};
function recognize$2(_x, _x2, _x3, _x4, _x5, _x6) {
  return _recognize$.apply(this, arguments);
}
function _recognize$() {
  _recognize$ = (0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (injector, configLoader, rootComponentType, config, urlTree, urlSerializer, paramsInheritanceStrategy = 'emptyOnly', abortSignal) {
    return new Recognizer$1(injector, configLoader, rootComponentType, config, urlTree, paramsInheritanceStrategy, urlSerializer, abortSignal).recognize();
  });
  return _recognize$.apply(this, arguments);
}
const MAX_ALLOWED_REDIRECTS$1 = 31;
let Recognizer$1 = class Recognizer {
  injector;
  configLoader;
  rootComponentType;
  config;
  urlTree;
  paramsInheritanceStrategy;
  urlSerializer;
  abortSignal;
  applyRedirects;
  absoluteRedirectCount = 0;
  allowRedirects = true;
  constructor(injector, configLoader, rootComponentType, config, urlTree, paramsInheritanceStrategy, urlSerializer, abortSignal) {
    this.injector = injector;
    this.configLoader = configLoader;
    this.rootComponentType = rootComponentType;
    this.config = config;
    this.urlTree = urlTree;
    this.paramsInheritanceStrategy = paramsInheritanceStrategy;
    this.urlSerializer = urlSerializer;
    this.abortSignal = abortSignal;
    this.applyRedirects = new ApplyRedirects$1(this.urlSerializer, this.urlTree);
  }
  noMatchError(e) {
    return new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4002, typeof ngDevMode === 'undefined' || ngDevMode ? `Cannot match any routes. URL Segment: '${e.segmentGroup}'` : `'${e.segmentGroup}'`);
  }
  recognize() {
    var _this2 = this;
    return (0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const rootSegmentGroup = split(_this2.urlTree.root, [], [], _this2.config).segmentGroup;
      const {
        children,
        rootSnapshot
      } = yield _this2.match(rootSegmentGroup);
      const rootNode = new TreeNode(rootSnapshot, children);
      const routeState = new RouterStateSnapshot('', rootNode);
      const tree = createUrlTreeFromSnapshot(rootSnapshot, [], _this2.urlTree.queryParams, _this2.urlTree.fragment);
      tree.queryParams = _this2.urlTree.queryParams;
      routeState.url = _this2.urlSerializer.serialize(tree);
      return {
        state: routeState,
        tree
      };
    })();
  }
  match(rootSegmentGroup) {
    var _this3 = this;
    return (0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const rootSnapshot = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze({
        ..._this3.urlTree.queryParams
      }), _this3.urlTree.fragment, Object.freeze({}), PRIMARY_OUTLET, _this3.rootComponentType, null, {});
      try {
        const children = yield _this3.processSegmentGroup(_this3.injector, _this3.config, rootSegmentGroup, PRIMARY_OUTLET, rootSnapshot);
        return {
          children,
          rootSnapshot
        };
      } catch (e) {
        if (e instanceof AbsoluteRedirect$1) {
          _this3.urlTree = e.urlTree;
          return _this3.match(e.urlTree.root);
        }
        if (e instanceof NoMatch$1) {
          throw _this3.noMatchError(e);
        }
        throw e;
      }
    })();
  }
  processSegmentGroup(injector, config, segmentGroup, outlet, parentRoute) {
    var _this4 = this;
    return (0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
        return _this4.processChildren(injector, config, segmentGroup, parentRoute);
      }
      const child = yield _this4.processSegment(injector, config, segmentGroup, segmentGroup.segments, outlet, true, parentRoute);
      return child instanceof TreeNode ? [child] : [];
    })();
  }
  processChildren(injector, config, segmentGroup, parentRoute) {
    var _this5 = this;
    return (0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const childOutlets = [];
      for (const child of Object.keys(segmentGroup.children)) {
        if (child === 'primary') {
          childOutlets.unshift(child);
        } else {
          childOutlets.push(child);
        }
      }
      let children = [];
      for (const childOutlet of childOutlets) {
        const child = segmentGroup.children[childOutlet];
        const sortedConfig = sortByMatchingOutlets(config, childOutlet);
        const outletChildren = yield _this5.processSegmentGroup(injector, sortedConfig, child, childOutlet, parentRoute);
        children.push(...outletChildren);
      }
      const mergedChildren = mergeEmptyPathMatches$1(children);
      if (typeof ngDevMode === 'undefined' || ngDevMode) {
        checkOutletNameUniqueness$1(mergedChildren);
      }
      sortActivatedRouteSnapshots$1(mergedChildren);
      return mergedChildren;
    })();
  }
  processSegment(injector, routes, segmentGroup, segments, outlet, allowRedirects, parentRoute) {
    var _this6 = this;
    return (0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      for (const r of routes) {
        try {
          return yield _this6.processSegmentAgainstRoute(r._injector ?? injector, routes, r, segmentGroup, segments, outlet, allowRedirects, parentRoute);
        } catch (e) {
          if (e instanceof NoMatch$1 || isEmptyError(e)) {
            continue;
          }
          throw e;
        }
      }
      if (noLeftoversInUrl(segmentGroup, segments, outlet)) {
        return new NoLeftoversInUrl$1();
      }
      throw new NoMatch$1(segmentGroup);
    })();
  }
  processSegmentAgainstRoute(injector, routes, route, rawSegment, segments, outlet, allowRedirects, parentRoute) {
    var _this7 = this;
    return (0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (getOutlet(route) !== outlet && (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))) {
        throw new NoMatch$1(rawSegment);
      }
      if (route.redirectTo === undefined) {
        return _this7.matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute);
      }
      if (_this7.allowRedirects && allowRedirects) {
        return _this7.expandSegmentAgainstRouteUsingRedirect(injector, rawSegment, routes, route, segments, outlet, parentRoute);
      }
      throw new NoMatch$1(rawSegment);
    })();
  }
  expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, segments, outlet, parentRoute) {
    var _this8 = this;
    return (0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const {
        matched,
        parameters,
        consumedSegments,
        positionalParamSegments,
        remainingSegments
      } = match(segmentGroup, route, segments);
      if (!matched) throw new NoMatch$1(segmentGroup);
      if (typeof route.redirectTo === 'string' && route.redirectTo[0] === '/') {
        _this8.absoluteRedirectCount++;
        if (_this8.absoluteRedirectCount > MAX_ALLOWED_REDIRECTS$1) {
          if (ngDevMode) {
            throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4016, `Detected possible infinite redirect when redirecting from '${_this8.urlTree}' to '${route.redirectTo}'.\n` + `This is currently a dev mode only error but will become a` + ` call stack size exceeded error in production in a future major version.`);
          }
          _this8.allowRedirects = false;
        }
      }
      const currentSnapshot = new ActivatedRouteSnapshot(segments, parameters, Object.freeze({
        ..._this8.urlTree.queryParams
      }), _this8.urlTree.fragment, getData$1(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve$1(route));
      const inherited = getInherited(currentSnapshot, parentRoute, _this8.paramsInheritanceStrategy);
      currentSnapshot.params = Object.freeze(inherited.params);
      currentSnapshot.data = Object.freeze(inherited.data);
      if (_this8.abortSignal.aborted) {
        throw new Error(_this8.abortSignal.reason);
      }
      const newTree = yield _this8.applyRedirects.applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments, currentSnapshot, injector);
      const newSegments = yield _this8.applyRedirects.lineralizeSegments(route, newTree);
      return _this8.processSegment(injector, routes, segmentGroup, newSegments.concat(remainingSegments), outlet, false, parentRoute);
    })();
  }
  matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute) {
    var _this9 = this;
    return (0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (_this9.abortSignal.aborted) {
        throw new Error(_this9.abortSignal.reason);
      }
      const result = yield firstValueFrom(matchWithChecks(rawSegment, route, segments, injector, _this9.urlSerializer, _this9.abortSignal));
      if (route.path === '**') {
        rawSegment.children = {};
      }
      if (!result?.matched) {
        throw new NoMatch$1(rawSegment);
      }
      injector = route._injector ?? injector;
      const {
        routes: childConfig
      } = yield _this9.getChildConfig(injector, route, segments);
      const childInjector = route._loadedInjector ?? injector;
      const {
        parameters,
        consumedSegments,
        remainingSegments
      } = result;
      const snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze({
        ..._this9.urlTree.queryParams
      }), _this9.urlTree.fragment, getData$1(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve$1(route));
      const inherited = getInherited(snapshot, parentRoute, _this9.paramsInheritanceStrategy);
      snapshot.params = Object.freeze(inherited.params);
      snapshot.data = Object.freeze(inherited.data);
      const {
        segmentGroup,
        slicedSegments
      } = split(rawSegment, consumedSegments, remainingSegments, childConfig);
      if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
        const children = yield _this9.processChildren(childInjector, childConfig, segmentGroup, snapshot);
        return new TreeNode(snapshot, children);
      }
      if (childConfig.length === 0 && slicedSegments.length === 0) {
        return new TreeNode(snapshot, []);
      }
      const matchedOnOutlet = getOutlet(route) === outlet;
      const child = yield _this9.processSegment(childInjector, childConfig, segmentGroup, slicedSegments, matchedOnOutlet ? PRIMARY_OUTLET : outlet, true, snapshot);
      return new TreeNode(snapshot, child instanceof TreeNode ? [child] : []);
    })();
  }
  getChildConfig(injector, route, segments) {
    var _this0 = this;
    return (0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (route.children) {
        return {
          routes: route.children,
          injector
        };
      }
      if (route.loadChildren) {
        if (route._loadedRoutes !== undefined) {
          return {
            routes: route._loadedRoutes,
            injector: route._loadedInjector
          };
        }
        if (_this0.abortSignal.aborted) {
          throw new Error(_this0.abortSignal.reason);
        }
        const shouldLoadResult = yield firstValueFrom(runCanLoadGuards(injector, route, segments, _this0.urlSerializer, _this0.abortSignal));
        if (shouldLoadResult) {
          const cfg = yield _this0.configLoader.loadChildren(injector, route);
          route._loadedRoutes = cfg.routes;
          route._loadedInjector = cfg.injector;
          return cfg;
        }
        throw canLoadFails$1(route);
      }
      return {
        routes: [],
        injector
      };
    })();
  }
};
function sortActivatedRouteSnapshots$1(nodes) {
  nodes.sort((a, b) => {
    if (a.value.outlet === PRIMARY_OUTLET) return -1;
    if (b.value.outlet === PRIMARY_OUTLET) return 1;
    return a.value.outlet.localeCompare(b.value.outlet);
  });
}
function hasEmptyPathConfig$1(node) {
  const config = node.value.routeConfig;
  return config && config.path === '';
}
function mergeEmptyPathMatches$1(nodes) {
  const result = [];
  const mergedNodes = new Set();
  for (const node of nodes) {
    if (!hasEmptyPathConfig$1(node)) {
      result.push(node);
      continue;
    }
    const duplicateEmptyPathNode = result.find(resultNode => node.value.routeConfig === resultNode.value.routeConfig);
    if (duplicateEmptyPathNode !== undefined) {
      duplicateEmptyPathNode.children.push(...node.children);
      mergedNodes.add(duplicateEmptyPathNode);
    } else {
      result.push(node);
    }
  }
  for (const mergedNode of mergedNodes) {
    const mergedChildren = mergeEmptyPathMatches$1(mergedNode.children);
    result.push(new TreeNode(mergedNode.value, mergedChildren));
  }
  return result.filter(n => !mergedNodes.has(n));
}
function checkOutletNameUniqueness$1(nodes) {
  const names = {};
  nodes.forEach(n => {
    const routeWithSameOutletName = names[n.value.outlet];
    if (routeWithSameOutletName) {
      const p = routeWithSameOutletName.url.map(s => s.toString()).join('/');
      const c = n.value.url.map(s => s.toString()).join('/');
      throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4006, (typeof ngDevMode === 'undefined' || ngDevMode) && `Two segments cannot have the same outlet name: '${p}' and '${c}'.`);
    }
    names[n.value.outlet] = n.value;
  });
}
function getData$1(route) {
  return route.data || {};
}
function getResolve$1(route) {
  return route.resolve || {};
}
class NoMatch {
  segmentGroup;
  constructor(segmentGroup) {
    this.segmentGroup = segmentGroup || null;
  }
}
class AbsoluteRedirect extends Error {
  urlTree;
  constructor(urlTree) {
    super();
    this.urlTree = urlTree;
  }
}
function noMatch(segmentGroup) {
  return (0,rxjs__WEBPACK_IMPORTED_MODULE_17__.throwError)(new NoMatch(segmentGroup));
}
function namedOutletsRedirect(redirectTo) {
  return (0,rxjs__WEBPACK_IMPORTED_MODULE_17__.throwError)(new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4000, (typeof ngDevMode === 'undefined' || ngDevMode) && `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`));
}
function canLoadFails(route) {
  return (0,rxjs__WEBPACK_IMPORTED_MODULE_17__.throwError)(navigationCancelingError((typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot load children because the guard of the route "path: '${route.path}'" returned false`, NavigationCancellationCode.GuardRejected));
}
class ApplyRedirects {
  urlSerializer;
  urlTree;
  constructor(urlSerializer, urlTree) {
    this.urlSerializer = urlSerializer;
    this.urlTree = urlTree;
  }
  lineralizeSegments(route, urlTree) {
    let res = [];
    let c = urlTree.root;
    while (true) {
      res = res.concat(c.segments);
      if (c.numberOfChildren === 0) {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(res);
      }
      if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {
        return namedOutletsRedirect(`${route.redirectTo}`);
      }
      c = c.children[PRIMARY_OUTLET];
    }
  }
  applyRedirectCommands(segments, redirectTo, posParams, currentSnapshot, injector) {
    return getRedirectResult(redirectTo, currentSnapshot, injector).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.map)(redirect => {
      if (redirect instanceof UrlTree) {
        throw new AbsoluteRedirect(redirect);
      }
      const newTree = this.applyRedirectCreateUrlTree(redirect, this.urlSerializer.parse(redirect), segments, posParams);
      if (redirect[0] === '/') {
        throw new AbsoluteRedirect(newTree);
      }
      return newTree;
    }));
  }
  applyRedirectCreateUrlTree(redirectTo, urlTree, segments, posParams) {
    const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);
    return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);
  }
  createQueryParams(redirectToParams, actualParams) {
    const res = {};
    Object.entries(redirectToParams).forEach(([k, v]) => {
      const copySourceValue = typeof v === 'string' && v[0] === ':';
      if (copySourceValue) {
        const sourceName = v.substring(1);
        res[k] = actualParams[sourceName];
      } else {
        res[k] = v;
      }
    });
    return res;
  }
  createSegmentGroup(redirectTo, group, segments, posParams) {
    const updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);
    let children = {};
    Object.entries(group.children).forEach(([name, child]) => {
      children[name] = this.createSegmentGroup(redirectTo, child, segments, posParams);
    });
    return new UrlSegmentGroup(updatedSegments, children);
  }
  createSegments(redirectTo, redirectToSegments, actualSegments, posParams) {
    return redirectToSegments.map(s => s.path[0] === ':' ? this.findPosParam(redirectTo, s, posParams) : this.findOrReturn(s, actualSegments));
  }
  findPosParam(redirectTo, redirectToUrlSegment, posParams) {
    const pos = posParams[redirectToUrlSegment.path.substring(1)];
    if (!pos) throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4001, (typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`);
    return pos;
  }
  findOrReturn(redirectToUrlSegment, actualSegments) {
    let idx = 0;
    for (const s of actualSegments) {
      if (s.path === redirectToUrlSegment.path) {
        actualSegments.splice(idx);
        return s;
      }
      idx++;
    }
    return redirectToUrlSegment;
  }
}
function getRedirectResult(redirectTo, currentSnapshot, injector) {
  if (typeof redirectTo === 'string') {
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(redirectTo);
  }
  const redirectToFn = redirectTo;
  const {
    queryParams,
    fragment,
    routeConfig,
    url,
    outlet,
    params,
    data,
    title
  } = currentSnapshot;
  return wrapIntoObservable((0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.runInInjectionContext)(injector, () => redirectToFn({
    params,
    data,
    queryParams,
    fragment,
    routeConfig,
    url,
    outlet,
    title
  })));
}
class NoLeftoversInUrl {}
function recognize$1(injector, configLoader, rootComponentType, config, urlTree, urlSerializer, paramsInheritanceStrategy = 'emptyOnly', abortSignal) {
  return new Recognizer(injector, configLoader, rootComponentType, config, urlTree, paramsInheritanceStrategy, urlSerializer).recognize();
}
const MAX_ALLOWED_REDIRECTS = 31;
class Recognizer {
  injector;
  configLoader;
  rootComponentType;
  config;
  urlTree;
  paramsInheritanceStrategy;
  urlSerializer;
  applyRedirects;
  absoluteRedirectCount = 0;
  allowRedirects = true;
  constructor(injector, configLoader, rootComponentType, config, urlTree, paramsInheritanceStrategy, urlSerializer) {
    this.injector = injector;
    this.configLoader = configLoader;
    this.rootComponentType = rootComponentType;
    this.config = config;
    this.urlTree = urlTree;
    this.paramsInheritanceStrategy = paramsInheritanceStrategy;
    this.urlSerializer = urlSerializer;
    this.applyRedirects = new ApplyRedirects(this.urlSerializer, this.urlTree);
  }
  noMatchError(e) {
    return new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4002, typeof ngDevMode === 'undefined' || ngDevMode ? `Cannot match any routes. URL Segment: '${e.segmentGroup}'` : `'${e.segmentGroup}'`);
  }
  recognize() {
    const rootSegmentGroup = split(this.urlTree.root, [], [], this.config).segmentGroup;
    return this.match(rootSegmentGroup).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.map)(({
      children,
      rootSnapshot
    }) => {
      const rootNode = new TreeNode(rootSnapshot, children);
      const routeState = new RouterStateSnapshot('', rootNode);
      const tree = createUrlTreeFromSnapshot(rootSnapshot, [], this.urlTree.queryParams, this.urlTree.fragment);
      tree.queryParams = this.urlTree.queryParams;
      routeState.url = this.urlSerializer.serialize(tree);
      return {
        state: routeState,
        tree
      };
    }));
  }
  match(rootSegmentGroup) {
    const rootSnapshot = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze({
      ...this.urlTree.queryParams
    }), this.urlTree.fragment, Object.freeze({}), PRIMARY_OUTLET, this.rootComponentType, null, {});
    return this.processSegmentGroup(this.injector, this.config, rootSegmentGroup, PRIMARY_OUTLET, rootSnapshot).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.map)(children => {
      return {
        children,
        rootSnapshot
      };
    }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_19__.catchError)(e => {
      if (e instanceof AbsoluteRedirect) {
        this.urlTree = e.urlTree;
        return this.match(e.urlTree.root);
      }
      if (e instanceof NoMatch) {
        throw this.noMatchError(e);
      }
      throw e;
    }));
  }
  processSegmentGroup(injector, config, segmentGroup, outlet, parentRoute) {
    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
      return this.processChildren(injector, config, segmentGroup, parentRoute);
    }
    return this.processSegment(injector, config, segmentGroup, segmentGroup.segments, outlet, true, parentRoute).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.map)(child => child instanceof TreeNode ? [child] : []));
  }
  processChildren(injector, config, segmentGroup, parentRoute) {
    const childOutlets = [];
    for (const child of Object.keys(segmentGroup.children)) {
      if (child === 'primary') {
        childOutlets.unshift(child);
      } else {
        childOutlets.push(child);
      }
    }
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_15__.from)(childOutlets).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_20__.concatMap)(childOutlet => {
      const child = segmentGroup.children[childOutlet];
      const sortedConfig = sortByMatchingOutlets(config, childOutlet);
      return this.processSegmentGroup(injector, sortedConfig, child, childOutlet, parentRoute);
    }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_28__.scan)((children, outletChildren) => {
      children.push(...outletChildren);
      return children;
    }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_21__.defaultIfEmpty)(null), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_25__.last)(), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_27__.mergeMap)(children => {
      if (children === null) return noMatch(segmentGroup);
      const mergedChildren = mergeEmptyPathMatches(children);
      if (typeof ngDevMode === 'undefined' || ngDevMode) {
        checkOutletNameUniqueness(mergedChildren);
      }
      sortActivatedRouteSnapshots(mergedChildren);
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(mergedChildren);
    }));
  }
  processSegment(injector, routes, segmentGroup, segments, outlet, allowRedirects, parentRoute) {
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_15__.from)(routes).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_20__.concatMap)(r => {
      return this.processSegmentAgainstRoute(r._injector ?? injector, routes, r, segmentGroup, segments, outlet, allowRedirects, parentRoute).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_19__.catchError)(e => {
        if (e instanceof NoMatch) {
          return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(null);
        }
        throw e;
      }));
    }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_24__.first)(x => !!x), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_19__.catchError)(e => {
      if (isEmptyError(e)) {
        if (noLeftoversInUrl(segmentGroup, segments, outlet)) {
          return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(new NoLeftoversInUrl());
        }
        return noMatch(segmentGroup);
      }
      throw e;
    }));
  }
  processSegmentAgainstRoute(injector, routes, route, rawSegment, segments, outlet, allowRedirects, parentRoute) {
    if (getOutlet(route) !== outlet && (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))) {
      return noMatch(rawSegment);
    }
    if (route.redirectTo === undefined) {
      return this.matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute);
    }
    if (this.allowRedirects && allowRedirects) {
      return this.expandSegmentAgainstRouteUsingRedirect(injector, rawSegment, routes, route, segments, outlet, parentRoute);
    }
    return noMatch(rawSegment);
  }
  expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, segments, outlet, parentRoute) {
    const {
      matched,
      parameters,
      consumedSegments,
      positionalParamSegments,
      remainingSegments
    } = match(segmentGroup, route, segments);
    if (!matched) return noMatch(segmentGroup);
    if (typeof route.redirectTo === 'string' && route.redirectTo[0] === '/') {
      this.absoluteRedirectCount++;
      if (this.absoluteRedirectCount > MAX_ALLOWED_REDIRECTS) {
        if (ngDevMode) {
          throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4016, `Detected possible infinite redirect when redirecting from '${this.urlTree}' to '${route.redirectTo}'.\n` + `This is currently a dev mode only error but will become a` + ` call stack size exceeded error in production in a future major version.`);
        }
        this.allowRedirects = false;
      }
    }
    const currentSnapshot = new ActivatedRouteSnapshot(segments, parameters, Object.freeze({
      ...this.urlTree.queryParams
    }), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve(route));
    const inherited = getInherited(currentSnapshot, parentRoute, this.paramsInheritanceStrategy);
    currentSnapshot.params = Object.freeze(inherited.params);
    currentSnapshot.data = Object.freeze(inherited.data);
    const newTree$ = this.applyRedirects.applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments, currentSnapshot, injector);
    return newTree$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_30__.switchMap)(newTree => this.applyRedirects.lineralizeSegments(route, newTree)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_27__.mergeMap)(newSegments => {
      return this.processSegment(injector, routes, segmentGroup, newSegments.concat(remainingSegments), outlet, false, parentRoute);
    }));
  }
  matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute) {
    const matchResult = matchWithChecks(rawSegment, route, segments, injector, this.urlSerializer);
    if (route.path === '**') {
      rawSegment.children = {};
    }
    return matchResult.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_30__.switchMap)(result => {
      if (!result.matched) {
        return noMatch(rawSegment);
      }
      injector = route._injector ?? injector;
      return this.getChildConfig(injector, route, segments).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_30__.switchMap)(({
        routes: childConfig
      }) => {
        const childInjector = route._loadedInjector ?? injector;
        const {
          parameters,
          consumedSegments,
          remainingSegments
        } = result;
        const snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze({
          ...this.urlTree.queryParams
        }), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve(route));
        const inherited = getInherited(snapshot, parentRoute, this.paramsInheritanceStrategy);
        snapshot.params = Object.freeze(inherited.params);
        snapshot.data = Object.freeze(inherited.data);
        const {
          segmentGroup,
          slicedSegments
        } = split(rawSegment, consumedSegments, remainingSegments, childConfig);
        if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
          return this.processChildren(childInjector, childConfig, segmentGroup, snapshot).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.map)(children => {
            return new TreeNode(snapshot, children);
          }));
        }
        if (childConfig.length === 0 && slicedSegments.length === 0) {
          return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(new TreeNode(snapshot, []));
        }
        const matchedOnOutlet = getOutlet(route) === outlet;
        return this.processSegment(childInjector, childConfig, segmentGroup, slicedSegments, matchedOnOutlet ? PRIMARY_OUTLET : outlet, true, snapshot).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.map)(child => {
          return new TreeNode(snapshot, child instanceof TreeNode ? [child] : []);
        }));
      }));
    }));
  }
  getChildConfig(injector, route, segments) {
    if (route.children) {
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)({
        routes: route.children,
        injector
      });
    }
    if (route.loadChildren) {
      if (route._loadedRoutes !== undefined) {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)({
          routes: route._loadedRoutes,
          injector: route._loadedInjector
        });
      }
      return runCanLoadGuards(injector, route, segments, this.urlSerializer).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_27__.mergeMap)(shouldLoadResult => {
        if (shouldLoadResult) {
          return (0,rxjs__WEBPACK_IMPORTED_MODULE_15__.from)(this.configLoader.loadChildren(injector, route)).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_34__.tap)(cfg => {
            route._loadedRoutes = cfg.routes;
            route._loadedInjector = cfg.injector;
          }));
        }
        return canLoadFails(route);
      }));
    }
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)({
      routes: [],
      injector
    });
  }
}
function sortActivatedRouteSnapshots(nodes) {
  nodes.sort((a, b) => {
    if (a.value.outlet === PRIMARY_OUTLET) return -1;
    if (b.value.outlet === PRIMARY_OUTLET) return 1;
    return a.value.outlet.localeCompare(b.value.outlet);
  });
}
function hasEmptyPathConfig(node) {
  const config = node.value.routeConfig;
  return config && config.path === '';
}
function mergeEmptyPathMatches(nodes) {
  const result = [];
  const mergedNodes = new Set();
  for (const node of nodes) {
    if (!hasEmptyPathConfig(node)) {
      result.push(node);
      continue;
    }
    const duplicateEmptyPathNode = result.find(resultNode => node.value.routeConfig === resultNode.value.routeConfig);
    if (duplicateEmptyPathNode !== undefined) {
      duplicateEmptyPathNode.children.push(...node.children);
      mergedNodes.add(duplicateEmptyPathNode);
    } else {
      result.push(node);
    }
  }
  for (const mergedNode of mergedNodes) {
    const mergedChildren = mergeEmptyPathMatches(mergedNode.children);
    result.push(new TreeNode(mergedNode.value, mergedChildren));
  }
  return result.filter(n => !mergedNodes.has(n));
}
function checkOutletNameUniqueness(nodes) {
  const names = {};
  nodes.forEach(n => {
    const routeWithSameOutletName = names[n.value.outlet];
    if (routeWithSameOutletName) {
      const p = routeWithSameOutletName.url.map(s => s.toString()).join('/');
      const c = n.value.url.map(s => s.toString()).join('/');
      throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4006, (typeof ngDevMode === 'undefined' || ngDevMode) && `Two segments cannot have the same outlet name: '${p}' and '${c}'.`);
    }
    names[n.value.outlet] = n.value;
  });
}
function getData(route) {
  return route.data || {};
}
function getResolve(route) {
  return route.resolve || {};
}
const RECOGNIZE_IMPL = new _angular_common__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'RECOGNIZE_IMPL' : '', {
  factory: () => {
    return recognize$2;
  }
});
function provideSometimesSyncRecognize() {
  return (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.makeEnvironmentProviders)([{
    provide: RECOGNIZE_IMPL,
    useValue: recognize$1
  }]);
}
function recognize(injector, configLoader, rootComponentType, config, serializer, paramsInheritanceStrategy, abortSignal) {
  const recognizeImpl = injector.get(RECOGNIZE_IMPL);
  return (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_27__.mergeMap)(t => (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(t).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_30__.switchMap)(t => recognizeImpl(injector, configLoader, rootComponentType, config, t.extractedUrl, serializer, paramsInheritanceStrategy, abortSignal)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.map)(({
    state: targetSnapshot,
    tree: urlAfterRedirects
  }) => {
    return {
      ...t,
      targetSnapshot,
      urlAfterRedirects
    };
  })));
}
function resolveData(paramsInheritanceStrategy, injector) {
  return (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_27__.mergeMap)(t => {
    const {
      targetSnapshot,
      guards: {
        canActivateChecks
      }
    } = t;
    if (!canActivateChecks.length) {
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(t);
    }
    const routesWithResolversToRun = new Set(canActivateChecks.map(check => check.route));
    const routesNeedingDataUpdates = new Set();
    for (const route of routesWithResolversToRun) {
      if (routesNeedingDataUpdates.has(route)) {
        continue;
      }
      for (const newRoute of flattenRouteTree(route)) {
        routesNeedingDataUpdates.add(newRoute);
      }
    }
    let routesProcessed = 0;
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_15__.from)(routesNeedingDataUpdates).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_20__.concatMap)(route => {
      if (routesWithResolversToRun.has(route)) {
        return runResolve(route, targetSnapshot, paramsInheritanceStrategy, injector);
      } else {
        route.data = getInherited(route, route.parent, paramsInheritanceStrategy).resolve;
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(void 0);
      }
    }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_34__.tap)(() => routesProcessed++), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_32__.takeLast)(1), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_27__.mergeMap)(_ => routesProcessed === routesNeedingDataUpdates.size ? (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(t) : rxjs__WEBPACK_IMPORTED_MODULE_18__.EMPTY));
  });
}
function flattenRouteTree(route) {
  const descendants = route.children.map(child => flattenRouteTree(child)).flat();
  return [route, ...descendants];
}
function runResolve(futureARS, futureRSS, paramsInheritanceStrategy, injector) {
  const config = futureARS.routeConfig;
  const resolve = futureARS._resolve;
  if (config?.title !== undefined && !hasStaticTitle(config)) {
    resolve[RouteTitleKey] = config.title;
  }
  return (0,rxjs__WEBPACK_IMPORTED_MODULE_14__.defer)(() => {
    futureARS.data = getInherited(futureARS, futureARS.parent, paramsInheritanceStrategy).resolve;
    return resolveNode(resolve, futureARS, futureRSS, injector).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.map)(resolvedData => {
      futureARS._resolvedData = resolvedData;
      futureARS.data = {
        ...futureARS.data,
        ...resolvedData
      };
      return null;
    }));
  });
}
function resolveNode(resolve, futureARS, futureRSS, injector) {
  const keys = getDataKeys(resolve);
  if (keys.length === 0) {
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)({});
  }
  const data = {};
  return (0,rxjs__WEBPACK_IMPORTED_MODULE_15__.from)(keys).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_27__.mergeMap)(key => getResolver(resolve[key], futureARS, futureRSS, injector).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_24__.first)(), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_34__.tap)(value => {
    if (value instanceof RedirectCommand) {
      throw redirectingNavigationError(new DefaultUrlSerializer(), value);
    }
    data[key] = value;
  }))), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_32__.takeLast)(1), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.map)(() => data), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_19__.catchError)(e => isEmptyError(e) ? rxjs__WEBPACK_IMPORTED_MODULE_18__.EMPTY : (0,rxjs__WEBPACK_IMPORTED_MODULE_17__.throwError)(e)));
}
function getResolver(injectionToken, futureARS, futureRSS, injector) {
  const closestInjector = getClosestRouteInjector(futureARS) ?? injector;
  const resolver = getTokenOrFunctionIdentity(injectionToken, closestInjector);
  const resolverValue = resolver.resolve ? resolver.resolve(futureARS, futureRSS) : (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.runInInjectionContext)(closestInjector, () => resolver(futureARS, futureRSS));
  return wrapIntoObservable(resolverValue);
}
function switchTap(next) {
  return (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_30__.switchMap)(v => {
    const nextResult = next(v);
    if (nextResult) {
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_15__.from)(nextResult).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.map)(() => v));
    }
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(v);
  });
}
class TitleStrategy {
  buildTitle(snapshot) {
    let pageTitle;
    let route = snapshot.root;
    while (route !== undefined) {
      pageTitle = this.getResolvedTitleForRoute(route) ?? pageTitle;
      route = route.children.find(child => child.outlet === PRIMARY_OUTLET);
    }
    return pageTitle;
  }
  getResolvedTitleForRoute(snapshot) {
    return snapshot.data[RouteTitleKey];
  }
  static ɵfac = function TitleStrategy_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || TitleStrategy)();
  };
  static ɵprov = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: TitleStrategy,
    factory: () => (() => (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(DefaultTitleStrategy))(),
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(TitleStrategy, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
    args: [{
      providedIn: 'root',
      useFactory: () => (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(DefaultTitleStrategy)
    }]
  }], null, null);
})();
class DefaultTitleStrategy extends TitleStrategy {
  title;
  constructor(title) {
    super();
    this.title = title;
  }
  updateTitle(snapshot) {
    const title = this.buildTitle(snapshot);
    if (title !== undefined) {
      this.title.setTitle(title);
    }
  }
  static ɵfac = function DefaultTitleStrategy_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || DefaultTitleStrategy)(_angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_platform_browser__WEBPACK_IMPORTED_MODULE_35__.Title));
  };
  static ɵprov = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: DefaultTitleStrategy,
    factory: DefaultTitleStrategy.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(DefaultTitleStrategy, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], () => [{
    type: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_35__.Title
  }], null);
})();
const ROUTER_CONFIGURATION = new _angular_common__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'router config' : '', {
  factory: () => ({})
});
const ROUTES = new _angular_common__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'ROUTES' : '');
class RouterConfigLoader {
  componentLoaders = new WeakMap();
  childrenLoaders = new WeakMap();
  onLoadStartListener;
  onLoadEndListener;
  compiler = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_3__.Compiler);
  loadComponent(injector, route) {
    var _this1 = this;
    return (0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (_this1.componentLoaders.get(route)) {
        return _this1.componentLoaders.get(route);
      } else if (route._loadedComponent) {
        return Promise.resolve(route._loadedComponent);
      }
      if (_this1.onLoadStartListener) {
        _this1.onLoadStartListener(route);
      }
      const loader = (0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
        try {
          const loaded = yield wrapIntoPromise((0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.runInInjectionContext)(injector, () => route.loadComponent()));
          const component = yield maybeResolveResources(maybeUnwrapDefaultExport(loaded));
          if (_this1.onLoadEndListener) {
            _this1.onLoadEndListener(route);
          }
          (typeof ngDevMode === 'undefined' || ngDevMode) && assertStandalone(route.path ?? '', component);
          route._loadedComponent = component;
          return component;
        } finally {
          _this1.componentLoaders.delete(route);
        }
      })();
      _this1.componentLoaders.set(route, loader);
      return loader;
    })();
  }
  loadChildren(parentInjector, route) {
    var _this10 = this;
    if (this.childrenLoaders.get(route)) {
      return this.childrenLoaders.get(route);
    } else if (route._loadedRoutes) {
      return Promise.resolve({
        routes: route._loadedRoutes,
        injector: route._loadedInjector
      });
    }
    if (this.onLoadStartListener) {
      this.onLoadStartListener(route);
    }
    const loader = (0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      try {
        const result = yield loadChildren(route, _this10.compiler, parentInjector, _this10.onLoadEndListener);
        route._loadedRoutes = result.routes;
        route._loadedInjector = result.injector;
        return result;
      } finally {
        _this10.childrenLoaders.delete(route);
      }
    })();
    this.childrenLoaders.set(route, loader);
    return loader;
  }
  static ɵfac = function RouterConfigLoader_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || RouterConfigLoader)();
  };
  static ɵprov = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: RouterConfigLoader,
    factory: RouterConfigLoader.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(RouterConfigLoader, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], null, null);
})();
function loadChildren(_x7, _x8, _x9, _x0) {
  return _loadChildren.apply(this, arguments);
}
function _loadChildren() {
  _loadChildren = (0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (route, compiler, parentInjector, onLoadEndListener) {
    const loaded = yield wrapIntoPromise((0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.runInInjectionContext)(parentInjector, () => route.loadChildren()));
    const t = yield maybeResolveResources(maybeUnwrapDefaultExport(loaded));
    let factoryOrRoutes;
    if (t instanceof _angular_core__WEBPACK_IMPORTED_MODULE_3__.NgModuleFactory$1 || Array.isArray(t)) {
      factoryOrRoutes = t;
    } else {
      factoryOrRoutes = yield compiler.compileModuleAsync(t);
    }
    if (onLoadEndListener) {
      onLoadEndListener(route);
    }
    let injector;
    let rawRoutes;
    let requireStandaloneComponents = false;
    if (Array.isArray(factoryOrRoutes)) {
      rawRoutes = factoryOrRoutes;
      requireStandaloneComponents = true;
    } else {
      injector = factoryOrRoutes.create(parentInjector).injector;
      rawRoutes = injector.get(ROUTES, [], {
        optional: true,
        self: true
      }).flat();
    }
    const routes = rawRoutes.map(standardizeConfig);
    (typeof ngDevMode === 'undefined' || ngDevMode) && validateConfig(routes, route.path, requireStandaloneComponents);
    return {
      routes,
      injector
    };
  });
  return _loadChildren.apply(this, arguments);
}
function isWrappedDefaultExport(value) {
  return value && typeof value === 'object' && 'default' in value;
}
function maybeUnwrapDefaultExport(input) {
  return isWrappedDefaultExport(input) ? input['default'] : input;
}
function maybeResolveResources(_x1) {
  return _maybeResolveResources.apply(this, arguments);
}
function _maybeResolveResources() {
  _maybeResolveResources = (0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (value) {
    if ((typeof ngJitMode === 'undefined' || ngJitMode) && typeof fetch === 'function') {
      try {
        yield (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.resolveComponentResources)(fetch);
      } catch (error) {
        console.error(error);
      }
    }
    return value;
  });
  return _maybeResolveResources.apply(this, arguments);
}
class UrlHandlingStrategy {
  static ɵfac = function UrlHandlingStrategy_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || UrlHandlingStrategy)();
  };
  static ɵprov = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: UrlHandlingStrategy,
    factory: () => (() => (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(DefaultUrlHandlingStrategy))(),
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(UrlHandlingStrategy, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
    args: [{
      providedIn: 'root',
      useFactory: () => (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(DefaultUrlHandlingStrategy)
    }]
  }], null, null);
})();
class DefaultUrlHandlingStrategy {
  shouldProcessUrl(url) {
    return true;
  }
  extract(url) {
    return url;
  }
  merge(newUrlPart, wholeUrl) {
    return newUrlPart;
  }
  static ɵfac = function DefaultUrlHandlingStrategy_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || DefaultUrlHandlingStrategy)();
  };
  static ɵprov = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: DefaultUrlHandlingStrategy,
    factory: DefaultUrlHandlingStrategy.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(DefaultUrlHandlingStrategy, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], null, null);
})();
const CREATE_VIEW_TRANSITION = new _angular_common__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'view transition helper' : '');
const VIEW_TRANSITION_OPTIONS = new _angular_common__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'view transition options' : '');
function createViewTransition(injector, from, to) {
  const transitionOptions = injector.get(VIEW_TRANSITION_OPTIONS);
  const document = injector.get(_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT);
  if (!document.startViewTransition || transitionOptions.skipNextTransition) {
    transitionOptions.skipNextTransition = false;
    return new Promise(resolve => setTimeout(resolve));
  }
  let resolveViewTransitionStarted;
  const viewTransitionStarted = new Promise(resolve => {
    resolveViewTransitionStarted = resolve;
  });
  const transition = document.startViewTransition(() => {
    resolveViewTransitionStarted();
    return createRenderPromise(injector);
  });
  transition.ready.catch(error => {
    if (typeof ngDevMode === 'undefined' || ngDevMode) {
      console.error(error);
    }
  });
  transition.finished.catch(error => {
    if (typeof ngDevMode === 'undefined' || ngDevMode) {
      console.error(error);
    }
  });
  const {
    onViewTransitionCreated
  } = transitionOptions;
  if (onViewTransitionCreated) {
    (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.runInInjectionContext)(injector, () => onViewTransitionCreated({
      transition,
      from,
      to
    }));
  }
  return viewTransitionStarted;
}
function createRenderPromise(injector) {
  return new Promise(resolve => {
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.afterNextRender)({
      read: () => setTimeout(resolve)
    }, {
      injector
    });
  });
}
const noop = () => {};
const NAVIGATION_ERROR_HANDLER = new _angular_common__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'navigation error handler' : '');
class NavigationTransitions {
  currentNavigation = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.signal)(null, {
    ...(ngDevMode ? {
      debugName: "currentNavigation"
    } : {}),
    equal: () => false
  });
  currentTransition = null;
  lastSuccessfulNavigation = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.signal)(null, ...(ngDevMode ? [{
    debugName: "lastSuccessfulNavigation"
  }] : []));
  events = new rxjs__WEBPACK_IMPORTED_MODULE_6__.Subject();
  transitionAbortWithErrorSubject = new rxjs__WEBPACK_IMPORTED_MODULE_6__.Subject();
  configLoader = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(RouterConfigLoader);
  environmentInjector = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_common__WEBPACK_IMPORTED_MODULE_1__.EnvironmentInjector);
  destroyRef = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_common__WEBPACK_IMPORTED_MODULE_1__.DestroyRef);
  urlSerializer = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(UrlSerializer);
  rootContexts = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(ChildrenOutletContexts);
  location = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_common__WEBPACK_IMPORTED_MODULE_2__.Location);
  inputBindingEnabled = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(INPUT_BINDER, {
    optional: true
  }) !== null;
  titleStrategy = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(TitleStrategy);
  options = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(ROUTER_CONFIGURATION, {
    optional: true
  }) || {};
  paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || 'emptyOnly';
  urlHandlingStrategy = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(UrlHandlingStrategy);
  createViewTransition = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(CREATE_VIEW_TRANSITION, {
    optional: true
  });
  navigationErrorHandler = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(NAVIGATION_ERROR_HANDLER, {
    optional: true
  });
  navigationId = 0;
  get hasRequestedNavigation() {
    return this.navigationId !== 0;
  }
  transitions;
  afterPreactivation = () => (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(void 0);
  rootComponentType = null;
  destroyed = false;
  constructor() {
    const onLoadStart = r => this.events.next(new RouteConfigLoadStart(r));
    const onLoadEnd = r => this.events.next(new RouteConfigLoadEnd(r));
    this.configLoader.onLoadEndListener = onLoadEnd;
    this.configLoader.onLoadStartListener = onLoadStart;
    this.destroyRef.onDestroy(() => {
      this.destroyed = true;
    });
  }
  complete() {
    this.transitions?.complete();
  }
  handleNavigationRequest(request) {
    const id = ++this.navigationId;
    (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.untracked)(() => {
      this.transitions?.next({
        ...request,
        extractedUrl: this.urlHandlingStrategy.extract(request.rawUrl),
        targetSnapshot: null,
        targetRouterState: null,
        guards: {
          canActivateChecks: [],
          canDeactivateChecks: []
        },
        guardsResult: null,
        id
      });
    });
  }
  setupNavigations(router) {
    this.transitions = new rxjs__WEBPACK_IMPORTED_MODULE_7__.BehaviorSubject(null);
    return this.transitions.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.filter)(t => t !== null), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_30__.switchMap)(overallTransitionState => {
      let completedOrAborted = false;
      const abortController = new AbortController();
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(overallTransitionState).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_30__.switchMap)(t => {
        if (this.navigationId > overallTransitionState.id) {
          const cancellationReason = typeof ngDevMode === 'undefined' || ngDevMode ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}` : '';
          this.cancelNavigationTransition(overallTransitionState, cancellationReason, NavigationCancellationCode.SupersededByNewNavigation);
          return rxjs__WEBPACK_IMPORTED_MODULE_18__.EMPTY;
        }
        this.currentTransition = overallTransitionState;
        const lastSuccessfulNavigation = this.lastSuccessfulNavigation();
        this.currentNavigation.set({
          id: t.id,
          initialUrl: t.rawUrl,
          extractedUrl: t.extractedUrl,
          targetBrowserUrl: typeof t.extras.browserUrl === 'string' ? this.urlSerializer.parse(t.extras.browserUrl) : t.extras.browserUrl,
          trigger: t.source,
          extras: t.extras,
          previousNavigation: !lastSuccessfulNavigation ? null : {
            ...lastSuccessfulNavigation,
            previousNavigation: null
          },
          abort: () => abortController.abort()
        });
        const urlTransition = !router.navigated || this.isUpdatingInternalState() || this.isUpdatedBrowserUrl();
        const onSameUrlNavigation = t.extras.onSameUrlNavigation ?? router.onSameUrlNavigation;
        if (!urlTransition && onSameUrlNavigation !== 'reload') {
          const reason = typeof ngDevMode === 'undefined' || ngDevMode ? `Navigation to ${t.rawUrl} was ignored because it is the same as the current Router URL.` : '';
          this.events.next(new NavigationSkipped(t.id, this.urlSerializer.serialize(t.rawUrl), reason, NavigationSkippedCode.IgnoredSameUrlNavigation));
          t.resolve(false);
          return rxjs__WEBPACK_IMPORTED_MODULE_18__.EMPTY;
        }
        if (this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)) {
          return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(t).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_30__.switchMap)(t => {
            this.events.next(new NavigationStart(t.id, this.urlSerializer.serialize(t.extractedUrl), t.source, t.restoredState));
            if (t.id !== this.navigationId) {
              return rxjs__WEBPACK_IMPORTED_MODULE_18__.EMPTY;
            }
            return Promise.resolve(t);
          }), recognize(this.environmentInjector, this.configLoader, this.rootComponentType, router.config, this.urlSerializer, this.paramsInheritanceStrategy, abortController.signal), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_34__.tap)(t => {
            overallTransitionState.targetSnapshot = t.targetSnapshot;
            overallTransitionState.urlAfterRedirects = t.urlAfterRedirects;
            this.currentNavigation.update(nav => {
              nav.finalUrl = t.urlAfterRedirects;
              return nav;
            });
            const routesRecognized = new RoutesRecognized(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);
            this.events.next(routesRecognized);
          }));
        } else if (urlTransition && this.urlHandlingStrategy.shouldProcessUrl(t.currentRawUrl)) {
          const {
            id,
            extractedUrl,
            source,
            restoredState,
            extras
          } = t;
          const navStart = new NavigationStart(id, this.urlSerializer.serialize(extractedUrl), source, restoredState);
          this.events.next(navStart);
          const targetSnapshot = createEmptyState(this.rootComponentType).snapshot;
          this.currentTransition = overallTransitionState = {
            ...t,
            targetSnapshot,
            urlAfterRedirects: extractedUrl,
            extras: {
              ...extras,
              skipLocationChange: false,
              replaceUrl: false
            }
          };
          this.currentNavigation.update(nav => {
            nav.finalUrl = extractedUrl;
            return nav;
          });
          return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(overallTransitionState);
        } else {
          const reason = typeof ngDevMode === 'undefined' || ngDevMode ? `Navigation was ignored because the UrlHandlingStrategy` + ` indicated neither the current URL ${t.currentRawUrl} nor target URL ${t.rawUrl} should be processed.` : '';
          this.events.next(new NavigationSkipped(t.id, this.urlSerializer.serialize(t.extractedUrl), reason, NavigationSkippedCode.IgnoredByUrlHandlingStrategy));
          t.resolve(false);
          return rxjs__WEBPACK_IMPORTED_MODULE_18__.EMPTY;
        }
      }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_34__.tap)(t => {
        const guardsStart = new GuardsCheckStart(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);
        this.events.next(guardsStart);
      }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.map)(t => {
        this.currentTransition = overallTransitionState = {
          ...t,
          guards: getAllRouteGuards(t.targetSnapshot, t.currentSnapshot, this.rootContexts)
        };
        return overallTransitionState;
      }), checkGuards(this.environmentInjector, evt => this.events.next(evt)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_34__.tap)(t => {
        overallTransitionState.guardsResult = t.guardsResult;
        if (t.guardsResult && typeof t.guardsResult !== 'boolean') {
          throw redirectingNavigationError(this.urlSerializer, t.guardsResult);
        }
        const guardsEnd = new GuardsCheckEnd(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult);
        this.events.next(guardsEnd);
      }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.filter)(t => {
        if (!t.guardsResult) {
          this.cancelNavigationTransition(t, '', NavigationCancellationCode.GuardRejected);
          return false;
        }
        return true;
      }), switchTap(t => {
        if (t.guards.canActivateChecks.length === 0) {
          return undefined;
        }
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(t).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_34__.tap)(t => {
          const resolveStart = new ResolveStart(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);
          this.events.next(resolveStart);
        }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_30__.switchMap)(t => {
          let dataResolved = false;
          return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(t).pipe(resolveData(this.paramsInheritanceStrategy, this.environmentInjector), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_34__.tap)({
            next: () => dataResolved = true,
            complete: () => {
              if (!dataResolved) {
                this.cancelNavigationTransition(t, typeof ngDevMode === 'undefined' || ngDevMode ? `At least one route resolver didn't emit any value.` : '', NavigationCancellationCode.NoDataFromResolver);
              }
            }
          }));
        }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_34__.tap)(t => {
          const resolveEnd = new ResolveEnd(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);
          this.events.next(resolveEnd);
        }));
      }), switchTap(t => {
        const loadComponents = route => {
          const loaders = [];
          if (route.routeConfig?._loadedComponent) {
            route.component = route.routeConfig?._loadedComponent;
          } else if (route.routeConfig?.loadComponent) {
            const injector = getClosestRouteInjector(route) ?? this.environmentInjector;
            loaders.push(this.configLoader.loadComponent(injector, route.routeConfig).then(loadedComponent => {
              route.component = loadedComponent;
            }));
          }
          for (const child of route.children) {
            loaders.push(...loadComponents(child));
          }
          return loaders;
        };
        const loaders = loadComponents(t.targetSnapshot.root);
        return loaders.length === 0 ? (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(t) : (0,rxjs__WEBPACK_IMPORTED_MODULE_15__.from)(Promise.all(loaders).then(() => t));
      }), switchTap(() => this.afterPreactivation()), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_30__.switchMap)(() => {
        const {
          currentSnapshot,
          targetSnapshot
        } = overallTransitionState;
        const viewTransitionStarted = this.createViewTransition?.(this.environmentInjector, currentSnapshot.root, targetSnapshot.root);
        return viewTransitionStarted ? (0,rxjs__WEBPACK_IMPORTED_MODULE_15__.from)(viewTransitionStarted).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.map)(() => overallTransitionState)) : (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.of)(overallTransitionState);
      }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.map)(t => {
        const targetRouterState = createRouterState(router.routeReuseStrategy, t.targetSnapshot, t.currentRouterState);
        this.currentTransition = overallTransitionState = {
          ...t,
          targetRouterState
        };
        this.currentNavigation.update(nav => {
          nav.targetRouterState = targetRouterState;
          return nav;
        });
        return overallTransitionState;
      }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_34__.tap)(() => {
        this.events.next(new BeforeActivateRoutes());
      }), activateRoutes(this.rootContexts, router.routeReuseStrategy, evt => this.events.next(evt), this.inputBindingEnabled), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_31__.take)(1), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_33__.takeUntil)(abortSignalToObservable(abortController.signal).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.filter)(() => !completedOrAborted && !overallTransitionState.targetRouterState), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_34__.tap)(() => {
        this.cancelNavigationTransition(overallTransitionState, abortController.signal.reason + '', NavigationCancellationCode.Aborted);
      }))), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_34__.tap)({
        next: t => {
          completedOrAborted = true;
          this.currentNavigation.update(nav => {
            nav.abort = noop;
            return nav;
          });
          this.lastSuccessfulNavigation.set((0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.untracked)(this.currentNavigation));
          this.events.next(new NavigationEnd(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects)));
          this.titleStrategy?.updateTitle(t.targetRouterState.snapshot);
          t.resolve(true);
        },
        complete: () => {
          completedOrAborted = true;
        }
      }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_33__.takeUntil)(this.transitionAbortWithErrorSubject.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_34__.tap)(err => {
        throw err;
      }))), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_23__.finalize)(() => {
        abortController.abort();
        if (!completedOrAborted) {
          const cancelationReason = typeof ngDevMode === 'undefined' || ngDevMode ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}` : '';
          this.cancelNavigationTransition(overallTransitionState, cancelationReason, NavigationCancellationCode.SupersededByNewNavigation);
        }
        if (this.currentTransition?.id === overallTransitionState.id) {
          this.currentNavigation.set(null);
          this.currentTransition = null;
        }
      }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_19__.catchError)(e => {
        if (this.destroyed) {
          overallTransitionState.resolve(false);
          return rxjs__WEBPACK_IMPORTED_MODULE_18__.EMPTY;
        }
        completedOrAborted = true;
        if (isNavigationCancelingError(e)) {
          this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e.message, e.cancellationCode));
          if (!isRedirectingNavigationCancelingError(e)) {
            overallTransitionState.resolve(false);
          } else {
            this.events.next(new RedirectRequest(e.url, e.navigationBehaviorOptions));
          }
        } else {
          const navigationError = new NavigationError(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e, overallTransitionState.targetSnapshot ?? undefined);
          try {
            const navigationErrorHandlerResult = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.runInInjectionContext)(this.environmentInjector, () => this.navigationErrorHandler?.(navigationError));
            if (navigationErrorHandlerResult instanceof RedirectCommand) {
              const {
                message,
                cancellationCode
              } = redirectingNavigationError(this.urlSerializer, navigationErrorHandlerResult);
              this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), message, cancellationCode));
              this.events.next(new RedirectRequest(navigationErrorHandlerResult.redirectTo, navigationErrorHandlerResult.navigationBehaviorOptions));
            } else {
              this.events.next(navigationError);
              throw e;
            }
          } catch (ee) {
            if (this.options.resolveNavigationPromiseOnError) {
              overallTransitionState.resolve(false);
            } else {
              overallTransitionState.reject(ee);
            }
          }
        }
        return rxjs__WEBPACK_IMPORTED_MODULE_18__.EMPTY;
      }));
    }));
  }
  cancelNavigationTransition(t, reason, code) {
    const navCancel = new NavigationCancel(t.id, this.urlSerializer.serialize(t.extractedUrl), reason, code);
    this.events.next(navCancel);
    t.resolve(false);
  }
  isUpdatingInternalState() {
    return this.currentTransition?.extractedUrl.toString() !== this.currentTransition?.currentUrlTree.toString();
  }
  isUpdatedBrowserUrl() {
    const currentBrowserUrl = this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(true)));
    const currentNavigation = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.untracked)(this.currentNavigation);
    const targetBrowserUrl = currentNavigation?.targetBrowserUrl ?? currentNavigation?.extractedUrl;
    return currentBrowserUrl.toString() !== targetBrowserUrl?.toString() && !currentNavigation?.extras.skipLocationChange;
  }
  static ɵfac = function NavigationTransitions_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || NavigationTransitions)();
  };
  static ɵprov = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: NavigationTransitions,
    factory: NavigationTransitions.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(NavigationTransitions, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], () => [], null);
})();
function isBrowserTriggeredNavigation(source) {
  return source !== IMPERATIVE_NAVIGATION;
}
class RouteReuseStrategy {
  static ɵfac = function RouteReuseStrategy_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || RouteReuseStrategy)();
  };
  static ɵprov = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: RouteReuseStrategy,
    factory: () => (() => (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(DefaultRouteReuseStrategy))(),
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(RouteReuseStrategy, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
    args: [{
      providedIn: 'root',
      useFactory: () => (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(DefaultRouteReuseStrategy)
    }]
  }], null, null);
})();
class BaseRouteReuseStrategy {
  shouldDetach(route) {
    return false;
  }
  store(route, detachedTree) {}
  shouldAttach(route) {
    return false;
  }
  retrieve(route) {
    return null;
  }
  shouldReuseRoute(future, curr) {
    return future.routeConfig === curr.routeConfig;
  }
}
class DefaultRouteReuseStrategy extends BaseRouteReuseStrategy {
  static ɵfac = /* @__PURE__ */(() => {
    let ɵDefaultRouteReuseStrategy_BaseFactory;
    return function DefaultRouteReuseStrategy_Factory(__ngFactoryType__) {
      return (ɵDefaultRouteReuseStrategy_BaseFactory || (ɵDefaultRouteReuseStrategy_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵgetInheritedFactory"](DefaultRouteReuseStrategy)))(__ngFactoryType__ || DefaultRouteReuseStrategy);
    };
  })();
  static ɵprov = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: DefaultRouteReuseStrategy,
    factory: DefaultRouteReuseStrategy.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(DefaultRouteReuseStrategy, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], null, null);
})();
class StateManager {
  urlSerializer = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(UrlSerializer);
  options = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(ROUTER_CONFIGURATION, {
    optional: true
  }) || {};
  canceledNavigationResolution = this.options.canceledNavigationResolution || 'replace';
  location = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_common__WEBPACK_IMPORTED_MODULE_2__.Location);
  urlHandlingStrategy = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(UrlHandlingStrategy);
  urlUpdateStrategy = this.options.urlUpdateStrategy || 'deferred';
  currentUrlTree = new UrlTree();
  getCurrentUrlTree() {
    return this.currentUrlTree;
  }
  rawUrlTree = this.currentUrlTree;
  getRawUrlTree() {
    return this.rawUrlTree;
  }
  createBrowserPath({
    finalUrl,
    initialUrl,
    targetBrowserUrl
  }) {
    const rawUrl = finalUrl !== undefined ? this.urlHandlingStrategy.merge(finalUrl, initialUrl) : initialUrl;
    const url = targetBrowserUrl ?? rawUrl;
    const path = url instanceof UrlTree ? this.urlSerializer.serialize(url) : url;
    return path;
  }
  commitTransition({
    targetRouterState,
    finalUrl,
    initialUrl
  }) {
    if (finalUrl && targetRouterState) {
      this.currentUrlTree = finalUrl;
      this.rawUrlTree = this.urlHandlingStrategy.merge(finalUrl, initialUrl);
      this.routerState = targetRouterState;
    } else {
      this.rawUrlTree = initialUrl;
    }
  }
  routerState = createEmptyState(null);
  getRouterState() {
    return this.routerState;
  }
  stateMemento = this.createStateMemento();
  updateStateMemento() {
    this.stateMemento = this.createStateMemento();
  }
  createStateMemento() {
    return {
      rawUrlTree: this.rawUrlTree,
      currentUrlTree: this.currentUrlTree,
      routerState: this.routerState
    };
  }
  resetInternalState({
    finalUrl
  }) {
    this.routerState = this.stateMemento.routerState;
    this.currentUrlTree = this.stateMemento.currentUrlTree;
    this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, finalUrl ?? this.rawUrlTree);
  }
  static ɵfac = function StateManager_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || StateManager)();
  };
  static ɵprov = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: StateManager,
    factory: () => (() => (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(HistoryStateManager))(),
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(StateManager, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
    args: [{
      providedIn: 'root',
      useFactory: () => (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(HistoryStateManager)
    }]
  }], null, null);
})();
class HistoryStateManager extends StateManager {
  currentPageId = 0;
  lastSuccessfulId = -1;
  restoredState() {
    return this.location.getState();
  }
  get browserPageId() {
    if (this.canceledNavigationResolution !== 'computed') {
      return this.currentPageId;
    }
    return this.restoredState()?.ɵrouterPageId ?? this.currentPageId;
  }
  registerNonRouterCurrentEntryChangeListener(listener) {
    return this.location.subscribe(event => {
      if (event['type'] === 'popstate') {
        setTimeout(() => {
          listener(event['url'], event.state, 'popstate');
        });
      }
    });
  }
  handleRouterEvent(e, currentTransition) {
    if (e instanceof NavigationStart) {
      this.updateStateMemento();
    } else if (e instanceof NavigationSkipped) {
      this.commitTransition(currentTransition);
    } else if (e instanceof RoutesRecognized) {
      if (this.urlUpdateStrategy === 'eager') {
        if (!currentTransition.extras.skipLocationChange) {
          this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);
        }
      }
    } else if (e instanceof BeforeActivateRoutes) {
      this.commitTransition(currentTransition);
      if (this.urlUpdateStrategy === 'deferred' && !currentTransition.extras.skipLocationChange) {
        this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);
      }
    } else if (e instanceof NavigationCancel && e.code !== NavigationCancellationCode.SupersededByNewNavigation && e.code !== NavigationCancellationCode.Redirect) {
      this.restoreHistory(currentTransition);
    } else if (e instanceof NavigationError) {
      this.restoreHistory(currentTransition, true);
    } else if (e instanceof NavigationEnd) {
      this.lastSuccessfulId = e.id;
      this.currentPageId = this.browserPageId;
    }
  }
  setBrowserUrl(path, {
    extras,
    id
  }) {
    const {
      replaceUrl,
      state
    } = extras;
    if (this.location.isCurrentPathEqualTo(path) || !!replaceUrl) {
      const currentBrowserPageId = this.browserPageId;
      const newState = {
        ...state,
        ...this.generateNgRouterState(id, currentBrowserPageId)
      };
      this.location.replaceState(path, '', newState);
    } else {
      const newState = {
        ...state,
        ...this.generateNgRouterState(id, this.browserPageId + 1)
      };
      this.location.go(path, '', newState);
    }
  }
  restoreHistory(navigation, restoringFromCaughtError = false) {
    if (this.canceledNavigationResolution === 'computed') {
      const currentBrowserPageId = this.browserPageId;
      const targetPagePosition = this.currentPageId - currentBrowserPageId;
      if (targetPagePosition !== 0) {
        this.location.historyGo(targetPagePosition);
      } else if (this.getCurrentUrlTree() === navigation.finalUrl && targetPagePosition === 0) {
        this.resetInternalState(navigation);
        this.resetUrlToCurrentUrlTree();
      } else ;
    } else if (this.canceledNavigationResolution === 'replace') {
      if (restoringFromCaughtError) {
        this.resetInternalState(navigation);
      }
      this.resetUrlToCurrentUrlTree();
    }
  }
  resetUrlToCurrentUrlTree() {
    this.location.replaceState(this.urlSerializer.serialize(this.getRawUrlTree()), '', this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId));
  }
  generateNgRouterState(navigationId, routerPageId) {
    if (this.canceledNavigationResolution === 'computed') {
      return {
        navigationId,
        ɵrouterPageId: routerPageId
      };
    }
    return {
      navigationId
    };
  }
  static ɵfac = /* @__PURE__ */(() => {
    let ɵHistoryStateManager_BaseFactory;
    return function HistoryStateManager_Factory(__ngFactoryType__) {
      return (ɵHistoryStateManager_BaseFactory || (ɵHistoryStateManager_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵgetInheritedFactory"](HistoryStateManager)))(__ngFactoryType__ || HistoryStateManager);
    };
  })();
  static ɵprov = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: HistoryStateManager,
    factory: HistoryStateManager.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(HistoryStateManager, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], null, null);
})();
function afterNextNavigation(router, action) {
  router.events.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.filter)(e => e instanceof NavigationEnd || e instanceof NavigationCancel || e instanceof NavigationError || e instanceof NavigationSkipped), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.map)(e => {
    if (e instanceof NavigationEnd || e instanceof NavigationSkipped) {
      return 0;
    }
    const redirecting = e instanceof NavigationCancel ? e.code === NavigationCancellationCode.Redirect || e.code === NavigationCancellationCode.SupersededByNewNavigation : false;
    return redirecting ? 2 : 1;
  }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.filter)(result => result !== 2), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_31__.take)(1)).subscribe(() => {
    action();
  });
}
const exactMatchOptions = {
  paths: 'exact',
  fragment: 'ignored',
  matrixParams: 'ignored',
  queryParams: 'exact'
};
const subsetMatchOptions = {
  paths: 'subset',
  fragment: 'ignored',
  matrixParams: 'ignored',
  queryParams: 'subset'
};
class Router {
  get currentUrlTree() {
    return this.stateManager.getCurrentUrlTree();
  }
  get rawUrlTree() {
    return this.stateManager.getRawUrlTree();
  }
  disposed = false;
  nonRouterCurrentEntryChangeSubscription;
  console = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_3__.Console);
  stateManager = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(StateManager);
  options = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(ROUTER_CONFIGURATION, {
    optional: true
  }) || {};
  pendingTasks = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_common__WEBPACK_IMPORTED_MODULE_1__.PendingTasksInternal);
  urlUpdateStrategy = this.options.urlUpdateStrategy || 'deferred';
  navigationTransitions = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(NavigationTransitions);
  urlSerializer = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(UrlSerializer);
  location = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_common__WEBPACK_IMPORTED_MODULE_2__.Location);
  urlHandlingStrategy = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(UrlHandlingStrategy);
  injector = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_common__WEBPACK_IMPORTED_MODULE_1__.EnvironmentInjector);
  _events = new rxjs__WEBPACK_IMPORTED_MODULE_6__.Subject();
  get events() {
    return this._events;
  }
  get routerState() {
    return this.stateManager.getRouterState();
  }
  navigated = false;
  routeReuseStrategy = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(RouteReuseStrategy);
  onSameUrlNavigation = this.options.onSameUrlNavigation || 'ignore';
  config = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(ROUTES, {
    optional: true
  })?.flat() ?? [];
  componentInputBindingEnabled = !!(0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(INPUT_BINDER, {
    optional: true
  });
  currentNavigation = this.navigationTransitions.currentNavigation.asReadonly();
  constructor() {
    this.resetConfig(this.config);
    this.navigationTransitions.setupNavigations(this).subscribe({
      error: e => {
        this.console.warn(ngDevMode ? `Unhandled Navigation Error: ${e}` : e);
      }
    });
    this.subscribeToNavigationEvents();
  }
  eventsSubscription = new rxjs__WEBPACK_IMPORTED_MODULE_8__.Subscription();
  subscribeToNavigationEvents() {
    const subscription = this.navigationTransitions.events.subscribe(e => {
      try {
        const currentTransition = this.navigationTransitions.currentTransition;
        const currentNavigation = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.untracked)(this.navigationTransitions.currentNavigation);
        if (currentTransition !== null && currentNavigation !== null) {
          this.stateManager.handleRouterEvent(e, currentNavigation);
          if (e instanceof NavigationCancel && e.code !== NavigationCancellationCode.Redirect && e.code !== NavigationCancellationCode.SupersededByNewNavigation) {
            this.navigated = true;
          } else if (e instanceof NavigationEnd) {
            this.navigated = true;
          } else if (e instanceof RedirectRequest) {
            const opts = e.navigationBehaviorOptions;
            const mergedTree = this.urlHandlingStrategy.merge(e.url, currentTransition.currentRawUrl);
            const extras = {
              browserUrl: currentTransition.extras.browserUrl,
              info: currentTransition.extras.info,
              skipLocationChange: currentTransition.extras.skipLocationChange,
              replaceUrl: currentTransition.extras.replaceUrl || this.urlUpdateStrategy === 'eager' || isBrowserTriggeredNavigation(currentTransition.source),
              ...opts
            };
            this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras, {
              resolve: currentTransition.resolve,
              reject: currentTransition.reject,
              promise: currentTransition.promise
            });
          }
        }
        if (isPublicRouterEvent(e)) {
          this._events.next(e);
        }
      } catch (e) {
        this.navigationTransitions.transitionAbortWithErrorSubject.next(e);
      }
    });
    this.eventsSubscription.add(subscription);
  }
  resetRootComponentType(rootComponentType) {
    this.routerState.root.component = rootComponentType;
    this.navigationTransitions.rootComponentType = rootComponentType;
  }
  initialNavigation() {
    this.setUpLocationChangeListener();
    if (!this.navigationTransitions.hasRequestedNavigation) {
      this.navigateToSyncWithBrowser(this.location.path(true), IMPERATIVE_NAVIGATION, this.stateManager.restoredState());
    }
  }
  setUpLocationChangeListener() {
    this.nonRouterCurrentEntryChangeSubscription ??= this.stateManager.registerNonRouterCurrentEntryChangeListener((url, state, source) => {
      this.navigateToSyncWithBrowser(url, source, state);
    });
  }
  navigateToSyncWithBrowser(url, source, state) {
    const extras = {
      replaceUrl: true
    };
    const restoredState = state?.navigationId ? state : null;
    if (state) {
      const stateCopy = {
        ...state
      };
      delete stateCopy.navigationId;
      delete stateCopy.ɵrouterPageId;
      if (Object.keys(stateCopy).length !== 0) {
        extras.state = stateCopy;
      }
    }
    const urlTree = this.parseUrl(url);
    this.scheduleNavigation(urlTree, source, restoredState, extras).catch(e => {
      if (this.disposed) {
        return;
      }
      this.injector.get(_angular_common__WEBPACK_IMPORTED_MODULE_1__.INTERNAL_APPLICATION_ERROR_HANDLER)(e);
    });
  }
  get url() {
    return this.serializeUrl(this.currentUrlTree);
  }
  getCurrentNavigation() {
    return (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.untracked)(this.navigationTransitions.currentNavigation);
  }
  get lastSuccessfulNavigation() {
    return this.navigationTransitions.lastSuccessfulNavigation;
  }
  resetConfig(config) {
    (typeof ngDevMode === 'undefined' || ngDevMode) && validateConfig(config);
    this.config = config.map(standardizeConfig);
    this.navigated = false;
  }
  ngOnDestroy() {
    this.dispose();
  }
  dispose() {
    this._events.unsubscribe();
    this.navigationTransitions.complete();
    if (this.nonRouterCurrentEntryChangeSubscription) {
      this.nonRouterCurrentEntryChangeSubscription.unsubscribe();
      this.nonRouterCurrentEntryChangeSubscription = undefined;
    }
    this.disposed = true;
    this.eventsSubscription.unsubscribe();
  }
  createUrlTree(commands, navigationExtras = {}) {
    const {
      relativeTo,
      queryParams,
      fragment,
      queryParamsHandling,
      preserveFragment
    } = navigationExtras;
    const f = preserveFragment ? this.currentUrlTree.fragment : fragment;
    let q = null;
    switch (queryParamsHandling ?? this.options.defaultQueryParamsHandling) {
      case 'merge':
        q = {
          ...this.currentUrlTree.queryParams,
          ...queryParams
        };
        break;
      case 'preserve':
        q = this.currentUrlTree.queryParams;
        break;
      default:
        q = queryParams || null;
    }
    if (q !== null) {
      q = this.removeEmptyProps(q);
    }
    let relativeToUrlSegmentGroup;
    try {
      const relativeToSnapshot = relativeTo ? relativeTo.snapshot : this.routerState.snapshot.root;
      relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeToSnapshot);
    } catch (e) {
      if (typeof commands[0] !== 'string' || commands[0][0] !== '/') {
        commands = [];
      }
      relativeToUrlSegmentGroup = this.currentUrlTree.root;
    }
    return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, q, f ?? null, this.urlSerializer);
  }
  navigateByUrl(url, extras = {
    skipLocationChange: false
  }) {
    const urlTree = isUrlTree(url) ? url : this.parseUrl(url);
    const mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);
    return this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras);
  }
  navigate(commands, extras = {
    skipLocationChange: false
  }) {
    validateCommands(commands);
    return this.navigateByUrl(this.createUrlTree(commands, extras), extras);
  }
  serializeUrl(url) {
    return this.urlSerializer.serialize(url);
  }
  parseUrl(url) {
    try {
      return this.urlSerializer.parse(url);
    } catch (e) {
      this.console.warn((0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(4018, ngDevMode && `Error parsing URL ${url}. Falling back to '/' instead. \n` + e));
      return this.urlSerializer.parse('/');
    }
  }
  isActive(url, matchOptions) {
    let options;
    if (matchOptions === true) {
      options = {
        ...exactMatchOptions
      };
    } else if (matchOptions === false) {
      options = {
        ...subsetMatchOptions
      };
    } else {
      options = matchOptions;
    }
    if (isUrlTree(url)) {
      return containsTree(this.currentUrlTree, url, options);
    }
    const urlTree = this.parseUrl(url);
    return containsTree(this.currentUrlTree, urlTree, options);
  }
  removeEmptyProps(params) {
    return Object.entries(params).reduce((result, [key, value]) => {
      if (value !== null && value !== undefined) {
        result[key] = value;
      }
      return result;
    }, {});
  }
  scheduleNavigation(rawUrl, source, restoredState, extras, priorPromise) {
    if (this.disposed) {
      return Promise.resolve(false);
    }
    let resolve;
    let reject;
    let promise;
    if (priorPromise) {
      resolve = priorPromise.resolve;
      reject = priorPromise.reject;
      promise = priorPromise.promise;
    } else {
      promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
    }
    const taskId = this.pendingTasks.add();
    afterNextNavigation(this, () => {
      queueMicrotask(() => this.pendingTasks.remove(taskId));
    });
    this.navigationTransitions.handleNavigationRequest({
      source,
      restoredState,
      currentUrlTree: this.currentUrlTree,
      currentRawUrl: this.currentUrlTree,
      rawUrl,
      extras,
      resolve: resolve,
      reject: reject,
      promise,
      currentSnapshot: this.routerState.snapshot,
      currentRouterState: this.routerState
    });
    return promise.catch(e => {
      return Promise.reject(e);
    });
  }
  static ɵfac = function Router_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || Router)();
  };
  static ɵprov = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: Router,
    factory: Router.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(Router, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], () => [], null);
})();
function validateCommands(commands) {
  for (let i = 0; i < commands.length; i++) {
    const cmd = commands[i];
    if (cmd == null) {
      throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(4008, (typeof ngDevMode === 'undefined' || ngDevMode) && `The requested path contains ${cmd} segment at index ${i}`);
    }
  }
}


/***/ }),

/***/ 1157:
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/config.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   config: () => (/* binding */ config)
/* harmony export */ });
const config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: undefined,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

/***/ }),

/***/ 1171:
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/Subject.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnonymousSubject: () => (/* binding */ AnonymousSubject),
/* harmony export */   Subject: () => (/* binding */ Subject)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Observable */ 1814);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Subscription */ 1038);
/* harmony import */ var _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/ObjectUnsubscribedError */ 518);
/* harmony import */ var _util_arrRemove__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/arrRemove */ 7223);
/* harmony import */ var _util_errorContext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util/errorContext */ 7831);





class Subject extends _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable {
  constructor() {
    super();
    this.closed = false;
    this.currentObservers = null;
    this.observers = [];
    this.isStopped = false;
    this.hasError = false;
    this.thrownError = null;
  }
  lift(operator) {
    const subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  }
  _throwIfClosed() {
    if (this.closed) {
      throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_2__.ObjectUnsubscribedError();
    }
  }
  next(value) {
    (0,_util_errorContext__WEBPACK_IMPORTED_MODULE_4__.errorContext)(() => {
      this._throwIfClosed();
      if (!this.isStopped) {
        if (!this.currentObservers) {
          this.currentObservers = Array.from(this.observers);
        }
        for (const observer of this.currentObservers) {
          observer.next(value);
        }
      }
    });
  }
  error(err) {
    (0,_util_errorContext__WEBPACK_IMPORTED_MODULE_4__.errorContext)(() => {
      this._throwIfClosed();
      if (!this.isStopped) {
        this.hasError = this.isStopped = true;
        this.thrownError = err;
        const {
          observers
        } = this;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  }
  complete() {
    (0,_util_errorContext__WEBPACK_IMPORTED_MODULE_4__.errorContext)(() => {
      this._throwIfClosed();
      if (!this.isStopped) {
        this.isStopped = true;
        const {
          observers
        } = this;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  }
  unsubscribe() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  }
  get observed() {
    var _a;
    return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
  }
  _trySubscribe(subscriber) {
    this._throwIfClosed();
    return super._trySubscribe(subscriber);
  }
  _subscribe(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  }
  _innerSubscribe(subscriber) {
    const {
      hasError,
      isStopped,
      observers
    } = this;
    if (hasError || isStopped) {
      return _Subscription__WEBPACK_IMPORTED_MODULE_1__.EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new _Subscription__WEBPACK_IMPORTED_MODULE_1__.Subscription(() => {
      this.currentObservers = null;
      (0,_util_arrRemove__WEBPACK_IMPORTED_MODULE_3__.arrRemove)(observers, subscriber);
    });
  }
  _checkFinalizedStatuses(subscriber) {
    const {
      hasError,
      thrownError,
      isStopped
    } = this;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  }
  asObservable() {
    const observable = new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
    observable.source = this;
    return observable;
  }
}
Subject.create = (destination, source) => {
  return new AnonymousSubject(destination, source);
};
class AnonymousSubject extends Subject {
  constructor(destination, source) {
    super();
    this.destination = destination;
    this.source = source;
  }
  next(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  }
  error(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  }
  complete() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  }
  _subscribe(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : _Subscription__WEBPACK_IMPORTED_MODULE_1__.EMPTY_SUBSCRIPTION;
  }
}

/***/ }),

/***/ 1175:
/*!********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@angular+router@21.0.5_@angular+common@21.0.5_@angular+core@21.0.5_@angular+platform-browser@21.0.5_rxjs@7.8.2/node_modules/@angular/router/fesm2022/router.mjs ***!
  \********************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ActivatedRoute: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ActivatedRoute),
/* harmony export */   ActivatedRouteSnapshot: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ActivatedRouteSnapshot),
/* harmony export */   ActivationEnd: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ActivationEnd),
/* harmony export */   ActivationStart: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ActivationStart),
/* harmony export */   BaseRouteReuseStrategy: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.BaseRouteReuseStrategy),
/* harmony export */   ChildActivationEnd: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ChildActivationEnd),
/* harmony export */   ChildActivationStart: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ChildActivationStart),
/* harmony export */   ChildrenOutletContexts: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ChildrenOutletContexts),
/* harmony export */   DefaultTitleStrategy: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.DefaultTitleStrategy),
/* harmony export */   DefaultUrlSerializer: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.DefaultUrlSerializer),
/* harmony export */   EventType: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.EventType),
/* harmony export */   GuardsCheckEnd: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.GuardsCheckEnd),
/* harmony export */   GuardsCheckStart: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.GuardsCheckStart),
/* harmony export */   NavigationCancel: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NavigationCancel),
/* harmony export */   NavigationCancellationCode: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NavigationCancellationCode),
/* harmony export */   NavigationEnd: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NavigationEnd),
/* harmony export */   NavigationError: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NavigationError),
/* harmony export */   NavigationSkipped: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NavigationSkipped),
/* harmony export */   NavigationSkippedCode: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NavigationSkippedCode),
/* harmony export */   NavigationStart: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NavigationStart),
/* harmony export */   NoPreloading: () => (/* reexport safe */ _router_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NoPreloading),
/* harmony export */   OutletContext: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.OutletContext),
/* harmony export */   PRIMARY_OUTLET: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.PRIMARY_OUTLET),
/* harmony export */   PreloadAllModules: () => (/* reexport safe */ _router_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PreloadAllModules),
/* harmony export */   PreloadingStrategy: () => (/* reexport safe */ _router_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PreloadingStrategy),
/* harmony export */   ROUTER_CONFIGURATION: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ROUTER_CONFIGURATION),
/* harmony export */   ROUTER_INITIALIZER: () => (/* reexport safe */ _router_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ROUTER_INITIALIZER),
/* harmony export */   ROUTER_OUTLET_DATA: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ROUTER_OUTLET_DATA),
/* harmony export */   ROUTES: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ROUTES),
/* harmony export */   RedirectCommand: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RedirectCommand),
/* harmony export */   ResolveEnd: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ResolveEnd),
/* harmony export */   ResolveStart: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ResolveStart),
/* harmony export */   RouteConfigLoadEnd: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RouteConfigLoadEnd),
/* harmony export */   RouteConfigLoadStart: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RouteConfigLoadStart),
/* harmony export */   RouteReuseStrategy: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RouteReuseStrategy),
/* harmony export */   Router: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.Router),
/* harmony export */   RouterEvent: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RouterEvent),
/* harmony export */   RouterLink: () => (/* reexport safe */ _router_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RouterLink),
/* harmony export */   RouterLinkActive: () => (/* reexport safe */ _router_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RouterLinkActive),
/* harmony export */   RouterLinkWithHref: () => (/* reexport safe */ _router_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RouterLink),
/* harmony export */   RouterModule: () => (/* reexport safe */ _router_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RouterModule),
/* harmony export */   RouterOutlet: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RouterOutlet),
/* harmony export */   RouterPreloader: () => (/* reexport safe */ _router_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RouterPreloader),
/* harmony export */   RouterState: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RouterState),
/* harmony export */   RouterStateSnapshot: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RouterStateSnapshot),
/* harmony export */   RoutesRecognized: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RoutesRecognized),
/* harmony export */   Scroll: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.Scroll),
/* harmony export */   TitleStrategy: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.TitleStrategy),
/* harmony export */   UrlHandlingStrategy: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.UrlHandlingStrategy),
/* harmony export */   UrlSegment: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.UrlSegment),
/* harmony export */   UrlSegmentGroup: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.UrlSegmentGroup),
/* harmony export */   UrlSerializer: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.UrlSerializer),
/* harmony export */   UrlTree: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.UrlTree),
/* harmony export */   VERSION: () => (/* binding */ VERSION),
/* harmony export */   convertToParamMap: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.convertToParamMap),
/* harmony export */   createUrlTreeFromSnapshot: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.createUrlTreeFromSnapshot),
/* harmony export */   defaultUrlMatcher: () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.defaultUrlMatcher),
/* harmony export */   mapToCanActivate: () => (/* binding */ mapToCanActivate),
/* harmony export */   mapToCanActivateChild: () => (/* binding */ mapToCanActivateChild),
/* harmony export */   mapToCanDeactivate: () => (/* binding */ mapToCanDeactivate),
/* harmony export */   mapToCanMatch: () => (/* binding */ mapToCanMatch),
/* harmony export */   mapToResolve: () => (/* binding */ mapToResolve),
/* harmony export */   provideRouter: () => (/* reexport safe */ _router_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.provideRouter),
/* harmony export */   provideRoutes: () => (/* reexport safe */ _router_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.provideRoutes),
/* harmony export */   withComponentInputBinding: () => (/* reexport safe */ _router_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.withComponentInputBinding),
/* harmony export */   withDebugTracing: () => (/* reexport safe */ _router_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.withDebugTracing),
/* harmony export */   withDisabledInitialNavigation: () => (/* reexport safe */ _router_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.withDisabledInitialNavigation),
/* harmony export */   withEnabledBlockingInitialNavigation: () => (/* reexport safe */ _router_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.withEnabledBlockingInitialNavigation),
/* harmony export */   withHashLocation: () => (/* reexport safe */ _router_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.withHashLocation),
/* harmony export */   withInMemoryScrolling: () => (/* reexport safe */ _router_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.withInMemoryScrolling),
/* harmony export */   withNavigationErrorHandler: () => (/* reexport safe */ _router_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.withNavigationErrorHandler),
/* harmony export */   withPreloading: () => (/* reexport safe */ _router_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.withPreloading),
/* harmony export */   withRouterConfig: () => (/* reexport safe */ _router_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.withRouterConfig),
/* harmony export */   withViewTransitions: () => (/* reexport safe */ _router_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.withViewTransitions),
/* harmony export */   "ɵEmptyOutletComponent": () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵEmptyOutletComponent"]),
/* harmony export */   "ɵROUTER_PROVIDERS": () => (/* reexport safe */ _router_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ROUTER_PROVIDERS),
/* harmony export */   "ɵafterNextNavigation": () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.afterNextNavigation),
/* harmony export */   "ɵloadChildren": () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.loadChildren),
/* harmony export */   "ɵprovideSometimesSyncRecognize": () => (/* reexport safe */ _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.provideSometimesSyncRecognize),
/* harmony export */   "ɵwithPlatformNavigation": () => (/* reexport safe */ _router_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.withPlatformNavigation)
/* harmony export */ });
/* harmony import */ var _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_router-chunk.mjs */ 1088);
/* harmony import */ var _router_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_router_module-chunk.mjs */ 1571);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ 64);
/**
 * @license Angular v21.0.5
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */








function mapToCanMatch(providers) {
  return providers.map(provider => (...params) => (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(provider).canMatch(...params));
}
function mapToCanActivate(providers) {
  return providers.map(provider => (...params) => (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(provider).canActivate(...params));
}
function mapToCanActivateChild(providers) {
  return providers.map(provider => (...params) => (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(provider).canActivateChild(...params));
}
function mapToCanDeactivate(providers) {
  return providers.map(provider => (...params) => (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(provider).canDeactivate(...params));
}
function mapToResolve(provider) {
  return (...params) => (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(provider).resolve(...params);
}
const VERSION = /* @__PURE__ */new _angular_core__WEBPACK_IMPORTED_MODULE_2__.Version('21.0.5');


/***/ }),

/***/ 1267:
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/operators/first.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   first: () => (/* binding */ first)
/* harmony export */ });
/* harmony import */ var _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/EmptyError */ 5815);
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./filter */ 4191);
/* harmony import */ var _take__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./take */ 6942);
/* harmony import */ var _defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./defaultIfEmpty */ 1834);
/* harmony import */ var _throwIfEmpty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./throwIfEmpty */ 197);
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/identity */ 5232);






function first(predicate, defaultValue) {
  const hasDefaultValue = arguments.length >= 2;
  return source => source.pipe(predicate ? (0,_filter__WEBPACK_IMPORTED_MODULE_1__.filter)((v, i) => predicate(v, i, source)) : _util_identity__WEBPACK_IMPORTED_MODULE_5__.identity, (0,_take__WEBPACK_IMPORTED_MODULE_2__.take)(1), hasDefaultValue ? (0,_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__.defaultIfEmpty)(defaultValue) : (0,_throwIfEmpty__WEBPACK_IMPORTED_MODULE_4__.throwIfEmpty)(() => new _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__.EmptyError()));
}

/***/ }),

/***/ 1571:
/*!**********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@angular+router@21.0.5_@angular+common@21.0.5_@angular+core@21.0.5_@angular+platform-browser@21.0.5_rxjs@7.8.2/node_modules/@angular/router/fesm2022/_router_module-chunk.mjs ***!
  \**********************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NoPreloading: () => (/* binding */ NoPreloading),
/* harmony export */   PreloadAllModules: () => (/* binding */ PreloadAllModules),
/* harmony export */   PreloadingStrategy: () => (/* binding */ PreloadingStrategy),
/* harmony export */   ROUTER_INITIALIZER: () => (/* binding */ ROUTER_INITIALIZER),
/* harmony export */   ROUTER_PROVIDERS: () => (/* binding */ ROUTER_PROVIDERS),
/* harmony export */   RouterLink: () => (/* binding */ RouterLink),
/* harmony export */   RouterLinkActive: () => (/* binding */ RouterLinkActive),
/* harmony export */   RouterModule: () => (/* binding */ RouterModule),
/* harmony export */   RouterPreloader: () => (/* binding */ RouterPreloader),
/* harmony export */   provideRouter: () => (/* binding */ provideRouter),
/* harmony export */   provideRoutes: () => (/* binding */ provideRoutes),
/* harmony export */   withComponentInputBinding: () => (/* binding */ withComponentInputBinding),
/* harmony export */   withDebugTracing: () => (/* binding */ withDebugTracing),
/* harmony export */   withDisabledInitialNavigation: () => (/* binding */ withDisabledInitialNavigation),
/* harmony export */   withEnabledBlockingInitialNavigation: () => (/* binding */ withEnabledBlockingInitialNavigation),
/* harmony export */   withHashLocation: () => (/* binding */ withHashLocation),
/* harmony export */   withInMemoryScrolling: () => (/* binding */ withInMemoryScrolling),
/* harmony export */   withNavigationErrorHandler: () => (/* binding */ withNavigationErrorHandler),
/* harmony export */   withPlatformNavigation: () => (/* binding */ withPlatformNavigation),
/* harmony export */   withPreloading: () => (/* binding */ withPreloading),
/* harmony export */   withRouterConfig: () => (/* binding */ withRouterConfig),
/* harmony export */   withViewTransitions: () => (/* binding */ withViewTransitions)
/* harmony export */ });
/* harmony import */ var C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 3194);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ 933);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ 3126);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/common */ 5726);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/common */ 2802);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/common */ 8021);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/core */ 64);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/core */ 7367);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/core */ 8357);
/* harmony import */ var _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./_router-chunk.mjs */ 1088);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! rxjs */ 1171);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! rxjs */ 7909);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! rxjs */ 9596);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! rxjs/operators */ 4502);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! rxjs/operators */ 4927);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! rxjs/operators */ 4191);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! rxjs/operators */ 8310);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! rxjs/operators */ 1991);

/**
 * @license Angular v21.0.5
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */








class RouterLink {
  router;
  route;
  tabIndexAttribute;
  renderer;
  el;
  locationStrategy;
  reactiveHref = (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.signal)(null, ...(ngDevMode ? [{
    debugName: "reactiveHref"
  }] : []));
  get href() {
    return (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.untracked)(this.reactiveHref);
  }
  set href(value) {
    this.reactiveHref.set(value);
  }
  target;
  queryParams;
  fragment;
  queryParamsHandling;
  state;
  info;
  relativeTo;
  isAnchorElement;
  subscription;
  onChanges = new rxjs__WEBPACK_IMPORTED_MODULE_10__.Subject();
  applicationErrorHandler = (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_6__.INTERNAL_APPLICATION_ERROR_HANDLER);
  options = (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.inject)(_router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.ROUTER_CONFIGURATION, {
    optional: true
  });
  constructor(router, route, tabIndexAttribute, renderer, el, locationStrategy) {
    this.router = router;
    this.route = route;
    this.tabIndexAttribute = tabIndexAttribute;
    this.renderer = renderer;
    this.el = el;
    this.locationStrategy = locationStrategy;
    this.reactiveHref.set((0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.inject)(new _angular_core__WEBPACK_IMPORTED_MODULE_8__.HostAttributeToken('href'), {
      optional: true
    }));
    const tagName = el.nativeElement.tagName?.toLowerCase();
    this.isAnchorElement = tagName === 'a' || tagName === 'area' || !!(typeof customElements === 'object' && customElements.get(tagName)?.observedAttributes?.includes?.('href'));
    if (!this.isAnchorElement) {
      this.subscribeToNavigationEventsIfNecessary();
    } else {
      this.setTabIndexIfNotOnNativeEl('0');
    }
  }
  subscribeToNavigationEventsIfNecessary() {
    if (this.subscription !== undefined || !this.isAnchorElement) {
      return;
    }
    let createSubcription = this.preserveFragment;
    const dependsOnRouterState = handling => handling === 'merge' || handling === 'preserve';
    createSubcription ||= dependsOnRouterState(this.queryParamsHandling);
    createSubcription ||= !this.queryParamsHandling && !dependsOnRouterState(this.options?.defaultQueryParamsHandling);
    if (!createSubcription) {
      return;
    }
    this.subscription = this.router.events.subscribe(s => {
      if (s instanceof _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.NavigationEnd) {
        this.updateHref();
      }
    });
  }
  preserveFragment = false;
  skipLocationChange = false;
  replaceUrl = false;
  setTabIndexIfNotOnNativeEl(newTabIndex) {
    if (this.tabIndexAttribute != null || this.isAnchorElement) {
      return;
    }
    this.applyAttributeValue('tabindex', newTabIndex);
  }
  ngOnChanges(changes) {
    if (ngDevMode && (0,_router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.isUrlTree)(this.routerLinkInput) && (this.fragment !== undefined || this.queryParams || this.queryParamsHandling || this.preserveFragment || this.relativeTo)) {
      throw new _angular_core__WEBPACK_IMPORTED_MODULE_6__.RuntimeError(4017, 'Cannot configure queryParams or fragment when using a UrlTree as the routerLink input value.');
    }
    if (this.isAnchorElement) {
      this.updateHref();
      this.subscribeToNavigationEventsIfNecessary();
    }
    this.onChanges.next(this);
  }
  routerLinkInput = null;
  set routerLink(commandsOrUrlTree) {
    if (commandsOrUrlTree == null) {
      this.routerLinkInput = null;
      this.setTabIndexIfNotOnNativeEl(null);
    } else {
      if ((0,_router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.isUrlTree)(commandsOrUrlTree)) {
        this.routerLinkInput = commandsOrUrlTree;
      } else {
        this.routerLinkInput = Array.isArray(commandsOrUrlTree) ? commandsOrUrlTree : [commandsOrUrlTree];
      }
      this.setTabIndexIfNotOnNativeEl('0');
    }
  }
  onClick(button, ctrlKey, shiftKey, altKey, metaKey) {
    const urlTree = this.urlTree;
    if (urlTree === null) {
      return true;
    }
    if (this.isAnchorElement) {
      if (button !== 0 || ctrlKey || shiftKey || altKey || metaKey) {
        return true;
      }
      if (typeof this.target === 'string' && this.target != '_self') {
        return true;
      }
    }
    const extras = {
      skipLocationChange: this.skipLocationChange,
      replaceUrl: this.replaceUrl,
      state: this.state,
      info: this.info
    };
    this.router.navigateByUrl(urlTree, extras)?.catch(e => {
      this.applicationErrorHandler(e);
    });
    return !this.isAnchorElement;
  }
  ngOnDestroy() {
    this.subscription?.unsubscribe();
  }
  updateHref() {
    const urlTree = this.urlTree;
    this.reactiveHref.set(urlTree !== null && this.locationStrategy ? this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(urlTree)) ?? '' : null);
  }
  applyAttributeValue(attrName, attrValue) {
    const renderer = this.renderer;
    const nativeElement = this.el.nativeElement;
    if (attrValue !== null) {
      renderer.setAttribute(nativeElement, attrName, attrValue);
    } else {
      renderer.removeAttribute(nativeElement, attrName);
    }
  }
  get urlTree() {
    if (this.routerLinkInput === null) {
      return null;
    } else if ((0,_router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.isUrlTree)(this.routerLinkInput)) {
      return this.routerLinkInput;
    }
    return this.router.createUrlTree(this.routerLinkInput, {
      relativeTo: this.relativeTo !== undefined ? this.relativeTo : this.route,
      queryParams: this.queryParams,
      fragment: this.fragment,
      queryParamsHandling: this.queryParamsHandling,
      preserveFragment: this.preserveFragment
    });
  }
  static ɵfac = function RouterLink_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || RouterLink)(_angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵdirectiveInject"](_router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.Router), _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵdirectiveInject"](_router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.ActivatedRoute), _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵinjectAttribute"]('tabindex'), _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_7__.Renderer2), _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_7__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵdirectiveInject"](_angular_common__WEBPACK_IMPORTED_MODULE_1__.LocationStrategy));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵdefineDirective"]({
    type: RouterLink,
    selectors: [["", "routerLink", ""]],
    hostVars: 2,
    hostBindings: function RouterLink_HostBindings(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵlistener"]("click", function RouterLink_click_HostBindingHandler($event) {
          return ctx.onClick($event.button, $event.ctrlKey, $event.shiftKey, $event.altKey, $event.metaKey);
        });
      }
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵattribute"]("href", ctx.reactiveHref(), _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵsanitizeUrlOrResourceUrl"])("target", ctx.target);
      }
    },
    inputs: {
      target: "target",
      queryParams: "queryParams",
      fragment: "fragment",
      queryParamsHandling: "queryParamsHandling",
      state: "state",
      info: "info",
      relativeTo: "relativeTo",
      preserveFragment: [2, "preserveFragment", "preserveFragment", _angular_core__WEBPACK_IMPORTED_MODULE_8__.booleanAttribute],
      skipLocationChange: [2, "skipLocationChange", "skipLocationChange", _angular_core__WEBPACK_IMPORTED_MODULE_8__.booleanAttribute],
      replaceUrl: [2, "replaceUrl", "replaceUrl", _angular_core__WEBPACK_IMPORTED_MODULE_8__.booleanAttribute],
      routerLink: "routerLink"
    },
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵNgOnChangesFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_7__.setClassMetadata(RouterLink, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Directive,
    args: [{
      selector: '[routerLink]',
      host: {
        '[attr.href]': 'reactiveHref()'
      }
    }]
  }], () => [{
    type: _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.Router
  }, {
    type: _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.ActivatedRoute
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Attribute,
      args: ['tabindex']
    }]
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Renderer2
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.ElementRef
  }, {
    type: _angular_common__WEBPACK_IMPORTED_MODULE_1__.LocationStrategy
  }], {
    target: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.HostBinding,
      args: ['attr.target']
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Input
    }],
    queryParams: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Input
    }],
    fragment: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Input
    }],
    queryParamsHandling: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Input
    }],
    state: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Input
    }],
    info: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Input
    }],
    relativeTo: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Input
    }],
    preserveFragment: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Input,
      args: [{
        transform: _angular_core__WEBPACK_IMPORTED_MODULE_8__.booleanAttribute
      }]
    }],
    skipLocationChange: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Input,
      args: [{
        transform: _angular_core__WEBPACK_IMPORTED_MODULE_8__.booleanAttribute
      }]
    }],
    replaceUrl: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Input,
      args: [{
        transform: _angular_core__WEBPACK_IMPORTED_MODULE_8__.booleanAttribute
      }]
    }],
    routerLink: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Input
    }],
    onClick: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.HostListener,
      args: ['click', ['$event.button', '$event.ctrlKey', '$event.shiftKey', '$event.altKey', '$event.metaKey']]
    }]
  });
})();
class RouterLinkActive {
  router;
  element;
  renderer;
  cdr;
  links;
  classes = [];
  routerEventsSubscription;
  linkInputChangesSubscription;
  _isActive = false;
  get isActive() {
    return this._isActive;
  }
  routerLinkActiveOptions = {
    exact: false
  };
  ariaCurrentWhenActive;
  isActiveChange = new _angular_core__WEBPACK_IMPORTED_MODULE_6__.EventEmitter();
  link = (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.inject)(RouterLink, {
    optional: true
  });
  constructor(router, element, renderer, cdr) {
    this.router = router;
    this.element = element;
    this.renderer = renderer;
    this.cdr = cdr;
    this.routerEventsSubscription = router.events.subscribe(s => {
      if (s instanceof _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.NavigationEnd) {
        this.update();
      }
    });
  }
  ngAfterContentInit() {
    (0,rxjs__WEBPACK_IMPORTED_MODULE_12__.of)(this.links.changes, (0,rxjs__WEBPACK_IMPORTED_MODULE_12__.of)(null)).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_16__.mergeAll)()).subscribe(_ => {
      this.update();
      this.subscribeToEachLinkOnChanges();
    });
  }
  subscribeToEachLinkOnChanges() {
    this.linkInputChangesSubscription?.unsubscribe();
    const allLinkChanges = [...this.links.toArray(), this.link].filter(link => !!link).map(link => link.onChanges);
    this.linkInputChangesSubscription = (0,rxjs__WEBPACK_IMPORTED_MODULE_11__.from)(allLinkChanges).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_16__.mergeAll)()).subscribe(link => {
      if (this._isActive !== this.isLinkActive(this.router)(link)) {
        this.update();
      }
    });
  }
  set routerLinkActive(data) {
    const classes = Array.isArray(data) ? data : data.split(' ');
    this.classes = classes.filter(c => !!c);
  }
  ngOnChanges(changes) {
    this.update();
  }
  ngOnDestroy() {
    this.routerEventsSubscription.unsubscribe();
    this.linkInputChangesSubscription?.unsubscribe();
  }
  update() {
    if (!this.links || !this.router.navigated) return;
    queueMicrotask(() => {
      const hasActiveLinks = this.hasActiveLinks();
      this.classes.forEach(c => {
        if (hasActiveLinks) {
          this.renderer.addClass(this.element.nativeElement, c);
        } else {
          this.renderer.removeClass(this.element.nativeElement, c);
        }
      });
      if (hasActiveLinks && this.ariaCurrentWhenActive !== undefined) {
        this.renderer.setAttribute(this.element.nativeElement, 'aria-current', this.ariaCurrentWhenActive.toString());
      } else {
        this.renderer.removeAttribute(this.element.nativeElement, 'aria-current');
      }
      if (this._isActive !== hasActiveLinks) {
        this._isActive = hasActiveLinks;
        this.cdr.markForCheck();
        this.isActiveChange.emit(hasActiveLinks);
      }
    });
  }
  isLinkActive(router) {
    const options = isActiveMatchOptions(this.routerLinkActiveOptions) ? this.routerLinkActiveOptions : this.routerLinkActiveOptions.exact || false;
    return link => {
      const urlTree = link.urlTree;
      return urlTree ? router.isActive(urlTree, options) : false;
    };
  }
  hasActiveLinks() {
    const isActiveCheckFn = this.isLinkActive(this.router);
    return this.link && isActiveCheckFn(this.link) || this.links.some(isActiveCheckFn);
  }
  static ɵfac = function RouterLinkActive_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || RouterLinkActive)(_angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵdirectiveInject"](_router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.Router), _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_7__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_7__.Renderer2), _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_8__.ChangeDetectorRef));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵdefineDirective"]({
    type: RouterLinkActive,
    selectors: [["", "routerLinkActive", ""]],
    contentQueries: function RouterLinkActive_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵcontentQuery"](dirIndex, RouterLink, 5);
      }
      if (rf & 2) {
        let _t;
        _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵloadQuery"]()) && (ctx.links = _t);
      }
    },
    inputs: {
      routerLinkActiveOptions: "routerLinkActiveOptions",
      ariaCurrentWhenActive: "ariaCurrentWhenActive",
      routerLinkActive: "routerLinkActive"
    },
    outputs: {
      isActiveChange: "isActiveChange"
    },
    exportAs: ["routerLinkActive"],
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵNgOnChangesFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_7__.setClassMetadata(RouterLinkActive, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Directive,
    args: [{
      selector: '[routerLinkActive]',
      exportAs: 'routerLinkActive'
    }]
  }], () => [{
    type: _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.Router
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.ElementRef
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Renderer2
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.ChangeDetectorRef
  }], {
    links: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.ContentChildren,
      args: [RouterLink, {
        descendants: true
      }]
    }],
    routerLinkActiveOptions: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Input
    }],
    ariaCurrentWhenActive: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Input
    }],
    isActiveChange: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Output
    }],
    routerLinkActive: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Input
    }]
  });
})();
function isActiveMatchOptions(options) {
  return !!options.paths;
}
class PreloadingStrategy {}
class PreloadAllModules {
  preload(route, fn) {
    return fn().pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_13__.catchError)(() => (0,rxjs__WEBPACK_IMPORTED_MODULE_12__.of)(null)));
  }
  static ɵfac = function PreloadAllModules_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || PreloadAllModules)();
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_6__["ɵɵdefineInjectable"]({
    token: PreloadAllModules,
    factory: PreloadAllModules.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_7__.setClassMetadata(PreloadAllModules, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], null, null);
})();
class NoPreloading {
  preload(route, fn) {
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_12__.of)(null);
  }
  static ɵfac = function NoPreloading_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || NoPreloading)();
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_6__["ɵɵdefineInjectable"]({
    token: NoPreloading,
    factory: NoPreloading.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_7__.setClassMetadata(NoPreloading, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], null, null);
})();
class RouterPreloader {
  router;
  injector;
  preloadingStrategy;
  loader;
  subscription;
  constructor(router, injector, preloadingStrategy, loader) {
    this.router = router;
    this.injector = injector;
    this.preloadingStrategy = preloadingStrategy;
    this.loader = loader;
  }
  setUpPreloading() {
    this.subscription = this.router.events.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_15__.filter)(e => e instanceof _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.NavigationEnd), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_14__.concatMap)(() => this.preload())).subscribe(() => {});
  }
  preload() {
    return this.processRoutes(this.injector, this.router.config);
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  processRoutes(injector, routes) {
    const res = [];
    for (const route of routes) {
      if (route.providers && !route._injector) {
        route._injector = (0,_angular_core__WEBPACK_IMPORTED_MODULE_7__.createEnvironmentInjector)(route.providers, injector, `Route: ${route.path}`);
      }
      const injectorForCurrentRoute = route._injector ?? injector;
      const injectorForChildren = route._loadedInjector ?? injectorForCurrentRoute;
      if (route.loadChildren && !route._loadedRoutes && route.canLoad === undefined || route.loadComponent && !route._loadedComponent) {
        res.push(this.preloadConfig(injectorForCurrentRoute, route));
      }
      if (route.children || route._loadedRoutes) {
        res.push(this.processRoutes(injectorForChildren, route.children ?? route._loadedRoutes));
      }
    }
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_11__.from)(res).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_16__.mergeAll)());
  }
  preloadConfig(injector, route) {
    return this.preloadingStrategy.preload(route, () => {
      let loadedChildren$;
      if (route.loadChildren && route.canLoad === undefined) {
        loadedChildren$ = (0,rxjs__WEBPACK_IMPORTED_MODULE_11__.from)(this.loader.loadChildren(injector, route));
      } else {
        loadedChildren$ = (0,rxjs__WEBPACK_IMPORTED_MODULE_12__.of)(null);
      }
      const recursiveLoadChildren$ = loadedChildren$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_17__.mergeMap)(config => {
        if (config === null) {
          return (0,rxjs__WEBPACK_IMPORTED_MODULE_12__.of)(void 0);
        }
        route._loadedRoutes = config.routes;
        route._loadedInjector = config.injector;
        return this.processRoutes(config.injector ?? injector, config.routes);
      }));
      if (route.loadComponent && !route._loadedComponent) {
        const loadComponent$ = this.loader.loadComponent(injector, route);
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_11__.from)([recursiveLoadChildren$, loadComponent$]).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_16__.mergeAll)());
      } else {
        return recursiveLoadChildren$;
      }
    });
  }
  static ɵfac = function RouterPreloader_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || RouterPreloader)(_angular_core__WEBPACK_IMPORTED_MODULE_6__["ɵɵinject"](_router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.Router), _angular_core__WEBPACK_IMPORTED_MODULE_6__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_6__.EnvironmentInjector), _angular_core__WEBPACK_IMPORTED_MODULE_6__["ɵɵinject"](PreloadingStrategy), _angular_core__WEBPACK_IMPORTED_MODULE_6__["ɵɵinject"](_router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.RouterConfigLoader));
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_6__["ɵɵdefineInjectable"]({
    token: RouterPreloader,
    factory: RouterPreloader.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_7__.setClassMetadata(RouterPreloader, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], () => [{
    type: _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.Router
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_6__.EnvironmentInjector
  }, {
    type: PreloadingStrategy
  }, {
    type: _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.RouterConfigLoader
  }], null);
})();
const ROUTER_SCROLLER = new _angular_core__WEBPACK_IMPORTED_MODULE_6__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Router Scroller' : '');
class RouterScroller {
  urlSerializer;
  transitions;
  viewportScroller;
  zone;
  options;
  routerEventsSubscription;
  scrollEventsSubscription;
  lastId = 0;
  lastSource = _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.IMPERATIVE_NAVIGATION;
  restoredId = 0;
  store = {};
  constructor(urlSerializer, transitions, viewportScroller, zone, options = {}) {
    this.urlSerializer = urlSerializer;
    this.transitions = transitions;
    this.viewportScroller = viewportScroller;
    this.zone = zone;
    this.options = options;
    options.scrollPositionRestoration ||= 'disabled';
    options.anchorScrolling ||= 'disabled';
  }
  init() {
    if (this.options.scrollPositionRestoration !== 'disabled') {
      this.viewportScroller.setHistoryScrollRestoration('manual');
    }
    this.routerEventsSubscription = this.createScrollEvents();
    this.scrollEventsSubscription = this.consumeScrollEvents();
  }
  createScrollEvents() {
    return this.transitions.events.subscribe(e => {
      if (e instanceof _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.NavigationStart) {
        this.store[this.lastId] = this.viewportScroller.getScrollPosition();
        this.lastSource = e.navigationTrigger;
        this.restoredId = e.restoredState ? e.restoredState.navigationId : 0;
      } else if (e instanceof _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.NavigationEnd) {
        this.lastId = e.id;
        this.scheduleScrollEvent(e, this.urlSerializer.parse(e.urlAfterRedirects).fragment);
      } else if (e instanceof _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.NavigationSkipped && e.code === _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.NavigationSkippedCode.IgnoredSameUrlNavigation) {
        this.lastSource = undefined;
        this.restoredId = 0;
        this.scheduleScrollEvent(e, this.urlSerializer.parse(e.url).fragment);
      }
    });
  }
  consumeScrollEvents() {
    return this.transitions.events.subscribe(e => {
      if (!(e instanceof _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.Scroll)) return;
      const instantScroll = {
        behavior: 'instant'
      };
      if (e.position) {
        if (this.options.scrollPositionRestoration === 'top') {
          this.viewportScroller.scrollToPosition([0, 0], instantScroll);
        } else if (this.options.scrollPositionRestoration === 'enabled') {
          this.viewportScroller.scrollToPosition(e.position, instantScroll);
        }
      } else {
        if (e.anchor && this.options.anchorScrolling === 'enabled') {
          this.viewportScroller.scrollToAnchor(e.anchor);
        } else if (this.options.scrollPositionRestoration !== 'disabled') {
          this.viewportScroller.scrollToPosition([0, 0]);
        }
      }
    });
  }
  scheduleScrollEvent(routerEvent, anchor) {
    var _this = this;
    this.zone.runOutsideAngular(/*#__PURE__*/(0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      yield new Promise(resolve => {
        setTimeout(resolve);
        if (typeof requestAnimationFrame !== 'undefined') {
          requestAnimationFrame(resolve);
        }
      });
      _this.zone.run(() => {
        _this.transitions.events.next(new _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.Scroll(routerEvent, _this.lastSource === 'popstate' ? _this.store[_this.restoredId] : null, anchor));
      });
    }));
  }
  ngOnDestroy() {
    this.routerEventsSubscription?.unsubscribe();
    this.scrollEventsSubscription?.unsubscribe();
  }
  static ɵfac = function RouterScroller_Factory(__ngFactoryType__) {
    _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵinvalidFactory"]();
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_6__["ɵɵdefineInjectable"]({
    token: RouterScroller,
    factory: RouterScroller.ɵfac
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_7__.setClassMetadata(RouterScroller, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Injectable
  }], () => [{
    type: _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.UrlSerializer
  }, {
    type: _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.NavigationTransitions
  }, {
    type: _angular_common__WEBPACK_IMPORTED_MODULE_2__.ViewportScroller
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_6__.NgZone
  }, {
    type: undefined
  }], null);
})();
function getLoadedRoutes(route) {
  return route._loadedRoutes;
}
function getRouterInstance(injector) {
  return injector.get(_router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.Router, null, {
    optional: true
  });
}
function navigateByUrl(router, url) {
  if (!(router instanceof _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.Router)) {
    throw new Error('The provided router is not an Angular Router.');
  }
  return router.navigateByUrl(url);
}
class NavigationStateManager extends _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.HistoryStateManager {
  navigation = (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.inject)(_angular_common__WEBPACK_IMPORTED_MODULE_4__.PlatformNavigation);
  registerNonRouterCurrentEntryChangeListener(listener) {
    return this.location.subscribe(event => {
      if (event['type'] === 'popstate') {
        const state = this.navigation.currentEntry?.getState();
        listener(event['url'], state, 'popstate');
      }
    });
  }
  static ɵfac = /* @__PURE__ */(() => {
    let ɵNavigationStateManager_BaseFactory;
    return function NavigationStateManager_Factory(__ngFactoryType__) {
      return (ɵNavigationStateManager_BaseFactory || (ɵNavigationStateManager_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵgetInheritedFactory"](NavigationStateManager)))(__ngFactoryType__ || NavigationStateManager);
    };
  })();
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_6__["ɵɵdefineInjectable"]({
    token: NavigationStateManager,
    factory: NavigationStateManager.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_7__.setClassMetadata(NavigationStateManager, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], null, null);
})();
function provideRouter(routes, ...features) {
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_7__.publishExternalGlobalUtil)('ɵgetLoadedRoutes', getLoadedRoutes);
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_7__.publishExternalGlobalUtil)('ɵgetRouterInstance', getRouterInstance);
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_7__.publishExternalGlobalUtil)('ɵnavigateByUrl', navigateByUrl);
  }
  return (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.makeEnvironmentProviders)([{
    provide: _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.ROUTES,
    multi: true,
    useValue: routes
  }, typeof ngDevMode === 'undefined' || ngDevMode ? {
    provide: ROUTER_IS_PROVIDED,
    useValue: true
  } : [], {
    provide: _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.ActivatedRoute,
    useFactory: rootRoute
  }, {
    provide: _angular_core__WEBPACK_IMPORTED_MODULE_7__.APP_BOOTSTRAP_LISTENER,
    multi: true,
    useFactory: getBootstrapListener
  }, features.map(feature => feature.ɵproviders)]);
}
function rootRoute() {
  return (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.inject)(_router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.Router).routerState.root;
}
function routerFeature(kind, providers) {
  return {
    ɵkind: kind,
    ɵproviders: providers
  };
}
const ROUTER_IS_PROVIDED = new _angular_core__WEBPACK_IMPORTED_MODULE_6__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Router is provided' : '', {
  factory: () => false
});
const routerIsProvidedDevModeCheck = {
  provide: _angular_core__WEBPACK_IMPORTED_MODULE_6__.ENVIRONMENT_INITIALIZER,
  multi: true,
  useFactory() {
    return () => {
      if (!(0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.inject)(ROUTER_IS_PROVIDED)) {
        console.warn('`provideRoutes` was called without `provideRouter` or `RouterModule.forRoot`. ' + 'This is likely a mistake.');
      }
    };
  }
};
function provideRoutes(routes) {
  return [{
    provide: _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.ROUTES,
    multi: true,
    useValue: routes
  }, typeof ngDevMode === 'undefined' || ngDevMode ? routerIsProvidedDevModeCheck : []];
}
function withInMemoryScrolling(options = {}) {
  const providers = [{
    provide: ROUTER_SCROLLER,
    useFactory: () => {
      const viewportScroller = (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.inject)(_angular_common__WEBPACK_IMPORTED_MODULE_2__.ViewportScroller);
      const zone = (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_6__.NgZone);
      const transitions = (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.inject)(_router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.NavigationTransitions);
      const urlSerializer = (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.inject)(_router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.UrlSerializer);
      return new RouterScroller(urlSerializer, transitions, viewportScroller, zone, options);
    }
  }];
  return routerFeature(4, providers);
}
function withPlatformNavigation() {
  const devModeLocationCheck = typeof ngDevMode === 'undefined' || ngDevMode ? [(0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.provideEnvironmentInitializer)(() => {
    const locationInstance = (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.inject)(_angular_common__WEBPACK_IMPORTED_MODULE_1__.Location);
    if (!(locationInstance instanceof _angular_common__WEBPACK_IMPORTED_MODULE_2__["ɵNavigationAdapterForLocation"])) {
      const locationConstructorName = locationInstance.constructor.name;
      let message = `'withPlatformNavigation' provides a 'Location' implementation that ensures navigation APIs are consistently used.` + ` An instance of ${locationConstructorName} was found instead.`;
      if (locationConstructorName === 'SpyLocation') {
        message += ` One of 'RouterTestingModule' or 'provideLocationMocks' was likely used. 'withPlatformNavigation' does not work with these because they override the Location implementation.`;
      }
      throw new Error(message);
    }
  })] : [];
  const providers = [{
    provide: _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.StateManager,
    useExisting: NavigationStateManager
  }, {
    provide: _angular_common__WEBPACK_IMPORTED_MODULE_1__.Location,
    useClass: _angular_common__WEBPACK_IMPORTED_MODULE_2__["ɵNavigationAdapterForLocation"]
  }, devModeLocationCheck];
  return routerFeature(4, providers);
}
function getBootstrapListener() {
  const injector = (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_6__.Injector);
  return bootstrappedComponentRef => {
    const ref = injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_7__.ApplicationRef);
    if (bootstrappedComponentRef !== ref.components[0]) {
      return;
    }
    const router = injector.get(_router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.Router);
    const bootstrapDone = injector.get(BOOTSTRAP_DONE);
    if (injector.get(INITIAL_NAVIGATION) === 1) {
      router.initialNavigation();
    }
    injector.get(ROUTER_PRELOADER, null, {
      optional: true
    })?.setUpPreloading();
    injector.get(ROUTER_SCROLLER, null, {
      optional: true
    })?.init();
    router.resetRootComponentType(ref.componentTypes[0]);
    if (!bootstrapDone.closed) {
      bootstrapDone.next();
      bootstrapDone.complete();
      bootstrapDone.unsubscribe();
    }
  };
}
const BOOTSTRAP_DONE = new _angular_core__WEBPACK_IMPORTED_MODULE_6__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'bootstrap done indicator' : '', {
  factory: () => {
    return new rxjs__WEBPACK_IMPORTED_MODULE_10__.Subject();
  }
});
const INITIAL_NAVIGATION = new _angular_core__WEBPACK_IMPORTED_MODULE_6__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'initial navigation' : '', {
  factory: () => 1
});
function withEnabledBlockingInitialNavigation() {
  const providers = [{
    provide: _angular_core__WEBPACK_IMPORTED_MODULE_7__.IS_ENABLED_BLOCKING_INITIAL_NAVIGATION,
    useValue: true
  }, {
    provide: INITIAL_NAVIGATION,
    useValue: 0
  }, (0,_angular_core__WEBPACK_IMPORTED_MODULE_7__.provideAppInitializer)(() => {
    const injector = (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_6__.Injector);
    const locationInitialized = injector.get(_angular_common__WEBPACK_IMPORTED_MODULE_5__.LOCATION_INITIALIZED, Promise.resolve());
    return locationInitialized.then(() => {
      return new Promise(resolve => {
        const router = injector.get(_router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.Router);
        const bootstrapDone = injector.get(BOOTSTRAP_DONE);
        (0,_router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.afterNextNavigation)(router, () => {
          resolve(true);
        });
        injector.get(_router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.NavigationTransitions).afterPreactivation = () => {
          resolve(true);
          return bootstrapDone.closed ? (0,rxjs__WEBPACK_IMPORTED_MODULE_12__.of)(void 0) : bootstrapDone;
        };
        router.initialNavigation();
      });
    });
  })];
  return routerFeature(2, providers);
}
function withDisabledInitialNavigation() {
  const providers = [(0,_angular_core__WEBPACK_IMPORTED_MODULE_7__.provideAppInitializer)(() => {
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.inject)(_router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.Router).setUpLocationChangeListener();
  }), {
    provide: INITIAL_NAVIGATION,
    useValue: 2
  }];
  return routerFeature(3, providers);
}
function withDebugTracing() {
  let providers = [];
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
    providers = [{
      provide: _angular_core__WEBPACK_IMPORTED_MODULE_6__.ENVIRONMENT_INITIALIZER,
      multi: true,
      useFactory: () => {
        const router = (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.inject)(_router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.Router);
        return () => router.events.subscribe(e => {
          console.group?.(`Router Event: ${e.constructor.name}`);
          console.log((0,_router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.stringifyEvent)(e));
          console.log(e);
          console.groupEnd?.();
        });
      }
    }];
  } else {
    providers = [];
  }
  return routerFeature(1, providers);
}
const ROUTER_PRELOADER = new _angular_core__WEBPACK_IMPORTED_MODULE_6__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'router preloader' : '');
function withPreloading(preloadingStrategy) {
  const providers = [{
    provide: ROUTER_PRELOADER,
    useExisting: RouterPreloader
  }, {
    provide: PreloadingStrategy,
    useExisting: preloadingStrategy
  }];
  return routerFeature(0, providers);
}
function withRouterConfig(options) {
  const providers = [{
    provide: _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.ROUTER_CONFIGURATION,
    useValue: options
  }];
  return routerFeature(5, providers);
}
function withHashLocation() {
  const providers = [{
    provide: _angular_common__WEBPACK_IMPORTED_MODULE_1__.LocationStrategy,
    useClass: _angular_common__WEBPACK_IMPORTED_MODULE_3__.HashLocationStrategy
  }];
  return routerFeature(6, providers);
}
function withNavigationErrorHandler(handler) {
  const providers = [{
    provide: _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.NAVIGATION_ERROR_HANDLER,
    useValue: handler
  }];
  return routerFeature(7, providers);
}
function withComponentInputBinding() {
  const providers = [_router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.RoutedComponentInputBinder, {
    provide: _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.INPUT_BINDER,
    useExisting: _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.RoutedComponentInputBinder
  }];
  return routerFeature(8, providers);
}
function withViewTransitions(options) {
  (0,_angular_core__WEBPACK_IMPORTED_MODULE_7__.performanceMarkFeature)('NgRouterViewTransitions');
  const providers = [{
    provide: _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.CREATE_VIEW_TRANSITION,
    useValue: _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.createViewTransition
  }, {
    provide: _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.VIEW_TRANSITION_OPTIONS,
    useValue: {
      skipNextTransition: !!options?.skipInitialTransition,
      ...options
    }
  }];
  return routerFeature(9, providers);
}
const ROUTER_DIRECTIVES = [_router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.RouterOutlet, RouterLink, RouterLinkActive, _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__["ɵEmptyOutletComponent"]];
const ROUTER_FORROOT_GUARD = new _angular_core__WEBPACK_IMPORTED_MODULE_6__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'router duplicate forRoot guard' : '');
const ROUTER_PROVIDERS = [_angular_common__WEBPACK_IMPORTED_MODULE_1__.Location, {
  provide: _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.UrlSerializer,
  useClass: _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.DefaultUrlSerializer
}, _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.Router, _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.ChildrenOutletContexts, {
  provide: _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.ActivatedRoute,
  useFactory: rootRoute
}, _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.RouterConfigLoader, typeof ngDevMode === 'undefined' || ngDevMode ? {
  provide: ROUTER_IS_PROVIDED,
  useValue: true
} : []];
class RouterModule {
  constructor() {
    if (typeof ngDevMode === 'undefined' || ngDevMode) {
      (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.inject)(ROUTER_FORROOT_GUARD, {
        optional: true
      });
    }
  }
  static forRoot(routes, config) {
    return {
      ngModule: RouterModule,
      providers: [ROUTER_PROVIDERS, typeof ngDevMode === 'undefined' || ngDevMode ? config?.enableTracing ? withDebugTracing().ɵproviders : [] : [], {
        provide: _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.ROUTES,
        multi: true,
        useValue: routes
      }, typeof ngDevMode === 'undefined' || ngDevMode ? {
        provide: ROUTER_FORROOT_GUARD,
        useFactory: provideForRootGuard
      } : [], config?.errorHandler ? {
        provide: _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.NAVIGATION_ERROR_HANDLER,
        useValue: config.errorHandler
      } : [], {
        provide: _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.ROUTER_CONFIGURATION,
        useValue: config ? config : {}
      }, config?.useHash ? provideHashLocationStrategy() : providePathLocationStrategy(), provideRouterScroller(), config?.preloadingStrategy ? withPreloading(config.preloadingStrategy).ɵproviders : [], config?.initialNavigation ? provideInitialNavigation(config) : [], config?.bindToComponentInputs ? withComponentInputBinding().ɵproviders : [], config?.enableViewTransitions ? withViewTransitions().ɵproviders : [], provideRouterInitializer()]
    };
  }
  static forChild(routes) {
    return {
      ngModule: RouterModule,
      providers: [{
        provide: _router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.ROUTES,
        multi: true,
        useValue: routes
      }]
    };
  }
  static ɵfac = function RouterModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || RouterModule)();
  };
  static ɵmod = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵdefineNgModule"]({
    type: RouterModule
  });
  static ɵinj = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_6__["ɵɵdefineInjector"]({});
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_7__.setClassMetadata(RouterModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.NgModule,
    args: [{
      imports: ROUTER_DIRECTIVES,
      exports: ROUTER_DIRECTIVES
    }]
  }], () => [], null);
})();
function provideRouterScroller() {
  return {
    provide: ROUTER_SCROLLER,
    useFactory: () => {
      const viewportScroller = (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.inject)(_angular_common__WEBPACK_IMPORTED_MODULE_2__.ViewportScroller);
      const zone = (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_6__.NgZone);
      const config = (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.inject)(_router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.ROUTER_CONFIGURATION);
      const transitions = (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.inject)(_router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.NavigationTransitions);
      const urlSerializer = (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.inject)(_router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.UrlSerializer);
      if (config.scrollOffset) {
        viewportScroller.setOffset(config.scrollOffset);
      }
      return new RouterScroller(urlSerializer, transitions, viewportScroller, zone, config);
    }
  };
}
function provideHashLocationStrategy() {
  return {
    provide: _angular_common__WEBPACK_IMPORTED_MODULE_1__.LocationStrategy,
    useClass: _angular_common__WEBPACK_IMPORTED_MODULE_3__.HashLocationStrategy
  };
}
function providePathLocationStrategy() {
  return {
    provide: _angular_common__WEBPACK_IMPORTED_MODULE_1__.LocationStrategy,
    useClass: _angular_common__WEBPACK_IMPORTED_MODULE_1__.PathLocationStrategy
  };
}
function provideForRootGuard() {
  const router = (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.inject)(_router_chunk_mjs__WEBPACK_IMPORTED_MODULE_9__.Router, {
    optional: true,
    skipSelf: true
  });
  if (router) {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_6__.RuntimeError(4007, `The Router was provided more than once. This can happen if 'forRoot' is used outside of the root injector.` + ` Lazy loaded modules should use RouterModule.forChild() instead.`);
  }
  return 'guarded';
}
function provideInitialNavigation(config) {
  return [config.initialNavigation === 'disabled' ? withDisabledInitialNavigation().ɵproviders : [], config.initialNavigation === 'enabledBlocking' ? withEnabledBlockingInitialNavigation().ɵproviders : []];
}
const ROUTER_INITIALIZER = new _angular_core__WEBPACK_IMPORTED_MODULE_6__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'Router Initializer' : '');
function provideRouterInitializer() {
  return [{
    provide: ROUTER_INITIALIZER,
    useFactory: getBootstrapListener
  }, {
    provide: _angular_core__WEBPACK_IMPORTED_MODULE_7__.APP_BOOTSTRAP_LISTENER,
    multi: true,
    useExisting: ROUTER_INITIALIZER
  }];
}


/***/ }),

/***/ 1584:
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/operators/subscribeOn.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   subscribeOn: () => (/* binding */ subscribeOn)
/* harmony export */ });
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ 8419);

function subscribeOn(scheduler, delay = 0) {
  return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)((source, subscriber) => {
    subscriber.add(scheduler.schedule(() => source.subscribe(subscriber), delay));
  });
}

/***/ }),

/***/ 1676:
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/NotificationFactories.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   COMPLETE_NOTIFICATION: () => (/* binding */ COMPLETE_NOTIFICATION),
/* harmony export */   createNotification: () => (/* binding */ createNotification),
/* harmony export */   errorNotification: () => (/* binding */ errorNotification),
/* harmony export */   nextNotification: () => (/* binding */ nextNotification)
/* harmony export */ });
const COMPLETE_NOTIFICATION = (() => createNotification('C', undefined, undefined))();
function errorNotification(error) {
  return createNotification('E', undefined, error);
}
function nextNotification(value) {
  return createNotification('N', value, undefined);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

/***/ }),

/***/ 1683:
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/util/args.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   popNumber: () => (/* binding */ popNumber),
/* harmony export */   popResultSelector: () => (/* binding */ popResultSelector),
/* harmony export */   popScheduler: () => (/* binding */ popScheduler)
/* harmony export */ });
/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction */ 4010);
/* harmony import */ var _isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isScheduler */ 5669);


function last(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args) {
  return (0,_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(last(args)) ? args.pop() : undefined;
}
function popScheduler(args) {
  return (0,_isScheduler__WEBPACK_IMPORTED_MODULE_1__.isScheduler)(last(args)) ? args.pop() : undefined;
}
function popNumber(args, defaultValue) {
  return typeof last(args) === 'number' ? args.pop() : defaultValue;
}

/***/ }),

/***/ 1814:
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/Observable.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Observable: () => (/* binding */ Observable)
/* harmony export */ });
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Subscriber */ 7157);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Subscription */ 1038);
/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./symbol/observable */ 1935);
/* harmony import */ var _util_pipe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/pipe */ 3282);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./config */ 1157);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util/isFunction */ 4010);
/* harmony import */ var _util_errorContext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util/errorContext */ 7831);







class Observable {
  constructor(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  lift(operator) {
    const observable = new Observable();
    observable.source = this;
    observable.operator = operator;
    return observable;
  }
  subscribe(observerOrNext, error, complete) {
    const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new _Subscriber__WEBPACK_IMPORTED_MODULE_0__.SafeSubscriber(observerOrNext, error, complete);
    (0,_util_errorContext__WEBPACK_IMPORTED_MODULE_6__.errorContext)(() => {
      const {
        operator,
        source
      } = this;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? this._subscribe(subscriber) : this._trySubscribe(subscriber));
    });
    return subscriber;
  }
  _trySubscribe(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  }
  forEach(next, promiseCtor) {
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor((resolve, reject) => {
      const subscriber = new _Subscriber__WEBPACK_IMPORTED_MODULE_0__.SafeSubscriber({
        next: value => {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      this.subscribe(subscriber);
    });
  }
  _subscribe(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  }
  [_symbol_observable__WEBPACK_IMPORTED_MODULE_2__.observable]() {
    return this;
  }
  pipe(...operations) {
    return (0,_util_pipe__WEBPACK_IMPORTED_MODULE_3__.pipeFromArray)(operations)(this);
  }
  toPromise(promiseCtor) {
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor((resolve, reject) => {
      let value;
      this.subscribe(x => value = x, err => reject(err), () => resolve(value));
    });
  }
}
Observable.create = subscribe => {
  return new Observable(subscribe);
};
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : _config__WEBPACK_IMPORTED_MODULE_4__.config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_5__.isFunction)(value.next) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_5__.isFunction)(value.error) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_5__.isFunction)(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof _Subscriber__WEBPACK_IMPORTED_MODULE_0__.Subscriber || isObserver(value) && (0,_Subscription__WEBPACK_IMPORTED_MODULE_1__.isSubscription)(value);
}

/***/ }),

/***/ 1834:
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/operators/defaultIfEmpty.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultIfEmpty: () => (/* binding */ defaultIfEmpty)
/* harmony export */ });
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ 8419);
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OperatorSubscriber */ 3943);


function defaultIfEmpty(defaultValue) {
  return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)((source, subscriber) => {
    let hasValue = false;
    source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, value => {
      hasValue = true;
      subscriber.next(value);
    }, () => {
      if (!hasValue) {
        subscriber.next(defaultValue);
      }
      subscriber.complete();
    }));
  });
}

/***/ }),

/***/ 1918:
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/util/noop.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   noop: () => (/* binding */ noop)
/* harmony export */ });
function noop() {}

/***/ }),

/***/ 1923:
/*!*****************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@angular+core@21.0.5_@angular+compiler@21.0.5_rxjs@7.8.2_zone.js@0.16.0/node_modules/@angular/core/fesm2022/_linked_signal-chunk.mjs ***!
  \*****************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createLinkedSignal: () => (/* binding */ createLinkedSignal),
/* harmony export */   linkedSignalSetFn: () => (/* binding */ linkedSignalSetFn),
/* harmony export */   linkedSignalUpdateFn: () => (/* binding */ linkedSignalUpdateFn)
/* harmony export */ });
/* harmony import */ var _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_effect-chunk.mjs */ 476);
/**
 * @license Angular v21.0.5
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */


function createLinkedSignal(sourceFn, computationFn, equalityFn) {
  const node = Object.create(LINKED_SIGNAL_NODE);
  node.source = sourceFn;
  node.computation = computationFn;
  if (equalityFn != undefined) {
    node.equal = equalityFn;
  }
  const linkedSignalGetter = () => {
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.producerUpdateValueVersion)(node);
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.producerAccessed)(node);
    if (node.value === _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ERRORED) {
      throw node.error;
    }
    return node.value;
  };
  const getter = linkedSignalGetter;
  getter[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.SIGNAL] = node;
  if (typeof ngDevMode !== 'undefined' && ngDevMode) {
    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';
    getter.toString = () => `[LinkedSignal${debugName}: ${node.value}]`;
  }
  (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.runPostProducerCreatedFn)(node);
  return getter;
}
function linkedSignalSetFn(node, newValue) {
  (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.producerUpdateValueVersion)(node);
  (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.signalSetFn)(node, newValue);
  (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.producerMarkClean)(node);
}
function linkedSignalUpdateFn(node, updater) {
  (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.producerUpdateValueVersion)(node);
  (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.signalUpdateFn)(node, updater);
  (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.producerMarkClean)(node);
}
const LINKED_SIGNAL_NODE = /* @__PURE__ */(() => {
  return {
    ..._effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.REACTIVE_NODE,
    value: _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.UNSET,
    dirty: true,
    error: null,
    equal: _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.defaultEquals,
    kind: 'linkedSignal',
    producerMustRecompute(node) {
      return node.value === _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.UNSET || node.value === _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.COMPUTING;
    },
    producerRecomputeValue(node) {
      if (node.value === _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.COMPUTING) {
        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');
      }
      const oldValue = node.value;
      node.value = _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.COMPUTING;
      const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.consumerBeforeComputation)(node);
      let newValue;
      try {
        const newSourceValue = node.source();
        const prev = oldValue === _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.UNSET || oldValue === _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ERRORED ? undefined : {
          source: node.sourceValue,
          value: oldValue
        };
        newValue = node.computation(newSourceValue, prev);
        node.sourceValue = newSourceValue;
      } catch (err) {
        newValue = _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ERRORED;
        node.error = err;
      } finally {
        (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.consumerAfterComputation)(node, prevConsumer);
      }
      if (oldValue !== _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.UNSET && newValue !== _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ERRORED && node.equal(oldValue, newValue)) {
        node.value = oldValue;
        return;
      }
      node.value = newValue;
      node.version++;
    }
  };
})();


/***/ }),

/***/ 1935:
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/symbol/observable.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   observable: () => (/* binding */ observable)
/* harmony export */ });
const observable = (() => typeof Symbol === 'function' && Symbol.observable || '@@observable')();

/***/ }),

/***/ 1991:
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/operators/mergeMap.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mergeMap: () => (/* binding */ mergeMap)
/* harmony export */ });
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map */ 4063);
/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../observable/innerFrom */ 5829);
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/lift */ 8419);
/* harmony import */ var _mergeInternals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mergeInternals */ 3439);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/isFunction */ 4010);





function mergeMap(project, resultSelector, concurrent = Infinity) {
  if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_4__.isFunction)(resultSelector)) {
    return mergeMap((a, i) => (0,_map__WEBPACK_IMPORTED_MODULE_0__.map)((b, ii) => resultSelector(a, b, i, ii))((0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_1__.innerFrom)(project(a, i))), concurrent);
  } else if (typeof resultSelector === 'number') {
    concurrent = resultSelector;
  }
  return (0,_util_lift__WEBPACK_IMPORTED_MODULE_2__.operate)((source, subscriber) => (0,_mergeInternals__WEBPACK_IMPORTED_MODULE_3__.mergeInternals)(source, subscriber, project, concurrent));
}

/***/ }),

/***/ 2473:
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/observable/concat.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   concat: () => (/* binding */ concat)
/* harmony export */ });
/* harmony import */ var _operators_concatAll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../operators/concatAll */ 302);
/* harmony import */ var _util_args__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/args */ 1683);
/* harmony import */ var _from__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./from */ 7909);



function concat(...args) {
  return (0,_operators_concatAll__WEBPACK_IMPORTED_MODULE_0__.concatAll)()((0,_from__WEBPACK_IMPORTED_MODULE_2__.from)(args, (0,_util_args__WEBPACK_IMPORTED_MODULE_1__.popScheduler)(args)));
}

/***/ }),

/***/ 2556:
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/operators/tap.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tap: () => (/* binding */ tap)
/* harmony export */ });
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/isFunction */ 4010);
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/lift */ 8419);
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OperatorSubscriber */ 3943);
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/identity */ 5232);




function tap(observerOrNext, error, complete) {
  const tapObserver = (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(observerOrNext) || error || complete ? {
    next: observerOrNext,
    error,
    complete
  } : observerOrNext;
  return tapObserver ? (0,_util_lift__WEBPACK_IMPORTED_MODULE_1__.operate)((source, subscriber) => {
    var _a;
    (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
    let isUnsub = true;
    source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__.createOperatorSubscriber)(subscriber, value => {
      var _a;
      (_a = tapObserver.next) === null || _a === void 0 ? void 0 : _a.call(tapObserver, value);
      subscriber.next(value);
    }, () => {
      var _a;
      isUnsub = false;
      (_a = tapObserver.complete) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
      subscriber.complete();
    }, err => {
      var _a;
      isUnsub = false;
      (_a = tapObserver.error) === null || _a === void 0 ? void 0 : _a.call(tapObserver, err);
      subscriber.error(err);
    }, () => {
      var _a, _b;
      if (isUnsub) {
        (_a = tapObserver.unsubscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : _util_identity__WEBPACK_IMPORTED_MODULE_3__.identity;
}

/***/ }),

/***/ 2572:
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/util/isInteropObservable.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isInteropObservable: () => (/* binding */ isInteropObservable)
/* harmony export */ });
/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../symbol/observable */ 1935);
/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction */ 4010);


function isInteropObservable(input) {
  return (0,_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(input[_symbol_observable__WEBPACK_IMPORTED_MODULE_0__.observable]);
}

/***/ }),

/***/ 2761:
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/observable/defer.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defer: () => (/* binding */ defer)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ 1814);
/* harmony import */ var _innerFrom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./innerFrom */ 5829);


function defer(observableFactory) {
  return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(subscriber => {
    (0,_innerFrom__WEBPACK_IMPORTED_MODULE_1__.innerFrom)(observableFactory()).subscribe(subscriber);
  });
}

/***/ }),

/***/ 2802:
/*!********************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@angular+common@21.0.5_@angular+core@21.0.5_rxjs@7.8.2/node_modules/@angular/common/fesm2022/_platform_navigation-chunk.mjs ***!
  \********************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PlatformNavigation: () => (/* binding */ PlatformNavigation)
/* harmony export */ });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ 64);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ 7367);
/**
 * @license Angular v21.0.5
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */



class PlatformNavigation {
  static ɵfac = function PlatformNavigation_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || PlatformNavigation)();
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: PlatformNavigation,
    factory: () => (() => window.navigation)(),
    providedIn: 'platform'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(PlatformNavigation, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,
    args: [{
      providedIn: 'platform',
      useFactory: () => window.navigation
    }]
  }], null, null);
})();


/***/ }),

/***/ 3008:
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/util/isIterable.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isIterable: () => (/* binding */ isIterable)
/* harmony export */ });
/* harmony import */ var _symbol_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../symbol/iterator */ 4956);
/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction */ 4010);


function isIterable(input) {
  return (0,_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(input === null || input === void 0 ? void 0 : input[_symbol_iterator__WEBPACK_IMPORTED_MODULE_0__.iterator]);
}

/***/ }),

/***/ 3036:
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@angular+common@21.0.5_@angular+core@21.0.5_rxjs@7.8.2/node_modules/@angular/common/fesm2022/_module-chunk.mjs ***!
  \*******************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FetchBackend: () => (/* binding */ FetchBackend),
/* harmony export */   HTTP_INTERCEPTORS: () => (/* binding */ HTTP_INTERCEPTORS),
/* harmony export */   HTTP_ROOT_INTERCEPTOR_FNS: () => (/* binding */ HTTP_ROOT_INTERCEPTOR_FNS),
/* harmony export */   HttpBackend: () => (/* binding */ HttpBackend),
/* harmony export */   HttpClient: () => (/* binding */ HttpClient),
/* harmony export */   HttpClientJsonpModule: () => (/* binding */ HttpClientJsonpModule),
/* harmony export */   HttpClientModule: () => (/* binding */ HttpClientModule),
/* harmony export */   HttpClientXsrfModule: () => (/* binding */ HttpClientXsrfModule),
/* harmony export */   HttpContext: () => (/* binding */ HttpContext),
/* harmony export */   HttpContextToken: () => (/* binding */ HttpContextToken),
/* harmony export */   HttpErrorResponse: () => (/* binding */ HttpErrorResponse),
/* harmony export */   HttpEventType: () => (/* binding */ HttpEventType),
/* harmony export */   HttpFeatureKind: () => (/* binding */ HttpFeatureKind),
/* harmony export */   HttpHandler: () => (/* binding */ HttpHandler),
/* harmony export */   HttpHeaderResponse: () => (/* binding */ HttpHeaderResponse),
/* harmony export */   HttpHeaders: () => (/* binding */ HttpHeaders),
/* harmony export */   HttpInterceptorHandler: () => (/* binding */ HttpInterceptorHandler),
/* harmony export */   HttpParams: () => (/* binding */ HttpParams),
/* harmony export */   HttpRequest: () => (/* binding */ HttpRequest),
/* harmony export */   HttpResponse: () => (/* binding */ HttpResponse),
/* harmony export */   HttpResponseBase: () => (/* binding */ HttpResponseBase),
/* harmony export */   HttpStatusCode: () => (/* binding */ HttpStatusCode),
/* harmony export */   HttpUrlEncodingCodec: () => (/* binding */ HttpUrlEncodingCodec),
/* harmony export */   HttpXhrBackend: () => (/* binding */ HttpXhrBackend),
/* harmony export */   HttpXsrfTokenExtractor: () => (/* binding */ HttpXsrfTokenExtractor),
/* harmony export */   JsonpClientBackend: () => (/* binding */ JsonpClientBackend),
/* harmony export */   JsonpInterceptor: () => (/* binding */ JsonpInterceptor),
/* harmony export */   REQUESTS_CONTRIBUTE_TO_STABILITY: () => (/* binding */ REQUESTS_CONTRIBUTE_TO_STABILITY),
/* harmony export */   provideHttpClient: () => (/* binding */ provideHttpClient),
/* harmony export */   withFetch: () => (/* binding */ withFetch),
/* harmony export */   withInterceptors: () => (/* binding */ withInterceptors),
/* harmony export */   withInterceptorsFromDi: () => (/* binding */ withInterceptorsFromDi),
/* harmony export */   withJsonpSupport: () => (/* binding */ withJsonpSupport),
/* harmony export */   withNoXsrfProtection: () => (/* binding */ withNoXsrfProtection),
/* harmony export */   withRequestsMadeViaParent: () => (/* binding */ withRequestsMadeViaParent),
/* harmony export */   withXsrfConfiguration: () => (/* binding */ withXsrfConfiguration)
/* harmony export */ });
/* harmony import */ var C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 3194);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ 64);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ 7367);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs/operators */ 4927);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ 4191);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs/operators */ 4563);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs/operators */ 4063);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs/operators */ 9671);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs */ 1814);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! rxjs */ 7909);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! rxjs */ 9596);
/* harmony import */ var _xhr_chunk_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./_xhr-chunk.mjs */ 7802);
/* harmony import */ var _platform_location_chunk_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./_platform_location-chunk.mjs */ 8021);

/**
 * @license Angular v21.0.5
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */







class HttpHeaders {
  headers;
  normalizedNames = new Map();
  lazyInit;
  lazyUpdate = null;
  constructor(headers) {
    if (!headers) {
      this.headers = new Map();
    } else if (typeof headers === 'string') {
      this.lazyInit = () => {
        this.headers = new Map();
        headers.split('\n').forEach(line => {
          const index = line.indexOf(':');
          if (index > 0) {
            const name = line.slice(0, index);
            const value = line.slice(index + 1).trim();
            this.addHeaderEntry(name, value);
          }
        });
      };
    } else if (typeof Headers !== 'undefined' && headers instanceof Headers) {
      this.headers = new Map();
      headers.forEach((value, name) => {
        this.addHeaderEntry(name, value);
      });
    } else {
      this.lazyInit = () => {
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
          assertValidHeaders(headers);
        }
        this.headers = new Map();
        Object.entries(headers).forEach(([name, values]) => {
          this.setHeaderEntries(name, values);
        });
      };
    }
  }
  has(name) {
    this.init();
    return this.headers.has(name.toLowerCase());
  }
  get(name) {
    this.init();
    const values = this.headers.get(name.toLowerCase());
    return values && values.length > 0 ? values[0] : null;
  }
  keys() {
    this.init();
    return Array.from(this.normalizedNames.values());
  }
  getAll(name) {
    this.init();
    return this.headers.get(name.toLowerCase()) || null;
  }
  append(name, value) {
    return this.clone({
      name,
      value,
      op: 'a'
    });
  }
  set(name, value) {
    return this.clone({
      name,
      value,
      op: 's'
    });
  }
  delete(name, value) {
    return this.clone({
      name,
      value,
      op: 'd'
    });
  }
  maybeSetNormalizedName(name, lcName) {
    if (!this.normalizedNames.has(lcName)) {
      this.normalizedNames.set(lcName, name);
    }
  }
  init() {
    if (!!this.lazyInit) {
      if (this.lazyInit instanceof HttpHeaders) {
        this.copyFrom(this.lazyInit);
      } else {
        this.lazyInit();
      }
      this.lazyInit = null;
      if (!!this.lazyUpdate) {
        this.lazyUpdate.forEach(update => this.applyUpdate(update));
        this.lazyUpdate = null;
      }
    }
  }
  copyFrom(other) {
    other.init();
    Array.from(other.headers.keys()).forEach(key => {
      this.headers.set(key, other.headers.get(key));
      this.normalizedNames.set(key, other.normalizedNames.get(key));
    });
  }
  clone(update) {
    const clone = new HttpHeaders();
    clone.lazyInit = !!this.lazyInit && this.lazyInit instanceof HttpHeaders ? this.lazyInit : this;
    clone.lazyUpdate = (this.lazyUpdate || []).concat([update]);
    return clone;
  }
  applyUpdate(update) {
    const key = update.name.toLowerCase();
    switch (update.op) {
      case 'a':
      case 's':
        let value = update.value;
        if (typeof value === 'string') {
          value = [value];
        }
        if (value.length === 0) {
          return;
        }
        this.maybeSetNormalizedName(update.name, key);
        const base = (update.op === 'a' ? this.headers.get(key) : undefined) || [];
        base.push(...value);
        this.headers.set(key, base);
        break;
      case 'd':
        const toDelete = update.value;
        if (!toDelete) {
          this.headers.delete(key);
          this.normalizedNames.delete(key);
        } else {
          let existing = this.headers.get(key);
          if (!existing) {
            return;
          }
          existing = existing.filter(value => toDelete.indexOf(value) === -1);
          if (existing.length === 0) {
            this.headers.delete(key);
            this.normalizedNames.delete(key);
          } else {
            this.headers.set(key, existing);
          }
        }
        break;
    }
  }
  addHeaderEntry(name, value) {
    const key = name.toLowerCase();
    this.maybeSetNormalizedName(name, key);
    if (this.headers.has(key)) {
      this.headers.get(key).push(value);
    } else {
      this.headers.set(key, [value]);
    }
  }
  setHeaderEntries(name, values) {
    const headerValues = (Array.isArray(values) ? values : [values]).map(value => value.toString());
    const key = name.toLowerCase();
    this.headers.set(key, headerValues);
    this.maybeSetNormalizedName(name, key);
  }
  forEach(fn) {
    this.init();
    Array.from(this.normalizedNames.keys()).forEach(key => fn(this.normalizedNames.get(key), this.headers.get(key)));
  }
}
function assertValidHeaders(headers) {
  for (const [key, value] of Object.entries(headers)) {
    if (!(typeof value === 'string' || typeof value === 'number') && !Array.isArray(value)) {
      throw new Error(`Unexpected value of the \`${key}\` header provided. ` + `Expecting either a string, a number or an array, but got: \`${value}\`.`);
    }
  }
}
class HttpContextToken {
  defaultValue;
  constructor(defaultValue) {
    this.defaultValue = defaultValue;
  }
}
class HttpContext {
  map = new Map();
  set(token, value) {
    this.map.set(token, value);
    return this;
  }
  get(token) {
    if (!this.map.has(token)) {
      this.map.set(token, token.defaultValue());
    }
    return this.map.get(token);
  }
  delete(token) {
    this.map.delete(token);
    return this;
  }
  has(token) {
    return this.map.has(token);
  }
  keys() {
    return this.map.keys();
  }
}
class HttpUrlEncodingCodec {
  encodeKey(key) {
    return standardEncoding(key);
  }
  encodeValue(value) {
    return standardEncoding(value);
  }
  decodeKey(key) {
    return decodeURIComponent(key);
  }
  decodeValue(value) {
    return decodeURIComponent(value);
  }
}
function paramParser(rawParams, codec) {
  const map = new Map();
  if (rawParams.length > 0) {
    const params = rawParams.replace(/^\?/, '').split('&');
    params.forEach(param => {
      const eqIdx = param.indexOf('=');
      const [key, val] = eqIdx == -1 ? [codec.decodeKey(param), ''] : [codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1))];
      const list = map.get(key) || [];
      list.push(val);
      map.set(key, list);
    });
  }
  return map;
}
const STANDARD_ENCODING_REGEX = /%(\d[a-f0-9])/gi;
const STANDARD_ENCODING_REPLACEMENTS = {
  '40': '@',
  '3A': ':',
  '24': '$',
  '2C': ',',
  '3B': ';',
  '3D': '=',
  '3F': '?',
  '2F': '/'
};
function standardEncoding(v) {
  return encodeURIComponent(v).replace(STANDARD_ENCODING_REGEX, (s, t) => STANDARD_ENCODING_REPLACEMENTS[t] ?? s);
}
function valueToString(value) {
  return `${value}`;
}
class HttpParams {
  map;
  encoder;
  updates = null;
  cloneFrom = null;
  constructor(options = {}) {
    this.encoder = options.encoder || new HttpUrlEncodingCodec();
    if (options.fromString) {
      if (options.fromObject) {
        throw new _angular_core__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(2805, ngDevMode && 'Cannot specify both fromString and fromObject.');
      }
      this.map = paramParser(options.fromString, this.encoder);
    } else if (!!options.fromObject) {
      this.map = new Map();
      Object.keys(options.fromObject).forEach(key => {
        const value = options.fromObject[key];
        const values = Array.isArray(value) ? value.map(valueToString) : [valueToString(value)];
        this.map.set(key, values);
      });
    } else {
      this.map = null;
    }
  }
  has(param) {
    this.init();
    return this.map.has(param);
  }
  get(param) {
    this.init();
    const res = this.map.get(param);
    return !!res ? res[0] : null;
  }
  getAll(param) {
    this.init();
    return this.map.get(param) || null;
  }
  keys() {
    this.init();
    return Array.from(this.map.keys());
  }
  append(param, value) {
    return this.clone({
      param,
      value,
      op: 'a'
    });
  }
  appendAll(params) {
    const updates = [];
    Object.keys(params).forEach(param => {
      const value = params[param];
      if (Array.isArray(value)) {
        value.forEach(_value => {
          updates.push({
            param,
            value: _value,
            op: 'a'
          });
        });
      } else {
        updates.push({
          param,
          value: value,
          op: 'a'
        });
      }
    });
    return this.clone(updates);
  }
  set(param, value) {
    return this.clone({
      param,
      value,
      op: 's'
    });
  }
  delete(param, value) {
    return this.clone({
      param,
      value,
      op: 'd'
    });
  }
  toString() {
    this.init();
    return this.keys().map(key => {
      const eKey = this.encoder.encodeKey(key);
      return this.map.get(key).map(value => eKey + '=' + this.encoder.encodeValue(value)).join('&');
    }).filter(param => param !== '').join('&');
  }
  clone(update) {
    const clone = new HttpParams({
      encoder: this.encoder
    });
    clone.cloneFrom = this.cloneFrom || this;
    clone.updates = (this.updates || []).concat(update);
    return clone;
  }
  init() {
    if (this.map === null) {
      this.map = new Map();
    }
    if (this.cloneFrom !== null) {
      this.cloneFrom.init();
      this.cloneFrom.keys().forEach(key => this.map.set(key, this.cloneFrom.map.get(key)));
      this.updates.forEach(update => {
        switch (update.op) {
          case 'a':
          case 's':
            const base = (update.op === 'a' ? this.map.get(update.param) : undefined) || [];
            base.push(valueToString(update.value));
            this.map.set(update.param, base);
            break;
          case 'd':
            if (update.value !== undefined) {
              let base = this.map.get(update.param) || [];
              const idx = base.indexOf(valueToString(update.value));
              if (idx !== -1) {
                base.splice(idx, 1);
              }
              if (base.length > 0) {
                this.map.set(update.param, base);
              } else {
                this.map.delete(update.param);
              }
            } else {
              this.map.delete(update.param);
              break;
            }
        }
      });
      this.cloneFrom = this.updates = null;
    }
  }
}
function mightHaveBody(method) {
  switch (method) {
    case 'DELETE':
    case 'GET':
    case 'HEAD':
    case 'OPTIONS':
    case 'JSONP':
      return false;
    default:
      return true;
  }
}
function isArrayBuffer(value) {
  return typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer;
}
function isBlob(value) {
  return typeof Blob !== 'undefined' && value instanceof Blob;
}
function isFormData(value) {
  return typeof FormData !== 'undefined' && value instanceof FormData;
}
function isUrlSearchParams(value) {
  return typeof URLSearchParams !== 'undefined' && value instanceof URLSearchParams;
}
const CONTENT_TYPE_HEADER = 'Content-Type';
const ACCEPT_HEADER = 'Accept';
const TEXT_CONTENT_TYPE = 'text/plain';
const JSON_CONTENT_TYPE = 'application/json';
const ACCEPT_HEADER_VALUE = `${JSON_CONTENT_TYPE}, ${TEXT_CONTENT_TYPE}, */*`;
class HttpRequest {
  url;
  body = null;
  headers;
  context;
  reportProgress = false;
  withCredentials = false;
  credentials;
  keepalive = false;
  cache;
  priority;
  mode;
  redirect;
  referrer;
  integrity;
  referrerPolicy;
  responseType = 'json';
  method;
  params;
  urlWithParams;
  transferCache;
  timeout;
  constructor(method, url, third, fourth) {
    this.url = url;
    this.method = method.toUpperCase();
    let options;
    if (mightHaveBody(this.method) || !!fourth) {
      this.body = third !== undefined ? third : null;
      options = fourth;
    } else {
      options = third;
    }
    if (options) {
      this.reportProgress = !!options.reportProgress;
      this.withCredentials = !!options.withCredentials;
      this.keepalive = !!options.keepalive;
      if (!!options.responseType) {
        this.responseType = options.responseType;
      }
      if (options.headers) {
        this.headers = options.headers;
      }
      if (options.context) {
        this.context = options.context;
      }
      if (options.params) {
        this.params = options.params;
      }
      if (options.priority) {
        this.priority = options.priority;
      }
      if (options.cache) {
        this.cache = options.cache;
      }
      if (options.credentials) {
        this.credentials = options.credentials;
      }
      if (typeof options.timeout === 'number') {
        if (options.timeout < 1 || !Number.isInteger(options.timeout)) {
          throw new _angular_core__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(2822, ngDevMode ? '`timeout` must be a positive integer value' : '');
        }
        this.timeout = options.timeout;
      }
      if (options.mode) {
        this.mode = options.mode;
      }
      if (options.redirect) {
        this.redirect = options.redirect;
      }
      if (options.integrity) {
        this.integrity = options.integrity;
      }
      if (options.referrer) {
        this.referrer = options.referrer;
      }
      if (options.referrerPolicy) {
        this.referrerPolicy = options.referrerPolicy;
      }
      this.transferCache = options.transferCache;
    }
    this.headers ??= new HttpHeaders();
    this.context ??= new HttpContext();
    if (!this.params) {
      this.params = new HttpParams();
      this.urlWithParams = url;
    } else {
      const params = this.params.toString();
      if (params.length === 0) {
        this.urlWithParams = url;
      } else {
        const qIdx = url.indexOf('?');
        const sep = qIdx === -1 ? '?' : qIdx < url.length - 1 ? '&' : '';
        this.urlWithParams = url + sep + params;
      }
    }
  }
  serializeBody() {
    if (this.body === null) {
      return null;
    }
    if (typeof this.body === 'string' || isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) || isUrlSearchParams(this.body)) {
      return this.body;
    }
    if (this.body instanceof HttpParams) {
      return this.body.toString();
    }
    if (typeof this.body === 'object' || typeof this.body === 'boolean' || Array.isArray(this.body)) {
      return JSON.stringify(this.body);
    }
    return this.body.toString();
  }
  detectContentTypeHeader() {
    if (this.body === null) {
      return null;
    }
    if (isFormData(this.body)) {
      return null;
    }
    if (isBlob(this.body)) {
      return this.body.type || null;
    }
    if (isArrayBuffer(this.body)) {
      return null;
    }
    if (typeof this.body === 'string') {
      return TEXT_CONTENT_TYPE;
    }
    if (this.body instanceof HttpParams) {
      return 'application/x-www-form-urlencoded;charset=UTF-8';
    }
    if (typeof this.body === 'object' || typeof this.body === 'number' || typeof this.body === 'boolean') {
      return JSON_CONTENT_TYPE;
    }
    return null;
  }
  clone(update = {}) {
    const method = update.method || this.method;
    const url = update.url || this.url;
    const responseType = update.responseType || this.responseType;
    const keepalive = update.keepalive ?? this.keepalive;
    const priority = update.priority || this.priority;
    const cache = update.cache || this.cache;
    const mode = update.mode || this.mode;
    const redirect = update.redirect || this.redirect;
    const credentials = update.credentials || this.credentials;
    const referrer = update.referrer || this.referrer;
    const integrity = update.integrity || this.integrity;
    const referrerPolicy = update.referrerPolicy || this.referrerPolicy;
    const transferCache = update.transferCache ?? this.transferCache;
    const timeout = update.timeout ?? this.timeout;
    const body = update.body !== undefined ? update.body : this.body;
    const withCredentials = update.withCredentials ?? this.withCredentials;
    const reportProgress = update.reportProgress ?? this.reportProgress;
    let headers = update.headers || this.headers;
    let params = update.params || this.params;
    const context = update.context ?? this.context;
    if (update.setHeaders !== undefined) {
      headers = Object.keys(update.setHeaders).reduce((headers, name) => headers.set(name, update.setHeaders[name]), headers);
    }
    if (update.setParams) {
      params = Object.keys(update.setParams).reduce((params, param) => params.set(param, update.setParams[param]), params);
    }
    return new HttpRequest(method, url, body, {
      params,
      headers,
      context,
      reportProgress,
      responseType,
      withCredentials,
      transferCache,
      keepalive,
      cache,
      priority,
      timeout,
      mode,
      redirect,
      credentials,
      referrer,
      integrity,
      referrerPolicy
    });
  }
}
var HttpEventType;
(function (HttpEventType) {
  HttpEventType[HttpEventType["Sent"] = 0] = "Sent";
  HttpEventType[HttpEventType["UploadProgress"] = 1] = "UploadProgress";
  HttpEventType[HttpEventType["ResponseHeader"] = 2] = "ResponseHeader";
  HttpEventType[HttpEventType["DownloadProgress"] = 3] = "DownloadProgress";
  HttpEventType[HttpEventType["Response"] = 4] = "Response";
  HttpEventType[HttpEventType["User"] = 5] = "User";
})(HttpEventType || (HttpEventType = {}));
class HttpResponseBase {
  headers;
  status;
  statusText;
  url;
  ok;
  type;
  redirected;
  responseType;
  constructor(init, defaultStatus = 200, defaultStatusText = 'OK') {
    this.headers = init.headers || new HttpHeaders();
    this.status = init.status !== undefined ? init.status : defaultStatus;
    this.statusText = init.statusText || defaultStatusText;
    this.url = init.url || null;
    this.redirected = init.redirected;
    this.responseType = init.responseType;
    this.ok = this.status >= 200 && this.status < 300;
  }
}
class HttpHeaderResponse extends HttpResponseBase {
  constructor(init = {}) {
    super(init);
  }
  type = HttpEventType.ResponseHeader;
  clone(update = {}) {
    return new HttpHeaderResponse({
      headers: update.headers || this.headers,
      status: update.status !== undefined ? update.status : this.status,
      statusText: update.statusText || this.statusText,
      url: update.url || this.url || undefined
    });
  }
}
class HttpResponse extends HttpResponseBase {
  body;
  constructor(init = {}) {
    super(init);
    this.body = init.body !== undefined ? init.body : null;
  }
  type = HttpEventType.Response;
  clone(update = {}) {
    return new HttpResponse({
      body: update.body !== undefined ? update.body : this.body,
      headers: update.headers || this.headers,
      status: update.status !== undefined ? update.status : this.status,
      statusText: update.statusText || this.statusText,
      url: update.url || this.url || undefined,
      redirected: update.redirected ?? this.redirected,
      responseType: update.responseType ?? this.responseType
    });
  }
}
class HttpErrorResponse extends HttpResponseBase {
  name = 'HttpErrorResponse';
  message;
  error;
  ok = false;
  constructor(init) {
    super(init, 0, 'Unknown Error');
    if (this.status >= 200 && this.status < 300) {
      this.message = `Http failure during parsing for ${init.url || '(unknown url)'}`;
    } else {
      this.message = `Http failure response for ${init.url || '(unknown url)'}: ${init.status} ${init.statusText}`;
    }
    this.error = init.error || null;
  }
}
const HTTP_STATUS_CODE_OK = 200;
const HTTP_STATUS_CODE_NO_CONTENT = 204;
var HttpStatusCode;
(function (HttpStatusCode) {
  HttpStatusCode[HttpStatusCode["Continue"] = 100] = "Continue";
  HttpStatusCode[HttpStatusCode["SwitchingProtocols"] = 101] = "SwitchingProtocols";
  HttpStatusCode[HttpStatusCode["Processing"] = 102] = "Processing";
  HttpStatusCode[HttpStatusCode["EarlyHints"] = 103] = "EarlyHints";
  HttpStatusCode[HttpStatusCode["Ok"] = 200] = "Ok";
  HttpStatusCode[HttpStatusCode["Created"] = 201] = "Created";
  HttpStatusCode[HttpStatusCode["Accepted"] = 202] = "Accepted";
  HttpStatusCode[HttpStatusCode["NonAuthoritativeInformation"] = 203] = "NonAuthoritativeInformation";
  HttpStatusCode[HttpStatusCode["NoContent"] = 204] = "NoContent";
  HttpStatusCode[HttpStatusCode["ResetContent"] = 205] = "ResetContent";
  HttpStatusCode[HttpStatusCode["PartialContent"] = 206] = "PartialContent";
  HttpStatusCode[HttpStatusCode["MultiStatus"] = 207] = "MultiStatus";
  HttpStatusCode[HttpStatusCode["AlreadyReported"] = 208] = "AlreadyReported";
  HttpStatusCode[HttpStatusCode["ImUsed"] = 226] = "ImUsed";
  HttpStatusCode[HttpStatusCode["MultipleChoices"] = 300] = "MultipleChoices";
  HttpStatusCode[HttpStatusCode["MovedPermanently"] = 301] = "MovedPermanently";
  HttpStatusCode[HttpStatusCode["Found"] = 302] = "Found";
  HttpStatusCode[HttpStatusCode["SeeOther"] = 303] = "SeeOther";
  HttpStatusCode[HttpStatusCode["NotModified"] = 304] = "NotModified";
  HttpStatusCode[HttpStatusCode["UseProxy"] = 305] = "UseProxy";
  HttpStatusCode[HttpStatusCode["Unused"] = 306] = "Unused";
  HttpStatusCode[HttpStatusCode["TemporaryRedirect"] = 307] = "TemporaryRedirect";
  HttpStatusCode[HttpStatusCode["PermanentRedirect"] = 308] = "PermanentRedirect";
  HttpStatusCode[HttpStatusCode["BadRequest"] = 400] = "BadRequest";
  HttpStatusCode[HttpStatusCode["Unauthorized"] = 401] = "Unauthorized";
  HttpStatusCode[HttpStatusCode["PaymentRequired"] = 402] = "PaymentRequired";
  HttpStatusCode[HttpStatusCode["Forbidden"] = 403] = "Forbidden";
  HttpStatusCode[HttpStatusCode["NotFound"] = 404] = "NotFound";
  HttpStatusCode[HttpStatusCode["MethodNotAllowed"] = 405] = "MethodNotAllowed";
  HttpStatusCode[HttpStatusCode["NotAcceptable"] = 406] = "NotAcceptable";
  HttpStatusCode[HttpStatusCode["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
  HttpStatusCode[HttpStatusCode["RequestTimeout"] = 408] = "RequestTimeout";
  HttpStatusCode[HttpStatusCode["Conflict"] = 409] = "Conflict";
  HttpStatusCode[HttpStatusCode["Gone"] = 410] = "Gone";
  HttpStatusCode[HttpStatusCode["LengthRequired"] = 411] = "LengthRequired";
  HttpStatusCode[HttpStatusCode["PreconditionFailed"] = 412] = "PreconditionFailed";
  HttpStatusCode[HttpStatusCode["PayloadTooLarge"] = 413] = "PayloadTooLarge";
  HttpStatusCode[HttpStatusCode["UriTooLong"] = 414] = "UriTooLong";
  HttpStatusCode[HttpStatusCode["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
  HttpStatusCode[HttpStatusCode["RangeNotSatisfiable"] = 416] = "RangeNotSatisfiable";
  HttpStatusCode[HttpStatusCode["ExpectationFailed"] = 417] = "ExpectationFailed";
  HttpStatusCode[HttpStatusCode["ImATeapot"] = 418] = "ImATeapot";
  HttpStatusCode[HttpStatusCode["MisdirectedRequest"] = 421] = "MisdirectedRequest";
  HttpStatusCode[HttpStatusCode["UnprocessableEntity"] = 422] = "UnprocessableEntity";
  HttpStatusCode[HttpStatusCode["Locked"] = 423] = "Locked";
  HttpStatusCode[HttpStatusCode["FailedDependency"] = 424] = "FailedDependency";
  HttpStatusCode[HttpStatusCode["TooEarly"] = 425] = "TooEarly";
  HttpStatusCode[HttpStatusCode["UpgradeRequired"] = 426] = "UpgradeRequired";
  HttpStatusCode[HttpStatusCode["PreconditionRequired"] = 428] = "PreconditionRequired";
  HttpStatusCode[HttpStatusCode["TooManyRequests"] = 429] = "TooManyRequests";
  HttpStatusCode[HttpStatusCode["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
  HttpStatusCode[HttpStatusCode["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
  HttpStatusCode[HttpStatusCode["InternalServerError"] = 500] = "InternalServerError";
  HttpStatusCode[HttpStatusCode["NotImplemented"] = 501] = "NotImplemented";
  HttpStatusCode[HttpStatusCode["BadGateway"] = 502] = "BadGateway";
  HttpStatusCode[HttpStatusCode["ServiceUnavailable"] = 503] = "ServiceUnavailable";
  HttpStatusCode[HttpStatusCode["GatewayTimeout"] = 504] = "GatewayTimeout";
  HttpStatusCode[HttpStatusCode["HttpVersionNotSupported"] = 505] = "HttpVersionNotSupported";
  HttpStatusCode[HttpStatusCode["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
  HttpStatusCode[HttpStatusCode["InsufficientStorage"] = 507] = "InsufficientStorage";
  HttpStatusCode[HttpStatusCode["LoopDetected"] = 508] = "LoopDetected";
  HttpStatusCode[HttpStatusCode["NotExtended"] = 510] = "NotExtended";
  HttpStatusCode[HttpStatusCode["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
})(HttpStatusCode || (HttpStatusCode = {}));
const XSSI_PREFIX$1 = /^\)\]\}',?\n/;
const FETCH_BACKEND = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'FETCH_BACKEND' : '');
class FetchBackend {
  fetchImpl = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(FetchFactory, {
    optional: true
  })?.fetch ?? ((...args) => globalThis.fetch(...args));
  ngZone = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone);
  destroyRef = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.DestroyRef);
  handle(request) {
    return new rxjs__WEBPACK_IMPORTED_MODULE_8__.Observable(observer => {
      const aborter = new AbortController();
      this.doRequest(request, aborter.signal, observer).then(noop, error => observer.error(new HttpErrorResponse({
        error
      })));
      let timeoutId;
      if (request.timeout) {
        timeoutId = this.ngZone.runOutsideAngular(() => setTimeout(() => {
          if (!aborter.signal.aborted) {
            aborter.abort(new DOMException('signal timed out', 'TimeoutError'));
          }
        }, request.timeout));
      }
      return () => {
        if (timeoutId !== undefined) {
          clearTimeout(timeoutId);
        }
        aborter.abort();
      };
    });
  }
  doRequest(request, signal, observer) {
    var _this = this;
    return (0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const init = _this.createRequestInit(request);
      let response;
      try {
        const fetchPromise = _this.ngZone.runOutsideAngular(() => _this.fetchImpl(request.urlWithParams, {
          signal,
          ...init
        }));
        silenceSuperfluousUnhandledPromiseRejection(fetchPromise);
        observer.next({
          type: HttpEventType.Sent
        });
        response = yield fetchPromise;
      } catch (error) {
        observer.error(new HttpErrorResponse({
          error,
          status: error.status ?? 0,
          statusText: error.statusText,
          url: request.urlWithParams,
          headers: error.headers
        }));
        return;
      }
      const headers = new HttpHeaders(response.headers);
      const statusText = response.statusText;
      const url = response.url || request.urlWithParams;
      let status = response.status;
      let body = null;
      if (request.reportProgress) {
        observer.next(new HttpHeaderResponse({
          headers,
          status,
          statusText,
          url
        }));
      }
      if (response.body) {
        const contentLength = response.headers.get('content-length');
        const chunks = [];
        const reader = response.body.getReader();
        let receivedLength = 0;
        let decoder;
        let partialText;
        const reqZone = typeof Zone !== 'undefined' && Zone.current;
        let canceled = false;
        yield _this.ngZone.runOutsideAngular(/*#__PURE__*/(0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
          while (true) {
            if (_this.destroyRef.destroyed) {
              yield reader.cancel();
              canceled = true;
              break;
            }
            const {
              done,
              value
            } = yield reader.read();
            if (done) {
              break;
            }
            chunks.push(value);
            receivedLength += value.length;
            if (request.reportProgress) {
              partialText = request.responseType === 'text' ? (partialText ?? '') + (decoder ??= new TextDecoder()).decode(value, {
                stream: true
              }) : undefined;
              const reportProgress = () => observer.next({
                type: HttpEventType.DownloadProgress,
                total: contentLength ? +contentLength : undefined,
                loaded: receivedLength,
                partialText
              });
              reqZone ? reqZone.run(reportProgress) : reportProgress();
            }
          }
        }));
        if (canceled) {
          observer.complete();
          return;
        }
        const chunksAll = _this.concatChunks(chunks, receivedLength);
        try {
          const contentType = response.headers.get(CONTENT_TYPE_HEADER) ?? '';
          body = _this.parseBody(request, chunksAll, contentType, status);
        } catch (error) {
          observer.error(new HttpErrorResponse({
            error,
            headers: new HttpHeaders(response.headers),
            status: response.status,
            statusText: response.statusText,
            url: response.url || request.urlWithParams
          }));
          return;
        }
      }
      if (status === 0) {
        status = body ? HTTP_STATUS_CODE_OK : 0;
      }
      const ok = status >= 200 && status < 300;
      const redirected = response.redirected;
      const responseType = response.type;
      if (ok) {
        observer.next(new HttpResponse({
          body,
          headers,
          status,
          statusText,
          url,
          redirected,
          responseType
        }));
        observer.complete();
      } else {
        observer.error(new HttpErrorResponse({
          error: body,
          headers,
          status,
          statusText,
          url,
          redirected,
          responseType
        }));
      }
    })();
  }
  parseBody(request, binContent, contentType, status) {
    switch (request.responseType) {
      case 'json':
        const text = new TextDecoder().decode(binContent).replace(XSSI_PREFIX$1, '');
        if (text === '') {
          return null;
        }
        try {
          return JSON.parse(text);
        } catch (e) {
          if (status < 200 || status >= 300) {
            return text;
          }
          throw e;
        }
      case 'text':
        return new TextDecoder().decode(binContent);
      case 'blob':
        return new Blob([binContent], {
          type: contentType
        });
      case 'arraybuffer':
        return binContent.buffer;
    }
  }
  createRequestInit(req) {
    const headers = {};
    let credentials;
    credentials = req.credentials;
    if (req.withCredentials) {
      (typeof ngDevMode === 'undefined' || ngDevMode) && warningOptionsMessage(req);
      credentials = 'include';
    }
    req.headers.forEach((name, values) => headers[name] = values.join(','));
    if (!req.headers.has(ACCEPT_HEADER)) {
      headers[ACCEPT_HEADER] = ACCEPT_HEADER_VALUE;
    }
    if (!req.headers.has(CONTENT_TYPE_HEADER)) {
      const detectedType = req.detectContentTypeHeader();
      if (detectedType !== null) {
        headers[CONTENT_TYPE_HEADER] = detectedType;
      }
    }
    return {
      body: req.serializeBody(),
      method: req.method,
      headers,
      credentials,
      keepalive: req.keepalive,
      cache: req.cache,
      priority: req.priority,
      mode: req.mode,
      redirect: req.redirect,
      referrer: req.referrer,
      integrity: req.integrity,
      referrerPolicy: req.referrerPolicy
    };
  }
  concatChunks(chunks, totalLength) {
    const chunksAll = new Uint8Array(totalLength);
    let position = 0;
    for (const chunk of chunks) {
      chunksAll.set(chunk, position);
      position += chunk.length;
    }
    return chunksAll;
  }
  static ɵfac = function FetchBackend_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || FetchBackend)();
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: FetchBackend,
    factory: FetchBackend.ɵfac
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata(FetchBackend, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Injectable
  }], null, null);
})();
class FetchFactory {}
function noop() {}
function warningOptionsMessage(req) {
  if (req.credentials && req.withCredentials) {
    console.warn((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(2819, `Angular detected that a \`HttpClient\` request has both \`withCredentials: true\` and \`credentials: '${req.credentials}'\` options. The \`withCredentials\` option is overriding the explicit \`credentials\` setting to 'include'. Consider removing \`withCredentials\` and using \`credentials: '${req.credentials}'\` directly for clarity.`));
  }
}
function silenceSuperfluousUnhandledPromiseRejection(promise) {
  promise.then(noop, noop);
}
const XSSI_PREFIX = /^\)\]\}',?\n/;
function validateXhrCompatibility(req) {
  const unsupportedOptions = [{
    property: 'keepalive',
    errorCode: 2813
  }, {
    property: 'cache',
    errorCode: 2814
  }, {
    property: 'priority',
    errorCode: 2815
  }, {
    property: 'mode',
    errorCode: 2816
  }, {
    property: 'redirect',
    errorCode: 2817
  }, {
    property: 'credentials',
    errorCode: 2818
  }, {
    property: 'integrity',
    errorCode: 2820
  }, {
    property: 'referrer',
    errorCode: 2821
  }, {
    property: 'referrerPolicy',
    errorCode: 2823
  }];
  for (const {
    property,
    errorCode
  } of unsupportedOptions) {
    if (req[property]) {
      console.warn((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(errorCode, `Angular detected that a \`HttpClient\` request with the \`${property}\` option was sent using XHR, which does not support it. To use the \`${property}\` option, enable Fetch API support by passing \`withFetch()\` as an argument to \`provideHttpClient()\`.`));
    }
  }
}
class HttpXhrBackend {
  xhrFactory;
  tracingService = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_2__.TracingService, {
    optional: true
  });
  constructor(xhrFactory) {
    this.xhrFactory = xhrFactory;
  }
  maybePropagateTrace(fn) {
    return this.tracingService?.propagate ? this.tracingService.propagate(fn) : fn;
  }
  handle(req) {
    if (req.method === 'JSONP') {
      throw new _angular_core__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-2800, (typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot make a JSONP request without JSONP support. To fix the problem, either add the \`withJsonpSupport()\` call (if \`provideHttpClient()\` is used) or import the \`HttpClientJsonpModule\` in the root NgModule.`);
    }
    ngDevMode && validateXhrCompatibility(req);
    const xhrFactory = this.xhrFactory;
    const source = typeof ngServerMode !== 'undefined' && ngServerMode && xhrFactory.ɵloadImpl ? (0,rxjs__WEBPACK_IMPORTED_MODULE_9__.from)(xhrFactory.ɵloadImpl()) : (0,rxjs__WEBPACK_IMPORTED_MODULE_10__.of)(null);
    return source.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.switchMap)(() => {
      return new rxjs__WEBPACK_IMPORTED_MODULE_8__.Observable(observer => {
        const xhr = xhrFactory.build();
        xhr.open(req.method, req.urlWithParams);
        if (req.withCredentials) {
          xhr.withCredentials = true;
        }
        req.headers.forEach((name, values) => xhr.setRequestHeader(name, values.join(',')));
        if (!req.headers.has(ACCEPT_HEADER)) {
          xhr.setRequestHeader(ACCEPT_HEADER, ACCEPT_HEADER_VALUE);
        }
        if (!req.headers.has(CONTENT_TYPE_HEADER)) {
          const detectedType = req.detectContentTypeHeader();
          if (detectedType !== null) {
            xhr.setRequestHeader(CONTENT_TYPE_HEADER, detectedType);
          }
        }
        if (req.timeout) {
          xhr.timeout = req.timeout;
        }
        if (req.responseType) {
          const responseType = req.responseType.toLowerCase();
          xhr.responseType = responseType !== 'json' ? responseType : 'text';
        }
        const reqBody = req.serializeBody();
        let headerResponse = null;
        const partialFromXhr = () => {
          if (headerResponse !== null) {
            return headerResponse;
          }
          const statusText = xhr.statusText || 'OK';
          const headers = new HttpHeaders(xhr.getAllResponseHeaders());
          const url = xhr.responseURL || req.url;
          headerResponse = new HttpHeaderResponse({
            headers,
            status: xhr.status,
            statusText,
            url
          });
          return headerResponse;
        };
        const onLoad = this.maybePropagateTrace(() => {
          let {
            headers,
            status,
            statusText,
            url
          } = partialFromXhr();
          let body = null;
          if (status !== HTTP_STATUS_CODE_NO_CONTENT) {
            body = typeof xhr.response === 'undefined' ? xhr.responseText : xhr.response;
          }
          if (status === 0) {
            status = !!body ? HTTP_STATUS_CODE_OK : 0;
          }
          let ok = status >= 200 && status < 300;
          if (req.responseType === 'json' && typeof body === 'string') {
            const originalBody = body;
            body = body.replace(XSSI_PREFIX, '');
            try {
              body = body !== '' ? JSON.parse(body) : null;
            } catch (error) {
              body = originalBody;
              if (ok) {
                ok = false;
                body = {
                  error,
                  text: body
                };
              }
            }
          }
          if (ok) {
            observer.next(new HttpResponse({
              body,
              headers,
              status,
              statusText,
              url: url || undefined
            }));
            observer.complete();
          } else {
            observer.error(new HttpErrorResponse({
              error: body,
              headers,
              status,
              statusText,
              url: url || undefined
            }));
          }
        });
        const onError = this.maybePropagateTrace(error => {
          const {
            url
          } = partialFromXhr();
          const res = new HttpErrorResponse({
            error,
            status: xhr.status || 0,
            statusText: xhr.statusText || 'Unknown Error',
            url: url || undefined
          });
          observer.error(res);
        });
        let onTimeout = onError;
        if (req.timeout) {
          onTimeout = this.maybePropagateTrace(_ => {
            const {
              url
            } = partialFromXhr();
            const res = new HttpErrorResponse({
              error: new DOMException('Request timed out', 'TimeoutError'),
              status: xhr.status || 0,
              statusText: xhr.statusText || 'Request timeout',
              url: url || undefined
            });
            observer.error(res);
          });
        }
        let sentHeaders = false;
        const onDownProgress = this.maybePropagateTrace(event => {
          if (!sentHeaders) {
            observer.next(partialFromXhr());
            sentHeaders = true;
          }
          let progressEvent = {
            type: HttpEventType.DownloadProgress,
            loaded: event.loaded
          };
          if (event.lengthComputable) {
            progressEvent.total = event.total;
          }
          if (req.responseType === 'text' && !!xhr.responseText) {
            progressEvent.partialText = xhr.responseText;
          }
          observer.next(progressEvent);
        });
        const onUpProgress = this.maybePropagateTrace(event => {
          let progress = {
            type: HttpEventType.UploadProgress,
            loaded: event.loaded
          };
          if (event.lengthComputable) {
            progress.total = event.total;
          }
          observer.next(progress);
        });
        xhr.addEventListener('load', onLoad);
        xhr.addEventListener('error', onError);
        xhr.addEventListener('timeout', onTimeout);
        xhr.addEventListener('abort', onError);
        if (req.reportProgress) {
          xhr.addEventListener('progress', onDownProgress);
          if (reqBody !== null && xhr.upload) {
            xhr.upload.addEventListener('progress', onUpProgress);
          }
        }
        xhr.send(reqBody);
        observer.next({
          type: HttpEventType.Sent
        });
        return () => {
          xhr.removeEventListener('error', onError);
          xhr.removeEventListener('abort', onError);
          xhr.removeEventListener('load', onLoad);
          xhr.removeEventListener('timeout', onTimeout);
          if (req.reportProgress) {
            xhr.removeEventListener('progress', onDownProgress);
            if (reqBody !== null && xhr.upload) {
              xhr.upload.removeEventListener('progress', onUpProgress);
            }
          }
          if (xhr.readyState !== xhr.DONE) {
            xhr.abort();
          }
        };
      });
    }));
  }
  static ɵfac = function HttpXhrBackend_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || HttpXhrBackend)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_xhr_chunk_mjs__WEBPACK_IMPORTED_MODULE_11__.XhrFactory));
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: HttpXhrBackend,
    factory: HttpXhrBackend.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata(HttpXhrBackend, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], () => [{
    type: _xhr_chunk_mjs__WEBPACK_IMPORTED_MODULE_11__.XhrFactory
  }], null);
})();
function interceptorChainEndFn(req, finalHandlerFn) {
  return finalHandlerFn(req);
}
function adaptLegacyInterceptorToChain(chainTailFn, interceptor) {
  return (initialRequest, finalHandlerFn) => interceptor.intercept(initialRequest, {
    handle: downstreamRequest => chainTailFn(downstreamRequest, finalHandlerFn)
  });
}
function chainedInterceptorFn(chainTailFn, interceptorFn, injector) {
  return (initialRequest, finalHandlerFn) => (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.runInInjectionContext)(injector, () => interceptorFn(initialRequest, downstreamRequest => chainTailFn(downstreamRequest, finalHandlerFn)));
}
const HTTP_INTERCEPTORS = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'HTTP_INTERCEPTORS' : '');
const HTTP_INTERCEPTOR_FNS = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'HTTP_INTERCEPTOR_FNS' : '', {
  factory: () => []
});
const HTTP_ROOT_INTERCEPTOR_FNS = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'HTTP_ROOT_INTERCEPTOR_FNS' : '');
const REQUESTS_CONTRIBUTE_TO_STABILITY = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'REQUESTS_CONTRIBUTE_TO_STABILITY' : '', {
  providedIn: 'root',
  factory: () => true
});
function legacyInterceptorFnFactory() {
  let chain = null;
  return (req, handler) => {
    if (chain === null) {
      const interceptors = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(HTTP_INTERCEPTORS, {
        optional: true
      }) ?? [];
      chain = interceptors.reduceRight(adaptLegacyInterceptorToChain, interceptorChainEndFn);
    }
    const pendingTasks = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.PendingTasks);
    const contributeToStability = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(REQUESTS_CONTRIBUTE_TO_STABILITY);
    if (contributeToStability) {
      const removeTask = pendingTasks.add();
      return chain(req, handler).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.finalize)(removeTask));
    } else {
      return chain(req, handler);
    }
  };
}
class HttpBackend {
  static ɵfac = function HttpBackend_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || HttpBackend)();
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: HttpBackend,
    factory: function HttpBackend_Factory(__ngFactoryType__) {
      let __ngConditionalFactory__ = null;
      if (__ngFactoryType__) {
        __ngConditionalFactory__ = new (__ngFactoryType__ || HttpBackend)();
      } else {
        __ngConditionalFactory__ = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](HttpXhrBackend);
      }
      return __ngConditionalFactory__;
    },
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata(HttpBackend, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Injectable,
    args: [{
      providedIn: 'root',
      useExisting: HttpXhrBackend
    }]
  }], null, null);
})();
let fetchBackendWarningDisplayed = false;
class HttpInterceptorHandler {
  backend;
  injector;
  chain = null;
  pendingTasks = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.PendingTasks);
  contributeToStability = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(REQUESTS_CONTRIBUTE_TO_STABILITY);
  constructor(backend, injector) {
    this.backend = backend;
    this.injector = injector;
    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !fetchBackendWarningDisplayed) {
      const isTestingBackend = this.backend.isTestingBackend;
      if (typeof ngServerMode !== 'undefined' && ngServerMode && !(this.backend instanceof FetchBackend) && !isTestingBackend) {
        fetchBackendWarningDisplayed = true;
        injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_2__.Console).warn((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(2801, 'Angular detected that `HttpClient` is not configured ' + "to use `fetch` APIs. It's strongly recommended to " + 'enable `fetch` for applications that use Server-Side Rendering ' + 'for better performance and compatibility. ' + 'To enable `fetch`, add the `withFetch()` to the `provideHttpClient()` ' + 'call at the root of the application.'));
      }
    }
  }
  handle(initialRequest) {
    if (this.chain === null) {
      const dedupedInterceptorFns = Array.from(new Set([...this.injector.get(HTTP_INTERCEPTOR_FNS), ...this.injector.get(HTTP_ROOT_INTERCEPTOR_FNS, [])]));
      this.chain = dedupedInterceptorFns.reduceRight((nextSequencedFn, interceptorFn) => chainedInterceptorFn(nextSequencedFn, interceptorFn, this.injector), interceptorChainEndFn);
    }
    if (this.contributeToStability) {
      const removeTask = this.pendingTasks.add();
      return this.chain(initialRequest, downstreamRequest => this.backend.handle(downstreamRequest)).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.finalize)(removeTask));
    } else {
      return this.chain(initialRequest, downstreamRequest => this.backend.handle(downstreamRequest));
    }
  }
  static ɵfac = function HttpInterceptorHandler_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || HttpInterceptorHandler)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](HttpBackend), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.EnvironmentInjector));
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: HttpInterceptorHandler,
    factory: HttpInterceptorHandler.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata(HttpInterceptorHandler, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], () => [{
    type: HttpBackend
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.EnvironmentInjector
  }], null);
})();
class HttpHandler {
  static ɵfac = function HttpHandler_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || HttpHandler)();
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: HttpHandler,
    factory: function HttpHandler_Factory(__ngFactoryType__) {
      let __ngConditionalFactory__ = null;
      if (__ngFactoryType__) {
        __ngConditionalFactory__ = new (__ngFactoryType__ || HttpHandler)();
      } else {
        __ngConditionalFactory__ = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](HttpInterceptorHandler);
      }
      return __ngConditionalFactory__;
    },
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata(HttpHandler, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Injectable,
    args: [{
      providedIn: 'root',
      useExisting: HttpInterceptorHandler
    }]
  }], null, null);
})();
function addBody(options, body) {
  return {
    body,
    headers: options.headers,
    context: options.context,
    observe: options.observe,
    params: options.params,
    reportProgress: options.reportProgress,
    responseType: options.responseType,
    withCredentials: options.withCredentials,
    credentials: options.credentials,
    transferCache: options.transferCache,
    timeout: options.timeout,
    keepalive: options.keepalive,
    priority: options.priority,
    cache: options.cache,
    mode: options.mode,
    redirect: options.redirect,
    integrity: options.integrity,
    referrer: options.referrer,
    referrerPolicy: options.referrerPolicy
  };
}
class HttpClient {
  handler;
  constructor(handler) {
    this.handler = handler;
  }
  request(first, url, options = {}) {
    let req;
    if (first instanceof HttpRequest) {
      req = first;
    } else {
      let headers = undefined;
      if (options.headers instanceof HttpHeaders) {
        headers = options.headers;
      } else {
        headers = new HttpHeaders(options.headers);
      }
      let params = undefined;
      if (!!options.params) {
        if (options.params instanceof HttpParams) {
          params = options.params;
        } else {
          params = new HttpParams({
            fromObject: options.params
          });
        }
      }
      req = new HttpRequest(first, url, options.body !== undefined ? options.body : null, {
        headers,
        context: options.context,
        params,
        reportProgress: options.reportProgress,
        responseType: options.responseType || 'json',
        withCredentials: options.withCredentials,
        transferCache: options.transferCache,
        keepalive: options.keepalive,
        priority: options.priority,
        cache: options.cache,
        mode: options.mode,
        redirect: options.redirect,
        credentials: options.credentials,
        referrer: options.referrer,
        referrerPolicy: options.referrerPolicy,
        integrity: options.integrity,
        timeout: options.timeout
      });
    }
    const events$ = (0,rxjs__WEBPACK_IMPORTED_MODULE_10__.of)(req).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.concatMap)(req => this.handler.handle(req)));
    if (first instanceof HttpRequest || options.observe === 'events') {
      return events$;
    }
    const res$ = events$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.filter)(event => event instanceof HttpResponse));
    switch (options.observe || 'body') {
      case 'body':
        switch (req.responseType) {
          case 'arraybuffer':
            return res$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.map)(res => {
              if (res.body !== null && !(res.body instanceof ArrayBuffer)) {
                throw new _angular_core__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(2806, ngDevMode && 'Response is not an ArrayBuffer.');
              }
              return res.body;
            }));
          case 'blob':
            return res$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.map)(res => {
              if (res.body !== null && !(res.body instanceof Blob)) {
                throw new _angular_core__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(2807, ngDevMode && 'Response is not a Blob.');
              }
              return res.body;
            }));
          case 'text':
            return res$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.map)(res => {
              if (res.body !== null && typeof res.body !== 'string') {
                throw new _angular_core__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(2808, ngDevMode && 'Response is not a string.');
              }
              return res.body;
            }));
          case 'json':
          default:
            return res$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.map)(res => res.body));
        }
      case 'response':
        return res$;
      default:
        throw new _angular_core__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(2809, ngDevMode && `Unreachable: unhandled observe type ${options.observe}}`);
    }
  }
  delete(url, options = {}) {
    return this.request('DELETE', url, options);
  }
  get(url, options = {}) {
    return this.request('GET', url, options);
  }
  head(url, options = {}) {
    return this.request('HEAD', url, options);
  }
  jsonp(url, callbackParam) {
    return this.request('JSONP', url, {
      params: new HttpParams().append(callbackParam, 'JSONP_CALLBACK'),
      observe: 'body',
      responseType: 'json'
    });
  }
  options(url, options = {}) {
    return this.request('OPTIONS', url, options);
  }
  patch(url, body, options = {}) {
    return this.request('PATCH', url, addBody(options, body));
  }
  post(url, body, options = {}) {
    return this.request('POST', url, addBody(options, body));
  }
  put(url, body, options = {}) {
    return this.request('PUT', url, addBody(options, body));
  }
  static ɵfac = function HttpClient_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || HttpClient)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](HttpHandler));
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: HttpClient,
    factory: HttpClient.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata(HttpClient, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], () => [{
    type: HttpHandler
  }], null);
})();
let nextRequestId = 0;
let foreignDocument;
const JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';
const JSONP_ERR_WRONG_METHOD = 'JSONP requests must use JSONP request method.';
const JSONP_ERR_WRONG_RESPONSE_TYPE = 'JSONP requests must use Json response type.';
const JSONP_ERR_HEADERS_NOT_SUPPORTED = 'JSONP requests do not support headers.';
class JsonpCallbackContext {}
function jsonpCallbackContext() {
  if (typeof window === 'object') {
    return window;
  }
  return {};
}
class JsonpClientBackend {
  callbackMap;
  document;
  resolvedPromise = Promise.resolve();
  constructor(callbackMap, document) {
    this.callbackMap = callbackMap;
    this.document = document;
  }
  nextCallback() {
    return `ng_jsonp_callback_${nextRequestId++}`;
  }
  handle(req) {
    if (req.method !== 'JSONP') {
      throw new _angular_core__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(2810, ngDevMode && JSONP_ERR_WRONG_METHOD);
    } else if (req.responseType !== 'json') {
      throw new _angular_core__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(2811, ngDevMode && JSONP_ERR_WRONG_RESPONSE_TYPE);
    }
    if (req.headers.keys().length > 0) {
      throw new _angular_core__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(2812, ngDevMode && JSONP_ERR_HEADERS_NOT_SUPPORTED);
    }
    return new rxjs__WEBPACK_IMPORTED_MODULE_8__.Observable(observer => {
      const callback = this.nextCallback();
      const url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, `=${callback}$1`);
      const node = this.document.createElement('script');
      node.src = url;
      let body = null;
      let finished = false;
      this.callbackMap[callback] = data => {
        delete this.callbackMap[callback];
        body = data;
        finished = true;
      };
      const cleanup = () => {
        node.removeEventListener('load', onLoad);
        node.removeEventListener('error', onError);
        node.remove();
        delete this.callbackMap[callback];
      };
      const onLoad = () => {
        this.resolvedPromise.then(() => {
          cleanup();
          if (!finished) {
            observer.error(new HttpErrorResponse({
              url,
              status: 0,
              statusText: 'JSONP Error',
              error: new Error(JSONP_ERR_NO_CALLBACK)
            }));
            return;
          }
          observer.next(new HttpResponse({
            body,
            status: HTTP_STATUS_CODE_OK,
            statusText: 'OK',
            url
          }));
          observer.complete();
        });
      };
      const onError = error => {
        cleanup();
        observer.error(new HttpErrorResponse({
          error,
          status: 0,
          statusText: 'JSONP Error',
          url
        }));
      };
      node.addEventListener('load', onLoad);
      node.addEventListener('error', onError);
      this.document.body.appendChild(node);
      observer.next({
        type: HttpEventType.Sent
      });
      return () => {
        if (!finished) {
          this.removeListeners(node);
        }
        cleanup();
      };
    });
  }
  removeListeners(script) {
    foreignDocument ??= this.document.implementation.createHTMLDocument();
    foreignDocument.adoptNode(script);
  }
  static ɵfac = function JsonpClientBackend_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || JsonpClientBackend)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](JsonpCallbackContext), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT));
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: JsonpClientBackend,
    factory: JsonpClientBackend.ɵfac
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata(JsonpClientBackend, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Injectable
  }], () => [{
    type: JsonpCallbackContext
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
      args: [_angular_core__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT]
    }]
  }], null);
})();
function jsonpInterceptorFn(req, next) {
  if (req.method === 'JSONP') {
    return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(JsonpClientBackend).handle(req);
  }
  return next(req);
}
class JsonpInterceptor {
  injector;
  constructor(injector) {
    this.injector = injector;
  }
  intercept(initialRequest, next) {
    return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.runInInjectionContext)(this.injector, () => jsonpInterceptorFn(initialRequest, downstreamRequest => next.handle(downstreamRequest)));
  }
  static ɵfac = function JsonpInterceptor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || JsonpInterceptor)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.EnvironmentInjector));
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: JsonpInterceptor,
    factory: JsonpInterceptor.ɵfac
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata(JsonpInterceptor, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Injectable
  }], () => [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.EnvironmentInjector
  }], null);
})();
const XSRF_ENABLED = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'XSRF_ENABLED' : '', {
  factory: () => true
});
const XSRF_DEFAULT_COOKIE_NAME = 'XSRF-TOKEN';
const XSRF_COOKIE_NAME = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'XSRF_COOKIE_NAME' : '', {
  providedIn: 'root',
  factory: () => XSRF_DEFAULT_COOKIE_NAME
});
const XSRF_DEFAULT_HEADER_NAME = 'X-XSRF-TOKEN';
const XSRF_HEADER_NAME = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'XSRF_HEADER_NAME' : '', {
  providedIn: 'root',
  factory: () => XSRF_DEFAULT_HEADER_NAME
});
class HttpXsrfCookieExtractor {
  cookieName = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(XSRF_COOKIE_NAME);
  doc = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT);
  lastCookieString = '';
  lastToken = null;
  parseCount = 0;
  getToken() {
    if (typeof ngServerMode !== 'undefined' && ngServerMode) {
      return null;
    }
    const cookieString = this.doc.cookie || '';
    if (cookieString !== this.lastCookieString) {
      this.parseCount++;
      this.lastToken = (0,_xhr_chunk_mjs__WEBPACK_IMPORTED_MODULE_11__.parseCookieValue)(cookieString, this.cookieName);
      this.lastCookieString = cookieString;
    }
    return this.lastToken;
  }
  static ɵfac = function HttpXsrfCookieExtractor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || HttpXsrfCookieExtractor)();
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: HttpXsrfCookieExtractor,
    factory: HttpXsrfCookieExtractor.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata(HttpXsrfCookieExtractor, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], null, null);
})();
class HttpXsrfTokenExtractor {
  static ɵfac = function HttpXsrfTokenExtractor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || HttpXsrfTokenExtractor)();
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: HttpXsrfTokenExtractor,
    factory: function HttpXsrfTokenExtractor_Factory(__ngFactoryType__) {
      let __ngConditionalFactory__ = null;
      if (__ngFactoryType__) {
        __ngConditionalFactory__ = new (__ngFactoryType__ || HttpXsrfTokenExtractor)();
      } else {
        __ngConditionalFactory__ = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](HttpXsrfCookieExtractor);
      }
      return __ngConditionalFactory__;
    },
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata(HttpXsrfTokenExtractor, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Injectable,
    args: [{
      providedIn: 'root',
      useExisting: HttpXsrfCookieExtractor
    }]
  }], null, null);
})();
function xsrfInterceptorFn(req, next) {
  if (!(0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(XSRF_ENABLED) || req.method === 'GET' || req.method === 'HEAD') {
    return next(req);
  }
  try {
    const locationHref = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(_platform_location_chunk_mjs__WEBPACK_IMPORTED_MODULE_12__.PlatformLocation).href;
    const {
      origin: locationOrigin
    } = new URL(locationHref);
    const {
      origin: requestOrigin
    } = new URL(req.url, locationOrigin);
    if (locationOrigin !== requestOrigin) {
      return next(req);
    }
  } catch {
    return next(req);
  }
  const token = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(HttpXsrfTokenExtractor).getToken();
  const headerName = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(XSRF_HEADER_NAME);
  if (token != null && !req.headers.has(headerName)) {
    req = req.clone({
      headers: req.headers.set(headerName, token)
    });
  }
  return next(req);
}
class HttpXsrfInterceptor {
  injector = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.EnvironmentInjector);
  intercept(initialRequest, next) {
    return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.runInInjectionContext)(this.injector, () => xsrfInterceptorFn(initialRequest, downstreamRequest => next.handle(downstreamRequest)));
  }
  static ɵfac = function HttpXsrfInterceptor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || HttpXsrfInterceptor)();
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: HttpXsrfInterceptor,
    factory: HttpXsrfInterceptor.ɵfac
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata(HttpXsrfInterceptor, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Injectable
  }], null, null);
})();
var HttpFeatureKind;
(function (HttpFeatureKind) {
  HttpFeatureKind[HttpFeatureKind["Interceptors"] = 0] = "Interceptors";
  HttpFeatureKind[HttpFeatureKind["LegacyInterceptors"] = 1] = "LegacyInterceptors";
  HttpFeatureKind[HttpFeatureKind["CustomXsrfConfiguration"] = 2] = "CustomXsrfConfiguration";
  HttpFeatureKind[HttpFeatureKind["NoXsrfProtection"] = 3] = "NoXsrfProtection";
  HttpFeatureKind[HttpFeatureKind["JsonpSupport"] = 4] = "JsonpSupport";
  HttpFeatureKind[HttpFeatureKind["RequestsMadeViaParent"] = 5] = "RequestsMadeViaParent";
  HttpFeatureKind[HttpFeatureKind["Fetch"] = 6] = "Fetch";
})(HttpFeatureKind || (HttpFeatureKind = {}));
function makeHttpFeature(kind, providers) {
  return {
    ɵkind: kind,
    ɵproviders: providers
  };
}
function provideHttpClient(...features) {
  if (ngDevMode) {
    const featureKinds = new Set(features.map(f => f.ɵkind));
    if (featureKinds.has(HttpFeatureKind.NoXsrfProtection) && featureKinds.has(HttpFeatureKind.CustomXsrfConfiguration)) {
      throw new Error(ngDevMode ? `Configuration error: found both withXsrfConfiguration() and withNoXsrfProtection() in the same call to provideHttpClient(), which is a contradiction.` : '');
    }
  }
  const providers = [HttpClient, HttpInterceptorHandler, {
    provide: HttpHandler,
    useExisting: HttpInterceptorHandler
  }, {
    provide: HttpBackend,
    useFactory: () => {
      return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(FETCH_BACKEND, {
        optional: true
      }) ?? (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(HttpXhrBackend);
    }
  }, {
    provide: HTTP_INTERCEPTOR_FNS,
    useValue: xsrfInterceptorFn,
    multi: true
  }];
  for (const feature of features) {
    providers.push(...feature.ɵproviders);
  }
  return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.makeEnvironmentProviders)(providers);
}
function withInterceptors(interceptorFns) {
  return makeHttpFeature(HttpFeatureKind.Interceptors, interceptorFns.map(interceptorFn => {
    return {
      provide: HTTP_INTERCEPTOR_FNS,
      useValue: interceptorFn,
      multi: true
    };
  }));
}
const LEGACY_INTERCEPTOR_FN = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'LEGACY_INTERCEPTOR_FN' : '');
function withInterceptorsFromDi() {
  return makeHttpFeature(HttpFeatureKind.LegacyInterceptors, [{
    provide: LEGACY_INTERCEPTOR_FN,
    useFactory: legacyInterceptorFnFactory
  }, {
    provide: HTTP_INTERCEPTOR_FNS,
    useExisting: LEGACY_INTERCEPTOR_FN,
    multi: true
  }]);
}
function withXsrfConfiguration({
  cookieName,
  headerName
}) {
  const providers = [];
  if (cookieName !== undefined) {
    providers.push({
      provide: XSRF_COOKIE_NAME,
      useValue: cookieName
    });
  }
  if (headerName !== undefined) {
    providers.push({
      provide: XSRF_HEADER_NAME,
      useValue: headerName
    });
  }
  return makeHttpFeature(HttpFeatureKind.CustomXsrfConfiguration, providers);
}
function withNoXsrfProtection() {
  return makeHttpFeature(HttpFeatureKind.NoXsrfProtection, [{
    provide: XSRF_ENABLED,
    useValue: false
  }]);
}
function withJsonpSupport() {
  return makeHttpFeature(HttpFeatureKind.JsonpSupport, [JsonpClientBackend, {
    provide: JsonpCallbackContext,
    useFactory: jsonpCallbackContext
  }, {
    provide: HTTP_INTERCEPTOR_FNS,
    useValue: jsonpInterceptorFn,
    multi: true
  }]);
}
function withRequestsMadeViaParent() {
  return makeHttpFeature(HttpFeatureKind.RequestsMadeViaParent, [{
    provide: HttpBackend,
    useFactory: () => {
      const handlerFromParent = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(HttpHandler, {
        skipSelf: true,
        optional: true
      });
      if (ngDevMode && handlerFromParent === null) {
        throw new Error('withRequestsMadeViaParent() can only be used when the parent injector also configures HttpClient');
      }
      return handlerFromParent;
    }
  }]);
}
function withFetch() {
  return makeHttpFeature(HttpFeatureKind.Fetch, [FetchBackend, {
    provide: FETCH_BACKEND,
    useExisting: FetchBackend
  }, {
    provide: HttpBackend,
    useExisting: FetchBackend
  }]);
}
class HttpClientXsrfModule {
  static disable() {
    return {
      ngModule: HttpClientXsrfModule,
      providers: [withNoXsrfProtection().ɵproviders]
    };
  }
  static withOptions(options = {}) {
    return {
      ngModule: HttpClientXsrfModule,
      providers: withXsrfConfiguration(options).ɵproviders
    };
  }
  static ɵfac = function HttpClientXsrfModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || HttpClientXsrfModule)();
  };
  static ɵmod = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineNgModule"]({
    type: HttpClientXsrfModule
  });
  static ɵinj = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
    providers: [HttpXsrfInterceptor, {
      provide: HTTP_INTERCEPTORS,
      useExisting: HttpXsrfInterceptor,
      multi: true
    }, {
      provide: HttpXsrfTokenExtractor,
      useClass: HttpXsrfCookieExtractor
    }, withXsrfConfiguration({
      cookieName: XSRF_DEFAULT_COOKIE_NAME,
      headerName: XSRF_DEFAULT_HEADER_NAME
    }).ɵproviders, {
      provide: XSRF_ENABLED,
      useValue: true
    }]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata(HttpClientXsrfModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.NgModule,
    args: [{
      providers: [HttpXsrfInterceptor, {
        provide: HTTP_INTERCEPTORS,
        useExisting: HttpXsrfInterceptor,
        multi: true
      }, {
        provide: HttpXsrfTokenExtractor,
        useClass: HttpXsrfCookieExtractor
      }, withXsrfConfiguration({
        cookieName: XSRF_DEFAULT_COOKIE_NAME,
        headerName: XSRF_DEFAULT_HEADER_NAME
      }).ɵproviders, {
        provide: XSRF_ENABLED,
        useValue: true
      }]
    }]
  }], null, null);
})();
class HttpClientModule {
  static ɵfac = function HttpClientModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || HttpClientModule)();
  };
  static ɵmod = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineNgModule"]({
    type: HttpClientModule
  });
  static ɵinj = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
    providers: [provideHttpClient(withInterceptorsFromDi())]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata(HttpClientModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.NgModule,
    args: [{
      providers: [provideHttpClient(withInterceptorsFromDi())]
    }]
  }], null, null);
})();
class HttpClientJsonpModule {
  static ɵfac = function HttpClientJsonpModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || HttpClientJsonpModule)();
  };
  static ɵmod = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineNgModule"]({
    type: HttpClientJsonpModule
  });
  static ɵinj = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
    providers: [withJsonpSupport().ɵproviders]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata(HttpClientJsonpModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.NgModule,
    args: [{
      providers: [withJsonpSupport().ɵproviders]
    }]
  }], null, null);
})();


/***/ }),

/***/ 3126:
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@angular+common@21.0.5_@angular+core@21.0.5_rxjs@7.8.2/node_modules/@angular/common/fesm2022/common.mjs ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   APP_BASE_HREF: () => (/* reexport safe */ _location_chunk_mjs__WEBPACK_IMPORTED_MODULE_7__.APP_BASE_HREF),
/* harmony export */   AsyncPipe: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.AsyncPipe),
/* harmony export */   BrowserPlatformLocation: () => (/* reexport safe */ _platform_location_chunk_mjs__WEBPACK_IMPORTED_MODULE_8__.BrowserPlatformLocation),
/* harmony export */   CommonModule: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CommonModule),
/* harmony export */   CurrencyPipe: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CurrencyPipe),
/* harmony export */   DATE_PIPE_DEFAULT_OPTIONS: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DATE_PIPE_DEFAULT_OPTIONS),
/* harmony export */   DATE_PIPE_DEFAULT_TIMEZONE: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DATE_PIPE_DEFAULT_TIMEZONE),
/* harmony export */   DOCUMENT: () => (/* reexport safe */ _angular_core__WEBPACK_IMPORTED_MODULE_2__.DOCUMENT),
/* harmony export */   DatePipe: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DatePipe),
/* harmony export */   DecimalPipe: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DecimalPipe),
/* harmony export */   FormStyle: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FormStyle),
/* harmony export */   FormatWidth: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FormatWidth),
/* harmony export */   HashLocationStrategy: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HashLocationStrategy),
/* harmony export */   I18nPluralPipe: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.I18nPluralPipe),
/* harmony export */   I18nSelectPipe: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.I18nSelectPipe),
/* harmony export */   IMAGE_CONFIG: () => (/* reexport safe */ _angular_core__WEBPACK_IMPORTED_MODULE_3__.IMAGE_CONFIG),
/* harmony export */   IMAGE_LOADER: () => (/* binding */ IMAGE_LOADER),
/* harmony export */   JsonPipe: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.JsonPipe),
/* harmony export */   KeyValuePipe: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.KeyValuePipe),
/* harmony export */   LOCATION_INITIALIZED: () => (/* reexport safe */ _platform_location_chunk_mjs__WEBPACK_IMPORTED_MODULE_8__.LOCATION_INITIALIZED),
/* harmony export */   Location: () => (/* reexport safe */ _location_chunk_mjs__WEBPACK_IMPORTED_MODULE_7__.Location),
/* harmony export */   LocationStrategy: () => (/* reexport safe */ _location_chunk_mjs__WEBPACK_IMPORTED_MODULE_7__.LocationStrategy),
/* harmony export */   LowerCasePipe: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.LowerCasePipe),
/* harmony export */   NgClass: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgClass),
/* harmony export */   NgComponentOutlet: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgComponentOutlet),
/* harmony export */   NgFor: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgForOf),
/* harmony export */   NgForOf: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgForOf),
/* harmony export */   NgForOfContext: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgForOfContext),
/* harmony export */   NgIf: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgIf),
/* harmony export */   NgIfContext: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgIfContext),
/* harmony export */   NgLocaleLocalization: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgLocaleLocalization),
/* harmony export */   NgLocalization: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgLocalization),
/* harmony export */   NgOptimizedImage: () => (/* binding */ NgOptimizedImage),
/* harmony export */   NgPlural: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgPlural),
/* harmony export */   NgPluralCase: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgPluralCase),
/* harmony export */   NgStyle: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgStyle),
/* harmony export */   NgSwitch: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgSwitch),
/* harmony export */   NgSwitchCase: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgSwitchCase),
/* harmony export */   NgSwitchDefault: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgSwitchDefault),
/* harmony export */   NgTemplateOutlet: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgTemplateOutlet),
/* harmony export */   NumberFormatStyle: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NumberFormatStyle),
/* harmony export */   NumberSymbol: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NumberSymbol),
/* harmony export */   PRECONNECT_CHECK_BLOCKLIST: () => (/* binding */ PRECONNECT_CHECK_BLOCKLIST),
/* harmony export */   PathLocationStrategy: () => (/* reexport safe */ _location_chunk_mjs__WEBPACK_IMPORTED_MODULE_7__.PathLocationStrategy),
/* harmony export */   PercentPipe: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PercentPipe),
/* harmony export */   PlatformLocation: () => (/* reexport safe */ _platform_location_chunk_mjs__WEBPACK_IMPORTED_MODULE_8__.PlatformLocation),
/* harmony export */   PlatformNavigation: () => (/* reexport safe */ _platform_navigation_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__.PlatformNavigation),
/* harmony export */   Plural: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.Plural),
/* harmony export */   SlicePipe: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.SlicePipe),
/* harmony export */   TitleCasePipe: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TitleCasePipe),
/* harmony export */   TranslationWidth: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TranslationWidth),
/* harmony export */   UpperCasePipe: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.UpperCasePipe),
/* harmony export */   VERSION: () => (/* binding */ VERSION),
/* harmony export */   ViewportScroller: () => (/* binding */ ViewportScroller),
/* harmony export */   WeekDay: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.WeekDay),
/* harmony export */   XhrFactory: () => (/* reexport safe */ _xhr_chunk_mjs__WEBPACK_IMPORTED_MODULE_6__.XhrFactory),
/* harmony export */   formatCurrency: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.formatCurrency),
/* harmony export */   formatDate: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.formatDate),
/* harmony export */   formatNumber: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.formatNumber),
/* harmony export */   formatPercent: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.formatPercent),
/* harmony export */   getCurrencySymbol: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrencySymbol),
/* harmony export */   getLocaleCurrencyCode: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLocaleCurrencyCode),
/* harmony export */   getLocaleCurrencyName: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLocaleCurrencyName),
/* harmony export */   getLocaleCurrencySymbol: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLocaleCurrencySymbol),
/* harmony export */   getLocaleDateFormat: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLocaleDateFormat),
/* harmony export */   getLocaleDateTimeFormat: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLocaleDateTimeFormat),
/* harmony export */   getLocaleDayNames: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLocaleDayNames),
/* harmony export */   getLocaleDayPeriods: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLocaleDayPeriods),
/* harmony export */   getLocaleDirection: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLocaleDirection),
/* harmony export */   getLocaleEraNames: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLocaleEraNames),
/* harmony export */   getLocaleExtraDayPeriodRules: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLocaleExtraDayPeriodRules),
/* harmony export */   getLocaleExtraDayPeriods: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLocaleExtraDayPeriods),
/* harmony export */   getLocaleFirstDayOfWeek: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLocaleFirstDayOfWeek),
/* harmony export */   getLocaleId: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLocaleId),
/* harmony export */   getLocaleMonthNames: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLocaleMonthNames),
/* harmony export */   getLocaleNumberFormat: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLocaleNumberFormat),
/* harmony export */   getLocaleNumberSymbol: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLocaleNumberSymbol),
/* harmony export */   getLocalePluralCase: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLocalePluralCase),
/* harmony export */   getLocaleTimeFormat: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLocaleTimeFormat),
/* harmony export */   getLocaleWeekEndRange: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLocaleWeekEndRange),
/* harmony export */   getNumberOfCurrencyDigits: () => (/* reexport safe */ _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNumberOfCurrencyDigits),
/* harmony export */   isPlatformBrowser: () => (/* binding */ isPlatformBrowser),
/* harmony export */   isPlatformServer: () => (/* binding */ isPlatformServer),
/* harmony export */   provideCloudflareLoader: () => (/* binding */ provideCloudflareLoader),
/* harmony export */   provideCloudinaryLoader: () => (/* binding */ provideCloudinaryLoader),
/* harmony export */   provideImageKitLoader: () => (/* binding */ provideImageKitLoader),
/* harmony export */   provideImgixLoader: () => (/* binding */ provideImgixLoader),
/* harmony export */   provideNetlifyLoader: () => (/* binding */ provideNetlifyLoader),
/* harmony export */   registerLocaleData: () => (/* binding */ registerLocaleData),
/* harmony export */   "ɵDomAdapter": () => (/* reexport safe */ _platform_location_chunk_mjs__WEBPACK_IMPORTED_MODULE_8__.DomAdapter),
/* harmony export */   "ɵNavigationAdapterForLocation": () => (/* binding */ NavigationAdapterForLocation),
/* harmony export */   "ɵNullViewportScroller": () => (/* binding */ NullViewportScroller),
/* harmony export */   "ɵPLATFORM_BROWSER_ID": () => (/* binding */ PLATFORM_BROWSER_ID),
/* harmony export */   "ɵPLATFORM_SERVER_ID": () => (/* binding */ PLATFORM_SERVER_ID),
/* harmony export */   "ɵgetDOM": () => (/* reexport safe */ _platform_location_chunk_mjs__WEBPACK_IMPORTED_MODULE_8__.getDOM),
/* harmony export */   "ɵnormalizeQueryParams": () => (/* reexport safe */ _location_chunk_mjs__WEBPACK_IMPORTED_MODULE_7__.normalizeQueryParams),
/* harmony export */   "ɵparseCookieValue": () => (/* reexport safe */ _xhr_chunk_mjs__WEBPACK_IMPORTED_MODULE_6__.parseCookieValue),
/* harmony export */   "ɵsetRootDomAdapter": () => (/* reexport safe */ _platform_location_chunk_mjs__WEBPACK_IMPORTED_MODULE_8__.setRootDomAdapter)
/* harmony export */ });
/* harmony import */ var C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 3194);
/* harmony import */ var _common_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_common_module-chunk.mjs */ 5726);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ 64);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/core */ 7367);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/core */ 8357);
/* harmony import */ var _platform_navigation_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_platform_navigation-chunk.mjs */ 2802);
/* harmony import */ var _xhr_chunk_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_xhr-chunk.mjs */ 7802);
/* harmony import */ var _location_chunk_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_location-chunk.mjs */ 933);
/* harmony import */ var _platform_location_chunk_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./_platform_location-chunk.mjs */ 8021);

/**
 * @license Angular v21.0.5
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */











class NavigationAdapterForLocation extends _location_chunk_mjs__WEBPACK_IMPORTED_MODULE_7__.Location {
  navigation = (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(_platform_navigation_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__.PlatformNavigation);
  destroyRef = (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_2__.DestroyRef);
  constructor() {
    super((0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(_location_chunk_mjs__WEBPACK_IMPORTED_MODULE_7__.LocationStrategy));
    this.registerNavigationListeners();
  }
  registerNavigationListeners() {
    const currentEntryChangeListener = () => {
      this._notifyUrlChangeListeners(this.path(true), this.getState());
    };
    this.navigation.addEventListener('currententrychange', currentEntryChangeListener);
    this.destroyRef.onDestroy(() => {
      this.navigation.removeEventListener('currententrychange', currentEntryChangeListener);
    });
  }
  getState() {
    return this.navigation.currentEntry?.getState();
  }
  replaceState(path, query = '', state = null) {
    const url = this.prepareExternalUrl(path + (0,_location_chunk_mjs__WEBPACK_IMPORTED_MODULE_7__.normalizeQueryParams)(query));
    this.navigation.navigate(url, {
      state,
      history: 'replace'
    });
  }
  go(path, query = '', state = null) {
    const url = this.prepareExternalUrl(path + (0,_location_chunk_mjs__WEBPACK_IMPORTED_MODULE_7__.normalizeQueryParams)(query));
    this.navigation.navigate(url, {
      state,
      history: 'push'
    });
  }
  back() {
    this.navigation.back();
  }
  forward() {
    this.navigation.forward();
  }
  onUrlChange(fn) {
    this._urlChangeListeners.push(fn);
    return () => {
      const fnIndex = this._urlChangeListeners.indexOf(fn);
      this._urlChangeListeners.splice(fnIndex, 1);
    };
  }
  static ɵfac = function NavigationAdapterForLocation_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || NavigationAdapterForLocation)();
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineInjectable"]({
    token: NavigationAdapterForLocation,
    factory: NavigationAdapterForLocation.ɵfac
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(NavigationAdapterForLocation, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable
  }], () => [], null);
})();
function registerLocaleData(data, localeId, extraData) {
  return (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.registerLocaleData)(data, localeId, extraData);
}
const PLATFORM_BROWSER_ID = 'browser';
const PLATFORM_SERVER_ID = 'server';
function isPlatformBrowser(platformId) {
  return platformId === PLATFORM_BROWSER_ID;
}
function isPlatformServer(platformId) {
  return platformId === PLATFORM_SERVER_ID;
}
const VERSION = /* @__PURE__ */new _angular_core__WEBPACK_IMPORTED_MODULE_2__.Version('21.0.5');
class ViewportScroller {
  static ɵprov = /* @__PURE__ */
  (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineInjectable"])({
    token: ViewportScroller,
    providedIn: 'root',
    factory: () => typeof ngServerMode !== 'undefined' && ngServerMode ? new NullViewportScroller() : new BrowserViewportScroller((0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_2__.DOCUMENT), window)
  });
}
class BrowserViewportScroller {
  document;
  window;
  offset = () => [0, 0];
  constructor(document, window) {
    this.document = document;
    this.window = window;
  }
  setOffset(offset) {
    if (Array.isArray(offset)) {
      this.offset = () => offset;
    } else {
      this.offset = offset;
    }
  }
  getScrollPosition() {
    return [this.window.scrollX, this.window.scrollY];
  }
  scrollToPosition(position, options) {
    this.window.scrollTo({
      ...options,
      left: position[0],
      top: position[1]
    });
  }
  scrollToAnchor(target, options) {
    const elSelected = findAnchorFromDocument(this.document, target);
    if (elSelected) {
      this.scrollToElement(elSelected, options);
      elSelected.focus();
    }
  }
  setHistoryScrollRestoration(scrollRestoration) {
    try {
      this.window.history.scrollRestoration = scrollRestoration;
    } catch {
      console.warn((0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.formatRuntimeError)(2400, ngDevMode && 'Failed to set `window.history.scrollRestoration`. ' + 'This may occur when:\n' + '• The script is running inside a sandboxed iframe\n' + '• The window is partially navigated or inactive\n' + '• The script is executed in an untrusted or special context (e.g., test runners, browser extensions, or content previews)\n' + 'Scroll position may not be preserved across navigation.'));
    }
  }
  scrollToElement(el, options) {
    const rect = el.getBoundingClientRect();
    const left = rect.left + this.window.pageXOffset;
    const top = rect.top + this.window.pageYOffset;
    const offset = this.offset();
    this.window.scrollTo({
      ...options,
      left: left - offset[0],
      top: top - offset[1]
    });
  }
}
function findAnchorFromDocument(document, target) {
  const documentResult = document.getElementById(target) || document.getElementsByName(target)[0];
  if (documentResult) {
    return documentResult;
  }
  if (typeof document.createTreeWalker === 'function' && document.body && typeof document.body.attachShadow === 'function') {
    const treeWalker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT);
    let currentNode = treeWalker.currentNode;
    while (currentNode) {
      const shadowRoot = currentNode.shadowRoot;
      if (shadowRoot) {
        const result = shadowRoot.getElementById(target) || shadowRoot.querySelector(`[name="${target}"]`);
        if (result) {
          return result;
        }
      }
      currentNode = treeWalker.nextNode();
    }
  }
  return null;
}
class NullViewportScroller {
  setOffset(offset) {}
  getScrollPosition() {
    return [0, 0];
  }
  scrollToPosition(position) {}
  scrollToAnchor(anchor) {}
  setHistoryScrollRestoration(scrollRestoration) {}
}
const PLACEHOLDER_QUALITY = '20';
function getUrl(src, win) {
  return isAbsoluteUrl(src) ? new URL(src) : new URL(src, win.location.href);
}
function isAbsoluteUrl(src) {
  return /^https?:\/\//.test(src);
}
function extractHostname(url) {
  return isAbsoluteUrl(url) ? new URL(url).hostname : url;
}
function isValidPath(path) {
  const isString = typeof path === 'string';
  if (!isString || path.trim() === '') {
    return false;
  }
  try {
    const url = new URL(path);
    return true;
  } catch {
    return false;
  }
}
function normalizePath(path) {
  return path.endsWith('/') ? path.slice(0, -1) : path;
}
function normalizeSrc(src) {
  return src.startsWith('/') ? src.slice(1) : src;
}
const noopImageLoader = config => config.src;
const IMAGE_LOADER = new _angular_core__WEBPACK_IMPORTED_MODULE_2__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'ImageLoader' : '', {
  factory: () => noopImageLoader
});
function createImageLoader(buildUrlFn, exampleUrls) {
  return function provideImageLoader(path) {
    if (!isValidPath(path)) {
      throwInvalidPathError(path, exampleUrls || []);
    }
    path = normalizePath(path);
    const loaderFn = config => {
      if (isAbsoluteUrl(config.src)) {
        throwUnexpectedAbsoluteUrlError(path, config.src);
      }
      return buildUrlFn(path, {
        ...config,
        src: normalizeSrc(config.src)
      });
    };
    const providers = [{
      provide: IMAGE_LOADER,
      useValue: loaderFn
    }];
    return providers;
  };
}
function throwInvalidPathError(path, exampleUrls) {
  throw new _angular_core__WEBPACK_IMPORTED_MODULE_2__.RuntimeError(2959, ngDevMode && `Image loader has detected an invalid path (\`${path}\`). ` + `To fix this, supply a path using one of the following formats: ${exampleUrls.join(' or ')}`);
}
function throwUnexpectedAbsoluteUrlError(path, url) {
  throw new _angular_core__WEBPACK_IMPORTED_MODULE_2__.RuntimeError(2959, ngDevMode && `Image loader has detected a \`<img>\` tag with an invalid \`ngSrc\` attribute: ${url}. ` + `This image loader expects \`ngSrc\` to be a relative URL - ` + `however the provided value is an absolute URL. ` + `To fix this, provide \`ngSrc\` as a path relative to the base URL ` + `configured for this loader (\`${path}\`).`);
}
const provideCloudflareLoader = createImageLoader(createCloudflareUrl, ngDevMode ? ['https://<ZONE>/cdn-cgi/image/<OPTIONS>/<SOURCE-IMAGE>'] : undefined);
function createCloudflareUrl(path, config) {
  let params = `format=auto`;
  if (config.width) {
    params += `,width=${config.width}`;
  }
  if (config.isPlaceholder) {
    params += `,quality=${PLACEHOLDER_QUALITY}`;
  }
  return `${path}/cdn-cgi/image/${params}/${config.src}`;
}
const cloudinaryLoaderInfo = {
  name: 'Cloudinary',
  testUrl: isCloudinaryUrl
};
const CLOUDINARY_LOADER_REGEX = /https?\:\/\/[^\/]+\.cloudinary\.com\/.+/;
function isCloudinaryUrl(url) {
  return CLOUDINARY_LOADER_REGEX.test(url);
}
const provideCloudinaryLoader = createImageLoader(createCloudinaryUrl, ngDevMode ? ['https://res.cloudinary.com/mysite', 'https://mysite.cloudinary.com', 'https://subdomain.mysite.com'] : undefined);
function createCloudinaryUrl(path, config) {
  const quality = config.isPlaceholder ? 'q_auto:low' : 'q_auto';
  let params = `f_auto,${quality}`;
  if (config.width) {
    params += `,w_${config.width}`;
  }
  if (config.loaderParams?.['rounded']) {
    params += `,r_max`;
  }
  return `${path}/image/upload/${params}/${config.src}`;
}
const imageKitLoaderInfo = {
  name: 'ImageKit',
  testUrl: isImageKitUrl
};
const IMAGE_KIT_LOADER_REGEX = /https?\:\/\/[^\/]+\.imagekit\.io\/.+/;
function isImageKitUrl(url) {
  return IMAGE_KIT_LOADER_REGEX.test(url);
}
const provideImageKitLoader = createImageLoader(createImagekitUrl, ngDevMode ? ['https://ik.imagekit.io/mysite', 'https://subdomain.mysite.com'] : undefined);
function createImagekitUrl(path, config) {
  const {
    src,
    width
  } = config;
  const params = [];
  if (width) {
    params.push(`w-${width}`);
  }
  if (config.isPlaceholder) {
    params.push(`q-${PLACEHOLDER_QUALITY}`);
  }
  const urlSegments = params.length ? [path, `tr:${params.join(',')}`, src] : [path, src];
  const url = new URL(urlSegments.join('/'));
  return url.href;
}
const imgixLoaderInfo = {
  name: 'Imgix',
  testUrl: isImgixUrl
};
const IMGIX_LOADER_REGEX = /https?\:\/\/[^\/]+\.imgix\.net\/.+/;
function isImgixUrl(url) {
  return IMGIX_LOADER_REGEX.test(url);
}
const provideImgixLoader = createImageLoader(createImgixUrl, ngDevMode ? ['https://somepath.imgix.net/'] : undefined);
function createImgixUrl(path, config) {
  const url = new URL(`${path}/${config.src}`);
  url.searchParams.set('auto', 'format');
  if (config.width) {
    url.searchParams.set('w', config.width.toString());
  }
  if (config.isPlaceholder) {
    url.searchParams.set('q', PLACEHOLDER_QUALITY);
  }
  return url.href;
}
const netlifyLoaderInfo = {
  name: 'Netlify',
  testUrl: isNetlifyUrl
};
const NETLIFY_LOADER_REGEX = /https?\:\/\/[^\/]+\.netlify\.app\/.+/;
function isNetlifyUrl(url) {
  return NETLIFY_LOADER_REGEX.test(url);
}
function provideNetlifyLoader(path) {
  if (path && !isValidPath(path)) {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_2__.RuntimeError(2959, ngDevMode && `Image loader has detected an invalid path (\`${path}\`). ` + `To fix this, supply either the full URL to the Netlify site, or leave it empty to use the current site.`);
  }
  if (path) {
    const url = new URL(path);
    path = url.origin;
  }
  const loaderFn = config => {
    return createNetlifyUrl(config, path);
  };
  const providers = [{
    provide: IMAGE_LOADER,
    useValue: loaderFn
  }];
  return providers;
}
const validParams = new Map([['height', 'h'], ['fit', 'fit'], ['quality', 'q'], ['q', 'q'], ['position', 'position']]);
function createNetlifyUrl(config, path) {
  const url = new URL(path ?? 'https://a/');
  url.pathname = '/.netlify/images';
  if (!isAbsoluteUrl(config.src) && !config.src.startsWith('/')) {
    config.src = '/' + config.src;
  }
  url.searchParams.set('url', config.src);
  if (config.width) {
    url.searchParams.set('w', config.width.toString());
  }
  const configQuality = config.loaderParams?.['quality'] ?? config.loaderParams?.['q'];
  if (config.isPlaceholder && !configQuality) {
    url.searchParams.set('q', PLACEHOLDER_QUALITY);
  }
  for (const [param, value] of Object.entries(config.loaderParams ?? {})) {
    if (validParams.has(param)) {
      url.searchParams.set(validParams.get(param), value.toString());
    } else {
      if (ngDevMode) {
        console.warn((0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.formatRuntimeError)(2959, `The Netlify image loader has detected an \`<img>\` tag with the unsupported attribute "\`${param}\`".`));
      }
    }
  }
  return url.hostname === 'a' ? url.href.replace(url.origin, '') : url.href;
}
function imgDirectiveDetails(ngSrc, includeNgSrc = true) {
  const ngSrcInfo = includeNgSrc ? `(activated on an <img> element with the \`ngSrc="${ngSrc}"\`) ` : '';
  return `The NgOptimizedImage directive ${ngSrcInfo}has detected that`;
}
function assertDevMode(checkName) {
  if (!ngDevMode) {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_2__.RuntimeError(2958, `Unexpected invocation of the ${checkName} in the prod mode. ` + `Please make sure that the prod mode is enabled for production builds.`);
  }
}
class LCPImageObserver {
  images = new Map();
  window = (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_2__.DOCUMENT).defaultView;
  observer = null;
  constructor() {
    assertDevMode('LCP checker');
    if ((typeof ngServerMode === 'undefined' || !ngServerMode) && typeof PerformanceObserver !== 'undefined') {
      this.observer = this.initPerformanceObserver();
    }
  }
  initPerformanceObserver() {
    const observer = new PerformanceObserver(entryList => {
      const entries = entryList.getEntries();
      if (entries.length === 0) return;
      const lcpElement = entries[entries.length - 1];
      const imgSrc = lcpElement.element?.src ?? '';
      if (imgSrc.startsWith('data:') || imgSrc.startsWith('blob:')) return;
      const img = this.images.get(imgSrc);
      if (!img) return;
      if (!img.priority && !img.alreadyWarnedPriority) {
        img.alreadyWarnedPriority = true;
        logMissingPriorityError(imgSrc);
      }
      if (img.modified && !img.alreadyWarnedModified) {
        img.alreadyWarnedModified = true;
        logModifiedWarning(imgSrc);
      }
    });
    observer.observe({
      type: 'largest-contentful-paint',
      buffered: true
    });
    return observer;
  }
  registerImage(rewrittenSrc, originalNgSrc, isPriority) {
    if (!this.observer) return;
    const newObservedImageState = {
      priority: isPriority,
      modified: false,
      alreadyWarnedModified: false,
      alreadyWarnedPriority: false
    };
    this.images.set(getUrl(rewrittenSrc, this.window).href, newObservedImageState);
  }
  unregisterImage(rewrittenSrc) {
    if (!this.observer) return;
    this.images.delete(getUrl(rewrittenSrc, this.window).href);
  }
  updateImage(originalSrc, newSrc) {
    if (!this.observer) return;
    const originalUrl = getUrl(originalSrc, this.window).href;
    const img = this.images.get(originalUrl);
    if (img) {
      img.modified = true;
      this.images.set(getUrl(newSrc, this.window).href, img);
      this.images.delete(originalUrl);
    }
  }
  ngOnDestroy() {
    if (!this.observer) return;
    this.observer.disconnect();
    this.images.clear();
  }
  static ɵfac = function LCPImageObserver_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || LCPImageObserver)();
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineInjectable"]({
    token: LCPImageObserver,
    factory: LCPImageObserver.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(LCPImageObserver, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], () => [], null);
})();
function logMissingPriorityError(ngSrc) {
  const directiveDetails = imgDirectiveDetails(ngSrc);
  console.error((0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.formatRuntimeError)(2955, `${directiveDetails} this image is the Largest Contentful Paint (LCP) ` + `element but was not marked "priority". This image should be marked ` + `"priority" in order to prioritize its loading. ` + `To fix this, add the "priority" attribute.`));
}
function logModifiedWarning(ngSrc) {
  const directiveDetails = imgDirectiveDetails(ngSrc);
  console.warn((0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.formatRuntimeError)(2964, `${directiveDetails} this image is the Largest Contentful Paint (LCP) ` + `element and has had its "ngSrc" attribute modified. This can cause ` + `slower loading performance. It is recommended not to modify the "ngSrc" ` + `property on any image which could be the LCP element.`));
}
const INTERNAL_PRECONNECT_CHECK_BLOCKLIST = new Set(['localhost', '127.0.0.1', '0.0.0.0', '[::1]']);
const PRECONNECT_CHECK_BLOCKLIST = new _angular_core__WEBPACK_IMPORTED_MODULE_2__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'PRECONNECT_CHECK_BLOCKLIST' : '');
class PreconnectLinkChecker {
  document = (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_2__.DOCUMENT);
  preconnectLinks = null;
  alreadySeen = new Set();
  window = this.document.defaultView;
  blocklist = new Set(INTERNAL_PRECONNECT_CHECK_BLOCKLIST);
  constructor() {
    assertDevMode('preconnect link checker');
    const blocklist = (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(PRECONNECT_CHECK_BLOCKLIST, {
      optional: true
    });
    if (blocklist) {
      this.populateBlocklist(blocklist);
    }
  }
  populateBlocklist(origins) {
    if (Array.isArray(origins)) {
      deepForEach(origins, origin => {
        this.blocklist.add(extractHostname(origin));
      });
    } else {
      this.blocklist.add(extractHostname(origins));
    }
  }
  assertPreconnect(rewrittenSrc, originalNgSrc) {
    if (typeof ngServerMode !== 'undefined' && ngServerMode) return;
    const imgUrl = getUrl(rewrittenSrc, this.window);
    if (this.blocklist.has(imgUrl.hostname) || this.alreadySeen.has(imgUrl.origin)) return;
    this.alreadySeen.add(imgUrl.origin);
    this.preconnectLinks ??= this.queryPreconnectLinks();
    if (!this.preconnectLinks.has(imgUrl.origin)) {
      console.warn((0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.formatRuntimeError)(2956, `${imgDirectiveDetails(originalNgSrc)} there is no preconnect tag present for this ` + `image. Preconnecting to the origin(s) that serve priority images ensures that these ` + `images are delivered as soon as possible. To fix this, please add the following ` + `element into the <head> of the document:\n` + `  <link rel="preconnect" href="${imgUrl.origin}">`));
    }
  }
  queryPreconnectLinks() {
    const preconnectUrls = new Set();
    const links = this.document.querySelectorAll('link[rel=preconnect]');
    for (const link of links) {
      const url = getUrl(link.href, this.window);
      preconnectUrls.add(url.origin);
    }
    return preconnectUrls;
  }
  ngOnDestroy() {
    this.preconnectLinks?.clear();
    this.alreadySeen.clear();
  }
  static ɵfac = function PreconnectLinkChecker_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || PreconnectLinkChecker)();
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineInjectable"]({
    token: PreconnectLinkChecker,
    factory: PreconnectLinkChecker.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(PreconnectLinkChecker, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], () => [], null);
})();
function deepForEach(input, fn) {
  for (let value of input) {
    Array.isArray(value) ? deepForEach(value, fn) : fn(value);
  }
}
const DEFAULT_PRELOADED_IMAGES_LIMIT = 5;
const PRELOADED_IMAGES = new _angular_core__WEBPACK_IMPORTED_MODULE_2__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'NG_OPTIMIZED_PRELOADED_IMAGES' : '', {
  factory: () => new Set()
});
class PreloadLinkCreator {
  preloadedImages = (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(PRELOADED_IMAGES);
  document = (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_2__.DOCUMENT);
  errorShown = false;
  createPreloadLinkTag(renderer, src, srcset, sizes) {
    if (ngDevMode && !this.errorShown && this.preloadedImages.size >= DEFAULT_PRELOADED_IMAGES_LIMIT) {
      this.errorShown = true;
      console.warn((0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.formatRuntimeError)(2961, `The \`NgOptimizedImage\` directive has detected that more than ` + `${DEFAULT_PRELOADED_IMAGES_LIMIT} images were marked as priority. ` + `This might negatively affect an overall performance of the page. ` + `To fix this, remove the "priority" attribute from images with less priority.`));
    }
    if (this.preloadedImages.has(src)) {
      return;
    }
    this.preloadedImages.add(src);
    const preload = renderer.createElement('link');
    renderer.setAttribute(preload, 'as', 'image');
    renderer.setAttribute(preload, 'href', src);
    renderer.setAttribute(preload, 'rel', 'preload');
    renderer.setAttribute(preload, 'fetchpriority', 'high');
    if (sizes) {
      renderer.setAttribute(preload, 'imageSizes', sizes);
    }
    if (srcset) {
      renderer.setAttribute(preload, 'imageSrcset', srcset);
    }
    renderer.appendChild(this.document.head, preload);
  }
  static ɵfac = function PreloadLinkCreator_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || PreloadLinkCreator)();
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineInjectable"]({
    token: PreloadLinkCreator,
    factory: PreloadLinkCreator.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(PreloadLinkCreator, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], null, null);
})();
const BASE64_IMG_MAX_LENGTH_IN_ERROR = 50;
const VALID_WIDTH_DESCRIPTOR_SRCSET = /^((\s*\d+w\s*(,|$)){1,})$/;
const VALID_DENSITY_DESCRIPTOR_SRCSET = /^((\s*\d+(\.\d+)?x\s*(,|$)){1,})$/;
const ABSOLUTE_SRCSET_DENSITY_CAP = 3;
const RECOMMENDED_SRCSET_DENSITY_CAP = 2;
const DENSITY_SRCSET_MULTIPLIERS = [1, 2];
const VIEWPORT_BREAKPOINT_CUTOFF = 640;
const ASPECT_RATIO_TOLERANCE = 0.1;
const OVERSIZED_IMAGE_TOLERANCE = 1000;
const FIXED_SRCSET_WIDTH_LIMIT = 1920;
const FIXED_SRCSET_HEIGHT_LIMIT = 1080;
const PLACEHOLDER_DIMENSION_LIMIT = 1000;
const DATA_URL_WARN_LIMIT = 4000;
const DATA_URL_ERROR_LIMIT = 10000;
const BUILT_IN_LOADERS = [imgixLoaderInfo, imageKitLoaderInfo, cloudinaryLoaderInfo, netlifyLoaderInfo];
const PRIORITY_COUNT_THRESHOLD = 10;
let IMGS_WITH_PRIORITY_ATTR_COUNT = 0;
class NgOptimizedImage {
  imageLoader = (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(IMAGE_LOADER);
  config = processConfig((0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_3__.IMAGE_CONFIG));
  renderer = (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_3__.Renderer2);
  imgElement = (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_3__.ElementRef).nativeElement;
  injector = (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_2__.Injector);
  destroyRef = (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_2__.DestroyRef);
  lcpObserver;
  _renderedSrc = null;
  ngSrc;
  ngSrcset;
  sizes;
  width;
  height;
  decoding;
  loading;
  priority = false;
  loaderParams;
  disableOptimizedSrcset = false;
  fill = false;
  placeholder;
  placeholderConfig;
  src;
  srcset;
  constructor() {
    if (ngDevMode) {
      this.lcpObserver = this.injector.get(LCPImageObserver);
      this.destroyRef.onDestroy(() => {
        if (!this.priority && this._renderedSrc !== null) {
          this.lcpObserver.unregisterImage(this._renderedSrc);
        }
      });
    }
  }
  ngOnInit() {
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.performanceMarkFeature)('NgOptimizedImage');
    if (ngDevMode) {
      const ngZone = this.injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_2__.NgZone);
      assertNonEmptyInput(this, 'ngSrc', this.ngSrc);
      assertValidNgSrcset(this, this.ngSrcset);
      assertNoConflictingSrc(this);
      if (this.ngSrcset) {
        assertNoConflictingSrcset(this);
      }
      assertNotBase64Image(this);
      assertNotBlobUrl(this);
      if (this.fill) {
        assertEmptyWidthAndHeight(this);
        ngZone.runOutsideAngular(() => assertNonZeroRenderedHeight(this, this.imgElement, this.renderer, this.destroyRef));
      } else {
        assertNonEmptyWidthAndHeight(this);
        if (this.height !== undefined) {
          assertGreaterThanZero(this, this.height, 'height');
        }
        if (this.width !== undefined) {
          assertGreaterThanZero(this, this.width, 'width');
        }
        ngZone.runOutsideAngular(() => assertNoImageDistortion(this, this.imgElement, this.renderer, this.destroyRef));
      }
      assertValidLoadingInput(this);
      assertValidDecodingInput(this);
      if (!this.ngSrcset) {
        assertNoComplexSizes(this);
      }
      assertValidPlaceholder(this, this.imageLoader);
      assertNotMissingBuiltInLoader(this.ngSrc, this.imageLoader);
      assertNoNgSrcsetWithoutLoader(this, this.imageLoader);
      assertNoLoaderParamsWithoutLoader(this, this.imageLoader);
      ngZone.runOutsideAngular(() => {
        this.lcpObserver.registerImage(this.getRewrittenSrc(), this.ngSrc, this.priority);
      });
      if (this.priority) {
        const checker = this.injector.get(PreconnectLinkChecker);
        checker.assertPreconnect(this.getRewrittenSrc(), this.ngSrc);
        if (typeof ngServerMode !== 'undefined' && !ngServerMode) {
          const applicationRef = this.injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_3__.ApplicationRef);
          assetPriorityCountBelowThreshold(applicationRef);
        }
      }
    }
    if (this.placeholder) {
      this.removePlaceholderOnLoad(this.imgElement);
    }
    this.setHostAttributes();
  }
  setHostAttributes() {
    if (this.fill) {
      this.sizes ||= '100vw';
    } else {
      this.setHostAttribute('width', this.width.toString());
      this.setHostAttribute('height', this.height.toString());
    }
    this.setHostAttribute('loading', this.getLoadingBehavior());
    this.setHostAttribute('fetchpriority', this.getFetchPriority());
    this.setHostAttribute('decoding', this.getDecoding());
    this.setHostAttribute('ng-img', 'true');
    const rewrittenSrcset = this.updateSrcAndSrcset();
    if (this.sizes) {
      if (this.getLoadingBehavior() === 'lazy') {
        this.setHostAttribute('sizes', 'auto, ' + this.sizes);
      } else {
        this.setHostAttribute('sizes', this.sizes);
      }
    } else {
      if (this.ngSrcset && VALID_WIDTH_DESCRIPTOR_SRCSET.test(this.ngSrcset) && this.getLoadingBehavior() === 'lazy') {
        this.setHostAttribute('sizes', 'auto, 100vw');
      }
    }
    if (typeof ngServerMode !== 'undefined' && ngServerMode && this.priority) {
      const preloadLinkCreator = this.injector.get(PreloadLinkCreator);
      preloadLinkCreator.createPreloadLinkTag(this.renderer, this.getRewrittenSrc(), rewrittenSrcset, this.sizes);
    }
  }
  ngOnChanges(changes) {
    if (ngDevMode) {
      assertNoPostInitInputChange(this, changes, ['ngSrcset', 'width', 'height', 'priority', 'fill', 'loading', 'sizes', 'loaderParams', 'disableOptimizedSrcset']);
    }
    if (changes['ngSrc'] && !changes['ngSrc'].isFirstChange()) {
      const oldSrc = this._renderedSrc;
      this.updateSrcAndSrcset(true);
      if (ngDevMode) {
        const newSrc = this._renderedSrc;
        if (oldSrc && newSrc && oldSrc !== newSrc) {
          const ngZone = this.injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_2__.NgZone);
          ngZone.runOutsideAngular(() => {
            this.lcpObserver.updateImage(oldSrc, newSrc);
          });
        }
      }
    }
    if (ngDevMode && changes['placeholder']?.currentValue && typeof ngServerMode !== 'undefined' && !ngServerMode) {
      assertPlaceholderDimensions(this, this.imgElement);
    }
  }
  callImageLoader(configWithoutCustomParams) {
    let augmentedConfig = configWithoutCustomParams;
    if (this.loaderParams) {
      augmentedConfig.loaderParams = this.loaderParams;
    }
    return this.imageLoader(augmentedConfig);
  }
  getLoadingBehavior() {
    if (!this.priority && this.loading !== undefined) {
      return this.loading;
    }
    return this.priority ? 'eager' : 'lazy';
  }
  getFetchPriority() {
    return this.priority ? 'high' : 'auto';
  }
  getDecoding() {
    if (this.priority) {
      return 'sync';
    }
    return this.decoding ?? 'auto';
  }
  getRewrittenSrc() {
    if (!this._renderedSrc) {
      const imgConfig = {
        src: this.ngSrc
      };
      this._renderedSrc = this.callImageLoader(imgConfig);
    }
    return this._renderedSrc;
  }
  getRewrittenSrcset() {
    const widthSrcSet = VALID_WIDTH_DESCRIPTOR_SRCSET.test(this.ngSrcset);
    const finalSrcs = this.ngSrcset.split(',').filter(src => src !== '').map(srcStr => {
      srcStr = srcStr.trim();
      const width = widthSrcSet ? parseFloat(srcStr) : parseFloat(srcStr) * this.width;
      return `${this.callImageLoader({
        src: this.ngSrc,
        width
      })} ${srcStr}`;
    });
    return finalSrcs.join(', ');
  }
  getAutomaticSrcset() {
    if (this.sizes) {
      return this.getResponsiveSrcset();
    } else {
      return this.getFixedSrcset();
    }
  }
  getResponsiveSrcset() {
    const {
      breakpoints
    } = this.config;
    let filteredBreakpoints = breakpoints;
    if (this.sizes?.trim() === '100vw') {
      filteredBreakpoints = breakpoints.filter(bp => bp >= VIEWPORT_BREAKPOINT_CUTOFF);
    }
    const finalSrcs = filteredBreakpoints.map(bp => `${this.callImageLoader({
      src: this.ngSrc,
      width: bp
    })} ${bp}w`);
    return finalSrcs.join(', ');
  }
  updateSrcAndSrcset(forceSrcRecalc = false) {
    if (forceSrcRecalc) {
      this._renderedSrc = null;
    }
    const rewrittenSrc = this.getRewrittenSrc();
    this.setHostAttribute('src', rewrittenSrc);
    let rewrittenSrcset = undefined;
    if (this.ngSrcset) {
      rewrittenSrcset = this.getRewrittenSrcset();
    } else if (this.shouldGenerateAutomaticSrcset()) {
      rewrittenSrcset = this.getAutomaticSrcset();
    }
    if (rewrittenSrcset) {
      this.setHostAttribute('srcset', rewrittenSrcset);
    }
    return rewrittenSrcset;
  }
  getFixedSrcset() {
    const finalSrcs = DENSITY_SRCSET_MULTIPLIERS.map(multiplier => `${this.callImageLoader({
      src: this.ngSrc,
      width: this.width * multiplier
    })} ${multiplier}x`);
    return finalSrcs.join(', ');
  }
  shouldGenerateAutomaticSrcset() {
    let oversizedImage = false;
    if (!this.sizes) {
      oversizedImage = this.width > FIXED_SRCSET_WIDTH_LIMIT || this.height > FIXED_SRCSET_HEIGHT_LIMIT;
    }
    return !this.disableOptimizedSrcset && !this.srcset && this.imageLoader !== noopImageLoader && !oversizedImage;
  }
  generatePlaceholder(placeholderInput) {
    const {
      placeholderResolution
    } = this.config;
    if (placeholderInput === true) {
      return `url(${this.callImageLoader({
        src: this.ngSrc,
        width: placeholderResolution,
        isPlaceholder: true
      })})`;
    } else if (typeof placeholderInput === 'string') {
      return `url(${placeholderInput})`;
    }
    return null;
  }
  shouldBlurPlaceholder(placeholderConfig) {
    if (!placeholderConfig || !placeholderConfig.hasOwnProperty('blur')) {
      return true;
    }
    return Boolean(placeholderConfig.blur);
  }
  removePlaceholderOnLoad(img) {
    const callback = () => {
      const changeDetectorRef = this.injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_4__.ChangeDetectorRef);
      removeLoadListenerFn();
      removeErrorListenerFn();
      this.placeholder = false;
      changeDetectorRef.markForCheck();
    };
    const removeLoadListenerFn = this.renderer.listen(img, 'load', callback);
    const removeErrorListenerFn = this.renderer.listen(img, 'error', callback);
    this.destroyRef.onDestroy(() => {
      removeLoadListenerFn();
      removeErrorListenerFn();
    });
    callOnLoadIfImageIsLoaded(img, callback);
  }
  setHostAttribute(name, value) {
    this.renderer.setAttribute(this.imgElement, name, value);
  }
  static ɵfac = function NgOptimizedImage_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || NgOptimizedImage)();
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineDirective"]({
    type: NgOptimizedImage,
    selectors: [["img", "ngSrc", ""]],
    hostVars: 18,
    hostBindings: function NgOptimizedImage_HostBindings(rf, ctx) {
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵstyleProp"]("position", ctx.fill ? "absolute" : null)("width", ctx.fill ? "100%" : null)("height", ctx.fill ? "100%" : null)("inset", ctx.fill ? "0" : null)("background-size", ctx.placeholder ? "cover" : null)("background-position", ctx.placeholder ? "50% 50%" : null)("background-repeat", ctx.placeholder ? "no-repeat" : null)("background-image", ctx.placeholder ? ctx.generatePlaceholder(ctx.placeholder) : null)("filter", ctx.placeholder && ctx.shouldBlurPlaceholder(ctx.placeholderConfig) ? "blur(15px)" : null);
      }
    },
    inputs: {
      ngSrc: [2, "ngSrc", "ngSrc", unwrapSafeUrl],
      ngSrcset: "ngSrcset",
      sizes: "sizes",
      width: [2, "width", "width", _angular_core__WEBPACK_IMPORTED_MODULE_4__.numberAttribute],
      height: [2, "height", "height", _angular_core__WEBPACK_IMPORTED_MODULE_4__.numberAttribute],
      decoding: "decoding",
      loading: "loading",
      priority: [2, "priority", "priority", _angular_core__WEBPACK_IMPORTED_MODULE_4__.booleanAttribute],
      loaderParams: "loaderParams",
      disableOptimizedSrcset: [2, "disableOptimizedSrcset", "disableOptimizedSrcset", _angular_core__WEBPACK_IMPORTED_MODULE_4__.booleanAttribute],
      fill: [2, "fill", "fill", _angular_core__WEBPACK_IMPORTED_MODULE_4__.booleanAttribute],
      placeholder: [2, "placeholder", "placeholder", booleanOrUrlAttribute],
      placeholderConfig: "placeholderConfig",
      src: "src",
      srcset: "srcset"
    },
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵNgOnChangesFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(NgOptimizedImage, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Directive,
    args: [{
      selector: 'img[ngSrc]',
      host: {
        '[style.position]': 'fill ? "absolute" : null',
        '[style.width]': 'fill ? "100%" : null',
        '[style.height]': 'fill ? "100%" : null',
        '[style.inset]': 'fill ? "0" : null',
        '[style.background-size]': 'placeholder ? "cover" : null',
        '[style.background-position]': 'placeholder ? "50% 50%" : null',
        '[style.background-repeat]': 'placeholder ? "no-repeat" : null',
        '[style.background-image]': 'placeholder ? generatePlaceholder(placeholder) : null',
        '[style.filter]': 'placeholder && shouldBlurPlaceholder(placeholderConfig) ? "blur(15px)" : null'
      }
    }]
  }], () => [], {
    ngSrc: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
      args: [{
        required: true,
        transform: unwrapSafeUrl
      }]
    }],
    ngSrcset: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input
    }],
    sizes: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input
    }],
    width: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
      args: [{
        transform: _angular_core__WEBPACK_IMPORTED_MODULE_4__.numberAttribute
      }]
    }],
    height: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
      args: [{
        transform: _angular_core__WEBPACK_IMPORTED_MODULE_4__.numberAttribute
      }]
    }],
    decoding: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input
    }],
    loading: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input
    }],
    priority: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
      args: [{
        transform: _angular_core__WEBPACK_IMPORTED_MODULE_4__.booleanAttribute
      }]
    }],
    loaderParams: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input
    }],
    disableOptimizedSrcset: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
      args: [{
        transform: _angular_core__WEBPACK_IMPORTED_MODULE_4__.booleanAttribute
      }]
    }],
    fill: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
      args: [{
        transform: _angular_core__WEBPACK_IMPORTED_MODULE_4__.booleanAttribute
      }]
    }],
    placeholder: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
      args: [{
        transform: booleanOrUrlAttribute
      }]
    }],
    placeholderConfig: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input
    }],
    src: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input
    }],
    srcset: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input
    }]
  });
})();
function processConfig(config) {
  let sortedBreakpoints = {};
  if (config.breakpoints) {
    sortedBreakpoints.breakpoints = config.breakpoints.sort((a, b) => a - b);
  }
  return Object.assign({}, _angular_core__WEBPACK_IMPORTED_MODULE_3__.IMAGE_CONFIG_DEFAULTS, config, sortedBreakpoints);
}
function assertNoConflictingSrc(dir) {
  if (dir.src) {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_2__.RuntimeError(2950, `${imgDirectiveDetails(dir.ngSrc)} both \`src\` and \`ngSrc\` have been set. ` + `Supplying both of these attributes breaks lazy loading. ` + `The NgOptimizedImage directive sets \`src\` itself based on the value of \`ngSrc\`. ` + `To fix this, please remove the \`src\` attribute.`);
  }
}
function assertNoConflictingSrcset(dir) {
  if (dir.srcset) {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_2__.RuntimeError(2951, `${imgDirectiveDetails(dir.ngSrc)} both \`srcset\` and \`ngSrcset\` have been set. ` + `Supplying both of these attributes breaks lazy loading. ` + `The NgOptimizedImage directive sets \`srcset\` itself based on the value of ` + `\`ngSrcset\`. To fix this, please remove the \`srcset\` attribute.`);
  }
}
function assertNotBase64Image(dir) {
  let ngSrc = dir.ngSrc.trim();
  if (ngSrc.startsWith('data:')) {
    if (ngSrc.length > BASE64_IMG_MAX_LENGTH_IN_ERROR) {
      ngSrc = ngSrc.substring(0, BASE64_IMG_MAX_LENGTH_IN_ERROR) + '...';
    }
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_2__.RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \`ngSrc\` is a Base64-encoded string ` + `(${ngSrc}). NgOptimizedImage does not support Base64-encoded strings. ` + `To fix this, disable the NgOptimizedImage directive for this element ` + `by removing \`ngSrc\` and using a standard \`src\` attribute instead.`);
  }
}
function assertNoComplexSizes(dir) {
  let sizes = dir.sizes;
  if (sizes?.match(/((\)|,)\s|^)\d+px/)) {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_2__.RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \`sizes\` was set to a string including ` + `pixel values. For automatic \`srcset\` generation, \`sizes\` must only include responsive ` + `values, such as \`sizes="50vw"\` or \`sizes="(min-width: 768px) 50vw, 100vw"\`. ` + `To fix this, modify the \`sizes\` attribute, or provide your own \`ngSrcset\` value directly.`);
  }
}
function assertValidPlaceholder(dir, imageLoader) {
  assertNoPlaceholderConfigWithoutPlaceholder(dir);
  assertNoRelativePlaceholderWithoutLoader(dir, imageLoader);
  assertNoOversizedDataUrl(dir);
}
function assertNoPlaceholderConfigWithoutPlaceholder(dir) {
  if (dir.placeholderConfig && !dir.placeholder) {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_2__.RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \`placeholderConfig\` options were provided for an ` + `image that does not use the \`placeholder\` attribute, and will have no effect.`);
  }
}
function assertNoRelativePlaceholderWithoutLoader(dir, imageLoader) {
  if (dir.placeholder === true && imageLoader === noopImageLoader) {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_2__.RuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \`placeholder\` attribute is set to true but ` + `no image loader is configured (i.e. the default one is being used), ` + `which would result in the same image being used for the primary image and its placeholder. ` + `To fix this, provide a loader or remove the \`placeholder\` attribute from the image.`);
  }
}
function assertNoOversizedDataUrl(dir) {
  if (dir.placeholder && typeof dir.placeholder === 'string' && dir.placeholder.startsWith('data:')) {
    if (dir.placeholder.length > DATA_URL_ERROR_LIMIT) {
      throw new _angular_core__WEBPACK_IMPORTED_MODULE_2__.RuntimeError(2965, `${imgDirectiveDetails(dir.ngSrc)} the \`placeholder\` attribute is set to a data URL which is longer ` + `than ${DATA_URL_ERROR_LIMIT} characters. This is strongly discouraged, as large inline placeholders ` + `directly increase the bundle size of Angular and hurt page load performance. To fix this, generate ` + `a smaller data URL placeholder.`);
    }
    if (dir.placeholder.length > DATA_URL_WARN_LIMIT) {
      console.warn((0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.formatRuntimeError)(2965, `${imgDirectiveDetails(dir.ngSrc)} the \`placeholder\` attribute is set to a data URL which is longer ` + `than ${DATA_URL_WARN_LIMIT} characters. This is discouraged, as large inline placeholders ` + `directly increase the bundle size of Angular and hurt page load performance. For better loading performance, ` + `generate a smaller data URL placeholder.`));
    }
  }
}
function assertNotBlobUrl(dir) {
  const ngSrc = dir.ngSrc.trim();
  if (ngSrc.startsWith('blob:')) {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_2__.RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`ngSrc\` was set to a blob URL (${ngSrc}). ` + `Blob URLs are not supported by the NgOptimizedImage directive. ` + `To fix this, disable the NgOptimizedImage directive for this element ` + `by removing \`ngSrc\` and using a regular \`src\` attribute instead.`);
  }
}
function assertNonEmptyInput(dir, name, value) {
  const isString = typeof value === 'string';
  const isEmptyString = isString && value.trim() === '';
  if (!isString || isEmptyString) {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_2__.RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`${name}\` has an invalid value ` + `(\`${value}\`). To fix this, change the value to a non-empty string.`);
  }
}
function assertValidNgSrcset(dir, value) {
  if (value == null) return;
  assertNonEmptyInput(dir, 'ngSrcset', value);
  const stringVal = value;
  const isValidWidthDescriptor = VALID_WIDTH_DESCRIPTOR_SRCSET.test(stringVal);
  const isValidDensityDescriptor = VALID_DENSITY_DESCRIPTOR_SRCSET.test(stringVal);
  if (isValidDensityDescriptor) {
    assertUnderDensityCap(dir, stringVal);
  }
  const isValidSrcset = isValidWidthDescriptor || isValidDensityDescriptor;
  if (!isValidSrcset) {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_2__.RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`ngSrcset\` has an invalid value (\`${value}\`). ` + `To fix this, supply \`ngSrcset\` using a comma-separated list of one or more width ` + `descriptors (e.g. "100w, 200w") or density descriptors (e.g. "1x, 2x").`);
  }
}
function assertUnderDensityCap(dir, value) {
  const underDensityCap = value.split(',').every(num => num === '' || parseFloat(num) <= ABSOLUTE_SRCSET_DENSITY_CAP);
  if (!underDensityCap) {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_2__.RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`ngSrcset\` contains an unsupported image density:` + `\`${value}\`. NgOptimizedImage generally recommends a max image density of ` + `${RECOMMENDED_SRCSET_DENSITY_CAP}x but supports image densities up to ` + `${ABSOLUTE_SRCSET_DENSITY_CAP}x. The human eye cannot distinguish between image densities ` + `greater than ${RECOMMENDED_SRCSET_DENSITY_CAP}x - which makes them unnecessary for ` + `most use cases. Images that will be pinch-zoomed are typically the primary use case for ` + `${ABSOLUTE_SRCSET_DENSITY_CAP}x images. Please remove the high density descriptor and try again.`);
  }
}
function postInitInputChangeError(dir, inputName) {
  let reason;
  if (inputName === 'width' || inputName === 'height') {
    reason = `Changing \`${inputName}\` may result in different attribute value ` + `applied to the underlying image element and cause layout shifts on a page.`;
  } else {
    reason = `Changing the \`${inputName}\` would have no effect on the underlying ` + `image element, because the resource loading has already occurred.`;
  }
  return new _angular_core__WEBPACK_IMPORTED_MODULE_2__.RuntimeError(2953, `${imgDirectiveDetails(dir.ngSrc)} \`${inputName}\` was updated after initialization. ` + `The NgOptimizedImage directive will not react to this input change. ${reason} ` + `To fix this, either switch \`${inputName}\` to a static value ` + `or wrap the image element in an @if that is gated on the necessary value.`);
}
function assertNoPostInitInputChange(dir, changes, inputs) {
  inputs.forEach(input => {
    const isUpdated = changes.hasOwnProperty(input);
    if (isUpdated && !changes[input].isFirstChange()) {
      if (input === 'ngSrc') {
        dir = {
          ngSrc: changes[input].previousValue
        };
      }
      throw postInitInputChangeError(dir, input);
    }
  });
}
function assertGreaterThanZero(dir, inputValue, inputName) {
  const validNumber = typeof inputValue === 'number' && inputValue > 0;
  const validString = typeof inputValue === 'string' && /^\d+$/.test(inputValue.trim()) && parseInt(inputValue) > 0;
  if (!validNumber && !validString) {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_2__.RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`${inputName}\` has an invalid value. ` + `To fix this, provide \`${inputName}\` as a number greater than 0.`);
  }
}
function assertNoImageDistortion(dir, img, renderer, destroyRef) {
  const callback = () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
    const computedStyle = window.getComputedStyle(img);
    let renderedWidth = parseFloat(computedStyle.getPropertyValue('width'));
    let renderedHeight = parseFloat(computedStyle.getPropertyValue('height'));
    const boxSizing = computedStyle.getPropertyValue('box-sizing');
    if (boxSizing === 'border-box') {
      const paddingTop = computedStyle.getPropertyValue('padding-top');
      const paddingRight = computedStyle.getPropertyValue('padding-right');
      const paddingBottom = computedStyle.getPropertyValue('padding-bottom');
      const paddingLeft = computedStyle.getPropertyValue('padding-left');
      renderedWidth -= parseFloat(paddingRight) + parseFloat(paddingLeft);
      renderedHeight -= parseFloat(paddingTop) + parseFloat(paddingBottom);
    }
    const renderedAspectRatio = renderedWidth / renderedHeight;
    const nonZeroRenderedDimensions = renderedWidth !== 0 && renderedHeight !== 0;
    const intrinsicWidth = img.naturalWidth;
    const intrinsicHeight = img.naturalHeight;
    const intrinsicAspectRatio = intrinsicWidth / intrinsicHeight;
    const suppliedWidth = dir.width;
    const suppliedHeight = dir.height;
    const suppliedAspectRatio = suppliedWidth / suppliedHeight;
    const inaccurateDimensions = Math.abs(suppliedAspectRatio - intrinsicAspectRatio) > ASPECT_RATIO_TOLERANCE;
    const stylingDistortion = nonZeroRenderedDimensions && Math.abs(intrinsicAspectRatio - renderedAspectRatio) > ASPECT_RATIO_TOLERANCE;
    if (inaccurateDimensions) {
      console.warn((0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.formatRuntimeError)(2952, `${imgDirectiveDetails(dir.ngSrc)} the aspect ratio of the image does not match ` + `the aspect ratio indicated by the width and height attributes. ` + `\nIntrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h ` + `(aspect-ratio: ${round(intrinsicAspectRatio)}). \nSupplied width and height attributes: ` + `${suppliedWidth}w x ${suppliedHeight}h (aspect-ratio: ${round(suppliedAspectRatio)}). ` + `\nTo fix this, update the width and height attributes.`));
    } else if (stylingDistortion) {
      console.warn((0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.formatRuntimeError)(2952, `${imgDirectiveDetails(dir.ngSrc)} the aspect ratio of the rendered image ` + `does not match the image's intrinsic aspect ratio. ` + `\nIntrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h ` + `(aspect-ratio: ${round(intrinsicAspectRatio)}). \nRendered image size: ` + `${renderedWidth}w x ${renderedHeight}h (aspect-ratio: ` + `${round(renderedAspectRatio)}). \nThis issue can occur if "width" and "height" ` + `attributes are added to an image without updating the corresponding ` + `image styling. To fix this, adjust image styling. In most cases, ` + `adding "height: auto" or "width: auto" to the image styling will fix ` + `this issue.`));
    } else if (!dir.ngSrcset && nonZeroRenderedDimensions) {
      const recommendedWidth = RECOMMENDED_SRCSET_DENSITY_CAP * renderedWidth;
      const recommendedHeight = RECOMMENDED_SRCSET_DENSITY_CAP * renderedHeight;
      const oversizedWidth = intrinsicWidth - recommendedWidth >= OVERSIZED_IMAGE_TOLERANCE;
      const oversizedHeight = intrinsicHeight - recommendedHeight >= OVERSIZED_IMAGE_TOLERANCE;
      if (oversizedWidth || oversizedHeight) {
        console.warn((0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.formatRuntimeError)(2960, `${imgDirectiveDetails(dir.ngSrc)} the intrinsic image is significantly ` + `larger than necessary. ` + `\nRendered image size: ${renderedWidth}w x ${renderedHeight}h. ` + `\nIntrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h. ` + `\nRecommended intrinsic image size: ${recommendedWidth}w x ${recommendedHeight}h. ` + `\nNote: Recommended intrinsic image size is calculated assuming a maximum DPR of ` + `${RECOMMENDED_SRCSET_DENSITY_CAP}. To improve loading time, resize the image ` + `or consider using the "ngSrcset" and "sizes" attributes.`));
      }
    }
  };
  const removeLoadListenerFn = renderer.listen(img, 'load', callback);
  const removeErrorListenerFn = renderer.listen(img, 'error', () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
  });
  destroyRef.onDestroy(() => {
    removeLoadListenerFn();
    removeErrorListenerFn();
  });
  callOnLoadIfImageIsLoaded(img, callback);
}
function assertNonEmptyWidthAndHeight(dir) {
  let missingAttributes = [];
  if (dir.width === undefined) missingAttributes.push('width');
  if (dir.height === undefined) missingAttributes.push('height');
  if (missingAttributes.length > 0) {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_2__.RuntimeError(2954, `${imgDirectiveDetails(dir.ngSrc)} these required attributes ` + `are missing: ${missingAttributes.map(attr => `"${attr}"`).join(', ')}. ` + `Including "width" and "height" attributes will prevent image-related layout shifts. ` + `To fix this, include "width" and "height" attributes on the image tag or turn on ` + `"fill" mode with the \`fill\` attribute.`);
  }
}
function assertEmptyWidthAndHeight(dir) {
  if (dir.width || dir.height) {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_2__.RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the attributes \`height\` and/or \`width\` are present ` + `along with the \`fill\` attribute. Because \`fill\` mode causes an image to fill its containing ` + `element, the size attributes have no effect and should be removed.`);
  }
}
function assertNonZeroRenderedHeight(dir, img, renderer, destroyRef) {
  const callback = () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
    const renderedHeight = img.clientHeight;
    if (dir.fill && renderedHeight === 0) {
      console.warn((0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.formatRuntimeError)(2952, `${imgDirectiveDetails(dir.ngSrc)} the height of the fill-mode image is zero. ` + `This is likely because the containing element does not have the CSS 'position' ` + `property set to one of the following: "relative", "fixed", or "absolute". ` + `To fix this problem, make sure the container element has the CSS 'position' ` + `property defined and the height of the element is not zero.`));
    }
  };
  const removeLoadListenerFn = renderer.listen(img, 'load', callback);
  const removeErrorListenerFn = renderer.listen(img, 'error', () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
  });
  destroyRef.onDestroy(() => {
    removeLoadListenerFn();
    removeErrorListenerFn();
  });
  callOnLoadIfImageIsLoaded(img, callback);
}
function assertValidLoadingInput(dir) {
  if (dir.loading && dir.priority) {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_2__.RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`loading\` attribute ` + `was used on an image that was marked "priority". ` + `Setting \`loading\` on priority images is not allowed ` + `because these images will always be eagerly loaded. ` + `To fix this, remove the “loading” attribute from the priority image.`);
  }
  const validInputs = ['auto', 'eager', 'lazy'];
  if (typeof dir.loading === 'string' && !validInputs.includes(dir.loading)) {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_2__.RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`loading\` attribute ` + `has an invalid value (\`${dir.loading}\`). ` + `To fix this, provide a valid value ("lazy", "eager", or "auto").`);
  }
}
function assertValidDecodingInput(dir) {
  const validInputs = ['sync', 'async', 'auto'];
  if (typeof dir.decoding === 'string' && !validInputs.includes(dir.decoding)) {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_2__.RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`decoding\` attribute ` + `has an invalid value (\`${dir.decoding}\`). ` + `To fix this, provide a valid value ("sync", "async", or "auto").`);
  }
}
function assertNotMissingBuiltInLoader(ngSrc, imageLoader) {
  if (imageLoader === noopImageLoader) {
    let builtInLoaderName = '';
    for (const loader of BUILT_IN_LOADERS) {
      if (loader.testUrl(ngSrc)) {
        builtInLoaderName = loader.name;
        break;
      }
    }
    if (builtInLoaderName) {
      console.warn((0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.formatRuntimeError)(2962, `NgOptimizedImage: It looks like your images may be hosted on the ` + `${builtInLoaderName} CDN, but your app is not using Angular's ` + `built-in loader for that CDN. We recommend switching to use ` + `the built-in by calling \`provide${builtInLoaderName}Loader()\` ` + `in your \`providers\` and passing it your instance's base URL. ` + `If you don't want to use the built-in loader, define a custom ` + `loader function using IMAGE_LOADER to silence this warning.`));
    }
  }
}
function assertNoNgSrcsetWithoutLoader(dir, imageLoader) {
  if (dir.ngSrcset && imageLoader === noopImageLoader) {
    console.warn((0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.formatRuntimeError)(2963, `${imgDirectiveDetails(dir.ngSrc)} the \`ngSrcset\` attribute is present but ` + `no image loader is configured (i.e. the default one is being used), ` + `which would result in the same image being used for all configured sizes. ` + `To fix this, provide a loader or remove the \`ngSrcset\` attribute from the image.`));
  }
}
function assertNoLoaderParamsWithoutLoader(dir, imageLoader) {
  if (dir.loaderParams && imageLoader === noopImageLoader) {
    console.warn((0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.formatRuntimeError)(2963, `${imgDirectiveDetails(dir.ngSrc)} the \`loaderParams\` attribute is present but ` + `no image loader is configured (i.e. the default one is being used), ` + `which means that the loaderParams data will not be consumed and will not affect the URL. ` + `To fix this, provide a custom loader or remove the \`loaderParams\` attribute from the image.`));
  }
}
function assetPriorityCountBelowThreshold(_x) {
  return _assetPriorityCountBelowThreshold.apply(this, arguments);
}
function _assetPriorityCountBelowThreshold() {
  _assetPriorityCountBelowThreshold = (0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (appRef) {
    if (IMGS_WITH_PRIORITY_ATTR_COUNT === 0) {
      IMGS_WITH_PRIORITY_ATTR_COUNT++;
      yield appRef.whenStable();
      if (IMGS_WITH_PRIORITY_ATTR_COUNT > PRIORITY_COUNT_THRESHOLD) {
        console.warn((0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.formatRuntimeError)(2966, `NgOptimizedImage: The "priority" attribute is set to true more than ${PRIORITY_COUNT_THRESHOLD} times (${IMGS_WITH_PRIORITY_ATTR_COUNT} times). ` + `Marking too many images as "high" priority can hurt your application's LCP (https://web.dev/lcp). ` + `"Priority" should only be set on the image expected to be the page's LCP element.`));
      }
    } else {
      IMGS_WITH_PRIORITY_ATTR_COUNT++;
    }
  });
  return _assetPriorityCountBelowThreshold.apply(this, arguments);
}
function assertPlaceholderDimensions(dir, imgElement) {
  const computedStyle = window.getComputedStyle(imgElement);
  let renderedWidth = parseFloat(computedStyle.getPropertyValue('width'));
  let renderedHeight = parseFloat(computedStyle.getPropertyValue('height'));
  if (renderedWidth > PLACEHOLDER_DIMENSION_LIMIT || renderedHeight > PLACEHOLDER_DIMENSION_LIMIT) {
    console.warn((0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.formatRuntimeError)(2967, `${imgDirectiveDetails(dir.ngSrc)} it uses a placeholder image, but at least one ` + `of the dimensions attribute (height or width) exceeds the limit of ${PLACEHOLDER_DIMENSION_LIMIT}px. ` + `To fix this, use a smaller image as a placeholder.`));
  }
}
function callOnLoadIfImageIsLoaded(img, callback) {
  if (img.complete && img.naturalWidth) {
    callback();
  }
}
function round(input) {
  return Number.isInteger(input) ? input : input.toFixed(2);
}
function unwrapSafeUrl(value) {
  if (typeof value === 'string') {
    return value;
  }
  return (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.unwrapSafeValue)(value);
}
function booleanOrUrlAttribute(value) {
  if (typeof value === 'string' && value !== 'true' && value !== 'false' && value !== '') {
    return value;
  }
  return (0,_angular_core__WEBPACK_IMPORTED_MODULE_4__.booleanAttribute)(value);
}


/***/ }),

/***/ 3194:
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _asyncToGenerator)
/* harmony export */ });
function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);
      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }
      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}


/***/ }),

/***/ 3282:
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/util/pipe.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   pipe: () => (/* binding */ pipe),
/* harmony export */   pipeFromArray: () => (/* binding */ pipeFromArray)
/* harmony export */ });
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity */ 5232);

function pipe(...fns) {
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return _identity__WEBPACK_IMPORTED_MODULE_0__.identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce((prev, fn) => fn(prev), input);
  };
}

/***/ }),

/***/ 3439:
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/operators/mergeInternals.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mergeInternals: () => (/* binding */ mergeInternals)
/* harmony export */ });
/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observable/innerFrom */ 5829);
/* harmony import */ var _util_executeSchedule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/executeSchedule */ 3494);
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OperatorSubscriber */ 3943);



function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
  const buffer = [];
  let active = 0;
  let index = 0;
  let isComplete = false;
  const checkComplete = () => {
    if (isComplete && !buffer.length && !active) {
      subscriber.complete();
    }
  };
  const outerNext = value => active < concurrent ? doInnerSub(value) : buffer.push(value);
  const doInnerSub = value => {
    expand && subscriber.next(value);
    active++;
    let innerComplete = false;
    (0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_0__.innerFrom)(project(value, index++)).subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__.createOperatorSubscriber)(subscriber, innerValue => {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, () => {
      innerComplete = true;
    }, undefined, () => {
      if (innerComplete) {
        try {
          active--;
          while (buffer.length && active < concurrent) {
            const bufferedValue = buffer.shift();
            if (innerSubScheduler) {
              (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_1__.executeSchedule)(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));
            } else {
              doInnerSub(bufferedValue);
            }
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__.createOperatorSubscriber)(subscriber, outerNext, () => {
    isComplete = true;
    checkComplete();
  }));
  return () => {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}

/***/ }),

/***/ 3465:
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/scheduled/scheduleReadableStreamLike.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   scheduleReadableStreamLike: () => (/* binding */ scheduleReadableStreamLike)
/* harmony export */ });
/* harmony import */ var _scheduleAsyncIterable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scheduleAsyncIterable */ 6838);
/* harmony import */ var _util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/isReadableStreamLike */ 9905);


function scheduleReadableStreamLike(input, scheduler) {
  return (0,_scheduleAsyncIterable__WEBPACK_IMPORTED_MODULE_0__.scheduleAsyncIterable)((0,_util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_1__.readableStreamLikeToAsyncGenerator)(input), scheduler);
}

/***/ }),

/***/ 3477:
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@angular+common@21.0.5_@angular+core@21.0.5_rxjs@7.8.2/node_modules/@angular/common/fesm2022/http.mjs ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FetchBackend: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.FetchBackend),
/* harmony export */   HTTP_INTERCEPTORS: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HTTP_INTERCEPTORS),
/* harmony export */   HTTP_TRANSFER_CACHE_ORIGIN_MAP: () => (/* binding */ HTTP_TRANSFER_CACHE_ORIGIN_MAP),
/* harmony export */   HttpBackend: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpBackend),
/* harmony export */   HttpClient: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpClient),
/* harmony export */   HttpClientJsonpModule: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpClientJsonpModule),
/* harmony export */   HttpClientModule: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpClientModule),
/* harmony export */   HttpClientXsrfModule: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpClientXsrfModule),
/* harmony export */   HttpContext: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpContext),
/* harmony export */   HttpContextToken: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpContextToken),
/* harmony export */   HttpErrorResponse: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpErrorResponse),
/* harmony export */   HttpEventType: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpEventType),
/* harmony export */   HttpFeatureKind: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpFeatureKind),
/* harmony export */   HttpHandler: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpHandler),
/* harmony export */   HttpHeaderResponse: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpHeaderResponse),
/* harmony export */   HttpHeaders: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpHeaders),
/* harmony export */   HttpParams: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpParams),
/* harmony export */   HttpRequest: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpRequest),
/* harmony export */   HttpResponse: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpResponse),
/* harmony export */   HttpResponseBase: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpResponseBase),
/* harmony export */   HttpStatusCode: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpStatusCode),
/* harmony export */   HttpUrlEncodingCodec: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpUrlEncodingCodec),
/* harmony export */   HttpXhrBackend: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpXhrBackend),
/* harmony export */   HttpXsrfTokenExtractor: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpXsrfTokenExtractor),
/* harmony export */   JsonpClientBackend: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.JsonpClientBackend),
/* harmony export */   JsonpInterceptor: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.JsonpInterceptor),
/* harmony export */   httpResource: () => (/* binding */ httpResource),
/* harmony export */   provideHttpClient: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.provideHttpClient),
/* harmony export */   withFetch: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.withFetch),
/* harmony export */   withInterceptors: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.withInterceptors),
/* harmony export */   withInterceptorsFromDi: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.withInterceptorsFromDi),
/* harmony export */   withJsonpSupport: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.withJsonpSupport),
/* harmony export */   withNoXsrfProtection: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.withNoXsrfProtection),
/* harmony export */   withRequestsMadeViaParent: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.withRequestsMadeViaParent),
/* harmony export */   withXsrfConfiguration: () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.withXsrfConfiguration),
/* harmony export */   "ɵHTTP_ROOT_INTERCEPTOR_FNS": () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HTTP_ROOT_INTERCEPTOR_FNS),
/* harmony export */   "ɵHttpInterceptingHandler": () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpInterceptorHandler),
/* harmony export */   "ɵREQUESTS_CONTRIBUTE_TO_STABILITY": () => (/* reexport safe */ _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.REQUESTS_CONTRIBUTE_TO_STABILITY),
/* harmony export */   "ɵwithHttpTransferCache": () => (/* binding */ withHttpTransferCache)
/* harmony export */ });
/* harmony import */ var _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_module-chunk.mjs */ 3036);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ 64);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ 7367);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/core */ 3863);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ 9596);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs/operators */ 2556);
/**
 * @license Angular v21.0.5
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */








const httpResource = (() => {
  const jsonFn = makeHttpResourceFn('json');
  jsonFn.arrayBuffer = makeHttpResourceFn('arraybuffer');
  jsonFn.blob = makeHttpResourceFn('blob');
  jsonFn.text = makeHttpResourceFn('text');
  return jsonFn;
})();
function makeHttpResourceFn(responseType) {
  return function httpResource(request, options) {
    if (ngDevMode && !options?.injector) {
      (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.assertInInjectionContext)(httpResource);
    }
    const injector = options?.injector ?? (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Injector);
    return new HttpResourceImpl(injector, () => normalizeRequest(request, responseType), options?.defaultValue, options?.debugName, options?.parse, options?.equal);
  };
}
function normalizeRequest(request, responseType) {
  let unwrappedRequest = typeof request === 'function' ? request() : request;
  if (unwrappedRequest === undefined) {
    return undefined;
  } else if (typeof unwrappedRequest === 'string') {
    unwrappedRequest = {
      url: unwrappedRequest
    };
  }
  const headers = unwrappedRequest.headers instanceof _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpHeaders ? unwrappedRequest.headers : new _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpHeaders(unwrappedRequest.headers);
  const params = unwrappedRequest.params instanceof _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpParams ? unwrappedRequest.params : new _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpParams({
    fromObject: unwrappedRequest.params
  });
  return new _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpRequest(unwrappedRequest.method ?? 'GET', unwrappedRequest.url, unwrappedRequest.body ?? null, {
    headers,
    params,
    reportProgress: unwrappedRequest.reportProgress,
    withCredentials: unwrappedRequest.withCredentials,
    keepalive: unwrappedRequest.keepalive,
    cache: unwrappedRequest.cache,
    priority: unwrappedRequest.priority,
    mode: unwrappedRequest.mode,
    redirect: unwrappedRequest.redirect,
    responseType,
    context: unwrappedRequest.context,
    transferCache: unwrappedRequest.transferCache,
    credentials: unwrappedRequest.credentials,
    referrer: unwrappedRequest.referrer,
    referrerPolicy: unwrappedRequest.referrerPolicy,
    integrity: unwrappedRequest.integrity,
    timeout: unwrappedRequest.timeout
  });
}
class HttpResourceImpl extends _angular_core__WEBPACK_IMPORTED_MODULE_3__.ResourceImpl {
  client;
  _headers = (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.linkedSignal)({
    ...(ngDevMode ? {
      debugName: "_headers"
    } : {}),
    source: this.extRequest,
    computation: () => undefined
  });
  _progress = (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.linkedSignal)({
    ...(ngDevMode ? {
      debugName: "_progress"
    } : {}),
    source: this.extRequest,
    computation: () => undefined
  });
  _statusCode = (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.linkedSignal)({
    ...(ngDevMode ? {
      debugName: "_statusCode"
    } : {}),
    source: this.extRequest,
    computation: () => undefined
  });
  headers = (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.computed)(() => this.status() === 'resolved' || this.status() === 'error' ? this._headers() : undefined, ...(ngDevMode ? [{
    debugName: "headers"
  }] : []));
  progress = this._progress.asReadonly();
  statusCode = this._statusCode.asReadonly();
  constructor(injector, request, defaultValue, debugName, parse, equal) {
    super(request, ({
      params: request,
      abortSignal
    }) => {
      let sub;
      const onAbort = () => sub.unsubscribe();
      abortSignal.addEventListener('abort', onAbort);
      const stream = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.signal)({
        value: undefined
      }, ...(ngDevMode ? [{
        debugName: "stream"
      }] : []));
      let resolve;
      const promise = new Promise(r => resolve = r);
      const send = value => {
        stream.set(value);
        resolve?.(stream);
        resolve = undefined;
      };
      sub = this.client.request(request).subscribe({
        next: event => {
          switch (event.type) {
            case _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpEventType.Response:
              this._headers.set(event.headers);
              this._statusCode.set(event.status);
              try {
                send({
                  value: parse ? parse(event.body) : event.body
                });
              } catch (error) {
                send({
                  error: (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.encapsulateResourceError)(error)
                });
              }
              break;
            case _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpEventType.DownloadProgress:
              this._progress.set(event);
              break;
          }
        },
        error: error => {
          if (error instanceof _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpErrorResponse) {
            this._headers.set(error.headers);
            this._statusCode.set(error.status);
          }
          send({
            error
          });
          abortSignal.removeEventListener('abort', onAbort);
        },
        complete: () => {
          if (resolve) {
            send({
              error: new _angular_core__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(991, ngDevMode && 'Resource completed before producing a value')
            });
          }
          abortSignal.removeEventListener('abort', onAbort);
        }
      });
      return promise;
    }, defaultValue, equal, debugName, injector);
    this.client = injector.get(_module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpClient);
  }
  set(value) {
    super.set(value);
    this._headers.set(undefined);
    this._progress.set(undefined);
    this._statusCode.set(undefined);
  }
}
const HTTP_TRANSFER_CACHE_ORIGIN_MAP = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'HTTP_TRANSFER_CACHE_ORIGIN_MAP' : '');
const BODY = 'b';
const HEADERS = 'h';
const STATUS = 's';
const STATUS_TEXT = 'st';
const REQ_URL = 'u';
const RESPONSE_TYPE = 'rt';
const CACHE_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'HTTP_TRANSFER_STATE_CACHE_OPTIONS' : '');
const ALLOWED_METHODS = ['GET', 'HEAD'];
function transferCacheInterceptorFn(req, next) {
  const {
    isCacheActive,
    ...globalOptions
  } = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(CACHE_OPTIONS);
  const {
    transferCache: requestOptions,
    method: requestMethod
  } = req;
  if (!isCacheActive || requestOptions === false || requestMethod === 'POST' && !globalOptions.includePostRequests && !requestOptions || requestMethod !== 'POST' && !ALLOWED_METHODS.includes(requestMethod) || !globalOptions.includeRequestsWithAuthHeaders && hasAuthHeaders(req) || globalOptions.filter?.(req) === false) {
    return next(req);
  }
  const transferState = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_2__.TransferState);
  const originMap = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(HTTP_TRANSFER_CACHE_ORIGIN_MAP, {
    optional: true
  });
  if (typeof ngServerMode !== 'undefined' && !ngServerMode && originMap) {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(2803, ngDevMode && 'Angular detected that the `HTTP_TRANSFER_CACHE_ORIGIN_MAP` token is configured and ' + 'present in the client side code. Please ensure that this token is only provided in the ' + 'server code of the application.');
  }
  const requestUrl = typeof ngServerMode !== 'undefined' && ngServerMode && originMap ? mapRequestOriginUrl(req.url, originMap) : req.url;
  const storeKey = makeCacheKey(req, requestUrl);
  const response = transferState.get(storeKey, null);
  let headersToInclude = globalOptions.includeHeaders;
  if (typeof requestOptions === 'object' && requestOptions.includeHeaders) {
    headersToInclude = requestOptions.includeHeaders;
  }
  if (response) {
    const {
      [BODY]: undecodedBody,
      [RESPONSE_TYPE]: responseType,
      [HEADERS]: httpHeaders,
      [STATUS]: status,
      [STATUS_TEXT]: statusText,
      [REQ_URL]: url
    } = response;
    let body = undecodedBody;
    switch (responseType) {
      case 'arraybuffer':
        body = new TextEncoder().encode(undecodedBody).buffer;
        break;
      case 'blob':
        body = new Blob([undecodedBody]);
        break;
    }
    let headers = new _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpHeaders(httpHeaders);
    if (typeof ngDevMode === 'undefined' || ngDevMode) {
      headers = appendMissingHeadersDetection(req.url, headers, headersToInclude ?? []);
    }
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_4__.of)(new _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpResponse({
      body,
      headers,
      status,
      statusText,
      url
    }));
  }
  const event$ = next(req);
  if (typeof ngServerMode !== 'undefined' && ngServerMode) {
    return event$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.tap)(event => {
      if (event instanceof _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpResponse) {
        transferState.set(storeKey, {
          [BODY]: event.body,
          [HEADERS]: getFilteredHeaders(event.headers, headersToInclude),
          [STATUS]: event.status,
          [STATUS_TEXT]: event.statusText,
          [REQ_URL]: requestUrl,
          [RESPONSE_TYPE]: req.responseType
        });
      }
    }));
  }
  return event$;
}
function hasAuthHeaders(req) {
  return req.headers.has('authorization') || req.headers.has('proxy-authorization');
}
function getFilteredHeaders(headers, includeHeaders) {
  if (!includeHeaders) {
    return {};
  }
  const headersMap = {};
  for (const key of includeHeaders) {
    const values = headers.getAll(key);
    if (values !== null) {
      headersMap[key] = values;
    }
  }
  return headersMap;
}
function sortAndConcatParams(params) {
  return [...params.keys()].sort().map(k => `${k}=${params.getAll(k)}`).join('&');
}
function makeCacheKey(request, mappedRequestUrl) {
  const {
    params,
    method,
    responseType
  } = request;
  const encodedParams = sortAndConcatParams(params);
  let serializedBody = request.serializeBody();
  if (serializedBody instanceof URLSearchParams) {
    serializedBody = sortAndConcatParams(serializedBody);
  } else if (typeof serializedBody !== 'string') {
    serializedBody = '';
  }
  const key = [method, responseType, mappedRequestUrl, serializedBody, encodedParams].join('|');
  const hash = generateHash(key);
  return (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.makeStateKey)(hash);
}
function generateHash(value) {
  let hash = 0;
  for (const char of value) {
    hash = Math.imul(31, hash) + char.charCodeAt(0) << 0;
  }
  hash += 2147483647 + 1;
  return hash.toString();
}
function withHttpTransferCache(cacheOptions) {
  return [{
    provide: CACHE_OPTIONS,
    useFactory: () => {
      (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.performanceMarkFeature)('NgHttpTransferCache');
      return {
        isCacheActive: true,
        ...cacheOptions
      };
    }
  }, {
    provide: _module_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HTTP_ROOT_INTERCEPTOR_FNS,
    useValue: transferCacheInterceptorFn,
    multi: true
  }, {
    provide: _angular_core__WEBPACK_IMPORTED_MODULE_2__.APP_BOOTSTRAP_LISTENER,
    multi: true,
    useFactory: () => {
      const appRef = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_2__.ApplicationRef);
      const cacheState = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(CACHE_OPTIONS);
      return () => {
        appRef.whenStable().then(() => {
          cacheState.isCacheActive = false;
        });
      };
    }
  }];
}
function appendMissingHeadersDetection(url, headers, headersToInclude) {
  const warningProduced = new Set();
  return new Proxy(headers, {
    get(target, prop) {
      const value = Reflect.get(target, prop);
      const methods = new Set(['get', 'has', 'getAll']);
      if (typeof value !== 'function' || !methods.has(prop)) {
        return value;
      }
      return headerName => {
        const key = (prop + ':' + headerName).toLowerCase();
        if (!headersToInclude.includes(headerName) && !warningProduced.has(key)) {
          warningProduced.add(key);
          const truncatedUrl = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.truncateMiddle)(url);
          console.warn((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(-2802, `Angular detected that the \`${headerName}\` header is accessed, but the value of the header ` + `was not transferred from the server to the client by the HttpTransferCache. ` + `To include the value of the \`${headerName}\` header for the \`${truncatedUrl}\` request, ` + `use the \`includeHeaders\` list. The \`includeHeaders\` can be defined either ` + `on a request level by adding the \`transferCache\` parameter, or on an application ` + `level by adding the \`httpCacheTransfer.includeHeaders\` argument to the ` + `\`provideClientHydration()\` call. `));
        }
        return value.apply(target, [headerName]);
      };
    }
  });
}
function mapRequestOriginUrl(url, originMap) {
  const origin = new URL(url, 'resolve://').origin;
  const mappedOrigin = originMap[origin];
  if (!mappedOrigin) {
    return url;
  }
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
    verifyMappedOrigin(mappedOrigin);
  }
  return url.replace(origin, mappedOrigin);
}
function verifyMappedOrigin(url) {
  if (new URL(url, 'resolve://').pathname !== '/') {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(2804, 'Angular detected a URL with a path segment in the value provided for the ' + `\`HTTP_TRANSFER_CACHE_ORIGIN_MAP\` token: ${url}. The map should only contain origins ` + 'without any other segments.');
  }
}


/***/ }),

/***/ 3494:
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/util/executeSchedule.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   executeSchedule: () => (/* binding */ executeSchedule)
/* harmony export */ });
function executeSchedule(parentSubscription, scheduler, work, delay = 0, repeat = false) {
  const scheduleSubscription = scheduler.schedule(function () {
    work();
    if (repeat) {
      parentSubscription.add(this.schedule(null, delay));
    } else {
      this.unsubscribe();
    }
  }, delay);
  parentSubscription.add(scheduleSubscription);
  if (!repeat) {
    return scheduleSubscription;
  }
}

/***/ }),

/***/ 3667:
/*!*************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@angular+core@21.0.5_@angular+compiler@21.0.5_rxjs@7.8.2_zone.js@0.16.0/node_modules/@angular/core/fesm2022/_not_found-chunk.mjs ***!
  \*************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NOT_FOUND: () => (/* binding */ NOT_FOUND),
/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),
/* harmony export */   getCurrentInjector: () => (/* binding */ getCurrentInjector),
/* harmony export */   inject: () => (/* binding */ inject),
/* harmony export */   isNotFound: () => (/* binding */ isNotFound),
/* harmony export */   setCurrentInjector: () => (/* binding */ setCurrentInjector)
/* harmony export */ });
/**
 * @license Angular v21.0.5
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */

let _currentInjector = undefined;
function getCurrentInjector() {
  return _currentInjector;
}
function setCurrentInjector(injector) {
  const former = _currentInjector;
  _currentInjector = injector;
  return former;
}
function inject(token, options) {
  const currentInjector = getCurrentInjector();
  if (!currentInjector) {
    throw new Error('Current injector is not set.');
  }
  if (!token.ɵprov) {
    throw new Error('Token is not an injectable');
  }
  return currentInjector.retrieve(token, options);
}
const NOT_FOUND = Symbol('NotFound');
class NotFoundError extends Error {
  name = 'ɵNotFound';
  constructor(message) {
    super(message);
  }
}
function isNotFound(e) {
  return e === NOT_FOUND || e?.name === 'ɵNotFound';
}


/***/ }),

/***/ 3725:
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/util/isPromise.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isPromise: () => (/* binding */ isPromise)
/* harmony export */ });
/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction */ 4010);

function isPromise(value) {
  return (0,_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value === null || value === void 0 ? void 0 : value.then);
}

/***/ }),

/***/ 3727:
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/observable/throwError.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   throwError: () => (/* binding */ throwError)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ 1814);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/isFunction */ 4010);


function throwError(errorOrErrorFactory, scheduler) {
  const errorFactory = (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(errorOrErrorFactory) ? errorOrErrorFactory : () => errorOrErrorFactory;
  const init = subscriber => subscriber.error(errorFactory());
  return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(scheduler ? subscriber => scheduler.schedule(init, 0, subscriber) : init);
}

/***/ }),

/***/ 3800:
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/scheduled/scheduled.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   scheduled: () => (/* binding */ scheduled)
/* harmony export */ });
/* harmony import */ var _scheduleObservable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scheduleObservable */ 399);
/* harmony import */ var _schedulePromise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedulePromise */ 6709);
/* harmony import */ var _scheduleArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scheduleArray */ 6809);
/* harmony import */ var _scheduleIterable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scheduleIterable */ 8808);
/* harmony import */ var _scheduleAsyncIterable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./scheduleAsyncIterable */ 6838);
/* harmony import */ var _util_isInteropObservable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/isInteropObservable */ 2572);
/* harmony import */ var _util_isPromise__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/isPromise */ 3725);
/* harmony import */ var _util_isArrayLike__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/isArrayLike */ 5102);
/* harmony import */ var _util_isIterable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/isIterable */ 3008);
/* harmony import */ var _util_isAsyncIterable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util/isAsyncIterable */ 7742);
/* harmony import */ var _util_throwUnobservableError__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../util/throwUnobservableError */ 9582);
/* harmony import */ var _util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../util/isReadableStreamLike */ 9905);
/* harmony import */ var _scheduleReadableStreamLike__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./scheduleReadableStreamLike */ 3465);













function scheduled(input, scheduler) {
  if (input != null) {
    if ((0,_util_isInteropObservable__WEBPACK_IMPORTED_MODULE_5__.isInteropObservable)(input)) {
      return (0,_scheduleObservable__WEBPACK_IMPORTED_MODULE_0__.scheduleObservable)(input, scheduler);
    }
    if ((0,_util_isArrayLike__WEBPACK_IMPORTED_MODULE_7__.isArrayLike)(input)) {
      return (0,_scheduleArray__WEBPACK_IMPORTED_MODULE_2__.scheduleArray)(input, scheduler);
    }
    if ((0,_util_isPromise__WEBPACK_IMPORTED_MODULE_6__.isPromise)(input)) {
      return (0,_schedulePromise__WEBPACK_IMPORTED_MODULE_1__.schedulePromise)(input, scheduler);
    }
    if ((0,_util_isAsyncIterable__WEBPACK_IMPORTED_MODULE_9__.isAsyncIterable)(input)) {
      return (0,_scheduleAsyncIterable__WEBPACK_IMPORTED_MODULE_4__.scheduleAsyncIterable)(input, scheduler);
    }
    if ((0,_util_isIterable__WEBPACK_IMPORTED_MODULE_8__.isIterable)(input)) {
      return (0,_scheduleIterable__WEBPACK_IMPORTED_MODULE_3__.scheduleIterable)(input, scheduler);
    }
    if ((0,_util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_11__.isReadableStreamLike)(input)) {
      return (0,_scheduleReadableStreamLike__WEBPACK_IMPORTED_MODULE_12__.scheduleReadableStreamLike)(input, scheduler);
    }
  }
  throw (0,_util_throwUnobservableError__WEBPACK_IMPORTED_MODULE_10__.createInvalidObservableTypeError)(input);
}

/***/ }),

/***/ 3863:
/*!************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@angular+core@21.0.5_@angular+compiler@21.0.5_rxjs@7.8.2_zone.js@0.16.0/node_modules/@angular/core/fesm2022/_resource-chunk.mjs ***!
  \************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OutputEmitterRef: () => (/* binding */ OutputEmitterRef),
/* harmony export */   ResourceImpl: () => (/* binding */ ResourceImpl),
/* harmony export */   computed: () => (/* binding */ computed),
/* harmony export */   encapsulateResourceError: () => (/* binding */ encapsulateResourceError),
/* harmony export */   getOutputDestroyRef: () => (/* binding */ getOutputDestroyRef),
/* harmony export */   linkedSignal: () => (/* binding */ linkedSignal),
/* harmony export */   resource: () => (/* binding */ resource)
/* harmony export */ });
/* harmony import */ var C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 3194);
/* harmony import */ var _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_untracked-chunk.mjs */ 64);
/* harmony import */ var _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_effect-chunk.mjs */ 476);
/* harmony import */ var _linked_signal_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_linked_signal-chunk.mjs */ 1923);

/**
 * @license Angular v21.0.5
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */




class OutputEmitterRef {
  destroyed = false;
  listeners = null;
  errorHandler = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ErrorHandler, {
    optional: true
  });
  destroyRef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DestroyRef);
  constructor() {
    this.destroyRef.onDestroy(() => {
      this.destroyed = true;
      this.listeners = null;
    });
  }
  subscribe(callback) {
    if (this.destroyed) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(953, ngDevMode && 'Unexpected subscription to destroyed `OutputRef`. ' + 'The owning directive/component is destroyed.');
    }
    (this.listeners ??= []).push(callback);
    return {
      unsubscribe: () => {
        const idx = this.listeners?.indexOf(callback);
        if (idx !== undefined && idx !== -1) {
          this.listeners?.splice(idx, 1);
        }
      }
    };
  }
  emit(value) {
    if (this.destroyed) {
      console.warn((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(953, ngDevMode && 'Unexpected emit for destroyed `OutputRef`. ' + 'The owning directive/component is destroyed.'));
      return;
    }
    if (this.listeners === null) {
      return;
    }
    const previousConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
    try {
      for (const listenerFn of this.listeners) {
        try {
          listenerFn(value);
        } catch (err) {
          this.errorHandler?.handleError(err);
        }
      }
    } finally {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(previousConsumer);
    }
  }
}
function getOutputDestroyRef(ref) {
  return ref.destroyRef;
}
function computed(computation, options) {
  const getter = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.createComputed)(computation, options?.equal);
  if (ngDevMode) {
    getter.toString = () => `[Computed: ${getter()}]`;
    getter[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SIGNAL].debugName = options?.debugName;
  }
  return getter;
}
const identityFn = v => v;
function linkedSignal(optionsOrComputation, options) {
  if (typeof optionsOrComputation === 'function') {
    const getter = (0,_linked_signal_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.createLinkedSignal)(optionsOrComputation, identityFn, options?.equal);
    return upgradeLinkedSignalGetter(getter, options?.debugName);
  } else {
    const getter = (0,_linked_signal_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.createLinkedSignal)(optionsOrComputation.source, optionsOrComputation.computation, optionsOrComputation.equal);
    return upgradeLinkedSignalGetter(getter, optionsOrComputation.debugName);
  }
}
function upgradeLinkedSignalGetter(getter, debugName) {
  if (ngDevMode) {
    getter.toString = () => `[LinkedSignal: ${getter()}]`;
    getter[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SIGNAL].debugName = debugName;
  }
  const node = getter[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SIGNAL];
  const upgradedGetter = getter;
  upgradedGetter.set = newValue => (0,_linked_signal_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.linkedSignalSetFn)(node, newValue);
  upgradedGetter.update = updateFn => (0,_linked_signal_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.linkedSignalUpdateFn)(node, updateFn);
  upgradedGetter.asReadonly = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.signalAsReadonlyFn.bind(getter);
  return upgradedGetter;
}
function resource(options) {
  if (ngDevMode && !options?.injector) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertInInjectionContext)(resource);
  }
  const oldNameForParams = options.request;
  const params = options.params ?? oldNameForParams ?? (() => null);
  return new ResourceImpl(params, getLoader(options), options.defaultValue, options.equal ? wrapEqualityFn(options.equal) : undefined, options.debugName, options.injector ?? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.Injector));
}
class BaseWritableResource {
  value;
  isLoading;
  constructor(value, debugName) {
    this.value = value;
    this.value.set = this.set.bind(this);
    this.value.update = this.update.bind(this);
    this.value.asReadonly = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.signalAsReadonlyFn;
    this.isLoading = computed(() => this.status() === 'loading' || this.status() === 'reloading', ngDevMode ? createDebugNameObject(debugName, 'isLoading') : undefined);
  }
  isError = computed(() => this.status() === 'error');
  update(updateFn) {
    this.set(updateFn((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(this.value)));
  }
  isValueDefined = computed(() => {
    if (this.isError()) {
      return false;
    }
    return this.value() !== undefined;
  });
  hasValue() {
    return this.isValueDefined();
  }
  asReadonly() {
    return this;
  }
}
class ResourceImpl extends BaseWritableResource {
  loaderFn;
  equal;
  debugName;
  pendingTasks;
  state;
  extRequest;
  effectRef;
  pendingController;
  resolvePendingTask = undefined;
  destroyed = false;
  unregisterOnDestroy;
  status;
  error;
  constructor(request, loaderFn, defaultValue, equal, debugName, injector) {
    super(computed(() => {
      const streamValue = this.state().stream?.();
      if (!streamValue) {
        return defaultValue;
      }
      if (this.state().status === 'loading' && this.error()) {
        return defaultValue;
      }
      if (!isResolved(streamValue)) {
        throw new ResourceValueError(this.error());
      }
      return streamValue.value;
    }, {
      equal,
      ...(ngDevMode ? createDebugNameObject(debugName, 'value') : undefined)
    }), debugName);
    this.loaderFn = loaderFn;
    this.equal = equal;
    this.debugName = debugName;
    this.extRequest = linkedSignal({
      source: request,
      computation: request => ({
        request,
        reload: 0
      }),
      ...(ngDevMode ? createDebugNameObject(debugName, 'extRequest') : undefined)
    });
    this.state = linkedSignal({
      source: this.extRequest,
      computation: (extRequest, previous) => {
        const status = extRequest.request === undefined ? 'idle' : 'loading';
        if (!previous) {
          return {
            extRequest,
            status,
            previousStatus: 'idle',
            stream: undefined
          };
        } else {
          return {
            extRequest,
            status,
            previousStatus: projectStatusOfState(previous.value),
            stream: previous.value.extRequest.request === extRequest.request ? previous.value.stream : undefined
          };
        }
      },
      ...(ngDevMode ? createDebugNameObject(debugName, 'state') : undefined)
    });
    this.effectRef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.effect)(this.loadEffect.bind(this), {
      injector,
      manualCleanup: true,
      ...(ngDevMode ? createDebugNameObject(debugName, 'loadEffect') : undefined)
    });
    this.pendingTasks = injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PendingTasks);
    this.unregisterOnDestroy = injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DestroyRef).onDestroy(() => this.destroy());
    this.status = computed(() => projectStatusOfState(this.state()), ngDevMode ? createDebugNameObject(debugName, 'status') : undefined);
    this.error = computed(() => {
      const stream = this.state().stream?.();
      return stream && !isResolved(stream) ? stream.error : undefined;
    }, ngDevMode ? createDebugNameObject(debugName, 'error') : undefined);
  }
  set(value) {
    if (this.destroyed) {
      return;
    }
    const error = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(this.error);
    const state = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(this.state);
    if (!error) {
      const current = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(this.value);
      if (state.status === 'local' && (this.equal ? this.equal(current, value) : current === value)) {
        return;
      }
    }
    this.state.set({
      extRequest: state.extRequest,
      status: 'local',
      previousStatus: 'local',
      stream: (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.signal)({
        value
      }, ngDevMode ? createDebugNameObject(this.debugName, 'stream') : undefined)
    });
    this.abortInProgressLoad();
  }
  reload() {
    const {
      status
    } = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(this.state);
    if (status === 'idle' || status === 'loading') {
      return false;
    }
    this.extRequest.update(({
      request,
      reload
    }) => ({
      request,
      reload: reload + 1
    }));
    return true;
  }
  destroy() {
    this.destroyed = true;
    this.unregisterOnDestroy();
    this.effectRef.destroy();
    this.abortInProgressLoad();
    this.state.set({
      extRequest: {
        request: undefined,
        reload: 0
      },
      status: 'idle',
      previousStatus: 'idle',
      stream: undefined
    });
  }
  loadEffect() {
    var _this = this;
    return (0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const extRequest = _this.extRequest();
      const {
        status: currentStatus,
        previousStatus
      } = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(_this.state);
      if (extRequest.request === undefined) {
        return;
      } else if (currentStatus !== 'loading') {
        return;
      }
      _this.abortInProgressLoad();
      let resolvePendingTask = _this.resolvePendingTask = _this.pendingTasks.add();
      const {
        signal: abortSignal
      } = _this.pendingController = new AbortController();
      try {
        const stream = yield (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(() => {
          return _this.loaderFn({
            params: extRequest.request,
            request: extRequest.request,
            abortSignal,
            previous: {
              status: previousStatus
            }
          });
        });
        if (abortSignal.aborted || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(_this.extRequest) !== extRequest) {
          return;
        }
        _this.state.set({
          extRequest,
          status: 'resolved',
          previousStatus: 'resolved',
          stream
        });
      } catch (err) {
        if (abortSignal.aborted || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(_this.extRequest) !== extRequest) {
          return;
        }
        _this.state.set({
          extRequest,
          status: 'resolved',
          previousStatus: 'error',
          stream: (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.signal)({
            error: encapsulateResourceError(err)
          }, ngDevMode ? createDebugNameObject(_this.debugName, 'stream') : undefined)
        });
      } finally {
        resolvePendingTask?.();
        resolvePendingTask = undefined;
      }
    })();
  }
  abortInProgressLoad() {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(() => this.pendingController?.abort());
    this.pendingController = undefined;
    this.resolvePendingTask?.();
    this.resolvePendingTask = undefined;
  }
}
function wrapEqualityFn(equal) {
  return (a, b) => a === undefined || b === undefined ? a === b : equal(a, b);
}
function getLoader(options) {
  if (isStreamingResourceOptions(options)) {
    return options.stream;
  }
  return /*#__PURE__*/function () {
    var _ref = (0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (params) {
      try {
        return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.signal)({
          value: yield options.loader(params)
        }, ngDevMode ? createDebugNameObject(options.debugName, 'stream') : undefined);
      } catch (err) {
        return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.signal)({
          error: encapsulateResourceError(err)
        }, ngDevMode ? createDebugNameObject(options.debugName, 'stream') : undefined);
      }
    });
    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();
}
function isStreamingResourceOptions(options) {
  return !!options.stream;
}
function projectStatusOfState(state) {
  switch (state.status) {
    case 'loading':
      return state.extRequest.reload === 0 ? 'loading' : 'reloading';
    case 'resolved':
      return isResolved(state.stream()) ? 'resolved' : 'error';
    default:
      return state.status;
  }
}
function isResolved(state) {
  return state.error === undefined;
}
function createDebugNameObject(resourceDebugName, internalSignalDebugName) {
  return {
    debugName: `Resource${resourceDebugName ? '#' + resourceDebugName : ''}.${internalSignalDebugName}`
  };
}
function encapsulateResourceError(error) {
  if (isErrorLike(error)) {
    return error;
  }
  return new ResourceWrappedError(error);
}
function isErrorLike(error) {
  return error instanceof Error || typeof error === 'object' && typeof error.name === 'string' && typeof error.message === 'string';
}
class ResourceValueError extends Error {
  constructor(error) {
    super(ngDevMode ? `Resource is currently in an error state (see Error.cause for details): ${error.message}` : error.message, {
      cause: error
    });
  }
}
class ResourceWrappedError extends Error {
  constructor(error) {
    super(ngDevMode ? `Resource returned an error that's not an Error instance: ${String(error)}. Check this error's .cause for the actual error.` : String(error), {
      cause: error
    });
  }
}


/***/ }),

/***/ 3875:
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/util/mapOneOrManyArgs.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mapOneOrManyArgs: () => (/* binding */ mapOneOrManyArgs)
/* harmony export */ });
/* harmony import */ var _operators_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../operators/map */ 4063);

const {
  isArray
} = Array;
function callOrApply(fn, args) {
  return isArray(args) ? fn(...args) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return (0,_operators_map__WEBPACK_IMPORTED_MODULE_0__.map)(args => callOrApply(fn, args));
}

/***/ }),

/***/ 3943:
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/operators/OperatorSubscriber.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OperatorSubscriber: () => (/* binding */ OperatorSubscriber),
/* harmony export */   createOperatorSubscriber: () => (/* binding */ createOperatorSubscriber)
/* harmony export */ });
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Subscriber */ 7157);

function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
class OperatorSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__.Subscriber {
  constructor(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    super(destination);
    this.onFinalize = onFinalize;
    this.shouldUnsubscribe = shouldUnsubscribe;
    this._next = onNext ? function (value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : super._next;
    this._error = onError ? function (err) {
      try {
        onError(err);
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : super._error;
    this._complete = onComplete ? function () {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : super._complete;
  }
  unsubscribe() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      const {
        closed
      } = this;
      super.unsubscribe();
      !closed && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  }
}

/***/ }),

/***/ 4010:
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/util/isFunction.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isFunction: () => (/* binding */ isFunction)
/* harmony export */ });
function isFunction(value) {
  return typeof value === 'function';
}

/***/ }),

/***/ 4063:
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/operators/map.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ 8419);
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OperatorSubscriber */ 3943);


function map(project, thisArg) {
  return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)((source, subscriber) => {
    let index = 0;
    source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, value => {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}

/***/ }),

/***/ 4191:
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/operators/filter.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   filter: () => (/* binding */ filter)
/* harmony export */ });
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ 8419);
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OperatorSubscriber */ 3943);


function filter(predicate, thisArg) {
  return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)((source, subscriber) => {
    let index = 0;
    source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, value => predicate.call(thisArg, value, index++) && subscriber.next(value)));
  });
}

/***/ }),

/***/ 4480:
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/util/argsArgArrayOrObject.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   argsArgArrayOrObject: () => (/* binding */ argsArgArrayOrObject)
/* harmony export */ });
const {
  isArray
} = Array;
const {
  getPrototypeOf,
  prototype: objectProto,
  keys: getKeys
} = Object;
function argsArgArrayOrObject(args) {
  if (args.length === 1) {
    const first = args[0];
    if (isArray(first)) {
      return {
        args: first,
        keys: null
      };
    }
    if (isPOJO(first)) {
      const keys = getKeys(first);
      return {
        args: keys.map(key => first[key]),
        keys
      };
    }
  }
  return {
    args: args,
    keys: null
  };
}
function isPOJO(obj) {
  return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;
}

/***/ }),

/***/ 4502:
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/operators/catchError.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   catchError: () => (/* binding */ catchError)
/* harmony export */ });
/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observable/innerFrom */ 5829);
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OperatorSubscriber */ 3943);
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/lift */ 8419);



function catchError(selector) {
  return (0,_util_lift__WEBPACK_IMPORTED_MODULE_2__.operate)((source, subscriber) => {
    let innerSub = null;
    let syncUnsub = false;
    let handledResult;
    innerSub = source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, undefined, undefined, err => {
      handledResult = (0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_0__.innerFrom)(selector(err, catchError(selector)(source)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}

/***/ }),

/***/ 4563:
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/operators/finalize.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   finalize: () => (/* binding */ finalize)
/* harmony export */ });
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ 8419);

function finalize(callback) {
  return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)((source, subscriber) => {
    try {
      source.subscribe(subscriber);
    } finally {
      subscriber.add(callback);
    }
  });
}

/***/ }),

/***/ 4621:
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/util/createObject.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createObject: () => (/* binding */ createObject)
/* harmony export */ });
function createObject(keys, values) {
  return keys.reduce((result, key, i) => (result[key] = values[i], result), {});
}

/***/ }),

/***/ 4720:
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/operators/scan.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   scan: () => (/* binding */ scan)
/* harmony export */ });
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ 8419);
/* harmony import */ var _scanInternals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scanInternals */ 9856);


function scan(accumulator, seed) {
  return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)((0,_scanInternals__WEBPACK_IMPORTED_MODULE_1__.scanInternals)(accumulator, seed, arguments.length >= 2, true));
}

/***/ }),

/***/ 4765:
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/operators/last.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   last: () => (/* binding */ last)
/* harmony export */ });
/* harmony import */ var _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/EmptyError */ 5815);
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./filter */ 4191);
/* harmony import */ var _takeLast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./takeLast */ 9338);
/* harmony import */ var _throwIfEmpty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./throwIfEmpty */ 197);
/* harmony import */ var _defaultIfEmpty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./defaultIfEmpty */ 1834);
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/identity */ 5232);






function last(predicate, defaultValue) {
  const hasDefaultValue = arguments.length >= 2;
  return source => source.pipe(predicate ? (0,_filter__WEBPACK_IMPORTED_MODULE_1__.filter)((v, i) => predicate(v, i, source)) : _util_identity__WEBPACK_IMPORTED_MODULE_5__.identity, (0,_takeLast__WEBPACK_IMPORTED_MODULE_2__.takeLast)(1), hasDefaultValue ? (0,_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_4__.defaultIfEmpty)(defaultValue) : (0,_throwIfEmpty__WEBPACK_IMPORTED_MODULE_3__.throwIfEmpty)(() => new _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__.EmptyError()));
}

/***/ }),

/***/ 4897:
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/observable/forkJoin.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forkJoin: () => (/* binding */ forkJoin)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ 1814);
/* harmony import */ var _util_argsArgArrayOrObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/argsArgArrayOrObject */ 4480);
/* harmony import */ var _innerFrom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./innerFrom */ 5829);
/* harmony import */ var _util_args__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/args */ 1683);
/* harmony import */ var _operators_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../operators/OperatorSubscriber */ 3943);
/* harmony import */ var _util_mapOneOrManyArgs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/mapOneOrManyArgs */ 3875);
/* harmony import */ var _util_createObject__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/createObject */ 4621);







function forkJoin(...args) {
  const resultSelector = (0,_util_args__WEBPACK_IMPORTED_MODULE_3__.popResultSelector)(args);
  const {
    args: sources,
    keys
  } = (0,_util_argsArgArrayOrObject__WEBPACK_IMPORTED_MODULE_1__.argsArgArrayOrObject)(args);
  const result = new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(subscriber => {
    const {
      length
    } = sources;
    if (!length) {
      subscriber.complete();
      return;
    }
    const values = new Array(length);
    let remainingCompletions = length;
    let remainingEmissions = length;
    for (let sourceIndex = 0; sourceIndex < length; sourceIndex++) {
      let hasValue = false;
      (0,_innerFrom__WEBPACK_IMPORTED_MODULE_2__.innerFrom)(sources[sourceIndex]).subscribe((0,_operators_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_4__.createOperatorSubscriber)(subscriber, value => {
        if (!hasValue) {
          hasValue = true;
          remainingEmissions--;
        }
        values[sourceIndex] = value;
      }, () => remainingCompletions--, undefined, () => {
        if (!remainingCompletions || !hasValue) {
          if (!remainingEmissions) {
            subscriber.next(keys ? (0,_util_createObject__WEBPACK_IMPORTED_MODULE_6__.createObject)(keys, values) : values);
          }
          subscriber.complete();
        }
      }));
    }
  });
  return resultSelector ? result.pipe((0,_util_mapOneOrManyArgs__WEBPACK_IMPORTED_MODULE_5__.mapOneOrManyArgs)(resultSelector)) : result;
}

/***/ }),

/***/ 4927:
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/operators/concatMap.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   concatMap: () => (/* binding */ concatMap)
/* harmony export */ });
/* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mergeMap */ 1991);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/isFunction */ 4010);


function concatMap(project, resultSelector) {
  return (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(resultSelector) ? (0,_mergeMap__WEBPACK_IMPORTED_MODULE_0__.mergeMap)(project, resultSelector, 1) : (0,_mergeMap__WEBPACK_IMPORTED_MODULE_0__.mergeMap)(project, 1);
}

/***/ }),

/***/ 4956:
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/symbol/iterator.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSymbolIterator: () => (/* binding */ getSymbolIterator),
/* harmony export */   iterator: () => (/* binding */ iterator)
/* harmony export */ });
function getSymbolIterator() {
  if (typeof Symbol !== 'function' || !Symbol.iterator) {
    return '@@iterator';
  }
  return Symbol.iterator;
}
const iterator = getSymbolIterator();

/***/ }),

/***/ 5102:
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/util/isArrayLike.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isArrayLike: () => (/* binding */ isArrayLike)
/* harmony export */ });
const isArrayLike = x => x && typeof x.length === 'number' && typeof x !== 'function';

/***/ }),

/***/ 5232:
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/util/identity.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   identity: () => (/* binding */ identity)
/* harmony export */ });
function identity(x) {
  return x;
}

/***/ }),

/***/ 5669:
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/util/isScheduler.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isScheduler: () => (/* binding */ isScheduler)
/* harmony export */ });
/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction */ 4010);

function isScheduler(value) {
  return value && (0,_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value.schedule);
}

/***/ }),

/***/ 5672:
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/observable/empty.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EMPTY: () => (/* binding */ EMPTY),
/* harmony export */   empty: () => (/* binding */ empty)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ 1814);

const EMPTY = new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(subscriber => subscriber.complete());
function empty(scheduler) {
  return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
  return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(subscriber => scheduler.schedule(() => subscriber.complete()));
}

/***/ }),

/***/ 5711:
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/observable/never.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NEVER: () => (/* binding */ NEVER),
/* harmony export */   never: () => (/* binding */ never)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ 1814);
/* harmony import */ var _util_noop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/noop */ 1918);


const NEVER = new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(_util_noop__WEBPACK_IMPORTED_MODULE_1__.noop);
function never() {
  return NEVER;
}

/***/ }),

/***/ 5726:
/*!**************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@angular+common@21.0.5_@angular+core@21.0.5_rxjs@7.8.2/node_modules/@angular/common/fesm2022/_common_module-chunk.mjs ***!
  \**************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsyncPipe: () => (/* binding */ AsyncPipe),
/* harmony export */   CommonModule: () => (/* binding */ CommonModule),
/* harmony export */   CurrencyPipe: () => (/* binding */ CurrencyPipe),
/* harmony export */   DATE_PIPE_DEFAULT_OPTIONS: () => (/* binding */ DATE_PIPE_DEFAULT_OPTIONS),
/* harmony export */   DATE_PIPE_DEFAULT_TIMEZONE: () => (/* binding */ DATE_PIPE_DEFAULT_TIMEZONE),
/* harmony export */   DatePipe: () => (/* binding */ DatePipe),
/* harmony export */   DecimalPipe: () => (/* binding */ DecimalPipe),
/* harmony export */   FormStyle: () => (/* binding */ FormStyle),
/* harmony export */   FormatWidth: () => (/* binding */ FormatWidth),
/* harmony export */   HashLocationStrategy: () => (/* binding */ HashLocationStrategy),
/* harmony export */   I18nPluralPipe: () => (/* binding */ I18nPluralPipe),
/* harmony export */   I18nSelectPipe: () => (/* binding */ I18nSelectPipe),
/* harmony export */   JsonPipe: () => (/* binding */ JsonPipe),
/* harmony export */   KeyValuePipe: () => (/* binding */ KeyValuePipe),
/* harmony export */   LowerCasePipe: () => (/* binding */ LowerCasePipe),
/* harmony export */   NgClass: () => (/* binding */ NgClass),
/* harmony export */   NgComponentOutlet: () => (/* binding */ NgComponentOutlet),
/* harmony export */   NgForOf: () => (/* binding */ NgForOf),
/* harmony export */   NgForOfContext: () => (/* binding */ NgForOfContext),
/* harmony export */   NgIf: () => (/* binding */ NgIf),
/* harmony export */   NgIfContext: () => (/* binding */ NgIfContext),
/* harmony export */   NgLocaleLocalization: () => (/* binding */ NgLocaleLocalization),
/* harmony export */   NgLocalization: () => (/* binding */ NgLocalization),
/* harmony export */   NgPlural: () => (/* binding */ NgPlural),
/* harmony export */   NgPluralCase: () => (/* binding */ NgPluralCase),
/* harmony export */   NgStyle: () => (/* binding */ NgStyle),
/* harmony export */   NgSwitch: () => (/* binding */ NgSwitch),
/* harmony export */   NgSwitchCase: () => (/* binding */ NgSwitchCase),
/* harmony export */   NgSwitchDefault: () => (/* binding */ NgSwitchDefault),
/* harmony export */   NgTemplateOutlet: () => (/* binding */ NgTemplateOutlet),
/* harmony export */   NumberFormatStyle: () => (/* binding */ NumberFormatStyle),
/* harmony export */   NumberSymbol: () => (/* binding */ NumberSymbol),
/* harmony export */   PercentPipe: () => (/* binding */ PercentPipe),
/* harmony export */   Plural: () => (/* binding */ Plural),
/* harmony export */   SlicePipe: () => (/* binding */ SlicePipe),
/* harmony export */   TitleCasePipe: () => (/* binding */ TitleCasePipe),
/* harmony export */   TranslationWidth: () => (/* binding */ TranslationWidth),
/* harmony export */   UpperCasePipe: () => (/* binding */ UpperCasePipe),
/* harmony export */   WeekDay: () => (/* binding */ WeekDay),
/* harmony export */   formatCurrency: () => (/* binding */ formatCurrency),
/* harmony export */   formatDate: () => (/* binding */ formatDate),
/* harmony export */   formatNumber: () => (/* binding */ formatNumber),
/* harmony export */   formatPercent: () => (/* binding */ formatPercent),
/* harmony export */   getCurrencySymbol: () => (/* binding */ getCurrencySymbol),
/* harmony export */   getLocaleCurrencyCode: () => (/* binding */ getLocaleCurrencyCode),
/* harmony export */   getLocaleCurrencyName: () => (/* binding */ getLocaleCurrencyName),
/* harmony export */   getLocaleCurrencySymbol: () => (/* binding */ getLocaleCurrencySymbol),
/* harmony export */   getLocaleDateFormat: () => (/* binding */ getLocaleDateFormat),
/* harmony export */   getLocaleDateTimeFormat: () => (/* binding */ getLocaleDateTimeFormat),
/* harmony export */   getLocaleDayNames: () => (/* binding */ getLocaleDayNames),
/* harmony export */   getLocaleDayPeriods: () => (/* binding */ getLocaleDayPeriods),
/* harmony export */   getLocaleDirection: () => (/* binding */ getLocaleDirection),
/* harmony export */   getLocaleEraNames: () => (/* binding */ getLocaleEraNames),
/* harmony export */   getLocaleExtraDayPeriodRules: () => (/* binding */ getLocaleExtraDayPeriodRules),
/* harmony export */   getLocaleExtraDayPeriods: () => (/* binding */ getLocaleExtraDayPeriods),
/* harmony export */   getLocaleFirstDayOfWeek: () => (/* binding */ getLocaleFirstDayOfWeek),
/* harmony export */   getLocaleId: () => (/* binding */ getLocaleId),
/* harmony export */   getLocaleMonthNames: () => (/* binding */ getLocaleMonthNames),
/* harmony export */   getLocaleNumberFormat: () => (/* binding */ getLocaleNumberFormat),
/* harmony export */   getLocaleNumberSymbol: () => (/* binding */ getLocaleNumberSymbol),
/* harmony export */   getLocalePluralCase: () => (/* binding */ getLocalePluralCase),
/* harmony export */   getLocaleTimeFormat: () => (/* binding */ getLocaleTimeFormat),
/* harmony export */   getLocaleWeekEndRange: () => (/* binding */ getLocaleWeekEndRange),
/* harmony export */   getNumberOfCurrencyDigits: () => (/* binding */ getNumberOfCurrencyDigits)
/* harmony export */ });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ 64);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ 7367);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ 8357);
/* harmony import */ var _location_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_location-chunk.mjs */ 933);
/* harmony import */ var _platform_location_chunk_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_platform_location-chunk.mjs */ 8021);
/**
 * @license Angular v21.0.5
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */





class HashLocationStrategy extends _location_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.LocationStrategy {
  _platformLocation;
  _baseHref = '';
  _removeListenerFns = [];
  constructor(_platformLocation, _baseHref) {
    super();
    this._platformLocation = _platformLocation;
    if (_baseHref != null) {
      this._baseHref = _baseHref;
    }
  }
  ngOnDestroy() {
    while (this._removeListenerFns.length) {
      this._removeListenerFns.pop()();
    }
  }
  onPopState(fn) {
    this._removeListenerFns.push(this._platformLocation.onPopState(fn), this._platformLocation.onHashChange(fn));
  }
  getBaseHref() {
    return this._baseHref;
  }
  path(includeHash = false) {
    const path = this._platformLocation.hash ?? '#';
    return path.length > 0 ? path.substring(1) : path;
  }
  prepareExternalUrl(internal) {
    const url = (0,_location_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.joinWithSlash)(this._baseHref, internal);
    return url.length > 0 ? '#' + url : url;
  }
  pushState(state, title, path, queryParams) {
    const url = this.prepareExternalUrl(path + (0,_location_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.normalizeQueryParams)(queryParams)) || this._platformLocation.pathname;
    this._platformLocation.pushState(state, title, url);
  }
  replaceState(state, title, path, queryParams) {
    const url = this.prepareExternalUrl(path + (0,_location_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.normalizeQueryParams)(queryParams)) || this._platformLocation.pathname;
    this._platformLocation.replaceState(state, title, url);
  }
  forward() {
    this._platformLocation.forward();
  }
  back() {
    this._platformLocation.back();
  }
  getState() {
    return this._platformLocation.getState();
  }
  historyGo(relativePosition = 0) {
    this._platformLocation.historyGo?.(relativePosition);
  }
  static ɵfac = function HashLocationStrategy_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || HashLocationStrategy)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_platform_location_chunk_mjs__WEBPACK_IMPORTED_MODULE_4__.PlatformLocation), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_location_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.APP_BASE_HREF, 8));
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: HashLocationStrategy,
    factory: HashLocationStrategy.ɵfac
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(HashLocationStrategy, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable
  }], () => [{
    type: _platform_location_chunk_mjs__WEBPACK_IMPORTED_MODULE_4__.PlatformLocation
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [_location_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.APP_BASE_HREF]
    }]
  }], null);
})();
const CURRENCIES_EN = {
  "ADP": [undefined, undefined, 0],
  "AFN": [undefined, "؋", 0],
  "ALL": [undefined, undefined, 0],
  "AMD": [undefined, "֏", 2],
  "AOA": [undefined, "Kz"],
  "ARS": [undefined, "$"],
  "AUD": ["A$", "$"],
  "AZN": [undefined, "₼"],
  "BAM": [undefined, "KM"],
  "BBD": [undefined, "$"],
  "BDT": [undefined, "৳"],
  "BHD": [undefined, undefined, 3],
  "BIF": [undefined, undefined, 0],
  "BMD": [undefined, "$"],
  "BND": [undefined, "$"],
  "BOB": [undefined, "Bs"],
  "BRL": ["R$"],
  "BSD": [undefined, "$"],
  "BWP": [undefined, "P"],
  "BYN": [undefined, undefined, 2],
  "BYR": [undefined, undefined, 0],
  "BZD": [undefined, "$"],
  "CAD": ["CA$", "$", 2],
  "CHF": [undefined, undefined, 2],
  "CLF": [undefined, undefined, 4],
  "CLP": [undefined, "$", 0],
  "CNY": ["CN¥", "¥"],
  "COP": [undefined, "$", 2],
  "CRC": [undefined, "₡", 2],
  "CUC": [undefined, "$"],
  "CUP": [undefined, "$"],
  "CZK": [undefined, "Kč", 2],
  "DJF": [undefined, undefined, 0],
  "DKK": [undefined, "kr", 2],
  "DOP": [undefined, "$"],
  "EGP": [undefined, "E£"],
  "ESP": [undefined, "₧", 0],
  "EUR": ["€"],
  "FJD": [undefined, "$"],
  "FKP": [undefined, "£"],
  "GBP": ["£"],
  "GEL": [undefined, "₾"],
  "GHS": [undefined, "GH₵"],
  "GIP": [undefined, "£"],
  "GNF": [undefined, "FG", 0],
  "GTQ": [undefined, "Q"],
  "GYD": [undefined, "$", 2],
  "HKD": ["HK$", "$"],
  "HNL": [undefined, "L"],
  "HRK": [undefined, "kn"],
  "HUF": [undefined, "Ft", 2],
  "IDR": [undefined, "Rp", 2],
  "ILS": ["₪"],
  "INR": ["₹"],
  "IQD": [undefined, undefined, 0],
  "IRR": [undefined, undefined, 0],
  "ISK": [undefined, "kr", 0],
  "ITL": [undefined, undefined, 0],
  "JMD": [undefined, "$"],
  "JOD": [undefined, undefined, 3],
  "JPY": ["¥", undefined, 0],
  "KGS": [undefined, "⃀"],
  "KHR": [undefined, "៛"],
  "KMF": [undefined, "CF", 0],
  "KPW": [undefined, "₩", 0],
  "KRW": ["₩", undefined, 0],
  "KWD": [undefined, undefined, 3],
  "KYD": [undefined, "$"],
  "KZT": [undefined, "₸"],
  "LAK": [undefined, "₭", 0],
  "LBP": [undefined, "L£", 0],
  "LKR": [undefined, "Rs"],
  "LRD": [undefined, "$"],
  "LTL": [undefined, "Lt"],
  "LUF": [undefined, undefined, 0],
  "LVL": [undefined, "Ls"],
  "LYD": [undefined, undefined, 3],
  "MGA": [undefined, "Ar", 0],
  "MGF": [undefined, undefined, 0],
  "MMK": [undefined, "K", 0],
  "MNT": [undefined, "₮", 2],
  "MRO": [undefined, undefined, 0],
  "MUR": [undefined, "Rs", 2],
  "MXN": ["MX$", "$"],
  "MYR": [undefined, "RM"],
  "NAD": [undefined, "$"],
  "NGN": [undefined, "₦"],
  "NIO": [undefined, "C$"],
  "NOK": [undefined, "kr", 2],
  "NPR": [undefined, "Rs"],
  "NZD": ["NZ$", "$"],
  "OMR": [undefined, undefined, 3],
  "PHP": ["₱"],
  "PKR": [undefined, "Rs", 2],
  "PLN": [undefined, "zł"],
  "PYG": [undefined, "₲", 0],
  "RON": [undefined, "lei"],
  "RSD": [undefined, undefined, 0],
  "RUB": [undefined, "₽"],
  "RWF": [undefined, "RF", 0],
  "SBD": [undefined, "$"],
  "SEK": [undefined, "kr", 2],
  "SGD": [undefined, "$"],
  "SHP": [undefined, "£"],
  "SLE": [undefined, undefined, 2],
  "SLL": [undefined, undefined, 0],
  "SOS": [undefined, undefined, 0],
  "SRD": [undefined, "$"],
  "SSP": [undefined, "£"],
  "STD": [undefined, undefined, 0],
  "STN": [undefined, "Db"],
  "SYP": [undefined, "£", 0],
  "THB": [undefined, "฿"],
  "TMM": [undefined, undefined, 0],
  "TND": [undefined, undefined, 3],
  "TOP": [undefined, "T$"],
  "TRL": [undefined, undefined, 0],
  "TRY": [undefined, "₺"],
  "TTD": [undefined, "$"],
  "TWD": ["NT$", "$", 2],
  "TZS": [undefined, undefined, 2],
  "UAH": [undefined, "₴"],
  "UGX": [undefined, undefined, 0],
  "USD": ["$"],
  "UYI": [undefined, undefined, 0],
  "UYU": [undefined, "$"],
  "UYW": [undefined, undefined, 4],
  "UZS": [undefined, undefined, 2],
  "VEF": [undefined, "Bs", 2],
  "VND": ["₫", undefined, 0],
  "VUV": [undefined, undefined, 0],
  "XAF": ["FCFA", undefined, 0],
  "XCD": ["EC$", "$"],
  "XCG": ["Cg."],
  "XOF": ["F CFA", undefined, 0],
  "XPF": ["CFPF", undefined, 0],
  "XXX": ["¤"],
  "YER": [undefined, undefined, 0],
  "ZAR": [undefined, "R"],
  "ZMK": [undefined, undefined, 0],
  "ZMW": [undefined, "ZK"],
  "ZWD": [undefined, undefined, 0]
};
var NumberFormatStyle;
(function (NumberFormatStyle) {
  NumberFormatStyle[NumberFormatStyle["Decimal"] = 0] = "Decimal";
  NumberFormatStyle[NumberFormatStyle["Percent"] = 1] = "Percent";
  NumberFormatStyle[NumberFormatStyle["Currency"] = 2] = "Currency";
  NumberFormatStyle[NumberFormatStyle["Scientific"] = 3] = "Scientific";
})(NumberFormatStyle || (NumberFormatStyle = {}));
var Plural;
(function (Plural) {
  Plural[Plural["Zero"] = 0] = "Zero";
  Plural[Plural["One"] = 1] = "One";
  Plural[Plural["Two"] = 2] = "Two";
  Plural[Plural["Few"] = 3] = "Few";
  Plural[Plural["Many"] = 4] = "Many";
  Plural[Plural["Other"] = 5] = "Other";
})(Plural || (Plural = {}));
var FormStyle;
(function (FormStyle) {
  FormStyle[FormStyle["Format"] = 0] = "Format";
  FormStyle[FormStyle["Standalone"] = 1] = "Standalone";
})(FormStyle || (FormStyle = {}));
var TranslationWidth;
(function (TranslationWidth) {
  TranslationWidth[TranslationWidth["Narrow"] = 0] = "Narrow";
  TranslationWidth[TranslationWidth["Abbreviated"] = 1] = "Abbreviated";
  TranslationWidth[TranslationWidth["Wide"] = 2] = "Wide";
  TranslationWidth[TranslationWidth["Short"] = 3] = "Short";
})(TranslationWidth || (TranslationWidth = {}));
var FormatWidth;
(function (FormatWidth) {
  FormatWidth[FormatWidth["Short"] = 0] = "Short";
  FormatWidth[FormatWidth["Medium"] = 1] = "Medium";
  FormatWidth[FormatWidth["Long"] = 2] = "Long";
  FormatWidth[FormatWidth["Full"] = 3] = "Full";
})(FormatWidth || (FormatWidth = {}));
const NumberSymbol = {
  Decimal: 0,
  Group: 1,
  List: 2,
  PercentSign: 3,
  PlusSign: 4,
  MinusSign: 5,
  Exponential: 6,
  SuperscriptingExponent: 7,
  PerMille: 8,
  Infinity: 9,
  NaN: 10,
  TimeSeparator: 11,
  CurrencyDecimal: 12,
  CurrencyGroup: 13
};
var WeekDay;
(function (WeekDay) {
  WeekDay[WeekDay["Sunday"] = 0] = "Sunday";
  WeekDay[WeekDay["Monday"] = 1] = "Monday";
  WeekDay[WeekDay["Tuesday"] = 2] = "Tuesday";
  WeekDay[WeekDay["Wednesday"] = 3] = "Wednesday";
  WeekDay[WeekDay["Thursday"] = 4] = "Thursday";
  WeekDay[WeekDay["Friday"] = 5] = "Friday";
  WeekDay[WeekDay["Saturday"] = 6] = "Saturday";
})(WeekDay || (WeekDay = {}));
function getLocaleId(locale) {
  return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.findLocaleData)(locale)[_angular_core__WEBPACK_IMPORTED_MODULE_1__.LocaleDataIndex.LocaleId];
}
function getLocaleDayPeriods(locale, formStyle, width) {
  const data = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.findLocaleData)(locale);
  const amPmData = [data[_angular_core__WEBPACK_IMPORTED_MODULE_1__.LocaleDataIndex.DayPeriodsFormat], data[_angular_core__WEBPACK_IMPORTED_MODULE_1__.LocaleDataIndex.DayPeriodsStandalone]];
  const amPm = getLastDefinedValue(amPmData, formStyle);
  return getLastDefinedValue(amPm, width);
}
function getLocaleDayNames(locale, formStyle, width) {
  const data = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.findLocaleData)(locale);
  const daysData = [data[_angular_core__WEBPACK_IMPORTED_MODULE_1__.LocaleDataIndex.DaysFormat], data[_angular_core__WEBPACK_IMPORTED_MODULE_1__.LocaleDataIndex.DaysStandalone]];
  const days = getLastDefinedValue(daysData, formStyle);
  return getLastDefinedValue(days, width);
}
function getLocaleMonthNames(locale, formStyle, width) {
  const data = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.findLocaleData)(locale);
  const monthsData = [data[_angular_core__WEBPACK_IMPORTED_MODULE_1__.LocaleDataIndex.MonthsFormat], data[_angular_core__WEBPACK_IMPORTED_MODULE_1__.LocaleDataIndex.MonthsStandalone]];
  const months = getLastDefinedValue(monthsData, formStyle);
  return getLastDefinedValue(months, width);
}
function getLocaleEraNames(locale, width) {
  const data = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.findLocaleData)(locale);
  const erasData = data[_angular_core__WEBPACK_IMPORTED_MODULE_1__.LocaleDataIndex.Eras];
  return getLastDefinedValue(erasData, width);
}
function getLocaleFirstDayOfWeek(locale) {
  const data = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.findLocaleData)(locale);
  return data[_angular_core__WEBPACK_IMPORTED_MODULE_1__.LocaleDataIndex.FirstDayOfWeek];
}
function getLocaleWeekEndRange(locale) {
  const data = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.findLocaleData)(locale);
  return data[_angular_core__WEBPACK_IMPORTED_MODULE_1__.LocaleDataIndex.WeekendRange];
}
function getLocaleDateFormat(locale, width) {
  const data = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.findLocaleData)(locale);
  return getLastDefinedValue(data[_angular_core__WEBPACK_IMPORTED_MODULE_1__.LocaleDataIndex.DateFormat], width);
}
function getLocaleTimeFormat(locale, width) {
  const data = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.findLocaleData)(locale);
  return getLastDefinedValue(data[_angular_core__WEBPACK_IMPORTED_MODULE_1__.LocaleDataIndex.TimeFormat], width);
}
function getLocaleDateTimeFormat(locale, width) {
  const data = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.findLocaleData)(locale);
  const dateTimeFormatData = data[_angular_core__WEBPACK_IMPORTED_MODULE_1__.LocaleDataIndex.DateTimeFormat];
  return getLastDefinedValue(dateTimeFormatData, width);
}
function getLocaleNumberSymbol(locale, symbol) {
  const data = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.findLocaleData)(locale);
  const res = data[_angular_core__WEBPACK_IMPORTED_MODULE_1__.LocaleDataIndex.NumberSymbols][symbol];
  if (typeof res === 'undefined') {
    if (symbol === NumberSymbol.CurrencyDecimal) {
      return data[_angular_core__WEBPACK_IMPORTED_MODULE_1__.LocaleDataIndex.NumberSymbols][NumberSymbol.Decimal];
    } else if (symbol === NumberSymbol.CurrencyGroup) {
      return data[_angular_core__WEBPACK_IMPORTED_MODULE_1__.LocaleDataIndex.NumberSymbols][NumberSymbol.Group];
    }
  }
  return res;
}
function getLocaleNumberFormat(locale, type) {
  const data = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.findLocaleData)(locale);
  return data[_angular_core__WEBPACK_IMPORTED_MODULE_1__.LocaleDataIndex.NumberFormats][type];
}
function getLocaleCurrencySymbol(locale) {
  const data = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.findLocaleData)(locale);
  return data[_angular_core__WEBPACK_IMPORTED_MODULE_1__.LocaleDataIndex.CurrencySymbol] || null;
}
function getLocaleCurrencyName(locale) {
  const data = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.findLocaleData)(locale);
  return data[_angular_core__WEBPACK_IMPORTED_MODULE_1__.LocaleDataIndex.CurrencyName] || null;
}
function getLocaleCurrencyCode(locale) {
  return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.getLocaleCurrencyCode)(locale);
}
function getLocaleCurrencies(locale) {
  const data = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.findLocaleData)(locale);
  return data[_angular_core__WEBPACK_IMPORTED_MODULE_1__.LocaleDataIndex.Currencies];
}
const getLocalePluralCase = _angular_core__WEBPACK_IMPORTED_MODULE_1__.getLocalePluralCase;
function checkFullData(data) {
  if (!data[_angular_core__WEBPACK_IMPORTED_MODULE_1__.LocaleDataIndex.ExtraData]) {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(2303, ngDevMode && `Missing extra locale data for the locale "${data[_angular_core__WEBPACK_IMPORTED_MODULE_1__.LocaleDataIndex.LocaleId]}". Use "registerLocaleData" to load new data. See the "I18n guide" on angular.io to know more.`);
  }
}
function getLocaleExtraDayPeriodRules(locale) {
  const data = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.findLocaleData)(locale);
  checkFullData(data);
  const rules = data[_angular_core__WEBPACK_IMPORTED_MODULE_1__.LocaleDataIndex.ExtraData][2] || [];
  return rules.map(rule => {
    if (typeof rule === 'string') {
      return extractTime(rule);
    }
    return [extractTime(rule[0]), extractTime(rule[1])];
  });
}
function getLocaleExtraDayPeriods(locale, formStyle, width) {
  const data = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.findLocaleData)(locale);
  checkFullData(data);
  const dayPeriodsData = [data[_angular_core__WEBPACK_IMPORTED_MODULE_1__.LocaleDataIndex.ExtraData][0], data[_angular_core__WEBPACK_IMPORTED_MODULE_1__.LocaleDataIndex.ExtraData][1]];
  const dayPeriods = getLastDefinedValue(dayPeriodsData, formStyle) || [];
  return getLastDefinedValue(dayPeriods, width) || [];
}
function getLocaleDirection(locale) {
  const data = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.findLocaleData)(locale);
  return data[_angular_core__WEBPACK_IMPORTED_MODULE_1__.LocaleDataIndex.Directionality];
}
function getLastDefinedValue(data, index) {
  for (let i = index; i > -1; i--) {
    if (typeof data[i] !== 'undefined') {
      return data[i];
    }
  }
  throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(2304, ngDevMode && 'Locale data API: locale data undefined');
}
function extractTime(time) {
  const [h, m] = time.split(':');
  return {
    hours: +h,
    minutes: +m
  };
}
function getCurrencySymbol(code, format, locale = 'en') {
  const currency = getLocaleCurrencies(locale)[code] || CURRENCIES_EN[code] || [];
  const symbolNarrow = currency[1];
  if (format === 'narrow' && typeof symbolNarrow === 'string') {
    return symbolNarrow;
  }
  return currency[0] || code;
}
const DEFAULT_NB_OF_CURRENCY_DIGITS = 2;
function getNumberOfCurrencyDigits(code) {
  let digits;
  const currency = CURRENCIES_EN[code];
  if (currency) {
    digits = currency[2];
  }
  return typeof digits === 'number' ? digits : DEFAULT_NB_OF_CURRENCY_DIGITS;
}
const ISO8601_DATE_REGEX = /^(\d{4,})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
const NAMED_FORMATS = {};
const DATE_FORMATS_SPLIT = /((?:[^BEGHLMOSWYZabcdhmswyz']+)|(?:'(?:[^']|'')*')|(?:G{1,5}|y{1,4}|Y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|c{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4}))([\s\S]*)/;
function formatDate(value, format, locale, timezone) {
  let date = toDate(value);
  const namedFormat = getNamedFormat(locale, format);
  format = namedFormat || format;
  let parts = [];
  let match;
  while (format) {
    match = DATE_FORMATS_SPLIT.exec(format);
    if (match) {
      parts = parts.concat(match.slice(1));
      const part = parts.pop();
      if (!part) {
        break;
      }
      format = part;
    } else {
      parts.push(format);
      break;
    }
  }
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
    assertValidDateFormat(parts);
  }
  let dateTimezoneOffset = date.getTimezoneOffset();
  if (timezone) {
    dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
    date = convertTimezoneToLocal(date, timezone);
  }
  let text = '';
  parts.forEach(value => {
    const dateFormatter = getDateFormatter(value);
    text += dateFormatter ? dateFormatter(date, locale, dateTimezoneOffset) : value === "''" ? "'" : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
  });
  return text;
}
function assertValidDateFormat(parts) {
  if (parts.some(part => /^Y+$/.test(part)) && !parts.some(part => /^w+$/.test(part))) {
    const message = `Suspicious use of week-based year "Y" in date pattern "${parts.join('')}". Did you mean to use calendar year "y" instead?`;
    if (parts.length === 1) {
      console.error((0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.formatRuntimeError)(2300, message));
    } else {
      throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(2300, message);
    }
  }
}
function createDate(year, month, date) {
  const newDate = new Date(0);
  newDate.setFullYear(year, month, date);
  newDate.setHours(0, 0, 0);
  return newDate;
}
function getNamedFormat(locale, format) {
  const localeId = getLocaleId(locale);
  NAMED_FORMATS[localeId] ??= {};
  if (NAMED_FORMATS[localeId][format]) {
    return NAMED_FORMATS[localeId][format];
  }
  let formatValue = '';
  switch (format) {
    case 'shortDate':
      formatValue = getLocaleDateFormat(locale, FormatWidth.Short);
      break;
    case 'mediumDate':
      formatValue = getLocaleDateFormat(locale, FormatWidth.Medium);
      break;
    case 'longDate':
      formatValue = getLocaleDateFormat(locale, FormatWidth.Long);
      break;
    case 'fullDate':
      formatValue = getLocaleDateFormat(locale, FormatWidth.Full);
      break;
    case 'shortTime':
      formatValue = getLocaleTimeFormat(locale, FormatWidth.Short);
      break;
    case 'mediumTime':
      formatValue = getLocaleTimeFormat(locale, FormatWidth.Medium);
      break;
    case 'longTime':
      formatValue = getLocaleTimeFormat(locale, FormatWidth.Long);
      break;
    case 'fullTime':
      formatValue = getLocaleTimeFormat(locale, FormatWidth.Full);
      break;
    case 'short':
      const shortTime = getNamedFormat(locale, 'shortTime');
      const shortDate = getNamedFormat(locale, 'shortDate');
      formatValue = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Short), [shortTime, shortDate]);
      break;
    case 'medium':
      const mediumTime = getNamedFormat(locale, 'mediumTime');
      const mediumDate = getNamedFormat(locale, 'mediumDate');
      formatValue = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Medium), [mediumTime, mediumDate]);
      break;
    case 'long':
      const longTime = getNamedFormat(locale, 'longTime');
      const longDate = getNamedFormat(locale, 'longDate');
      formatValue = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Long), [longTime, longDate]);
      break;
    case 'full':
      const fullTime = getNamedFormat(locale, 'fullTime');
      const fullDate = getNamedFormat(locale, 'fullDate');
      formatValue = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Full), [fullTime, fullDate]);
      break;
  }
  if (formatValue) {
    NAMED_FORMATS[localeId][format] = formatValue;
  }
  return formatValue;
}
function formatDateTime(str, opt_values) {
  if (opt_values) {
    str = str.replace(/\{([^}]+)}/g, function (match, key) {
      return opt_values != null && key in opt_values ? opt_values[key] : match;
    });
  }
  return str;
}
function padNumber(num, digits, minusSign = '-', trim, negWrap) {
  let neg = '';
  if (num < 0 || negWrap && num <= 0) {
    if (negWrap) {
      num = -num + 1;
    } else {
      num = -num;
      neg = minusSign;
    }
  }
  let strNum = String(num);
  while (strNum.length < digits) {
    strNum = '0' + strNum;
  }
  if (trim) {
    strNum = strNum.slice(strNum.length - digits);
  }
  return neg + strNum;
}
function formatFractionalSeconds(milliseconds, digits) {
  const strMs = padNumber(milliseconds, 3);
  return strMs.substring(0, digits);
}
function dateGetter(name, size, offset = 0, trim = false, negWrap = false) {
  return function (date, locale) {
    let part = getDatePart(name, date);
    if (offset > 0 || part > -offset) {
      part += offset;
    }
    if (name === 3) {
      if (part === 0 && offset === -12) {
        part = 12;
      }
    } else if (name === 6) {
      return formatFractionalSeconds(part, size);
    }
    const localeMinus = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);
    return padNumber(part, size, localeMinus, trim, negWrap);
  };
}
function getDatePart(part, date) {
  switch (part) {
    case 0:
      return date.getFullYear();
    case 1:
      return date.getMonth();
    case 2:
      return date.getDate();
    case 3:
      return date.getHours();
    case 4:
      return date.getMinutes();
    case 5:
      return date.getSeconds();
    case 6:
      return date.getMilliseconds();
    case 7:
      return date.getDay();
    default:
      throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(2301, ngDevMode && `Unknown DateType value "${part}".`);
  }
}
function dateStrGetter(name, width, form = FormStyle.Format, extended = false) {
  return function (date, locale) {
    return getDateTranslation(date, locale, name, width, form, extended);
  };
}
function getDateTranslation(date, locale, name, width, form, extended) {
  switch (name) {
    case 2:
      return getLocaleMonthNames(locale, form, width)[date.getMonth()];
    case 1:
      return getLocaleDayNames(locale, form, width)[date.getDay()];
    case 0:
      const currentHours = date.getHours();
      const currentMinutes = date.getMinutes();
      if (extended) {
        const rules = getLocaleExtraDayPeriodRules(locale);
        const dayPeriods = getLocaleExtraDayPeriods(locale, form, width);
        const index = rules.findIndex(rule => {
          if (Array.isArray(rule)) {
            const [from, to] = rule;
            const afterFrom = currentHours >= from.hours && currentMinutes >= from.minutes;
            const beforeTo = currentHours < to.hours || currentHours === to.hours && currentMinutes < to.minutes;
            if (from.hours < to.hours) {
              if (afterFrom && beforeTo) {
                return true;
              }
            } else if (afterFrom || beforeTo) {
              return true;
            }
          } else {
            if (rule.hours === currentHours && rule.minutes === currentMinutes) {
              return true;
            }
          }
          return false;
        });
        if (index !== -1) {
          return dayPeriods[index];
        }
      }
      return getLocaleDayPeriods(locale, form, width)[currentHours < 12 ? 0 : 1];
    case 3:
      return getLocaleEraNames(locale, width)[date.getFullYear() <= 0 ? 0 : 1];
    default:
      const unexpected = name;
      throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(2302, ngDevMode && `unexpected translation type ${unexpected}`);
  }
}
function timeZoneGetter(width) {
  return function (date, locale, offset) {
    const zone = -1 * offset;
    const minusSign = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);
    const hours = zone > 0 ? Math.floor(zone / 60) : Math.ceil(zone / 60);
    switch (width) {
      case 0:
        return (zone >= 0 ? '+' : '') + padNumber(hours, 2, minusSign) + padNumber(Math.abs(zone % 60), 2, minusSign);
      case 1:
        return 'GMT' + (zone >= 0 ? '+' : '') + padNumber(hours, 1, minusSign);
      case 2:
        return 'GMT' + (zone >= 0 ? '+' : '') + padNumber(hours, 2, minusSign) + ':' + padNumber(Math.abs(zone % 60), 2, minusSign);
      case 3:
        if (offset === 0) {
          return 'Z';
        } else {
          return (zone >= 0 ? '+' : '') + padNumber(hours, 2, minusSign) + ':' + padNumber(Math.abs(zone % 60), 2, minusSign);
        }
      default:
        throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(2310, ngDevMode && `Unknown zone width "${width}"`);
    }
  };
}
const JANUARY = 0;
const THURSDAY = 4;
function getFirstThursdayOfYear(year) {
  const firstDayOfYear = createDate(year, JANUARY, 1).getDay();
  return createDate(year, 0, 1 + (firstDayOfYear <= THURSDAY ? THURSDAY : THURSDAY + 7) - firstDayOfYear);
}
function getThursdayThisIsoWeek(datetime) {
  const currentDay = datetime.getDay();
  const deltaToThursday = currentDay === 0 ? -3 : THURSDAY - currentDay;
  return createDate(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + deltaToThursday);
}
function weekGetter(size, monthBased = false) {
  return function (date, locale) {
    let result;
    if (monthBased) {
      const nbDaysBefore1stDayOfMonth = new Date(date.getFullYear(), date.getMonth(), 1).getDay() - 1;
      const today = date.getDate();
      result = 1 + Math.floor((today + nbDaysBefore1stDayOfMonth) / 7);
    } else {
      const thisThurs = getThursdayThisIsoWeek(date);
      const firstThurs = getFirstThursdayOfYear(thisThurs.getFullYear());
      const diff = thisThurs.getTime() - firstThurs.getTime();
      result = 1 + Math.round(diff / 6.048e8);
    }
    return padNumber(result, size, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  };
}
function weekNumberingYearGetter(size, trim = false) {
  return function (date, locale) {
    const thisThurs = getThursdayThisIsoWeek(date);
    const weekNumberingYear = thisThurs.getFullYear();
    return padNumber(weekNumberingYear, size, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign), trim);
  };
}
const DATE_FORMATS = {};
function getDateFormatter(format) {
  if (DATE_FORMATS[format]) {
    return DATE_FORMATS[format];
  }
  let formatter;
  switch (format) {
    case 'G':
    case 'GG':
    case 'GGG':
      formatter = dateStrGetter(3, TranslationWidth.Abbreviated);
      break;
    case 'GGGG':
      formatter = dateStrGetter(3, TranslationWidth.Wide);
      break;
    case 'GGGGG':
      formatter = dateStrGetter(3, TranslationWidth.Narrow);
      break;
    case 'y':
      formatter = dateGetter(0, 1, 0, false, true);
      break;
    case 'yy':
      formatter = dateGetter(0, 2, 0, true, true);
      break;
    case 'yyy':
      formatter = dateGetter(0, 3, 0, false, true);
      break;
    case 'yyyy':
      formatter = dateGetter(0, 4, 0, false, true);
      break;
    case 'Y':
      formatter = weekNumberingYearGetter(1);
      break;
    case 'YY':
      formatter = weekNumberingYearGetter(2, true);
      break;
    case 'YYY':
      formatter = weekNumberingYearGetter(3);
      break;
    case 'YYYY':
      formatter = weekNumberingYearGetter(4);
      break;
    case 'M':
    case 'L':
      formatter = dateGetter(1, 1, 1);
      break;
    case 'MM':
    case 'LL':
      formatter = dateGetter(1, 2, 1);
      break;
    case 'MMM':
      formatter = dateStrGetter(2, TranslationWidth.Abbreviated);
      break;
    case 'MMMM':
      formatter = dateStrGetter(2, TranslationWidth.Wide);
      break;
    case 'MMMMM':
      formatter = dateStrGetter(2, TranslationWidth.Narrow);
      break;
    case 'LLL':
      formatter = dateStrGetter(2, TranslationWidth.Abbreviated, FormStyle.Standalone);
      break;
    case 'LLLL':
      formatter = dateStrGetter(2, TranslationWidth.Wide, FormStyle.Standalone);
      break;
    case 'LLLLL':
      formatter = dateStrGetter(2, TranslationWidth.Narrow, FormStyle.Standalone);
      break;
    case 'w':
      formatter = weekGetter(1);
      break;
    case 'ww':
      formatter = weekGetter(2);
      break;
    case 'W':
      formatter = weekGetter(1, true);
      break;
    case 'd':
      formatter = dateGetter(2, 1);
      break;
    case 'dd':
      formatter = dateGetter(2, 2);
      break;
    case 'c':
    case 'cc':
      formatter = dateGetter(7, 1);
      break;
    case 'ccc':
      formatter = dateStrGetter(1, TranslationWidth.Abbreviated, FormStyle.Standalone);
      break;
    case 'cccc':
      formatter = dateStrGetter(1, TranslationWidth.Wide, FormStyle.Standalone);
      break;
    case 'ccccc':
      formatter = dateStrGetter(1, TranslationWidth.Narrow, FormStyle.Standalone);
      break;
    case 'cccccc':
      formatter = dateStrGetter(1, TranslationWidth.Short, FormStyle.Standalone);
      break;
    case 'E':
    case 'EE':
    case 'EEE':
      formatter = dateStrGetter(1, TranslationWidth.Abbreviated);
      break;
    case 'EEEE':
      formatter = dateStrGetter(1, TranslationWidth.Wide);
      break;
    case 'EEEEE':
      formatter = dateStrGetter(1, TranslationWidth.Narrow);
      break;
    case 'EEEEEE':
      formatter = dateStrGetter(1, TranslationWidth.Short);
      break;
    case 'a':
    case 'aa':
    case 'aaa':
      formatter = dateStrGetter(0, TranslationWidth.Abbreviated);
      break;
    case 'aaaa':
      formatter = dateStrGetter(0, TranslationWidth.Wide);
      break;
    case 'aaaaa':
      formatter = dateStrGetter(0, TranslationWidth.Narrow);
      break;
    case 'b':
    case 'bb':
    case 'bbb':
      formatter = dateStrGetter(0, TranslationWidth.Abbreviated, FormStyle.Standalone, true);
      break;
    case 'bbbb':
      formatter = dateStrGetter(0, TranslationWidth.Wide, FormStyle.Standalone, true);
      break;
    case 'bbbbb':
      formatter = dateStrGetter(0, TranslationWidth.Narrow, FormStyle.Standalone, true);
      break;
    case 'B':
    case 'BB':
    case 'BBB':
      formatter = dateStrGetter(0, TranslationWidth.Abbreviated, FormStyle.Format, true);
      break;
    case 'BBBB':
      formatter = dateStrGetter(0, TranslationWidth.Wide, FormStyle.Format, true);
      break;
    case 'BBBBB':
      formatter = dateStrGetter(0, TranslationWidth.Narrow, FormStyle.Format, true);
      break;
    case 'h':
      formatter = dateGetter(3, 1, -12);
      break;
    case 'hh':
      formatter = dateGetter(3, 2, -12);
      break;
    case 'H':
      formatter = dateGetter(3, 1);
      break;
    case 'HH':
      formatter = dateGetter(3, 2);
      break;
    case 'm':
      formatter = dateGetter(4, 1);
      break;
    case 'mm':
      formatter = dateGetter(4, 2);
      break;
    case 's':
      formatter = dateGetter(5, 1);
      break;
    case 'ss':
      formatter = dateGetter(5, 2);
      break;
    case 'S':
      formatter = dateGetter(6, 1);
      break;
    case 'SS':
      formatter = dateGetter(6, 2);
      break;
    case 'SSS':
      formatter = dateGetter(6, 3);
      break;
    case 'Z':
    case 'ZZ':
    case 'ZZZ':
      formatter = timeZoneGetter(0);
      break;
    case 'ZZZZZ':
      formatter = timeZoneGetter(3);
      break;
    case 'O':
    case 'OO':
    case 'OOO':
    case 'z':
    case 'zz':
    case 'zzz':
      formatter = timeZoneGetter(1);
      break;
    case 'OOOO':
    case 'ZZZZ':
    case 'zzzz':
      formatter = timeZoneGetter(2);
      break;
    default:
      return null;
  }
  DATE_FORMATS[format] = formatter;
  return formatter;
}
function timezoneToOffset(timezone, fallback) {
  timezone = timezone.replace(/:/g, '');
  const requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
  return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
}
function addDateMinutes(date, minutes) {
  date = new Date(date.getTime());
  date.setMinutes(date.getMinutes() + minutes);
  return date;
}
function convertTimezoneToLocal(date, timezone, reverse) {
  const reverseValue = -1;
  const dateTimezoneOffset = date.getTimezoneOffset();
  const timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
  return addDateMinutes(date, reverseValue * (timezoneOffset - dateTimezoneOffset));
}
function toDate(value) {
  if (isDate(value)) {
    return value;
  }
  if (typeof value === 'number' && !isNaN(value)) {
    return new Date(value);
  }
  if (typeof value === 'string') {
    value = value.trim();
    if (/^(\d{4}(-\d{1,2}(-\d{1,2})?)?)$/.test(value)) {
      const [y, m = 1, d = 1] = value.split('-').map(val => +val);
      return createDate(y, m - 1, d);
    }
    const parsedNb = parseFloat(value);
    if (!isNaN(value - parsedNb)) {
      return new Date(parsedNb);
    }
    let match;
    if (match = value.match(ISO8601_DATE_REGEX)) {
      return isoStringToDate(match);
    }
  }
  const date = new Date(value);
  if (!isDate(date)) {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(2311, ngDevMode && `Unable to convert "${value}" into a date`);
  }
  return date;
}
function isoStringToDate(match) {
  const date = new Date(0);
  let tzHour = 0;
  let tzMin = 0;
  const dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear;
  const timeSetter = match[8] ? date.setUTCHours : date.setHours;
  if (match[9]) {
    tzHour = Number(match[9] + match[10]);
    tzMin = Number(match[9] + match[11]);
  }
  dateSetter.call(date, Number(match[1]), Number(match[2]) - 1, Number(match[3]));
  const h = Number(match[4] || 0) - tzHour;
  const m = Number(match[5] || 0) - tzMin;
  const s = Number(match[6] || 0);
  const ms = Math.floor(parseFloat('0.' + (match[7] || 0)) * 1000);
  timeSetter.call(date, h, m, s, ms);
  return date;
}
function isDate(value) {
  return value instanceof Date && !isNaN(value.valueOf());
}
const NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(-(\d+))?)?$/;
const MAX_DIGITS = 22;
const DECIMAL_SEP = '.';
const ZERO_CHAR = '0';
const PATTERN_SEP = ';';
const GROUP_SEP = ',';
const DIGIT_CHAR = '#';
const CURRENCY_CHAR = '¤';
const PERCENT_CHAR = '%';
function formatNumberToLocaleString(value, pattern, locale, groupSymbol, decimalSymbol, digitsInfo, isPercent = false) {
  let formattedText = '';
  let isZero = false;
  if (!isFinite(value)) {
    formattedText = getLocaleNumberSymbol(locale, NumberSymbol.Infinity);
  } else {
    let parsedNumber = parseNumber(value);
    if (isPercent) {
      parsedNumber = toPercent(parsedNumber);
    }
    let minInt = pattern.minInt;
    let minFraction = pattern.minFrac;
    let maxFraction = pattern.maxFrac;
    if (digitsInfo) {
      const parts = digitsInfo.match(NUMBER_FORMAT_REGEXP);
      if (parts === null) {
        throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(2306, ngDevMode && `${digitsInfo} is not a valid digit info`);
      }
      const minIntPart = parts[1];
      const minFractionPart = parts[3];
      const maxFractionPart = parts[5];
      if (minIntPart != null) {
        minInt = parseIntAutoRadix(minIntPart);
      }
      if (minFractionPart != null) {
        minFraction = parseIntAutoRadix(minFractionPart);
      }
      if (maxFractionPart != null) {
        maxFraction = parseIntAutoRadix(maxFractionPart);
      } else if (minFractionPart != null && minFraction > maxFraction) {
        maxFraction = minFraction;
      }
    }
    roundNumber(parsedNumber, minFraction, maxFraction);
    let digits = parsedNumber.digits;
    let integerLen = parsedNumber.integerLen;
    const exponent = parsedNumber.exponent;
    let decimals = [];
    isZero = digits.every(d => !d);
    for (; integerLen < minInt; integerLen++) {
      digits.unshift(0);
    }
    for (; integerLen < 0; integerLen++) {
      digits.unshift(0);
    }
    if (integerLen > 0) {
      decimals = digits.splice(integerLen, digits.length);
    } else {
      decimals = digits;
      digits = [0];
    }
    const groups = [];
    if (digits.length >= pattern.lgSize) {
      groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(''));
    }
    while (digits.length > pattern.gSize) {
      groups.unshift(digits.splice(-pattern.gSize, digits.length).join(''));
    }
    if (digits.length) {
      groups.unshift(digits.join(''));
    }
    formattedText = groups.join(getLocaleNumberSymbol(locale, groupSymbol));
    if (decimals.length) {
      formattedText += getLocaleNumberSymbol(locale, decimalSymbol) + decimals.join('');
    }
    if (exponent) {
      formattedText += getLocaleNumberSymbol(locale, NumberSymbol.Exponential) + '+' + exponent;
    }
  }
  if (value < 0 && !isZero) {
    formattedText = pattern.negPre + formattedText + pattern.negSuf;
  } else {
    formattedText = pattern.posPre + formattedText + pattern.posSuf;
  }
  return formattedText;
}
function formatCurrency(value, locale, currency, currencyCode, digitsInfo) {
  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Currency);
  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  pattern.minFrac = getNumberOfCurrencyDigits(currencyCode);
  pattern.maxFrac = pattern.minFrac;
  const res = formatNumberToLocaleString(value, pattern, locale, NumberSymbol.CurrencyGroup, NumberSymbol.CurrencyDecimal, digitsInfo);
  return res.replace(CURRENCY_CHAR, currency).replace(CURRENCY_CHAR, '').trim();
}
function formatPercent(value, locale, digitsInfo) {
  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Percent);
  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  const res = formatNumberToLocaleString(value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo, true);
  return res.replace(new RegExp(PERCENT_CHAR, 'g'), getLocaleNumberSymbol(locale, NumberSymbol.PercentSign));
}
function formatNumber(value, locale, digitsInfo) {
  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Decimal);
  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  return formatNumberToLocaleString(value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo);
}
function parseNumberFormat(format, minusSign = '-') {
  const p = {
    minInt: 1,
    minFrac: 0,
    maxFrac: 0,
    posPre: '',
    posSuf: '',
    negPre: '',
    negSuf: '',
    gSize: 0,
    lgSize: 0
  };
  const patternParts = format.split(PATTERN_SEP);
  const positive = patternParts[0];
  const negative = patternParts[1];
  const positiveParts = positive.indexOf(DECIMAL_SEP) !== -1 ? positive.split(DECIMAL_SEP) : [positive.substring(0, positive.lastIndexOf(ZERO_CHAR) + 1), positive.substring(positive.lastIndexOf(ZERO_CHAR) + 1)],
    integer = positiveParts[0],
    fraction = positiveParts[1] || '';
  p.posPre = integer.substring(0, integer.indexOf(DIGIT_CHAR));
  for (let i = 0; i < fraction.length; i++) {
    const ch = fraction.charAt(i);
    if (ch === ZERO_CHAR) {
      p.minFrac = p.maxFrac = i + 1;
    } else if (ch === DIGIT_CHAR) {
      p.maxFrac = i + 1;
    } else {
      p.posSuf += ch;
    }
  }
  const groups = integer.split(GROUP_SEP);
  p.gSize = groups[1] ? groups[1].length : 0;
  p.lgSize = groups[2] || groups[1] ? (groups[2] || groups[1]).length : 0;
  if (negative) {
    const trunkLen = positive.length - p.posPre.length - p.posSuf.length,
      pos = negative.indexOf(DIGIT_CHAR);
    p.negPre = negative.substring(0, pos).replace(/'/g, '');
    p.negSuf = negative.slice(pos + trunkLen).replace(/'/g, '');
  } else {
    p.negPre = minusSign + p.posPre;
    p.negSuf = p.posSuf;
  }
  return p;
}
function toPercent(parsedNumber) {
  if (parsedNumber.digits[0] === 0) {
    return parsedNumber;
  }
  const fractionLen = parsedNumber.digits.length - parsedNumber.integerLen;
  if (parsedNumber.exponent) {
    parsedNumber.exponent += 2;
  } else {
    if (fractionLen === 0) {
      parsedNumber.digits.push(0, 0);
    } else if (fractionLen === 1) {
      parsedNumber.digits.push(0);
    }
    parsedNumber.integerLen += 2;
  }
  return parsedNumber;
}
function parseNumber(num) {
  let numStr = Math.abs(num) + '';
  let exponent = 0,
    digits,
    integerLen;
  let i, j, zeros;
  if ((integerLen = numStr.indexOf(DECIMAL_SEP)) > -1) {
    numStr = numStr.replace(DECIMAL_SEP, '');
  }
  if ((i = numStr.search(/e/i)) > 0) {
    if (integerLen < 0) integerLen = i;
    integerLen += +numStr.slice(i + 1);
    numStr = numStr.substring(0, i);
  } else if (integerLen < 0) {
    integerLen = numStr.length;
  }
  for (i = 0; numStr.charAt(i) === ZERO_CHAR; i++) {}
  if (i === (zeros = numStr.length)) {
    digits = [0];
    integerLen = 1;
  } else {
    zeros--;
    while (numStr.charAt(zeros) === ZERO_CHAR) zeros--;
    integerLen -= i;
    digits = [];
    for (j = 0; i <= zeros; i++, j++) {
      digits[j] = Number(numStr.charAt(i));
    }
  }
  if (integerLen > MAX_DIGITS) {
    digits = digits.splice(0, MAX_DIGITS - 1);
    exponent = integerLen - 1;
    integerLen = 1;
  }
  return {
    digits,
    exponent,
    integerLen
  };
}
function roundNumber(parsedNumber, minFrac, maxFrac) {
  if (minFrac > maxFrac) {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(2307, ngDevMode && `The minimum number of digits after fraction (${minFrac}) is higher than the maximum (${maxFrac}).`);
  }
  let digits = parsedNumber.digits;
  let fractionLen = digits.length - parsedNumber.integerLen;
  const fractionSize = Math.min(Math.max(minFrac, fractionLen), maxFrac);
  let roundAt = fractionSize + parsedNumber.integerLen;
  let digit = digits[roundAt];
  if (roundAt > 0) {
    digits.splice(Math.max(parsedNumber.integerLen, roundAt));
    for (let j = roundAt; j < digits.length; j++) {
      digits[j] = 0;
    }
  } else {
    fractionLen = Math.max(0, fractionLen);
    parsedNumber.integerLen = 1;
    digits.length = Math.max(1, roundAt = fractionSize + 1);
    digits[0] = 0;
    for (let i = 1; i < roundAt; i++) digits[i] = 0;
  }
  if (digit >= 5) {
    if (roundAt - 1 < 0) {
      for (let k = 0; k > roundAt; k--) {
        digits.unshift(0);
        parsedNumber.integerLen++;
      }
      digits.unshift(1);
      parsedNumber.integerLen++;
    } else {
      digits[roundAt - 1]++;
    }
  }
  for (; fractionLen < Math.max(0, fractionSize); fractionLen++) digits.push(0);
  let dropTrailingZeros = fractionSize !== 0;
  const minLen = minFrac + parsedNumber.integerLen;
  const carry = digits.reduceRight(function (carry, d, i, digits) {
    d = d + carry;
    digits[i] = d < 10 ? d : d - 10;
    if (dropTrailingZeros) {
      if (digits[i] === 0 && i >= minLen) {
        digits.pop();
      } else {
        dropTrailingZeros = false;
      }
    }
    return d >= 10 ? 1 : 0;
  }, 0);
  if (carry) {
    digits.unshift(carry);
    parsedNumber.integerLen++;
  }
}
function parseIntAutoRadix(text) {
  const result = parseInt(text);
  if (isNaN(result)) {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(2305, ngDevMode && 'Invalid integer literal when parsing ' + text);
  }
  return result;
}
class NgLocalization {
  static ɵfac = function NgLocalization_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || NgLocalization)();
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: NgLocalization,
    factory: () => (() => new NgLocaleLocalization((0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.LOCALE_ID)))(),
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(NgLocalization, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,
    args: [{
      providedIn: 'root',
      useFactory: () => new NgLocaleLocalization((0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.LOCALE_ID))
    }]
  }], null, null);
})();
function getPluralCategory(value, cases, ngLocalization, locale) {
  let key = `=${value}`;
  if (cases.indexOf(key) > -1) {
    return key;
  }
  key = ngLocalization.getPluralCategory(value, locale);
  if (cases.indexOf(key) > -1) {
    return key;
  }
  if (cases.indexOf('other') > -1) {
    return 'other';
  }
  throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(2308, ngDevMode && `No plural message found for value "${value}"`);
}
class NgLocaleLocalization extends NgLocalization {
  locale;
  constructor(locale) {
    super();
    this.locale = locale;
  }
  getPluralCategory(value, locale) {
    const plural = getLocalePluralCase(locale || this.locale)(value);
    switch (plural) {
      case Plural.Zero:
        return 'zero';
      case Plural.One:
        return 'one';
      case Plural.Two:
        return 'two';
      case Plural.Few:
        return 'few';
      case Plural.Many:
        return 'many';
      default:
        return 'other';
    }
  }
  static ɵfac = function NgLocaleLocalization_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || NgLocaleLocalization)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.LOCALE_ID));
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: NgLocaleLocalization,
    factory: NgLocaleLocalization.ɵfac
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(NgLocaleLocalization, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable
  }], () => [{
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [_angular_core__WEBPACK_IMPORTED_MODULE_1__.LOCALE_ID]
    }]
  }], null);
})();
const WS_REGEXP = /\s+/;
const EMPTY_ARRAY = [];
class NgClass {
  _ngEl;
  _renderer;
  initialClasses = EMPTY_ARRAY;
  rawClass;
  stateMap = new Map();
  constructor(_ngEl, _renderer) {
    this._ngEl = _ngEl;
    this._renderer = _renderer;
  }
  set klass(value) {
    this.initialClasses = value != null ? value.trim().split(WS_REGEXP) : EMPTY_ARRAY;
  }
  set ngClass(value) {
    this.rawClass = typeof value === 'string' ? value.trim().split(WS_REGEXP) : value;
  }
  ngDoCheck() {
    for (const klass of this.initialClasses) {
      this._updateState(klass, true);
    }
    const rawClass = this.rawClass;
    if (Array.isArray(rawClass) || rawClass instanceof Set) {
      for (const klass of rawClass) {
        this._updateState(klass, true);
      }
    } else if (rawClass != null) {
      for (const klass of Object.keys(rawClass)) {
        this._updateState(klass, Boolean(rawClass[klass]));
      }
    }
    this._applyStateDiff();
  }
  _updateState(klass, nextEnabled) {
    const state = this.stateMap.get(klass);
    if (state !== undefined) {
      if (state.enabled !== nextEnabled) {
        state.changed = true;
        state.enabled = nextEnabled;
      }
      state.touched = true;
    } else {
      this.stateMap.set(klass, {
        enabled: nextEnabled,
        changed: true,
        touched: true
      });
    }
  }
  _applyStateDiff() {
    for (const stateEntry of this.stateMap) {
      const klass = stateEntry[0];
      const state = stateEntry[1];
      if (state.changed) {
        this._toggleClass(klass, state.enabled);
        state.changed = false;
      } else if (!state.touched) {
        if (state.enabled) {
          this._toggleClass(klass, false);
        }
        this.stateMap.delete(klass);
      }
      state.touched = false;
    }
  }
  _toggleClass(klass, enabled) {
    if (ngDevMode) {
      if (typeof klass !== 'string') {
        throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.stringify)(klass)}`);
      }
    }
    klass = klass.trim();
    if (klass.length > 0) {
      klass.split(WS_REGEXP).forEach(klass => {
        if (enabled) {
          this._renderer.addClass(this._ngEl.nativeElement, klass);
        } else {
          this._renderer.removeClass(this._ngEl.nativeElement, klass);
        }
      });
    }
  }
  static ɵfac = function NgClass_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || NgClass)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.Renderer2));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: NgClass,
    selectors: [["", "ngClass", ""]],
    inputs: {
      klass: [0, "class", "klass"],
      ngClass: "ngClass"
    }
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(NgClass, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[ngClass]'
    }]
  }], () => [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Renderer2
  }], {
    klass: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,
      args: ['class']
    }],
    ngClass: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,
      args: ['ngClass']
    }]
  });
})();
class NgComponentOutlet {
  _viewContainerRef;
  ngComponentOutlet = null;
  ngComponentOutletInputs;
  ngComponentOutletInjector;
  ngComponentOutletEnvironmentInjector;
  ngComponentOutletContent;
  ngComponentOutletNgModule;
  _componentRef;
  _moduleRef;
  _inputsUsed = new Map();
  get componentInstance() {
    return this._componentRef?.instance ?? null;
  }
  constructor(_viewContainerRef) {
    this._viewContainerRef = _viewContainerRef;
  }
  _needToReCreateNgModuleInstance(changes) {
    return changes['ngComponentOutletNgModule'] !== undefined;
  }
  _needToReCreateComponentInstance(changes) {
    return changes['ngComponentOutlet'] !== undefined || changes['ngComponentOutletContent'] !== undefined || changes['ngComponentOutletInjector'] !== undefined || changes['ngComponentOutletEnvironmentInjector'] !== undefined || this._needToReCreateNgModuleInstance(changes);
  }
  ngOnChanges(changes) {
    if (this._needToReCreateComponentInstance(changes)) {
      this._viewContainerRef.clear();
      this._inputsUsed.clear();
      this._componentRef = undefined;
      if (this.ngComponentOutlet) {
        const injector = this.ngComponentOutletInjector || this._viewContainerRef.parentInjector;
        if (this._needToReCreateNgModuleInstance(changes)) {
          this._moduleRef?.destroy();
          if (this.ngComponentOutletNgModule) {
            this._moduleRef = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.createNgModule)(this.ngComponentOutletNgModule, getParentInjector(injector));
          } else {
            this._moduleRef = undefined;
          }
        }
        this._componentRef = this._viewContainerRef.createComponent(this.ngComponentOutlet, {
          injector,
          ngModuleRef: this._moduleRef,
          projectableNodes: this.ngComponentOutletContent,
          environmentInjector: this.ngComponentOutletEnvironmentInjector
        });
      }
    }
  }
  ngDoCheck() {
    if (this._componentRef) {
      if (this.ngComponentOutletInputs) {
        for (const inputName of Object.keys(this.ngComponentOutletInputs)) {
          this._inputsUsed.set(inputName, true);
        }
      }
      this._applyInputStateDiff(this._componentRef);
    }
  }
  ngOnDestroy() {
    this._moduleRef?.destroy();
  }
  _applyInputStateDiff(componentRef) {
    for (const [inputName, touched] of this._inputsUsed) {
      if (!touched) {
        componentRef.setInput(inputName, undefined);
        this._inputsUsed.delete(inputName);
      } else {
        componentRef.setInput(inputName, this.ngComponentOutletInputs[inputName]);
        this._inputsUsed.set(inputName, false);
      }
    }
  }
  static ɵfac = function NgComponentOutlet_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || NgComponentOutlet)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.ViewContainerRef));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: NgComponentOutlet,
    selectors: [["", "ngComponentOutlet", ""]],
    inputs: {
      ngComponentOutlet: "ngComponentOutlet",
      ngComponentOutletInputs: "ngComponentOutletInputs",
      ngComponentOutletInjector: "ngComponentOutletInjector",
      ngComponentOutletEnvironmentInjector: "ngComponentOutletEnvironmentInjector",
      ngComponentOutletContent: "ngComponentOutletContent",
      ngComponentOutletNgModule: "ngComponentOutletNgModule"
    },
    exportAs: ["ngComponentOutlet"],
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵNgOnChangesFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(NgComponentOutlet, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[ngComponentOutlet]',
      exportAs: 'ngComponentOutlet'
    }]
  }], () => [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ViewContainerRef
  }], {
    ngComponentOutlet: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    ngComponentOutletInputs: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    ngComponentOutletInjector: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    ngComponentOutletEnvironmentInjector: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    ngComponentOutletContent: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    ngComponentOutletNgModule: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }]
  });
})();
function getParentInjector(injector) {
  const parentNgModule = injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_1__.NgModuleRef$1);
  return parentNgModule.injector;
}
class NgForOfContext {
  $implicit;
  ngForOf;
  index;
  count;
  constructor($implicit, ngForOf, index, count) {
    this.$implicit = $implicit;
    this.ngForOf = ngForOf;
    this.index = index;
    this.count = count;
  }
  get first() {
    return this.index === 0;
  }
  get last() {
    return this.index === this.count - 1;
  }
  get even() {
    return this.index % 2 === 0;
  }
  get odd() {
    return !this.even;
  }
}
class NgForOf {
  _viewContainer;
  _template;
  _differs;
  set ngForOf(ngForOf) {
    this._ngForOf = ngForOf;
    this._ngForOfDirty = true;
  }
  set ngForTrackBy(fn) {
    if ((typeof ngDevMode === 'undefined' || ngDevMode) && fn != null && typeof fn !== 'function') {
      console.warn(`trackBy must be a function, but received ${JSON.stringify(fn)}. ` + `See https://angular.dev/api/common/NgForOf#change-propagation for more information.`);
    }
    this._trackByFn = fn;
  }
  get ngForTrackBy() {
    return this._trackByFn;
  }
  _ngForOf = null;
  _ngForOfDirty = true;
  _differ = null;
  _trackByFn;
  constructor(_viewContainer, _template, _differs) {
    this._viewContainer = _viewContainer;
    this._template = _template;
    this._differs = _differs;
  }
  set ngForTemplate(value) {
    if (value) {
      this._template = value;
    }
  }
  ngDoCheck() {
    if (this._ngForOfDirty) {
      this._ngForOfDirty = false;
      const value = this._ngForOf;
      if (!this._differ && value) {
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
          try {
            this._differ = this._differs.find(value).create(this.ngForTrackBy);
          } catch {
            let errorMessage = `Cannot find a differ supporting object '${value}' of type '` + `${getTypeName(value)}'. NgFor only supports binding to Iterables, such as Arrays.`;
            if (typeof value === 'object') {
              errorMessage += ' Did you mean to use the keyvalue pipe?';
            }
            throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(-2200, errorMessage);
          }
        } else {
          this._differ = this._differs.find(value).create(this.ngForTrackBy);
        }
      }
    }
    if (this._differ) {
      const changes = this._differ.diff(this._ngForOf);
      if (changes) this._applyChanges(changes);
    }
  }
  _applyChanges(changes) {
    const viewContainer = this._viewContainer;
    changes.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {
      if (item.previousIndex == null) {
        viewContainer.createEmbeddedView(this._template, new NgForOfContext(item.item, this._ngForOf, -1, -1), currentIndex === null ? undefined : currentIndex);
      } else if (currentIndex == null) {
        viewContainer.remove(adjustedPreviousIndex === null ? undefined : adjustedPreviousIndex);
      } else if (adjustedPreviousIndex !== null) {
        const view = viewContainer.get(adjustedPreviousIndex);
        viewContainer.move(view, currentIndex);
        applyViewChange(view, item);
      }
    });
    for (let i = 0, ilen = viewContainer.length; i < ilen; i++) {
      const viewRef = viewContainer.get(i);
      const context = viewRef.context;
      context.index = i;
      context.count = ilen;
      context.ngForOf = this._ngForOf;
    }
    changes.forEachIdentityChange(record => {
      const viewRef = viewContainer.get(record.currentIndex);
      applyViewChange(viewRef, record);
    });
  }
  static ngTemplateContextGuard(dir, ctx) {
    return true;
  }
  static ɵfac = function NgForOf_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || NgForOf)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.ViewContainerRef), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.TemplateRef), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__.IterableDiffers));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: NgForOf,
    selectors: [["", "ngFor", "", "ngForOf", ""]],
    inputs: {
      ngForOf: "ngForOf",
      ngForTrackBy: "ngForTrackBy",
      ngForTemplate: "ngForTemplate"
    }
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(NgForOf, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[ngFor][ngForOf]'
    }]
  }], () => [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ViewContainerRef
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.TemplateRef
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.IterableDiffers
  }], {
    ngForOf: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    ngForTrackBy: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    ngForTemplate: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }]
  });
})();
function applyViewChange(view, record) {
  view.context.$implicit = record.item;
}
function getTypeName(type) {
  return type['name'] || typeof type;
}
class NgIf {
  _viewContainer;
  _context = new NgIfContext();
  _thenTemplateRef = null;
  _elseTemplateRef = null;
  _thenViewRef = null;
  _elseViewRef = null;
  constructor(_viewContainer, templateRef) {
    this._viewContainer = _viewContainer;
    this._thenTemplateRef = templateRef;
  }
  set ngIf(condition) {
    this._context.$implicit = this._context.ngIf = condition;
    this._updateView();
  }
  set ngIfThen(templateRef) {
    assertTemplate(templateRef, (typeof ngDevMode === 'undefined' || ngDevMode) && 'ngIfThen');
    this._thenTemplateRef = templateRef;
    this._thenViewRef = null;
    this._updateView();
  }
  set ngIfElse(templateRef) {
    assertTemplate(templateRef, (typeof ngDevMode === 'undefined' || ngDevMode) && 'ngIfElse');
    this._elseTemplateRef = templateRef;
    this._elseViewRef = null;
    this._updateView();
  }
  _updateView() {
    if (this._context.$implicit) {
      if (!this._thenViewRef) {
        this._viewContainer.clear();
        this._elseViewRef = null;
        if (this._thenTemplateRef) {
          this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context);
        }
      }
    } else {
      if (!this._elseViewRef) {
        this._viewContainer.clear();
        this._thenViewRef = null;
        if (this._elseTemplateRef) {
          this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context);
        }
      }
    }
  }
  static ngIfUseIfTypeGuard;
  static ngTemplateGuard_ngIf;
  static ngTemplateContextGuard(dir, ctx) {
    return true;
  }
  static ɵfac = function NgIf_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || NgIf)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.ViewContainerRef), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.TemplateRef));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: NgIf,
    selectors: [["", "ngIf", ""]],
    inputs: {
      ngIf: "ngIf",
      ngIfThen: "ngIfThen",
      ngIfElse: "ngIfElse"
    }
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(NgIf, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[ngIf]'
    }]
  }], () => [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ViewContainerRef
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.TemplateRef
  }], {
    ngIf: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    ngIfThen: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    ngIfElse: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }]
  });
})();
class NgIfContext {
  $implicit = null;
  ngIf = null;
}
function assertTemplate(templateRef, property) {
  if (templateRef && !templateRef.createEmbeddedView) {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(2020, (typeof ngDevMode === 'undefined' || ngDevMode) && `${property} must be a TemplateRef, but received '${(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.stringify)(templateRef)}'.`);
  }
}
class SwitchView {
  _viewContainerRef;
  _templateRef;
  _created = false;
  constructor(_viewContainerRef, _templateRef) {
    this._viewContainerRef = _viewContainerRef;
    this._templateRef = _templateRef;
  }
  create() {
    this._created = true;
    this._viewContainerRef.createEmbeddedView(this._templateRef);
  }
  destroy() {
    this._created = false;
    this._viewContainerRef.clear();
  }
  enforceState(created) {
    if (created && !this._created) {
      this.create();
    } else if (!created && this._created) {
      this.destroy();
    }
  }
}
class NgSwitch {
  _defaultViews = [];
  _defaultUsed = false;
  _caseCount = 0;
  _lastCaseCheckIndex = 0;
  _lastCasesMatched = false;
  _ngSwitch;
  set ngSwitch(newValue) {
    this._ngSwitch = newValue;
    if (this._caseCount === 0) {
      this._updateDefaultCases(true);
    }
  }
  _addCase() {
    return this._caseCount++;
  }
  _addDefault(view) {
    this._defaultViews.push(view);
  }
  _matchCase(value) {
    const matched = value === this._ngSwitch;
    this._lastCasesMatched ||= matched;
    this._lastCaseCheckIndex++;
    if (this._lastCaseCheckIndex === this._caseCount) {
      this._updateDefaultCases(!this._lastCasesMatched);
      this._lastCaseCheckIndex = 0;
      this._lastCasesMatched = false;
    }
    return matched;
  }
  _updateDefaultCases(useDefault) {
    if (this._defaultViews.length > 0 && useDefault !== this._defaultUsed) {
      this._defaultUsed = useDefault;
      for (const defaultView of this._defaultViews) {
        defaultView.enforceState(useDefault);
      }
    }
  }
  static ɵfac = function NgSwitch_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || NgSwitch)();
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: NgSwitch,
    selectors: [["", "ngSwitch", ""]],
    inputs: {
      ngSwitch: "ngSwitch"
    }
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(NgSwitch, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[ngSwitch]'
    }]
  }], null, {
    ngSwitch: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }]
  });
})();
class NgSwitchCase {
  ngSwitch;
  _view;
  ngSwitchCase;
  constructor(viewContainer, templateRef, ngSwitch) {
    this.ngSwitch = ngSwitch;
    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !ngSwitch) {
      throwNgSwitchProviderNotFoundError('ngSwitchCase', 'NgSwitchCase');
    }
    ngSwitch._addCase();
    this._view = new SwitchView(viewContainer, templateRef);
  }
  ngDoCheck() {
    this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase));
  }
  static ɵfac = function NgSwitchCase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || NgSwitchCase)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.ViewContainerRef), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.TemplateRef), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](NgSwitch, 9));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: NgSwitchCase,
    selectors: [["", "ngSwitchCase", ""]],
    inputs: {
      ngSwitchCase: "ngSwitchCase"
    }
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(NgSwitchCase, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[ngSwitchCase]'
    }]
  }], () => [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ViewContainerRef
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.TemplateRef
  }, {
    type: NgSwitch,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Host
    }]
  }], {
    ngSwitchCase: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }]
  });
})();
class NgSwitchDefault {
  constructor(viewContainer, templateRef, ngSwitch) {
    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !ngSwitch) {
      throwNgSwitchProviderNotFoundError('ngSwitchDefault', 'NgSwitchDefault');
    }
    ngSwitch._addDefault(new SwitchView(viewContainer, templateRef));
  }
  static ɵfac = function NgSwitchDefault_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || NgSwitchDefault)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.ViewContainerRef), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.TemplateRef), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](NgSwitch, 9));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: NgSwitchDefault,
    selectors: [["", "ngSwitchDefault", ""]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(NgSwitchDefault, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[ngSwitchDefault]'
    }]
  }], () => [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ViewContainerRef
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.TemplateRef
  }, {
    type: NgSwitch,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Host
    }]
  }], null);
})();
function throwNgSwitchProviderNotFoundError(attrName, directiveName) {
  throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(2000, `An element with the "${attrName}" attribute ` + `(matching the "${directiveName}" directive) must be located inside an element with the "ngSwitch" attribute ` + `(matching "NgSwitch" directive)`);
}
class NgPlural {
  _localization;
  _activeView;
  _caseViews = {};
  constructor(_localization) {
    this._localization = _localization;
  }
  set ngPlural(value) {
    this._updateView(value);
  }
  addCase(value, switchView) {
    this._caseViews[value] = switchView;
  }
  _updateView(switchValue) {
    this._clearViews();
    const cases = Object.keys(this._caseViews);
    const key = getPluralCategory(switchValue, cases, this._localization);
    this._activateView(this._caseViews[key]);
  }
  _clearViews() {
    if (this._activeView) this._activeView.destroy();
  }
  _activateView(view) {
    if (view) {
      this._activeView = view;
      this._activeView.create();
    }
  }
  static ɵfac = function NgPlural_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || NgPlural)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](NgLocalization));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: NgPlural,
    selectors: [["", "ngPlural", ""]],
    inputs: {
      ngPlural: "ngPlural"
    }
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(NgPlural, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[ngPlural]'
    }]
  }], () => [{
    type: NgLocalization
  }], {
    ngPlural: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }]
  });
})();
class NgPluralCase {
  value;
  constructor(value, template, viewContainer, ngPlural) {
    this.value = value;
    const isANumber = !isNaN(Number(value));
    ngPlural.addCase(isANumber ? `=${value}` : value, new SwitchView(viewContainer, template));
  }
  static ɵfac = function NgPluralCase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || NgPluralCase)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinjectAttribute"]('ngPluralCase'), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.TemplateRef), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.ViewContainerRef), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](NgPlural, 1));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: NgPluralCase,
    selectors: [["", "ngPluralCase", ""]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(NgPluralCase, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[ngPluralCase]'
    }]
  }], () => [{
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Attribute,
      args: ['ngPluralCase']
    }]
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.TemplateRef
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ViewContainerRef
  }, {
    type: NgPlural,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Host
    }]
  }], null);
})();
class NgStyle {
  _ngEl;
  _differs;
  _renderer;
  _ngStyle = null;
  _differ = null;
  constructor(_ngEl, _differs, _renderer) {
    this._ngEl = _ngEl;
    this._differs = _differs;
    this._renderer = _renderer;
  }
  set ngStyle(values) {
    this._ngStyle = values;
    if (!this._differ && values) {
      this._differ = this._differs.find(values).create();
    }
  }
  ngDoCheck() {
    if (this._differ) {
      const changes = this._differ.diff(this._ngStyle);
      if (changes) {
        this._applyChanges(changes);
      }
    }
  }
  _setStyle(nameAndUnit, value) {
    const [name, unit] = nameAndUnit.split('.');
    const flags = name.indexOf('-') === -1 ? undefined : _angular_core__WEBPACK_IMPORTED_MODULE_1__.RendererStyleFlags2.DashCase;
    if (value != null) {
      this._renderer.setStyle(this._ngEl.nativeElement, name, unit ? `${value}${unit}` : value, flags);
    } else {
      this._renderer.removeStyle(this._ngEl.nativeElement, name, flags);
    }
  }
  _applyChanges(changes) {
    changes.forEachRemovedItem(record => this._setStyle(record.key, null));
    changes.forEachAddedItem(record => this._setStyle(record.key, record.currentValue));
    changes.forEachChangedItem(record => this._setStyle(record.key, record.currentValue));
  }
  static ɵfac = function NgStyle_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || NgStyle)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__.KeyValueDiffers), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.Renderer2));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: NgStyle,
    selectors: [["", "ngStyle", ""]],
    inputs: {
      ngStyle: "ngStyle"
    }
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(NgStyle, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[ngStyle]'
    }]
  }], () => [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.KeyValueDiffers
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Renderer2
  }], {
    ngStyle: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,
      args: ['ngStyle']
    }]
  });
})();
class NgTemplateOutlet {
  _viewContainerRef;
  _viewRef = null;
  ngTemplateOutletContext = null;
  ngTemplateOutlet = null;
  ngTemplateOutletInjector = null;
  constructor(_viewContainerRef) {
    this._viewContainerRef = _viewContainerRef;
  }
  ngOnChanges(changes) {
    if (this._shouldRecreateView(changes)) {
      const viewContainerRef = this._viewContainerRef;
      if (this._viewRef) {
        viewContainerRef.remove(viewContainerRef.indexOf(this._viewRef));
      }
      if (!this.ngTemplateOutlet) {
        this._viewRef = null;
        return;
      }
      const viewContext = this._createContextForwardProxy();
      this._viewRef = viewContainerRef.createEmbeddedView(this.ngTemplateOutlet, viewContext, {
        injector: this.ngTemplateOutletInjector ?? undefined
      });
    }
  }
  _shouldRecreateView(changes) {
    return !!changes['ngTemplateOutlet'] || !!changes['ngTemplateOutletInjector'];
  }
  _createContextForwardProxy() {
    return new Proxy({}, {
      set: (_target, prop, newValue) => {
        if (!this.ngTemplateOutletContext) {
          return false;
        }
        return Reflect.set(this.ngTemplateOutletContext, prop, newValue);
      },
      get: (_target, prop, receiver) => {
        if (!this.ngTemplateOutletContext) {
          return undefined;
        }
        return Reflect.get(this.ngTemplateOutletContext, prop, receiver);
      }
    });
  }
  static ɵfac = function NgTemplateOutlet_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || NgTemplateOutlet)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.ViewContainerRef));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: NgTemplateOutlet,
    selectors: [["", "ngTemplateOutlet", ""]],
    inputs: {
      ngTemplateOutletContext: "ngTemplateOutletContext",
      ngTemplateOutlet: "ngTemplateOutlet",
      ngTemplateOutletInjector: "ngTemplateOutletInjector"
    },
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵNgOnChangesFeature"]]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(NgTemplateOutlet, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[ngTemplateOutlet]'
    }]
  }], () => [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ViewContainerRef
  }], {
    ngTemplateOutletContext: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    ngTemplateOutlet: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    ngTemplateOutletInjector: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }]
  });
})();
const COMMON_DIRECTIVES = [NgClass, NgComponentOutlet, NgForOf, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase];
function invalidPipeArgumentError(type, value) {
  return new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(2100, ngDevMode && `InvalidPipeArgument: '${value}' for pipe '${(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.stringify)(type)}'`);
}
class SubscribableStrategy {
  createSubscription(async, updateLatestValue, onError) {
    return (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.untracked)(() => async.subscribe({
      next: updateLatestValue,
      error: onError
    }));
  }
  dispose(subscription) {
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.untracked)(() => subscription.unsubscribe());
  }
}
class PromiseStrategy {
  createSubscription(async, updateLatestValue, onError) {
    async.then(v => updateLatestValue?.(v), e => onError?.(e));
    return {
      unsubscribe: () => {
        updateLatestValue = null;
        onError = null;
      }
    };
  }
  dispose(subscription) {
    subscription.unsubscribe();
  }
}
const _promiseStrategy = new PromiseStrategy();
const _subscribableStrategy = new SubscribableStrategy();
class AsyncPipe {
  _ref;
  _latestValue = null;
  markForCheckOnValueUpdate = true;
  _subscription = null;
  _obj = null;
  _strategy = null;
  applicationErrorHandler = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_APPLICATION_ERROR_HANDLER);
  constructor(ref) {
    this._ref = ref;
  }
  ngOnDestroy() {
    if (this._subscription) {
      this._dispose();
    }
    this._ref = null;
  }
  transform(obj) {
    if (!this._obj) {
      if (obj) {
        try {
          this.markForCheckOnValueUpdate = false;
          this._subscribe(obj);
        } finally {
          this.markForCheckOnValueUpdate = true;
        }
      }
      return this._latestValue;
    }
    if (obj !== this._obj) {
      this._dispose();
      return this.transform(obj);
    }
    return this._latestValue;
  }
  _subscribe(obj) {
    this._obj = obj;
    this._strategy = this._selectStrategy(obj);
    this._subscription = this._strategy.createSubscription(obj, value => this._updateLatestValue(obj, value), e => this.applicationErrorHandler(e));
  }
  _selectStrategy(obj) {
    if ((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.isPromise)(obj)) {
      return _promiseStrategy;
    }
    if ((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.isSubscribable)(obj)) {
      return _subscribableStrategy;
    }
    throw invalidPipeArgumentError(AsyncPipe, obj);
  }
  _dispose() {
    this._strategy.dispose(this._subscription);
    this._latestValue = null;
    this._subscription = null;
    this._obj = null;
  }
  _updateLatestValue(async, value) {
    if (async === this._obj) {
      this._latestValue = value;
      if (this.markForCheckOnValueUpdate) {
        this._ref?.markForCheck();
      }
    }
  }
  static ɵfac = function AsyncPipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || AsyncPipe)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectorRef, 16));
  };
  static ɵpipe = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefinePipe"]({
    name: "async",
    type: AsyncPipe,
    pure: false
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(AsyncPipe, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Pipe,
    args: [{
      name: 'async',
      pure: false
    }]
  }], () => [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectorRef
  }], null);
})();
class LowerCasePipe {
  transform(value) {
    if (value == null) return null;
    if (typeof value !== 'string') {
      throw invalidPipeArgumentError(LowerCasePipe, value);
    }
    return value.toLowerCase();
  }
  static ɵfac = function LowerCasePipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || LowerCasePipe)();
  };
  static ɵpipe = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefinePipe"]({
    name: "lowercase",
    type: LowerCasePipe,
    pure: true
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(LowerCasePipe, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Pipe,
    args: [{
      name: 'lowercase'
    }]
  }], null, null);
})();
const unicodeWordMatch = /(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])\S*/g;
class TitleCasePipe {
  transform(value) {
    if (value == null) return null;
    if (typeof value !== 'string') {
      throw invalidPipeArgumentError(TitleCasePipe, value);
    }
    return value.replace(unicodeWordMatch, txt => txt[0].toUpperCase() + txt.slice(1).toLowerCase());
  }
  static ɵfac = function TitleCasePipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || TitleCasePipe)();
  };
  static ɵpipe = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefinePipe"]({
    name: "titlecase",
    type: TitleCasePipe,
    pure: true
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(TitleCasePipe, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Pipe,
    args: [{
      name: 'titlecase'
    }]
  }], null, null);
})();
class UpperCasePipe {
  transform(value) {
    if (value == null) return null;
    if (typeof value !== 'string') {
      throw invalidPipeArgumentError(UpperCasePipe, value);
    }
    return value.toUpperCase();
  }
  static ɵfac = function UpperCasePipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || UpperCasePipe)();
  };
  static ɵpipe = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefinePipe"]({
    name: "uppercase",
    type: UpperCasePipe,
    pure: true
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(UpperCasePipe, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Pipe,
    args: [{
      name: 'uppercase'
    }]
  }], null, null);
})();
const DEFAULT_DATE_FORMAT = 'mediumDate';
const DATE_PIPE_DEFAULT_TIMEZONE = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'DATE_PIPE_DEFAULT_TIMEZONE' : '');
const DATE_PIPE_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'DATE_PIPE_DEFAULT_OPTIONS' : '');
class DatePipe {
  locale;
  defaultTimezone;
  defaultOptions;
  constructor(locale, defaultTimezone, defaultOptions) {
    this.locale = locale;
    this.defaultTimezone = defaultTimezone;
    this.defaultOptions = defaultOptions;
  }
  transform(value, format, timezone, locale) {
    if (value == null || value === '' || value !== value) return null;
    try {
      const _format = format ?? this.defaultOptions?.dateFormat ?? DEFAULT_DATE_FORMAT;
      const _timezone = timezone ?? this.defaultOptions?.timezone ?? this.defaultTimezone ?? undefined;
      return formatDate(value, _format, locale || this.locale, _timezone);
    } catch (error) {
      throw invalidPipeArgumentError(DatePipe, error.message);
    }
  }
  static ɵfac = function DatePipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || DatePipe)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.LOCALE_ID, 16), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](DATE_PIPE_DEFAULT_TIMEZONE, 24), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](DATE_PIPE_DEFAULT_OPTIONS, 24));
  };
  static ɵpipe = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefinePipe"]({
    name: "date",
    type: DatePipe,
    pure: true
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(DatePipe, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Pipe,
    args: [{
      name: 'date'
    }]
  }], () => [{
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [_angular_core__WEBPACK_IMPORTED_MODULE_1__.LOCALE_ID]
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [DATE_PIPE_DEFAULT_TIMEZONE]
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [DATE_PIPE_DEFAULT_OPTIONS]
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
    }]
  }], null);
})();
const _INTERPOLATION_REGEXP = /#/g;
class I18nPluralPipe {
  _localization;
  constructor(_localization) {
    this._localization = _localization;
  }
  transform(value, pluralMap, locale) {
    if (value == null) return '';
    if (typeof pluralMap !== 'object' || pluralMap === null) {
      throw invalidPipeArgumentError(I18nPluralPipe, pluralMap);
    }
    const key = getPluralCategory(value, Object.keys(pluralMap), this._localization, locale);
    return pluralMap[key].replace(_INTERPOLATION_REGEXP, value.toString());
  }
  static ɵfac = function I18nPluralPipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || I18nPluralPipe)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](NgLocalization, 16));
  };
  static ɵpipe = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefinePipe"]({
    name: "i18nPlural",
    type: I18nPluralPipe,
    pure: true
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(I18nPluralPipe, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Pipe,
    args: [{
      name: 'i18nPlural'
    }]
  }], () => [{
    type: NgLocalization
  }], null);
})();
class I18nSelectPipe {
  transform(value, mapping) {
    if (value == null) return '';
    if (typeof mapping !== 'object' || typeof value !== 'string') {
      throw invalidPipeArgumentError(I18nSelectPipe, mapping);
    }
    if (mapping.hasOwnProperty(value)) {
      return mapping[value];
    }
    if (mapping.hasOwnProperty('other')) {
      return mapping['other'];
    }
    return '';
  }
  static ɵfac = function I18nSelectPipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || I18nSelectPipe)();
  };
  static ɵpipe = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefinePipe"]({
    name: "i18nSelect",
    type: I18nSelectPipe,
    pure: true
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(I18nSelectPipe, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Pipe,
    args: [{
      name: 'i18nSelect'
    }]
  }], null, null);
})();
class JsonPipe {
  transform(value) {
    return JSON.stringify(value, null, 2);
  }
  static ɵfac = function JsonPipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || JsonPipe)();
  };
  static ɵpipe = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefinePipe"]({
    name: "json",
    type: JsonPipe,
    pure: false
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(JsonPipe, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Pipe,
    args: [{
      name: 'json',
      pure: false
    }]
  }], null, null);
})();
function makeKeyValuePair(key, value) {
  return {
    key: key,
    value: value
  };
}
class KeyValuePipe {
  differs;
  constructor(differs) {
    this.differs = differs;
  }
  differ;
  keyValues = [];
  compareFn = defaultComparator;
  transform(input, compareFn = defaultComparator) {
    if (!input || !(input instanceof Map) && typeof input !== 'object') {
      return null;
    }
    this.differ ??= this.differs.find(input).create();
    const differChanges = this.differ.diff(input);
    const compareFnChanged = compareFn !== this.compareFn;
    if (differChanges) {
      this.keyValues = [];
      differChanges.forEachItem(r => {
        this.keyValues.push(makeKeyValuePair(r.key, r.currentValue));
      });
    }
    if (differChanges || compareFnChanged) {
      if (compareFn) {
        this.keyValues.sort(compareFn);
      }
      this.compareFn = compareFn;
    }
    return this.keyValues;
  }
  static ɵfac = function KeyValuePipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || KeyValuePipe)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__.KeyValueDiffers, 16));
  };
  static ɵpipe = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefinePipe"]({
    name: "keyvalue",
    type: KeyValuePipe,
    pure: false
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(KeyValuePipe, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Pipe,
    args: [{
      name: 'keyvalue',
      pure: false
    }]
  }], () => [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.KeyValueDiffers
  }], null);
})();
function defaultComparator(keyValueA, keyValueB) {
  const a = keyValueA.key;
  const b = keyValueB.key;
  if (a === b) return 0;
  if (a == null) return 1;
  if (b == null) return -1;
  if (typeof a == 'string' && typeof b == 'string') {
    return a < b ? -1 : 1;
  }
  if (typeof a == 'number' && typeof b == 'number') {
    return a - b;
  }
  if (typeof a == 'boolean' && typeof b == 'boolean') {
    return a < b ? -1 : 1;
  }
  const aString = String(a);
  const bString = String(b);
  return aString == bString ? 0 : aString < bString ? -1 : 1;
}
class DecimalPipe {
  _locale;
  constructor(_locale) {
    this._locale = _locale;
  }
  transform(value, digitsInfo, locale) {
    if (!isValue(value)) return null;
    locale ||= this._locale;
    try {
      const num = strToNumber(value);
      return formatNumber(num, locale, digitsInfo);
    } catch (error) {
      throw invalidPipeArgumentError(DecimalPipe, error.message);
    }
  }
  static ɵfac = function DecimalPipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || DecimalPipe)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.LOCALE_ID, 16));
  };
  static ɵpipe = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefinePipe"]({
    name: "number",
    type: DecimalPipe,
    pure: true
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(DecimalPipe, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Pipe,
    args: [{
      name: 'number'
    }]
  }], () => [{
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [_angular_core__WEBPACK_IMPORTED_MODULE_1__.LOCALE_ID]
    }]
  }], null);
})();
class PercentPipe {
  _locale;
  constructor(_locale) {
    this._locale = _locale;
  }
  transform(value, digitsInfo, locale) {
    if (!isValue(value)) return null;
    locale ||= this._locale;
    try {
      const num = strToNumber(value);
      return formatPercent(num, locale, digitsInfo);
    } catch (error) {
      throw invalidPipeArgumentError(PercentPipe, error.message);
    }
  }
  static ɵfac = function PercentPipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || PercentPipe)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.LOCALE_ID, 16));
  };
  static ɵpipe = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefinePipe"]({
    name: "percent",
    type: PercentPipe,
    pure: true
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(PercentPipe, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Pipe,
    args: [{
      name: 'percent'
    }]
  }], () => [{
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [_angular_core__WEBPACK_IMPORTED_MODULE_1__.LOCALE_ID]
    }]
  }], null);
})();
class CurrencyPipe {
  _locale;
  _defaultCurrencyCode;
  constructor(_locale, _defaultCurrencyCode = 'USD') {
    this._locale = _locale;
    this._defaultCurrencyCode = _defaultCurrencyCode;
  }
  transform(value, currencyCode = this._defaultCurrencyCode, display = 'symbol', digitsInfo, locale) {
    if (!isValue(value)) return null;
    locale ||= this._locale;
    if (typeof display === 'boolean') {
      if (typeof ngDevMode === 'undefined' || ngDevMode) {
        console.warn(`Warning: the currency pipe has been changed in Angular v5. The symbolDisplay option (third parameter) is now a string instead of a boolean. The accepted values are "code", "symbol" or "symbol-narrow".`);
      }
      display = display ? 'symbol' : 'code';
    }
    let currency = currencyCode || this._defaultCurrencyCode;
    if (display !== 'code') {
      if (display === 'symbol' || display === 'symbol-narrow') {
        currency = getCurrencySymbol(currency, display === 'symbol' ? 'wide' : 'narrow', locale);
      } else {
        currency = display;
      }
    }
    try {
      const num = strToNumber(value);
      return formatCurrency(num, locale, currency, currencyCode, digitsInfo);
    } catch (error) {
      throw invalidPipeArgumentError(CurrencyPipe, error.message);
    }
  }
  static ɵfac = function CurrencyPipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || CurrencyPipe)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.LOCALE_ID, 16), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CURRENCY_CODE, 16));
  };
  static ɵpipe = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefinePipe"]({
    name: "currency",
    type: CurrencyPipe,
    pure: true
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(CurrencyPipe, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Pipe,
    args: [{
      name: 'currency'
    }]
  }], () => [{
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [_angular_core__WEBPACK_IMPORTED_MODULE_1__.LOCALE_ID]
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
      args: [_angular_core__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CURRENCY_CODE]
    }]
  }], null);
})();
function isValue(value) {
  return !(value == null || value === '' || value !== value);
}
function strToNumber(value) {
  if (typeof value === 'string' && !isNaN(Number(value) - parseFloat(value))) {
    return Number(value);
  }
  if (typeof value !== 'number') {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(2309, ngDevMode && `${value} is not a number`);
  }
  return value;
}
class SlicePipe {
  transform(value, start, end) {
    if (value == null) return null;
    const supports = typeof value === 'string' || Array.isArray(value);
    if (!supports) {
      throw invalidPipeArgumentError(SlicePipe, value);
    }
    return value.slice(start, end);
  }
  static ɵfac = function SlicePipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || SlicePipe)();
  };
  static ɵpipe = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefinePipe"]({
    name: "slice",
    type: SlicePipe,
    pure: false
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(SlicePipe, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Pipe,
    args: [{
      name: 'slice',
      pure: false
    }]
  }], null, null);
})();
const COMMON_PIPES = [AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe, TitleCasePipe, CurrencyPipe, DatePipe, I18nPluralPipe, I18nSelectPipe, KeyValuePipe];
class CommonModule {
  static ɵfac = function CommonModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || CommonModule)();
  };
  static ɵmod = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
    type: CommonModule
  });
  static ɵinj = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({});
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(CommonModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgModule,
    args: [{
      imports: [COMMON_DIRECTIVES, COMMON_PIPES],
      exports: [COMMON_DIRECTIVES, COMMON_PIPES]
    }]
  }], null, null);
})();


/***/ }),

/***/ 5815:
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/util/EmptyError.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EmptyError: () => (/* binding */ EmptyError)
/* harmony export */ });
/* harmony import */ var _createErrorClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createErrorClass */ 8192);

const EmptyError = (0,_createErrorClass__WEBPACK_IMPORTED_MODULE_0__.createErrorClass)(_super => function EmptyErrorImpl() {
  _super(this);
  this.name = 'EmptyError';
  this.message = 'no elements in sequence';
});

/***/ }),

/***/ 5829:
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/observable/innerFrom.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fromArrayLike: () => (/* binding */ fromArrayLike),
/* harmony export */   fromAsyncIterable: () => (/* binding */ fromAsyncIterable),
/* harmony export */   fromInteropObservable: () => (/* binding */ fromInteropObservable),
/* harmony export */   fromIterable: () => (/* binding */ fromIterable),
/* harmony export */   fromPromise: () => (/* binding */ fromPromise),
/* harmony export */   fromReadableStreamLike: () => (/* binding */ fromReadableStreamLike),
/* harmony export */   innerFrom: () => (/* binding */ innerFrom)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ 945);
/* harmony import */ var _util_isArrayLike__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/isArrayLike */ 5102);
/* harmony import */ var _util_isPromise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/isPromise */ 3725);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Observable */ 1814);
/* harmony import */ var _util_isInteropObservable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/isInteropObservable */ 2572);
/* harmony import */ var _util_isAsyncIterable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/isAsyncIterable */ 7742);
/* harmony import */ var _util_throwUnobservableError__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/throwUnobservableError */ 9582);
/* harmony import */ var _util_isIterable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/isIterable */ 3008);
/* harmony import */ var _util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/isReadableStreamLike */ 9905);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util/isFunction */ 4010);
/* harmony import */ var _util_reportUnhandledError__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../util/reportUnhandledError */ 8083);
/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../symbol/observable */ 1935);












function innerFrom(input) {
  if (input instanceof _Observable__WEBPACK_IMPORTED_MODULE_3__.Observable) {
    return input;
  }
  if (input != null) {
    if ((0,_util_isInteropObservable__WEBPACK_IMPORTED_MODULE_4__.isInteropObservable)(input)) {
      return fromInteropObservable(input);
    }
    if ((0,_util_isArrayLike__WEBPACK_IMPORTED_MODULE_1__.isArrayLike)(input)) {
      return fromArrayLike(input);
    }
    if ((0,_util_isPromise__WEBPACK_IMPORTED_MODULE_2__.isPromise)(input)) {
      return fromPromise(input);
    }
    if ((0,_util_isAsyncIterable__WEBPACK_IMPORTED_MODULE_5__.isAsyncIterable)(input)) {
      return fromAsyncIterable(input);
    }
    if ((0,_util_isIterable__WEBPACK_IMPORTED_MODULE_7__.isIterable)(input)) {
      return fromIterable(input);
    }
    if ((0,_util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_8__.isReadableStreamLike)(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw (0,_util_throwUnobservableError__WEBPACK_IMPORTED_MODULE_6__.createInvalidObservableTypeError)(input);
}
function fromInteropObservable(obj) {
  return new _Observable__WEBPACK_IMPORTED_MODULE_3__.Observable(subscriber => {
    const obs = obj[_symbol_observable__WEBPACK_IMPORTED_MODULE_11__.observable]();
    if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_9__.isFunction)(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError('Provided object does not correctly implement Symbol.observable');
  });
}
function fromArrayLike(array) {
  return new _Observable__WEBPACK_IMPORTED_MODULE_3__.Observable(subscriber => {
    for (let i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new _Observable__WEBPACK_IMPORTED_MODULE_3__.Observable(subscriber => {
    promise.then(value => {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, err => subscriber.error(err)).then(null, _util_reportUnhandledError__WEBPACK_IMPORTED_MODULE_10__.reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new _Observable__WEBPACK_IMPORTED_MODULE_3__.Observable(subscriber => {
    for (const value of iterable) {
      subscriber.next(value);
      if (subscriber.closed) {
        return;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new _Observable__WEBPACK_IMPORTED_MODULE_3__.Observable(subscriber => {
    process(asyncIterable, subscriber).catch(err => subscriber.error(err));
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable((0,_util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_8__.readableStreamLikeToAsyncGenerator)(readableStream));
}
function process(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_1, _a;
  return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
    try {
      for (asyncIterable_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__asyncValues)(asyncIterable); asyncIterable_1_1 = yield asyncIterable_1.next(), !asyncIterable_1_1.done;) {
        const value = asyncIterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)) yield _a.call(asyncIterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}

/***/ }),

/***/ 5877:
/*!*************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@angular+core@21.0.5_@angular+compiler@21.0.5_rxjs@7.8.2_zone.js@0.16.0/node_modules/@angular/core/fesm2022/_attribute-chunk.mjs ***!
  \*************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Attribute: () => (/* binding */ Attribute)
/* harmony export */ });
/**
 * @license Angular v21.0.5
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */

const Attribute = {
  JSACTION: 'jsaction'
};


/***/ }),

/***/ 5913:
/*!************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@angular+service-worker@21.0.5_@angular+core@21.0.5_rxjs@7.8.2/node_modules/@angular/service-worker/fesm2022/service-worker.mjs ***!
  \************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ServiceWorkerModule: () => (/* binding */ ServiceWorkerModule),
/* harmony export */   SwPush: () => (/* binding */ SwPush),
/* harmony export */   SwRegistrationOptions: () => (/* binding */ SwRegistrationOptions),
/* harmony export */   SwUpdate: () => (/* binding */ SwUpdate),
/* harmony export */   provideServiceWorker: () => (/* binding */ provideServiceWorker)
/* harmony export */ });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ 64);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ 7367);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ 1814);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ 1171);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ 5711);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs/operators */ 4191);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs/operators */ 4063);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs/operators */ 9671);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs/operators */ 6942);
/**
 * @license Angular v21.0.5
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */





const ERR_SW_NOT_SUPPORTED = 'Service workers are disabled or not supported by this browser';
class NgswCommChannel {
  serviceWorker;
  worker;
  registration;
  events;
  constructor(serviceWorker, injector) {
    this.serviceWorker = serviceWorker;
    if (!serviceWorker) {
      this.worker = this.events = this.registration = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable(subscriber => subscriber.error(new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(5601, (typeof ngDevMode === 'undefined' || ngDevMode) && ERR_SW_NOT_SUPPORTED)));
    } else {
      let currentWorker = null;
      const workerSubject = new rxjs__WEBPACK_IMPORTED_MODULE_3__.Subject();
      this.worker = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable(subscriber => {
        if (currentWorker !== null) {
          subscriber.next(currentWorker);
        }
        return workerSubject.subscribe(v => subscriber.next(v));
      });
      const updateController = () => {
        const {
          controller
        } = serviceWorker;
        if (controller === null) {
          return;
        }
        currentWorker = controller;
        workerSubject.next(currentWorker);
      };
      serviceWorker.addEventListener('controllerchange', updateController);
      updateController();
      this.registration = this.worker.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.switchMap)(() => serviceWorker.getRegistration().then(registration => {
        if (!registration) {
          throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(5601, (typeof ngDevMode === 'undefined' || ngDevMode) && ERR_SW_NOT_SUPPORTED);
        }
        return registration;
      })));
      const _events = new rxjs__WEBPACK_IMPORTED_MODULE_3__.Subject();
      this.events = _events.asObservable();
      const messageListener = event => {
        const {
          data
        } = event;
        if (data?.type) {
          _events.next(data);
        }
      };
      serviceWorker.addEventListener('message', messageListener);
      const appRef = injector?.get(_angular_core__WEBPACK_IMPORTED_MODULE_1__.ApplicationRef, null, {
        optional: true
      });
      appRef?.onDestroy(() => {
        serviceWorker.removeEventListener('controllerchange', updateController);
        serviceWorker.removeEventListener('message', messageListener);
      });
    }
  }
  postMessage(action, payload) {
    return new Promise(resolve => {
      this.worker.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.take)(1)).subscribe(sw => {
        sw.postMessage({
          action,
          ...payload
        });
        resolve();
      });
    });
  }
  postMessageWithOperation(type, payload, operationNonce) {
    const waitForOperationCompleted = this.waitForOperationCompleted(operationNonce);
    const postMessage = this.postMessage(type, payload);
    return Promise.all([postMessage, waitForOperationCompleted]).then(([, result]) => result);
  }
  generateNonce() {
    return Math.round(Math.random() * 10000000);
  }
  eventsOfType(type) {
    let filterFn;
    if (typeof type === 'string') {
      filterFn = event => event.type === type;
    } else {
      filterFn = event => type.includes(event.type);
    }
    return this.events.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.filter)(filterFn));
  }
  nextEventOfType(type) {
    return this.eventsOfType(type).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.take)(1));
  }
  waitForOperationCompleted(nonce) {
    return new Promise((resolve, reject) => {
      this.eventsOfType('OPERATION_COMPLETED').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.filter)(event => event.nonce === nonce), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.take)(1), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.map)(event => {
        if (event.result !== undefined) {
          return event.result;
        }
        throw new Error(event.error);
      })).subscribe({
        next: resolve,
        error: reject
      });
    });
  }
  get isEnabled() {
    return !!this.serviceWorker;
  }
}
class SwPush {
  sw;
  messages;
  notificationClicks;
  notificationCloses;
  pushSubscriptionChanges;
  subscription;
  get isEnabled() {
    return this.sw.isEnabled;
  }
  pushManager = null;
  subscriptionChanges = new rxjs__WEBPACK_IMPORTED_MODULE_3__.Subject();
  constructor(sw) {
    this.sw = sw;
    if (!sw.isEnabled) {
      this.messages = rxjs__WEBPACK_IMPORTED_MODULE_4__.NEVER;
      this.notificationClicks = rxjs__WEBPACK_IMPORTED_MODULE_4__.NEVER;
      this.notificationCloses = rxjs__WEBPACK_IMPORTED_MODULE_4__.NEVER;
      this.pushSubscriptionChanges = rxjs__WEBPACK_IMPORTED_MODULE_4__.NEVER;
      this.subscription = rxjs__WEBPACK_IMPORTED_MODULE_4__.NEVER;
      return;
    }
    this.messages = this.sw.eventsOfType('PUSH').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.map)(message => message.data));
    this.notificationClicks = this.sw.eventsOfType('NOTIFICATION_CLICK').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.map)(message => message.data));
    this.notificationCloses = this.sw.eventsOfType('NOTIFICATION_CLOSE').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.map)(message => message.data));
    this.pushSubscriptionChanges = this.sw.eventsOfType('PUSH_SUBSCRIPTION_CHANGE').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.map)(message => message.data));
    this.pushManager = this.sw.registration.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.map)(registration => registration.pushManager));
    const workerDrivenSubscriptions = this.pushManager.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.switchMap)(pm => pm.getSubscription()));
    this.subscription = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable(subscriber => {
      const workerDrivenSubscription = workerDrivenSubscriptions.subscribe(subscriber);
      const subscriptionChanges = this.subscriptionChanges.subscribe(subscriber);
      return () => {
        workerDrivenSubscription.unsubscribe();
        subscriptionChanges.unsubscribe();
      };
    });
  }
  requestSubscription(options) {
    if (!this.sw.isEnabled || this.pushManager === null) {
      return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));
    }
    const pushOptions = {
      userVisibleOnly: true
    };
    let key = this.decodeBase64(options.serverPublicKey.replace(/_/g, '/').replace(/-/g, '+'));
    let applicationServerKey = new Uint8Array(new ArrayBuffer(key.length));
    for (let i = 0; i < key.length; i++) {
      applicationServerKey[i] = key.charCodeAt(i);
    }
    pushOptions.applicationServerKey = applicationServerKey;
    return new Promise((resolve, reject) => {
      this.pushManager.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.switchMap)(pm => pm.subscribe(pushOptions)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.take)(1)).subscribe({
        next: sub => {
          this.subscriptionChanges.next(sub);
          resolve(sub);
        },
        error: reject
      });
    });
  }
  unsubscribe() {
    if (!this.sw.isEnabled) {
      return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));
    }
    const doUnsubscribe = sub => {
      if (sub === null) {
        throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(5602, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Not subscribed to push notifications.');
      }
      return sub.unsubscribe().then(success => {
        if (!success) {
          throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(5603, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Unsubscribe failed!');
        }
        this.subscriptionChanges.next(null);
      });
    };
    return new Promise((resolve, reject) => {
      this.subscription.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.take)(1), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.switchMap)(doUnsubscribe)).subscribe({
        next: resolve,
        error: reject
      });
    });
  }
  decodeBase64(input) {
    return atob(input);
  }
  static ɵfac = function SwPush_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || SwPush)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](NgswCommChannel));
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: SwPush,
    factory: SwPush.ɵfac
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(SwPush, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable
  }], () => [{
    type: NgswCommChannel
  }], null);
})();
class SwUpdate {
  sw;
  versionUpdates;
  unrecoverable;
  get isEnabled() {
    return this.sw.isEnabled;
  }
  ongoingCheckForUpdate = null;
  constructor(sw) {
    this.sw = sw;
    if (!sw.isEnabled) {
      this.versionUpdates = rxjs__WEBPACK_IMPORTED_MODULE_4__.NEVER;
      this.unrecoverable = rxjs__WEBPACK_IMPORTED_MODULE_4__.NEVER;
      return;
    }
    this.versionUpdates = this.sw.eventsOfType(['VERSION_DETECTED', 'VERSION_INSTALLATION_FAILED', 'VERSION_READY', 'NO_NEW_VERSION_DETECTED']);
    this.unrecoverable = this.sw.eventsOfType('UNRECOVERABLE_STATE');
  }
  checkForUpdate() {
    if (!this.sw.isEnabled) {
      return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));
    }
    if (this.ongoingCheckForUpdate) {
      return this.ongoingCheckForUpdate;
    }
    const nonce = this.sw.generateNonce();
    this.ongoingCheckForUpdate = this.sw.postMessageWithOperation('CHECK_FOR_UPDATES', {
      nonce
    }, nonce).finally(() => {
      this.ongoingCheckForUpdate = null;
    });
    return this.ongoingCheckForUpdate;
  }
  activateUpdate() {
    if (!this.sw.isEnabled) {
      return Promise.reject(new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(5601, (typeof ngDevMode === 'undefined' || ngDevMode) && ERR_SW_NOT_SUPPORTED));
    }
    const nonce = this.sw.generateNonce();
    return this.sw.postMessageWithOperation('ACTIVATE_UPDATE', {
      nonce
    }, nonce);
  }
  static ɵfac = function SwUpdate_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || SwUpdate)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](NgswCommChannel));
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: SwUpdate,
    factory: SwUpdate.ɵfac
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(SwUpdate, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable
  }], () => [{
    type: NgswCommChannel
  }], null);
})();
const SCRIPT = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'NGSW_REGISTER_SCRIPT' : '');
function ngswAppInitializer() {
  if (typeof ngServerMode !== 'undefined' && ngServerMode) {
    return;
  }
  const options = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(SwRegistrationOptions);
  if (!('serviceWorker' in navigator && options.enabled !== false)) {
    return;
  }
  const script = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(SCRIPT);
  const ngZone = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone);
  const appRef = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.ApplicationRef);
  ngZone.runOutsideAngular(() => {
    const sw = navigator.serviceWorker;
    const onControllerChange = () => sw.controller?.postMessage({
      action: 'INITIALIZE'
    });
    sw.addEventListener('controllerchange', onControllerChange);
    appRef.onDestroy(() => {
      sw.removeEventListener('controllerchange', onControllerChange);
    });
  });
  ngZone.runOutsideAngular(() => {
    let readyToRegister;
    const {
      registrationStrategy
    } = options;
    if (typeof registrationStrategy === 'function') {
      readyToRegister = new Promise(resolve => registrationStrategy().subscribe(() => resolve()));
    } else {
      const [strategy, ...args] = (registrationStrategy || 'registerWhenStable:30000').split(':');
      switch (strategy) {
        case 'registerImmediately':
          readyToRegister = Promise.resolve();
          break;
        case 'registerWithDelay':
          readyToRegister = delayWithTimeout(+args[0] || 0);
          break;
        case 'registerWhenStable':
          readyToRegister = Promise.race([appRef.whenStable(), delayWithTimeout(+args[0])]);
          break;
        default:
          throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(5600, (typeof ngDevMode === 'undefined' || ngDevMode) && `Unknown ServiceWorker registration strategy: ${options.registrationStrategy}`);
      }
    }
    readyToRegister.then(() => {
      if (appRef.destroyed) {
        return;
      }
      navigator.serviceWorker.register(script, {
        scope: options.scope,
        updateViaCache: options.updateViaCache,
        type: options.type
      }).catch(err => console.error((0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.formatRuntimeError)(5604, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Service worker registration failed with: ' + err)));
    });
  });
}
function delayWithTimeout(timeout) {
  return new Promise(resolve => setTimeout(resolve, timeout));
}
function ngswCommChannelFactory() {
  const opts = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(SwRegistrationOptions);
  const injector = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Injector);
  const isBrowser = !(typeof ngServerMode !== 'undefined' && ngServerMode);
  return new NgswCommChannel(isBrowser && opts.enabled !== false ? navigator.serviceWorker : undefined, injector);
}
class SwRegistrationOptions {
  enabled;
  updateViaCache;
  type;
  scope;
  registrationStrategy;
}
function provideServiceWorker(script, options = {}) {
  return (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.makeEnvironmentProviders)([SwPush, SwUpdate, {
    provide: SCRIPT,
    useValue: script
  }, {
    provide: SwRegistrationOptions,
    useValue: options
  }, {
    provide: NgswCommChannel,
    useFactory: ngswCommChannelFactory
  }, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.provideAppInitializer)(ngswAppInitializer)]);
}
class ServiceWorkerModule {
  static register(script, options = {}) {
    return {
      ngModule: ServiceWorkerModule,
      providers: [provideServiceWorker(script, options)]
    };
  }
  static ɵfac = function ServiceWorkerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || ServiceWorkerModule)();
  };
  static ɵmod = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
    type: ServiceWorkerModule
  });
  static ɵinj = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
    providers: [SwPush, SwUpdate]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(ServiceWorkerModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgModule,
    args: [{
      providers: [SwPush, SwUpdate]
    }]
  }], null, null);
})();


/***/ }),

/***/ 6061:
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/operators/startWith.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   startWith: () => (/* binding */ startWith)
/* harmony export */ });
/* harmony import */ var _observable_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observable/concat */ 2473);
/* harmony import */ var _util_args__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/args */ 1683);
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/lift */ 8419);



function startWith(...values) {
  const scheduler = (0,_util_args__WEBPACK_IMPORTED_MODULE_1__.popScheduler)(values);
  return (0,_util_lift__WEBPACK_IMPORTED_MODULE_2__.operate)((source, subscriber) => {
    (scheduler ? (0,_observable_concat__WEBPACK_IMPORTED_MODULE_0__.concat)(values, source, scheduler) : (0,_observable_concat__WEBPACK_IMPORTED_MODULE_0__.concat)(values, source)).subscribe(subscriber);
  });
}

/***/ }),

/***/ 6275:
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/scheduler/timeoutProvider.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   timeoutProvider: () => (/* binding */ timeoutProvider)
/* harmony export */ });
const timeoutProvider = {
  setTimeout(handler, timeout, ...args) {
    const {
      delegate
    } = timeoutProvider;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout(handler, timeout, ...args);
    }
    return setTimeout(handler, timeout, ...args);
  },
  clearTimeout(handle) {
    const {
      delegate
    } = timeoutProvider;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: undefined
};

/***/ }),

/***/ 6709:
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/scheduled/schedulePromise.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   schedulePromise: () => (/* binding */ schedulePromise)
/* harmony export */ });
/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observable/innerFrom */ 5829);
/* harmony import */ var _operators_observeOn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../operators/observeOn */ 7328);
/* harmony import */ var _operators_subscribeOn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../operators/subscribeOn */ 1584);



function schedulePromise(input, scheduler) {
  return (0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_0__.innerFrom)(input).pipe((0,_operators_subscribeOn__WEBPACK_IMPORTED_MODULE_2__.subscribeOn)(scheduler), (0,_operators_observeOn__WEBPACK_IMPORTED_MODULE_1__.observeOn)(scheduler));
}

/***/ }),

/***/ 6711:
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/util/isObservable.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isObservable: () => (/* binding */ isObservable)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ 1814);
/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction */ 4010);


function isObservable(obj) {
  return !!obj && (obj instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable || (0,_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(obj.lift) && (0,_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(obj.subscribe));
}

/***/ }),

/***/ 6809:
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/scheduled/scheduleArray.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   scheduleArray: () => (/* binding */ scheduleArray)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ 1814);

function scheduleArray(input, scheduler) {
  return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(subscriber => {
    let i = 0;
    return scheduler.schedule(function () {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}

/***/ }),

/***/ 6838:
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/scheduled/scheduleAsyncIterable.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   scheduleAsyncIterable: () => (/* binding */ scheduleAsyncIterable)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ 1814);
/* harmony import */ var _util_executeSchedule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/executeSchedule */ 3494);


function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error('Iterable cannot be null');
  }
  return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(subscriber => {
    (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_1__.executeSchedule)(subscriber, scheduler, () => {
      const iterator = input[Symbol.asyncIterator]();
      (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_1__.executeSchedule)(subscriber, scheduler, () => {
        iterator.next().then(result => {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}

/***/ }),

/***/ 6924:
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/operators/takeUntil.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   takeUntil: () => (/* binding */ takeUntil)
/* harmony export */ });
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ 8419);
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OperatorSubscriber */ 3943);
/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../observable/innerFrom */ 5829);
/* harmony import */ var _util_noop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/noop */ 1918);




function takeUntil(notifier) {
  return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)((source, subscriber) => {
    (0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_2__.innerFrom)(notifier).subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, () => subscriber.complete(), _util_noop__WEBPACK_IMPORTED_MODULE_3__.noop));
    !subscriber.closed && source.subscribe(subscriber);
  });
}

/***/ }),

/***/ 6942:
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/operators/take.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   take: () => (/* binding */ take)
/* harmony export */ });
/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observable/empty */ 5672);
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/lift */ 8419);
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OperatorSubscriber */ 3943);



function take(count) {
  return count <= 0 ? () => _observable_empty__WEBPACK_IMPORTED_MODULE_0__.EMPTY : (0,_util_lift__WEBPACK_IMPORTED_MODULE_1__.operate)((source, subscriber) => {
    let seen = 0;
    source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__.createOperatorSubscriber)(subscriber, value => {
      if (++seen <= count) {
        subscriber.next(value);
        if (count <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}

/***/ }),

/***/ 7049:
/*!************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@angular+core@21.0.5_@angular+compiler@21.0.5_rxjs@7.8.2_zone.js@0.16.0/node_modules/@angular/core/fesm2022/_weak_ref-chunk.mjs ***!
  \************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   setAlternateWeakRefImpl: () => (/* binding */ setAlternateWeakRefImpl)
/* harmony export */ });
/**
 * @license Angular v21.0.5
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */

function setAlternateWeakRefImpl(impl) {}


/***/ }),

/***/ 7157:
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/Subscriber.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EMPTY_OBSERVER: () => (/* binding */ EMPTY_OBSERVER),
/* harmony export */   SafeSubscriber: () => (/* binding */ SafeSubscriber),
/* harmony export */   Subscriber: () => (/* binding */ Subscriber)
/* harmony export */ });
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/isFunction */ 4010);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Subscription */ 1038);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config */ 1157);
/* harmony import */ var _util_reportUnhandledError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/reportUnhandledError */ 8083);
/* harmony import */ var _util_noop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util/noop */ 1918);
/* harmony import */ var _NotificationFactories__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./NotificationFactories */ 1676);
/* harmony import */ var _scheduler_timeoutProvider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./scheduler/timeoutProvider */ 6275);
/* harmony import */ var _util_errorContext__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./util/errorContext */ 7831);








class Subscriber extends _Subscription__WEBPACK_IMPORTED_MODULE_1__.Subscription {
  constructor(destination) {
    super();
    this.isStopped = false;
    if (destination) {
      this.destination = destination;
      if ((0,_Subscription__WEBPACK_IMPORTED_MODULE_1__.isSubscription)(destination)) {
        destination.add(this);
      }
    } else {
      this.destination = EMPTY_OBSERVER;
    }
  }
  static create(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  }
  next(value) {
    if (this.isStopped) {
      handleStoppedNotification((0,_NotificationFactories__WEBPACK_IMPORTED_MODULE_5__.nextNotification)(value), this);
    } else {
      this._next(value);
    }
  }
  error(err) {
    if (this.isStopped) {
      handleStoppedNotification((0,_NotificationFactories__WEBPACK_IMPORTED_MODULE_5__.errorNotification)(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  }
  complete() {
    if (this.isStopped) {
      handleStoppedNotification(_NotificationFactories__WEBPACK_IMPORTED_MODULE_5__.COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  }
  unsubscribe() {
    if (!this.closed) {
      this.isStopped = true;
      super.unsubscribe();
      this.destination = null;
    }
  }
  _next(value) {
    this.destination.next(value);
  }
  _error(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  }
  _complete() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }
}
const _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
class ConsumerObserver {
  constructor(partialObserver) {
    this.partialObserver = partialObserver;
  }
  next(value) {
    const {
      partialObserver
    } = this;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  }
  error(err) {
    const {
      partialObserver
    } = this;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  }
  complete() {
    const {
      partialObserver
    } = this;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  }
}
class SafeSubscriber extends Subscriber {
  constructor(observerOrNext, error, complete) {
    super();
    let partialObserver;
    if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined,
        error: error !== null && error !== void 0 ? error : undefined,
        complete: complete !== null && complete !== void 0 ? complete : undefined
      };
    } else {
      let context;
      if (this && _config__WEBPACK_IMPORTED_MODULE_2__.config.useDeprecatedNextContext) {
        context = Object.create(observerOrNext);
        context.unsubscribe = () => this.unsubscribe();
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context),
          error: observerOrNext.error && bind(observerOrNext.error, context),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    this.destination = new ConsumerObserver(partialObserver);
  }
}
function handleUnhandledError(error) {
  if (_config__WEBPACK_IMPORTED_MODULE_2__.config.useDeprecatedSynchronousErrorHandling) {
    (0,_util_errorContext__WEBPACK_IMPORTED_MODULE_7__.captureError)(error);
  } else {
    (0,_util_reportUnhandledError__WEBPACK_IMPORTED_MODULE_3__.reportUnhandledError)(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  const {
    onStoppedNotification
  } = _config__WEBPACK_IMPORTED_MODULE_2__.config;
  onStoppedNotification && _scheduler_timeoutProvider__WEBPACK_IMPORTED_MODULE_6__.timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));
}
const EMPTY_OBSERVER = {
  closed: true,
  next: _util_noop__WEBPACK_IMPORTED_MODULE_4__.noop,
  error: defaultErrorHandler,
  complete: _util_noop__WEBPACK_IMPORTED_MODULE_4__.noop
};

/***/ }),

/***/ 7223:
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/util/arrRemove.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arrRemove: () => (/* binding */ arrRemove)
/* harmony export */ });
function arrRemove(arr, item) {
  if (arr) {
    const index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

/***/ }),

/***/ 7244:
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/util/UnsubscriptionError.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UnsubscriptionError: () => (/* binding */ UnsubscriptionError)
/* harmony export */ });
/* harmony import */ var _createErrorClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createErrorClass */ 8192);

const UnsubscriptionError = (0,_createErrorClass__WEBPACK_IMPORTED_MODULE_0__.createErrorClass)(_super => function UnsubscriptionErrorImpl(errors) {
  _super(this);
  this.message = errors ? `${errors.length} errors occurred during unsubscription:
${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\n  ')}` : '';
  this.name = 'UnsubscriptionError';
  this.errors = errors;
});

/***/ }),

/***/ 7328:
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/operators/observeOn.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   observeOn: () => (/* binding */ observeOn)
/* harmony export */ });
/* harmony import */ var _util_executeSchedule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/executeSchedule */ 3494);
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/lift */ 8419);
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OperatorSubscriber */ 3943);



function observeOn(scheduler, delay = 0) {
  return (0,_util_lift__WEBPACK_IMPORTED_MODULE_1__.operate)((source, subscriber) => {
    source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__.createOperatorSubscriber)(subscriber, value => (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_0__.executeSchedule)(subscriber, scheduler, () => subscriber.next(value), delay), () => (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_0__.executeSchedule)(subscriber, scheduler, () => subscriber.complete(), delay), err => (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_0__.executeSchedule)(subscriber, scheduler, () => subscriber.error(err), delay)));
  });
}

/***/ }),

/***/ 7367:
/*!**************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@angular+core@21.0.5_@angular+compiler@21.0.5_rxjs@7.8.2_zone.js@0.16.0/node_modules/@angular/core/fesm2022/_debug_node-chunk.mjs ***!
  \**************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AFTER_RENDER_PHASES: () => (/* binding */ AFTER_RENDER_PHASES),
/* harmony export */   ANIMATIONS_DISABLED: () => (/* binding */ ANIMATIONS_DISABLED),
/* harmony export */   ANIMATION_MODULE_TYPE: () => (/* binding */ ANIMATION_MODULE_TYPE),
/* harmony export */   APP_BOOTSTRAP_LISTENER: () => (/* binding */ APP_BOOTSTRAP_LISTENER),
/* harmony export */   APP_ID: () => (/* binding */ APP_ID),
/* harmony export */   APP_INITIALIZER: () => (/* binding */ APP_INITIALIZER),
/* harmony export */   AcxChangeDetectionStrategy: () => (/* binding */ AcxChangeDetectionStrategy),
/* harmony export */   AcxViewEncapsulation: () => (/* binding */ AcxViewEncapsulation),
/* harmony export */   AfterRenderImpl: () => (/* binding */ AfterRenderImpl),
/* harmony export */   AfterRenderManager: () => (/* binding */ AfterRenderManager),
/* harmony export */   AfterRenderSequence: () => (/* binding */ AfterRenderSequence),
/* harmony export */   ApplicationInitStatus: () => (/* binding */ ApplicationInitStatus),
/* harmony export */   ApplicationRef: () => (/* binding */ ApplicationRef),
/* harmony export */   Attribute: () => (/* binding */ Attribute),
/* harmony export */   COMPILER_OPTIONS: () => (/* binding */ COMPILER_OPTIONS),
/* harmony export */   CONTAINERS: () => (/* binding */ CONTAINERS),
/* harmony export */   CSP_NONCE: () => (/* binding */ CSP_NONCE),
/* harmony export */   CUSTOM_ELEMENTS_SCHEMA: () => (/* binding */ CUSTOM_ELEMENTS_SCHEMA),
/* harmony export */   ChangeDetectionSchedulerImpl: () => (/* binding */ ChangeDetectionSchedulerImpl),
/* harmony export */   ChangeDetectionStrategy: () => (/* binding */ ChangeDetectionStrategy),
/* harmony export */   Compiler: () => (/* binding */ Compiler),
/* harmony export */   CompilerFactory: () => (/* binding */ CompilerFactory),
/* harmony export */   Component: () => (/* binding */ Component),
/* harmony export */   ComponentFactory: () => (/* binding */ ComponentFactory),
/* harmony export */   ComponentFactory$1: () => (/* binding */ ComponentFactory$1),
/* harmony export */   ComponentFactoryResolver: () => (/* binding */ ComponentFactoryResolver$1),
/* harmony export */   ComponentRef: () => (/* binding */ ComponentRef$1),
/* harmony export */   ComponentRef$1: () => (/* binding */ ComponentRef),
/* harmony export */   Console: () => (/* binding */ Console),
/* harmony export */   DEFAULT_CURRENCY_CODE: () => (/* binding */ DEFAULT_CURRENCY_CODE),
/* harmony export */   DEFAULT_LOCALE_ID: () => (/* binding */ DEFAULT_LOCALE_ID),
/* harmony export */   DEFER_BLOCK_CONFIG: () => (/* binding */ DEFER_BLOCK_CONFIG),
/* harmony export */   DEFER_BLOCK_DEPENDENCY_INTERCEPTOR: () => (/* binding */ DEFER_BLOCK_DEPENDENCY_INTERCEPTOR),
/* harmony export */   DEFER_BLOCK_ID: () => (/* binding */ DEFER_BLOCK_ID),
/* harmony export */   DEFER_BLOCK_SSR_ID_ATTRIBUTE: () => (/* binding */ DEFER_BLOCK_SSR_ID_ATTRIBUTE),
/* harmony export */   DEFER_BLOCK_STATE: () => (/* binding */ DEFER_BLOCK_STATE$1),
/* harmony export */   DEFER_BLOCK_STATE$1: () => (/* binding */ DEFER_BLOCK_STATE),
/* harmony export */   DEFER_HYDRATE_TRIGGERS: () => (/* binding */ DEFER_HYDRATE_TRIGGERS),
/* harmony export */   DEFER_PARENT_BLOCK_ID: () => (/* binding */ DEFER_PARENT_BLOCK_ID),
/* harmony export */   DEHYDRATED_BLOCK_REGISTRY: () => (/* binding */ DEHYDRATED_BLOCK_REGISTRY),
/* harmony export */   DISCONNECTED_NODES: () => (/* binding */ DISCONNECTED_NODES),
/* harmony export */   DebugElement: () => (/* binding */ DebugElement),
/* harmony export */   DebugEventListener: () => (/* binding */ DebugEventListener),
/* harmony export */   DebugNode: () => (/* binding */ DebugNode),
/* harmony export */   DeferBlockBehavior: () => (/* binding */ DeferBlockBehavior),
/* harmony export */   DeferBlockState: () => (/* binding */ DeferBlockState),
/* harmony export */   DehydratedBlockRegistry: () => (/* binding */ DehydratedBlockRegistry),
/* harmony export */   Directive: () => (/* binding */ Directive),
/* harmony export */   ELEMENT_CONTAINERS: () => (/* binding */ ELEMENT_CONTAINERS),
/* harmony export */   EVENT_REPLAY_ENABLED_DEFAULT: () => (/* binding */ EVENT_REPLAY_ENABLED_DEFAULT),
/* harmony export */   ElementRef: () => (/* binding */ ElementRef),
/* harmony export */   EnvironmentNgModuleRefAdapter: () => (/* binding */ EnvironmentNgModuleRefAdapter),
/* harmony export */   Host: () => (/* binding */ Host),
/* harmony export */   HostBinding: () => (/* binding */ HostBinding),
/* harmony export */   HostListener: () => (/* binding */ HostListener),
/* harmony export */   HydrationStatus: () => (/* binding */ HydrationStatus),
/* harmony export */   I18N_DATA: () => (/* binding */ I18N_DATA),
/* harmony export */   IMAGE_CONFIG: () => (/* binding */ IMAGE_CONFIG),
/* harmony export */   IMAGE_CONFIG_DEFAULTS: () => (/* binding */ IMAGE_CONFIG_DEFAULTS),
/* harmony export */   IS_ENABLED_BLOCKING_INITIAL_NAVIGATION: () => (/* binding */ IS_ENABLED_BLOCKING_INITIAL_NAVIGATION),
/* harmony export */   IS_EVENT_REPLAY_ENABLED: () => (/* binding */ IS_EVENT_REPLAY_ENABLED),
/* harmony export */   IS_HYDRATION_DOM_REUSE_ENABLED: () => (/* binding */ IS_HYDRATION_DOM_REUSE_ENABLED),
/* harmony export */   IS_I18N_HYDRATION_ENABLED: () => (/* binding */ IS_I18N_HYDRATION_ENABLED),
/* harmony export */   IS_INCREMENTAL_HYDRATION_ENABLED: () => (/* binding */ IS_INCREMENTAL_HYDRATION_ENABLED),
/* harmony export */   Inject: () => (/* binding */ Inject),
/* harmony export */   Injectable: () => (/* binding */ Injectable),
/* harmony export */   Input: () => (/* binding */ Input),
/* harmony export */   JSACTION_BLOCK_ELEMENT_MAP: () => (/* binding */ JSACTION_BLOCK_ELEMENT_MAP),
/* harmony export */   JSACTION_EVENT_CONTRACT: () => (/* binding */ JSACTION_EVENT_CONTRACT),
/* harmony export */   LContext: () => (/* binding */ LContext),
/* harmony export */   LOCALE_ID: () => (/* binding */ LOCALE_ID),
/* harmony export */   LocaleDataIndex: () => (/* binding */ LocaleDataIndex),
/* harmony export */   MAX_ANIMATION_TIMEOUT: () => (/* binding */ MAX_ANIMATION_TIMEOUT),
/* harmony export */   MULTIPLIER: () => (/* binding */ MULTIPLIER),
/* harmony export */   MissingTranslationStrategy: () => (/* binding */ MissingTranslationStrategy),
/* harmony export */   ModuleWithComponentFactories: () => (/* binding */ ModuleWithComponentFactories),
/* harmony export */   NGH_ATTR_NAME: () => (/* binding */ NGH_ATTR_NAME),
/* harmony export */   NGH_DATA_KEY: () => (/* binding */ NGH_DATA_KEY),
/* harmony export */   NGH_DEFER_BLOCKS_KEY: () => (/* binding */ NGH_DEFER_BLOCKS_KEY),
/* harmony export */   NODES: () => (/* binding */ NODES),
/* harmony export */   NOOP_AFTER_RENDER_REF: () => (/* binding */ NOOP_AFTER_RENDER_REF),
/* harmony export */   NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR: () => (/* binding */ NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR),
/* harmony export */   NO_CHANGE: () => (/* binding */ NO_CHANGE),
/* harmony export */   NO_ERRORS_SCHEMA: () => (/* binding */ NO_ERRORS_SCHEMA),
/* harmony export */   NUM_ROOT_NODES: () => (/* binding */ NUM_ROOT_NODES),
/* harmony export */   NgModule: () => (/* binding */ NgModule),
/* harmony export */   NgModuleFactory: () => (/* binding */ NgModuleFactory),
/* harmony export */   NgModuleFactory$1: () => (/* binding */ NgModuleFactory$1),
/* harmony export */   NgModuleRef: () => (/* binding */ NgModuleRef),
/* harmony export */   NgModuleRef$1: () => (/* binding */ NgModuleRef$1),
/* harmony export */   Optional: () => (/* binding */ Optional),
/* harmony export */   Output: () => (/* binding */ Output),
/* harmony export */   PLATFORM_ID: () => (/* binding */ PLATFORM_ID),
/* harmony export */   PLATFORM_INITIALIZER: () => (/* binding */ PLATFORM_INITIALIZER),
/* harmony export */   PRESERVE_HOST_CONTENT: () => (/* binding */ PRESERVE_HOST_CONTENT),
/* harmony export */   Pipe: () => (/* binding */ Pipe),
/* harmony export */   ProfilerEvent: () => (/* binding */ ProfilerEvent),
/* harmony export */   QueryList: () => (/* binding */ QueryList),
/* harmony export */   ReflectionCapabilities: () => (/* binding */ ReflectionCapabilities),
/* harmony export */   Renderer2: () => (/* binding */ Renderer2),
/* harmony export */   RendererFactory2: () => (/* binding */ RendererFactory2),
/* harmony export */   RendererStyleFlags2: () => (/* binding */ RendererStyleFlags2),
/* harmony export */   SKIP_HYDRATION_ATTR_NAME: () => (/* binding */ SKIP_HYDRATION_ATTR_NAME),
/* harmony export */   SSR_CONTENT_INTEGRITY_MARKER: () => (/* binding */ SSR_CONTENT_INTEGRITY_MARKER),
/* harmony export */   Sanitizer: () => (/* binding */ Sanitizer),
/* harmony export */   SecurityContext: () => (/* binding */ SecurityContext),
/* harmony export */   Self: () => (/* binding */ Self),
/* harmony export */   SimpleChange: () => (/* binding */ SimpleChange),
/* harmony export */   SkipSelf: () => (/* binding */ SkipSelf),
/* harmony export */   TEMPLATES: () => (/* binding */ TEMPLATES),
/* harmony export */   TEMPLATE_ID: () => (/* binding */ TEMPLATE_ID),
/* harmony export */   TESTABILITY: () => (/* binding */ TESTABILITY),
/* harmony export */   TESTABILITY_GETTER: () => (/* binding */ TESTABILITY_GETTER),
/* harmony export */   TRANSLATIONS: () => (/* binding */ TRANSLATIONS),
/* harmony export */   TRANSLATIONS_FORMAT: () => (/* binding */ TRANSLATIONS_FORMAT),
/* harmony export */   TemplateRef: () => (/* binding */ TemplateRef),
/* harmony export */   Testability: () => (/* binding */ Testability),
/* harmony export */   TestabilityRegistry: () => (/* binding */ TestabilityRegistry),
/* harmony export */   TimerScheduler: () => (/* binding */ TimerScheduler),
/* harmony export */   TracingAction: () => (/* binding */ TracingAction),
/* harmony export */   TracingService: () => (/* binding */ TracingService),
/* harmony export */   TransferState: () => (/* binding */ TransferState),
/* harmony export */   Type: () => (/* binding */ Type),
/* harmony export */   UseExhaustiveCheckNoChanges: () => (/* binding */ UseExhaustiveCheckNoChanges),
/* harmony export */   ViewContainerRef: () => (/* binding */ ViewContainerRef),
/* harmony export */   ViewEncapsulation: () => (/* binding */ ViewEncapsulation),
/* harmony export */   ViewRef: () => (/* binding */ ViewRef),
/* harmony export */   _sanitizeHtml: () => (/* binding */ _sanitizeHtml),
/* harmony export */   _sanitizeUrl: () => (/* binding */ _sanitizeUrl),
/* harmony export */   afterEveryRender: () => (/* binding */ afterEveryRender),
/* harmony export */   afterNextRender: () => (/* binding */ afterNextRender),
/* harmony export */   allLeavingAnimations: () => (/* binding */ allLeavingAnimations),
/* harmony export */   allowSanitizationBypassAndThrow: () => (/* binding */ allowSanitizationBypassAndThrow),
/* harmony export */   angularCoreEnv: () => (/* binding */ angularCoreEnv),
/* harmony export */   appendDeferBlocksToJSActionMap: () => (/* binding */ appendDeferBlocksToJSActionMap),
/* harmony export */   asNativeElements: () => (/* binding */ asNativeElements),
/* harmony export */   assertComponentDef: () => (/* binding */ assertComponentDef),
/* harmony export */   assertStandaloneComponentType: () => (/* binding */ assertStandaloneComponentType),
/* harmony export */   bypassSanitizationTrustHtml: () => (/* binding */ bypassSanitizationTrustHtml),
/* harmony export */   bypassSanitizationTrustResourceUrl: () => (/* binding */ bypassSanitizationTrustResourceUrl),
/* harmony export */   bypassSanitizationTrustScript: () => (/* binding */ bypassSanitizationTrustScript),
/* harmony export */   bypassSanitizationTrustStyle: () => (/* binding */ bypassSanitizationTrustStyle),
/* harmony export */   bypassSanitizationTrustUrl: () => (/* binding */ bypassSanitizationTrustUrl),
/* harmony export */   calcPathForNode: () => (/* binding */ calcPathForNode),
/* harmony export */   checkNoChangesInternal: () => (/* binding */ checkNoChangesInternal),
/* harmony export */   cleanupDehydratedViews: () => (/* binding */ cleanupDehydratedViews),
/* harmony export */   clearResolutionOfComponentResourcesQueue: () => (/* binding */ clearResolutionOfComponentResourcesQueue),
/* harmony export */   collectNativeNodes: () => (/* binding */ collectNativeNodes),
/* harmony export */   collectNativeNodesInLContainer: () => (/* binding */ collectNativeNodesInLContainer),
/* harmony export */   compileComponent: () => (/* binding */ compileComponent),
/* harmony export */   compileDirective: () => (/* binding */ compileDirective),
/* harmony export */   compileNgModule: () => (/* binding */ compileNgModule),
/* harmony export */   compileNgModuleDefs: () => (/* binding */ compileNgModuleDefs),
/* harmony export */   compilePipe: () => (/* binding */ compilePipe),
/* harmony export */   convertHydrateTriggersToJsAction: () => (/* binding */ convertHydrateTriggersToJsAction),
/* harmony export */   countBlocksSkippedByHydration: () => (/* binding */ countBlocksSkippedByHydration),
/* harmony export */   createEnvironmentInjector: () => (/* binding */ createEnvironmentInjector),
/* harmony export */   createMultiResultQuerySignalFn: () => (/* binding */ createMultiResultQuerySignalFn),
/* harmony export */   createNgModule: () => (/* binding */ createNgModule),
/* harmony export */   createNgModuleRef: () => (/* binding */ createNgModuleRef),
/* harmony export */   createNgModuleRefWithProviders: () => (/* binding */ createNgModuleRefWithProviders),
/* harmony export */   createSingleResultOptionalQuerySignalFn: () => (/* binding */ createSingleResultOptionalQuerySignalFn),
/* harmony export */   createSingleResultRequiredQuerySignalFn: () => (/* binding */ createSingleResultRequiredQuerySignalFn),
/* harmony export */   depsTracker: () => (/* binding */ depsTracker),
/* harmony export */   devModeEqual: () => (/* binding */ devModeEqual),
/* harmony export */   enableApplyRootElementTransformImpl: () => (/* binding */ enableApplyRootElementTransformImpl),
/* harmony export */   enableClaimDehydratedIcuCaseImpl: () => (/* binding */ enableClaimDehydratedIcuCaseImpl),
/* harmony export */   enableFindMatchingDehydratedViewImpl: () => (/* binding */ enableFindMatchingDehydratedViewImpl),
/* harmony export */   enableLocateOrCreateContainerAnchorImpl: () => (/* binding */ enableLocateOrCreateContainerAnchorImpl),
/* harmony export */   enableLocateOrCreateContainerRefImpl: () => (/* binding */ enableLocateOrCreateContainerRefImpl),
/* harmony export */   enableLocateOrCreateElementContainerNodeImpl: () => (/* binding */ enableLocateOrCreateElementContainerNodeImpl),
/* harmony export */   enableLocateOrCreateElementNodeImpl: () => (/* binding */ enableLocateOrCreateElementNodeImpl),
/* harmony export */   enableLocateOrCreateI18nNodeImpl: () => (/* binding */ enableLocateOrCreateI18nNodeImpl),
/* harmony export */   enableLocateOrCreateTextNodeImpl: () => (/* binding */ enableLocateOrCreateTextNodeImpl),
/* harmony export */   enablePrepareI18nBlockForHydrationImpl: () => (/* binding */ enablePrepareI18nBlockForHydrationImpl),
/* harmony export */   enableProfiling: () => (/* binding */ enableProfiling),
/* harmony export */   enableRetrieveDeferBlockDataImpl: () => (/* binding */ enableRetrieveDeferBlockDataImpl),
/* harmony export */   enableRetrieveHydrationInfoImpl: () => (/* binding */ enableRetrieveHydrationInfoImpl),
/* harmony export */   enableStashEventListenerImpl: () => (/* binding */ enableStashEventListenerImpl),
/* harmony export */   findLocaleData: () => (/* binding */ findLocaleData),
/* harmony export */   flushModuleScopingQueueAsMuchAsPossible: () => (/* binding */ flushModuleScopingQueueAsMuchAsPossible),
/* harmony export */   gatherDeferBlocksCommentNodes: () => (/* binding */ gatherDeferBlocksCommentNodes),
/* harmony export */   generateStandaloneInDeclarationsError: () => (/* binding */ generateStandaloneInDeclarationsError),
/* harmony export */   getAsyncClassMetadataFn: () => (/* binding */ getAsyncClassMetadataFn),
/* harmony export */   getCompilerFacade: () => (/* binding */ getCompilerFacade),
/* harmony export */   getDebugNode: () => (/* binding */ getDebugNode),
/* harmony export */   getDeferBlocks: () => (/* binding */ getDeferBlocks$1),
/* harmony export */   getDirectives: () => (/* binding */ getDirectives),
/* harmony export */   getDocument: () => (/* binding */ getDocument),
/* harmony export */   getHostElement: () => (/* binding */ getHostElement),
/* harmony export */   getLContext: () => (/* binding */ getLContext),
/* harmony export */   getLDeferBlockDetails: () => (/* binding */ getLDeferBlockDetails),
/* harmony export */   getLNodeForHydration: () => (/* binding */ getLNodeForHydration),
/* harmony export */   getLocaleCurrencyCode: () => (/* binding */ getLocaleCurrencyCode),
/* harmony export */   getLocalePluralCase: () => (/* binding */ getLocalePluralCase),
/* harmony export */   getOrComputeI18nChildren: () => (/* binding */ getOrComputeI18nChildren),
/* harmony export */   getRegisteredNgModuleType: () => (/* binding */ getRegisteredNgModuleType),
/* harmony export */   getSanitizationBypassType: () => (/* binding */ getSanitizationBypassType),
/* harmony export */   getTDeferBlockDetails: () => (/* binding */ getTDeferBlockDetails),
/* harmony export */   getTransferState: () => (/* binding */ getTransferState),
/* harmony export */   inferTagNameFromDefinition: () => (/* binding */ inferTagNameFromDefinition),
/* harmony export */   inputBinding: () => (/* binding */ inputBinding),
/* harmony export */   invokeListeners: () => (/* binding */ invokeListeners),
/* harmony export */   isBoundToModule: () => (/* binding */ isBoundToModule),
/* harmony export */   isComponentDefPendingResolution: () => (/* binding */ isComponentDefPendingResolution),
/* harmony export */   isComponentResourceResolutionQueueEmpty: () => (/* binding */ isComponentResourceResolutionQueueEmpty),
/* harmony export */   isDeferBlock: () => (/* binding */ isDeferBlock),
/* harmony export */   isDetachedByI18n: () => (/* binding */ isDetachedByI18n),
/* harmony export */   isDisconnectedNode: () => (/* binding */ isDisconnectedNode),
/* harmony export */   isI18nHydrationEnabled: () => (/* binding */ isI18nHydrationEnabled),
/* harmony export */   isI18nHydrationSupportEnabled: () => (/* binding */ isI18nHydrationSupportEnabled),
/* harmony export */   isInSkipHydrationBlock: () => (/* binding */ isInSkipHydrationBlock),
/* harmony export */   isIncrementalHydrationEnabled: () => (/* binding */ isIncrementalHydrationEnabled),
/* harmony export */   isJsObject: () => (/* binding */ isJsObject),
/* harmony export */   isLetDeclaration: () => (/* binding */ isLetDeclaration),
/* harmony export */   isListLikeIterable: () => (/* binding */ isListLikeIterable),
/* harmony export */   isNgModule: () => (/* binding */ isNgModule),
/* harmony export */   isPromise: () => (/* binding */ isPromise),
/* harmony export */   isSignal: () => (/* binding */ isSignal),
/* harmony export */   isSubscribable: () => (/* binding */ isSubscribable),
/* harmony export */   isTNodeShape: () => (/* binding */ isTNodeShape),
/* harmony export */   isViewDirty: () => (/* binding */ isViewDirty),
/* harmony export */   isWritableSignal: () => (/* binding */ isWritableSignal),
/* harmony export */   iterateListLike: () => (/* binding */ iterateListLike),
/* harmony export */   makePropDecorator: () => (/* binding */ makePropDecorator),
/* harmony export */   makeStateKey: () => (/* binding */ makeStateKey),
/* harmony export */   markForRefresh: () => (/* binding */ markForRefresh),
/* harmony export */   noSideEffects: () => (/* binding */ noSideEffects),
/* harmony export */   optionsReducer: () => (/* binding */ optionsReducer),
/* harmony export */   outputBinding: () => (/* binding */ outputBinding),
/* harmony export */   patchComponentDefWithScope: () => (/* binding */ patchComponentDefWithScope),
/* harmony export */   performanceMarkFeature: () => (/* binding */ performanceMarkFeature),
/* harmony export */   processAndInitTriggers: () => (/* binding */ processAndInitTriggers),
/* harmony export */   processBlockData: () => (/* binding */ processBlockData),
/* harmony export */   processTextNodeBeforeSerialization: () => (/* binding */ processTextNodeBeforeSerialization),
/* harmony export */   profiler: () => (/* binding */ profiler),
/* harmony export */   provideAppInitializer: () => (/* binding */ provideAppInitializer),
/* harmony export */   provideNgReflectAttributes: () => (/* binding */ provideNgReflectAttributes),
/* harmony export */   provideZonelessChangeDetection: () => (/* binding */ provideZonelessChangeDetection),
/* harmony export */   provideZonelessChangeDetectionInternal: () => (/* binding */ provideZonelessChangeDetectionInternal),
/* harmony export */   publishDefaultGlobalUtils: () => (/* binding */ publishDefaultGlobalUtils),
/* harmony export */   publishExternalGlobalUtil: () => (/* binding */ publishExternalGlobalUtil),
/* harmony export */   publishSignalConfiguration: () => (/* binding */ publishSignalConfiguration),
/* harmony export */   readHydrationInfo: () => (/* binding */ readHydrationInfo),
/* harmony export */   readPatchedLView: () => (/* binding */ readPatchedLView),
/* harmony export */   registerLocaleData: () => (/* binding */ registerLocaleData),
/* harmony export */   registerNgModuleType: () => (/* binding */ registerNgModuleType),
/* harmony export */   remove: () => (/* binding */ remove),
/* harmony export */   removeListeners: () => (/* binding */ removeListeners),
/* harmony export */   renderDeferBlockState: () => (/* binding */ renderDeferBlockState),
/* harmony export */   resetCompiledComponents: () => (/* binding */ resetCompiledComponents),
/* harmony export */   resetIncrementalHydrationEnabledWarnedForTests: () => (/* binding */ resetIncrementalHydrationEnabledWarnedForTests),
/* harmony export */   resetJitOptions: () => (/* binding */ resetJitOptions),
/* harmony export */   resolveComponentResources: () => (/* binding */ resolveComponentResources),
/* harmony export */   restoreComponentResolutionQueue: () => (/* binding */ restoreComponentResolutionQueue),
/* harmony export */   setAllowDuplicateNgModuleIdsForTest: () => (/* binding */ setAllowDuplicateNgModuleIdsForTest),
/* harmony export */   setClassMetadata: () => (/* binding */ setClassMetadata),
/* harmony export */   setClassMetadataAsync: () => (/* binding */ setClassMetadataAsync),
/* harmony export */   setDocument: () => (/* binding */ setDocument),
/* harmony export */   setIsI18nHydrationSupportEnabled: () => (/* binding */ setIsI18nHydrationSupportEnabled),
/* harmony export */   setJSActionAttributes: () => (/* binding */ setJSActionAttributes),
/* harmony export */   setJitOptions: () => (/* binding */ setJitOptions),
/* harmony export */   setLocaleId: () => (/* binding */ setLocaleId),
/* harmony export */   setStashFn: () => (/* binding */ setStashFn),
/* harmony export */   setTestabilityGetter: () => (/* binding */ setTestabilityGetter),
/* harmony export */   sharedMapFunction: () => (/* binding */ sharedMapFunction),
/* harmony export */   sharedStashFunction: () => (/* binding */ sharedStashFunction),
/* harmony export */   transitiveScopesFor: () => (/* binding */ transitiveScopesFor),
/* harmony export */   triggerHydrationFromBlockName: () => (/* binding */ triggerHydrationFromBlockName),
/* harmony export */   triggerResourceLoading: () => (/* binding */ triggerResourceLoading),
/* harmony export */   trySerializeI18nBlock: () => (/* binding */ trySerializeI18nBlock),
/* harmony export */   twoWayBinding: () => (/* binding */ twoWayBinding),
/* harmony export */   unregisterAllLocaleData: () => (/* binding */ unregisterAllLocaleData),
/* harmony export */   unsupportedProjectionOfDomNodes: () => (/* binding */ unsupportedProjectionOfDomNodes),
/* harmony export */   unwrapSafeValue: () => (/* binding */ unwrapSafeValue),
/* harmony export */   validAppIdInitializer: () => (/* binding */ validAppIdInitializer),
/* harmony export */   validateMatchingNode: () => (/* binding */ validateMatchingNode),
/* harmony export */   validateNodeExists: () => (/* binding */ validateNodeExists),
/* harmony export */   verifySsrContentsIntegrity: () => (/* binding */ verifySsrContentsIntegrity),
/* harmony export */   "ɵCONTROL": () => (/* binding */ ɵCONTROL),
/* harmony export */   "ɵcontrolUpdate": () => (/* binding */ ɵcontrolUpdate),
/* harmony export */   "ɵgetUnknownElementStrictMode": () => (/* binding */ ɵgetUnknownElementStrictMode),
/* harmony export */   "ɵgetUnknownPropertyStrictMode": () => (/* binding */ ɵgetUnknownPropertyStrictMode),
/* harmony export */   "ɵsetClassDebugInfo": () => (/* binding */ ɵsetClassDebugInfo),
/* harmony export */   "ɵsetUnknownElementStrictMode": () => (/* binding */ ɵsetUnknownElementStrictMode),
/* harmony export */   "ɵsetUnknownPropertyStrictMode": () => (/* binding */ ɵsetUnknownPropertyStrictMode),
/* harmony export */   "ɵɵExternalStylesFeature": () => (/* binding */ ɵɵExternalStylesFeature),
/* harmony export */   "ɵɵHostDirectivesFeature": () => (/* binding */ ɵɵHostDirectivesFeature),
/* harmony export */   "ɵɵInheritDefinitionFeature": () => (/* binding */ ɵɵInheritDefinitionFeature),
/* harmony export */   "ɵɵNgOnChangesFeature": () => (/* binding */ ɵɵNgOnChangesFeature),
/* harmony export */   "ɵɵProvidersFeature": () => (/* binding */ ɵɵProvidersFeature),
/* harmony export */   "ɵɵadvance": () => (/* binding */ ɵɵadvance),
/* harmony export */   "ɵɵanimateEnter": () => (/* binding */ ɵɵanimateEnter),
/* harmony export */   "ɵɵanimateEnterListener": () => (/* binding */ ɵɵanimateEnterListener),
/* harmony export */   "ɵɵanimateLeave": () => (/* binding */ ɵɵanimateLeave),
/* harmony export */   "ɵɵanimateLeaveListener": () => (/* binding */ ɵɵanimateLeaveListener),
/* harmony export */   "ɵɵariaProperty": () => (/* binding */ ɵɵariaProperty),
/* harmony export */   "ɵɵattachSourceLocations": () => (/* binding */ ɵɵattachSourceLocations),
/* harmony export */   "ɵɵattribute": () => (/* binding */ ɵɵattribute),
/* harmony export */   "ɵɵclassMap": () => (/* binding */ ɵɵclassMap),
/* harmony export */   "ɵɵclassProp": () => (/* binding */ ɵɵclassProp),
/* harmony export */   "ɵɵcomponentInstance": () => (/* binding */ ɵɵcomponentInstance),
/* harmony export */   "ɵɵconditional": () => (/* binding */ ɵɵconditional),
/* harmony export */   "ɵɵconditionalBranchCreate": () => (/* binding */ ɵɵconditionalBranchCreate),
/* harmony export */   "ɵɵconditionalCreate": () => (/* binding */ ɵɵconditionalCreate),
/* harmony export */   "ɵɵcontentQuery": () => (/* binding */ ɵɵcontentQuery),
/* harmony export */   "ɵɵcontentQuerySignal": () => (/* binding */ ɵɵcontentQuerySignal),
/* harmony export */   "ɵɵcontrol": () => (/* binding */ ɵɵcontrol),
/* harmony export */   "ɵɵcontrolCreate": () => (/* binding */ ɵɵcontrolCreate),
/* harmony export */   "ɵɵdeclareLet": () => (/* binding */ ɵɵdeclareLet),
/* harmony export */   "ɵɵdefer": () => (/* binding */ ɵɵdefer),
/* harmony export */   "ɵɵdeferEnableTimerScheduling": () => (/* binding */ ɵɵdeferEnableTimerScheduling),
/* harmony export */   "ɵɵdeferHydrateNever": () => (/* binding */ ɵɵdeferHydrateNever),
/* harmony export */   "ɵɵdeferHydrateOnHover": () => (/* binding */ ɵɵdeferHydrateOnHover),
/* harmony export */   "ɵɵdeferHydrateOnIdle": () => (/* binding */ ɵɵdeferHydrateOnIdle),
/* harmony export */   "ɵɵdeferHydrateOnImmediate": () => (/* binding */ ɵɵdeferHydrateOnImmediate),
/* harmony export */   "ɵɵdeferHydrateOnInteraction": () => (/* binding */ ɵɵdeferHydrateOnInteraction),
/* harmony export */   "ɵɵdeferHydrateOnTimer": () => (/* binding */ ɵɵdeferHydrateOnTimer),
/* harmony export */   "ɵɵdeferHydrateOnViewport": () => (/* binding */ ɵɵdeferHydrateOnViewport),
/* harmony export */   "ɵɵdeferHydrateWhen": () => (/* binding */ ɵɵdeferHydrateWhen),
/* harmony export */   "ɵɵdeferOnHover": () => (/* binding */ ɵɵdeferOnHover),
/* harmony export */   "ɵɵdeferOnIdle": () => (/* binding */ ɵɵdeferOnIdle),
/* harmony export */   "ɵɵdeferOnImmediate": () => (/* binding */ ɵɵdeferOnImmediate),
/* harmony export */   "ɵɵdeferOnInteraction": () => (/* binding */ ɵɵdeferOnInteraction),
/* harmony export */   "ɵɵdeferOnTimer": () => (/* binding */ ɵɵdeferOnTimer),
/* harmony export */   "ɵɵdeferOnViewport": () => (/* binding */ ɵɵdeferOnViewport),
/* harmony export */   "ɵɵdeferPrefetchOnHover": () => (/* binding */ ɵɵdeferPrefetchOnHover),
/* harmony export */   "ɵɵdeferPrefetchOnIdle": () => (/* binding */ ɵɵdeferPrefetchOnIdle),
/* harmony export */   "ɵɵdeferPrefetchOnImmediate": () => (/* binding */ ɵɵdeferPrefetchOnImmediate),
/* harmony export */   "ɵɵdeferPrefetchOnInteraction": () => (/* binding */ ɵɵdeferPrefetchOnInteraction),
/* harmony export */   "ɵɵdeferPrefetchOnTimer": () => (/* binding */ ɵɵdeferPrefetchOnTimer),
/* harmony export */   "ɵɵdeferPrefetchOnViewport": () => (/* binding */ ɵɵdeferPrefetchOnViewport),
/* harmony export */   "ɵɵdeferPrefetchWhen": () => (/* binding */ ɵɵdeferPrefetchWhen),
/* harmony export */   "ɵɵdeferWhen": () => (/* binding */ ɵɵdeferWhen),
/* harmony export */   "ɵɵdefineComponent": () => (/* binding */ ɵɵdefineComponent),
/* harmony export */   "ɵɵdefineDirective": () => (/* binding */ ɵɵdefineDirective),
/* harmony export */   "ɵɵdefineNgModule": () => (/* binding */ ɵɵdefineNgModule),
/* harmony export */   "ɵɵdefinePipe": () => (/* binding */ ɵɵdefinePipe),
/* harmony export */   "ɵɵdirectiveInject": () => (/* binding */ ɵɵdirectiveInject),
/* harmony export */   "ɵɵdomElement": () => (/* binding */ ɵɵdomElement),
/* harmony export */   "ɵɵdomElementContainer": () => (/* binding */ ɵɵdomElementContainer),
/* harmony export */   "ɵɵdomElementContainerEnd": () => (/* binding */ ɵɵdomElementContainerEnd),
/* harmony export */   "ɵɵdomElementContainerStart": () => (/* binding */ ɵɵdomElementContainerStart),
/* harmony export */   "ɵɵdomElementEnd": () => (/* binding */ ɵɵdomElementEnd),
/* harmony export */   "ɵɵdomElementStart": () => (/* binding */ ɵɵdomElementStart),
/* harmony export */   "ɵɵdomListener": () => (/* binding */ ɵɵdomListener),
/* harmony export */   "ɵɵdomProperty": () => (/* binding */ ɵɵdomProperty),
/* harmony export */   "ɵɵdomTemplate": () => (/* binding */ ɵɵdomTemplate),
/* harmony export */   "ɵɵelement": () => (/* binding */ ɵɵelement),
/* harmony export */   "ɵɵelementContainer": () => (/* binding */ ɵɵelementContainer),
/* harmony export */   "ɵɵelementContainerEnd": () => (/* binding */ ɵɵelementContainerEnd),
/* harmony export */   "ɵɵelementContainerStart": () => (/* binding */ ɵɵelementContainerStart),
/* harmony export */   "ɵɵelementEnd": () => (/* binding */ ɵɵelementEnd),
/* harmony export */   "ɵɵelementStart": () => (/* binding */ ɵɵelementStart),
/* harmony export */   "ɵɵgetComponentDepsFactory": () => (/* binding */ ɵɵgetComponentDepsFactory),
/* harmony export */   "ɵɵgetCurrentView": () => (/* binding */ ɵɵgetCurrentView),
/* harmony export */   "ɵɵgetInheritedFactory": () => (/* binding */ ɵɵgetInheritedFactory),
/* harmony export */   "ɵɵgetReplaceMetadataURL": () => (/* binding */ ɵɵgetReplaceMetadataURL),
/* harmony export */   "ɵɵi18n": () => (/* binding */ ɵɵi18n),
/* harmony export */   "ɵɵi18nApply": () => (/* binding */ ɵɵi18nApply),
/* harmony export */   "ɵɵi18nAttributes": () => (/* binding */ ɵɵi18nAttributes),
/* harmony export */   "ɵɵi18nEnd": () => (/* binding */ ɵɵi18nEnd),
/* harmony export */   "ɵɵi18nExp": () => (/* binding */ ɵɵi18nExp),
/* harmony export */   "ɵɵi18nPostprocess": () => (/* binding */ ɵɵi18nPostprocess),
/* harmony export */   "ɵɵi18nStart": () => (/* binding */ ɵɵi18nStart),
/* harmony export */   "ɵɵinjectAttribute": () => (/* binding */ ɵɵinjectAttribute),
/* harmony export */   "ɵɵinterpolate": () => (/* binding */ ɵɵinterpolate),
/* harmony export */   "ɵɵinterpolate1": () => (/* binding */ ɵɵinterpolate1),
/* harmony export */   "ɵɵinterpolate2": () => (/* binding */ ɵɵinterpolate2),
/* harmony export */   "ɵɵinterpolate3": () => (/* binding */ ɵɵinterpolate3),
/* harmony export */   "ɵɵinterpolate4": () => (/* binding */ ɵɵinterpolate4),
/* harmony export */   "ɵɵinterpolate5": () => (/* binding */ ɵɵinterpolate5),
/* harmony export */   "ɵɵinterpolate6": () => (/* binding */ ɵɵinterpolate6),
/* harmony export */   "ɵɵinterpolate7": () => (/* binding */ ɵɵinterpolate7),
/* harmony export */   "ɵɵinterpolate8": () => (/* binding */ ɵɵinterpolate8),
/* harmony export */   "ɵɵinterpolateV": () => (/* binding */ ɵɵinterpolateV),
/* harmony export */   "ɵɵinvalidFactory": () => (/* binding */ ɵɵinvalidFactory),
/* harmony export */   "ɵɵlistener": () => (/* binding */ ɵɵlistener),
/* harmony export */   "ɵɵloadQuery": () => (/* binding */ ɵɵloadQuery),
/* harmony export */   "ɵɵnextContext": () => (/* binding */ ɵɵnextContext),
/* harmony export */   "ɵɵpipe": () => (/* binding */ ɵɵpipe),
/* harmony export */   "ɵɵpipeBind1": () => (/* binding */ ɵɵpipeBind1),
/* harmony export */   "ɵɵpipeBind2": () => (/* binding */ ɵɵpipeBind2),
/* harmony export */   "ɵɵpipeBind3": () => (/* binding */ ɵɵpipeBind3),
/* harmony export */   "ɵɵpipeBind4": () => (/* binding */ ɵɵpipeBind4),
/* harmony export */   "ɵɵpipeBindV": () => (/* binding */ ɵɵpipeBindV),
/* harmony export */   "ɵɵprojection": () => (/* binding */ ɵɵprojection),
/* harmony export */   "ɵɵprojectionDef": () => (/* binding */ ɵɵprojectionDef),
/* harmony export */   "ɵɵproperty": () => (/* binding */ ɵɵproperty),
/* harmony export */   "ɵɵpureFunction0": () => (/* binding */ ɵɵpureFunction0),
/* harmony export */   "ɵɵpureFunction1": () => (/* binding */ ɵɵpureFunction1),
/* harmony export */   "ɵɵpureFunction2": () => (/* binding */ ɵɵpureFunction2),
/* harmony export */   "ɵɵpureFunction3": () => (/* binding */ ɵɵpureFunction3),
/* harmony export */   "ɵɵpureFunction4": () => (/* binding */ ɵɵpureFunction4),
/* harmony export */   "ɵɵpureFunction5": () => (/* binding */ ɵɵpureFunction5),
/* harmony export */   "ɵɵpureFunction6": () => (/* binding */ ɵɵpureFunction6),
/* harmony export */   "ɵɵpureFunction7": () => (/* binding */ ɵɵpureFunction7),
/* harmony export */   "ɵɵpureFunction8": () => (/* binding */ ɵɵpureFunction8),
/* harmony export */   "ɵɵpureFunctionV": () => (/* binding */ ɵɵpureFunctionV),
/* harmony export */   "ɵɵqueryAdvance": () => (/* binding */ ɵɵqueryAdvance),
/* harmony export */   "ɵɵqueryRefresh": () => (/* binding */ ɵɵqueryRefresh),
/* harmony export */   "ɵɵreadContextLet": () => (/* binding */ ɵɵreadContextLet),
/* harmony export */   "ɵɵreference": () => (/* binding */ ɵɵreference),
/* harmony export */   "ɵɵrepeater": () => (/* binding */ ɵɵrepeater),
/* harmony export */   "ɵɵrepeaterCreate": () => (/* binding */ ɵɵrepeaterCreate),
/* harmony export */   "ɵɵrepeaterTrackByIdentity": () => (/* binding */ ɵɵrepeaterTrackByIdentity),
/* harmony export */   "ɵɵrepeaterTrackByIndex": () => (/* binding */ ɵɵrepeaterTrackByIndex),
/* harmony export */   "ɵɵreplaceMetadata": () => (/* binding */ ɵɵreplaceMetadata),
/* harmony export */   "ɵɵresolveBody": () => (/* binding */ ɵɵresolveBody),
/* harmony export */   "ɵɵresolveDocument": () => (/* binding */ ɵɵresolveDocument),
/* harmony export */   "ɵɵresolveWindow": () => (/* binding */ ɵɵresolveWindow),
/* harmony export */   "ɵɵsanitizeHtml": () => (/* binding */ ɵɵsanitizeHtml),
/* harmony export */   "ɵɵsanitizeResourceUrl": () => (/* binding */ ɵɵsanitizeResourceUrl),
/* harmony export */   "ɵɵsanitizeScript": () => (/* binding */ ɵɵsanitizeScript),
/* harmony export */   "ɵɵsanitizeStyle": () => (/* binding */ ɵɵsanitizeStyle),
/* harmony export */   "ɵɵsanitizeUrl": () => (/* binding */ ɵɵsanitizeUrl),
/* harmony export */   "ɵɵsanitizeUrlOrResourceUrl": () => (/* binding */ ɵɵsanitizeUrlOrResourceUrl),
/* harmony export */   "ɵɵsetComponentScope": () => (/* binding */ ɵɵsetComponentScope),
/* harmony export */   "ɵɵsetNgModuleScope": () => (/* binding */ ɵɵsetNgModuleScope),
/* harmony export */   "ɵɵstoreLet": () => (/* binding */ ɵɵstoreLet),
/* harmony export */   "ɵɵstyleMap": () => (/* binding */ ɵɵstyleMap),
/* harmony export */   "ɵɵstyleProp": () => (/* binding */ ɵɵstyleProp),
/* harmony export */   "ɵɵsyntheticHostListener": () => (/* binding */ ɵɵsyntheticHostListener),
/* harmony export */   "ɵɵsyntheticHostProperty": () => (/* binding */ ɵɵsyntheticHostProperty),
/* harmony export */   "ɵɵtemplate": () => (/* binding */ ɵɵtemplate),
/* harmony export */   "ɵɵtemplateRefExtractor": () => (/* binding */ ɵɵtemplateRefExtractor),
/* harmony export */   "ɵɵtext": () => (/* binding */ ɵɵtext),
/* harmony export */   "ɵɵtextInterpolate": () => (/* binding */ ɵɵtextInterpolate),
/* harmony export */   "ɵɵtextInterpolate1": () => (/* binding */ ɵɵtextInterpolate1),
/* harmony export */   "ɵɵtextInterpolate2": () => (/* binding */ ɵɵtextInterpolate2),
/* harmony export */   "ɵɵtextInterpolate3": () => (/* binding */ ɵɵtextInterpolate3),
/* harmony export */   "ɵɵtextInterpolate4": () => (/* binding */ ɵɵtextInterpolate4),
/* harmony export */   "ɵɵtextInterpolate5": () => (/* binding */ ɵɵtextInterpolate5),
/* harmony export */   "ɵɵtextInterpolate6": () => (/* binding */ ɵɵtextInterpolate6),
/* harmony export */   "ɵɵtextInterpolate7": () => (/* binding */ ɵɵtextInterpolate7),
/* harmony export */   "ɵɵtextInterpolate8": () => (/* binding */ ɵɵtextInterpolate8),
/* harmony export */   "ɵɵtextInterpolateV": () => (/* binding */ ɵɵtextInterpolateV),
/* harmony export */   "ɵɵtrustConstantHtml": () => (/* binding */ ɵɵtrustConstantHtml),
/* harmony export */   "ɵɵtrustConstantResourceUrl": () => (/* binding */ ɵɵtrustConstantResourceUrl),
/* harmony export */   "ɵɵtwoWayBindingSet": () => (/* binding */ ɵɵtwoWayBindingSet),
/* harmony export */   "ɵɵtwoWayListener": () => (/* binding */ ɵɵtwoWayListener),
/* harmony export */   "ɵɵtwoWayProperty": () => (/* binding */ ɵɵtwoWayProperty),
/* harmony export */   "ɵɵvalidateAttribute": () => (/* binding */ ɵɵvalidateAttribute),
/* harmony export */   "ɵɵviewQuery": () => (/* binding */ ɵɵviewQuery),
/* harmony export */   "ɵɵviewQuerySignal": () => (/* binding */ ɵɵviewQuerySignal)
/* harmony export */ });
/* harmony import */ var C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 3194);
/* harmony import */ var _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_untracked-chunk.mjs */ 64);
/* harmony import */ var _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core/primitives/signals */ 476);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ 1171);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ 1038);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs/operators */ 4063);
/* harmony import */ var _attribute_chunk_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_attribute-chunk.mjs */ 5877);

/**
 * @license Angular v21.0.5
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */







function noSideEffects(fn) {
  return {
    toString: fn
  }.toString();
}
const ANNOTATIONS = '__annotations__';
const PARAMETERS = '__parameters__';
const PROP_METADATA = '__prop__metadata__';
function makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function DecoratorFactory(...args) {
      if (this instanceof DecoratorFactory) {
        metaCtor.call(this, ...args);
        return this;
      }
      const annotationInstance = new DecoratorFactory(...args);
      return function TypeDecorator(cls) {
        if (typeFn) typeFn(cls, ...args);
        const annotations = cls.hasOwnProperty(ANNOTATIONS) ? cls[ANNOTATIONS] : Object.defineProperty(cls, ANNOTATIONS, {
          value: []
        })[ANNOTATIONS];
        annotations.push(annotationInstance);
        return cls;
      };
    }
    if (parentClass) {
      DecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    DecoratorFactory.prototype.ngMetadataName = name;
    DecoratorFactory.annotationCls = DecoratorFactory;
    return DecoratorFactory;
  });
}
function makeMetadataCtor(props) {
  return function ctor(...args) {
    if (props) {
      const values = props(...args);
      for (const propName in values) {
        this[propName] = values[propName];
      }
    }
  };
}
function makeParamDecorator(name, props, parentClass) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function ParamDecoratorFactory(...args) {
      if (this instanceof ParamDecoratorFactory) {
        metaCtor.apply(this, args);
        return this;
      }
      const annotationInstance = new ParamDecoratorFactory(...args);
      ParamDecorator.annotation = annotationInstance;
      return ParamDecorator;
      function ParamDecorator(cls, unusedKey, index) {
        const parameters = cls.hasOwnProperty(PARAMETERS) ? cls[PARAMETERS] : Object.defineProperty(cls, PARAMETERS, {
          value: []
        })[PARAMETERS];
        while (parameters.length <= index) {
          parameters.push(null);
        }
        (parameters[index] = parameters[index] || []).push(annotationInstance);
        return cls;
      }
    }
    ParamDecoratorFactory.prototype.ngMetadataName = name;
    ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;
    return ParamDecoratorFactory;
  });
}
function makePropDecorator(name, props, parentClass, additionalProcessing) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function PropDecoratorFactory(...args) {
      if (this instanceof PropDecoratorFactory) {
        metaCtor.apply(this, args);
        return this;
      }
      const decoratorInstance = new PropDecoratorFactory(...args);
      function PropDecorator(target, name) {
        if (target === undefined) {
          throw new Error('Standard Angular field decorators are not supported in JIT mode.');
        }
        const constructor = target.constructor;
        const meta = constructor.hasOwnProperty(PROP_METADATA) ? constructor[PROP_METADATA] : Object.defineProperty(constructor, PROP_METADATA, {
          value: {}
        })[PROP_METADATA];
        meta[name] = meta.hasOwnProperty(name) && meta[name] || [];
        meta[name].unshift(decoratorInstance);
      }
      return PropDecorator;
    }
    if (parentClass) {
      PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    PropDecoratorFactory.prototype.ngMetadataName = name;
    PropDecoratorFactory.annotationCls = PropDecoratorFactory;
    return PropDecoratorFactory;
  });
}
const Inject = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.attachInjectFlag)(makeParamDecorator('Inject', token => ({
  token
})), -1);
const Optional = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.attachInjectFlag)(makeParamDecorator('Optional'), 8);
const Self = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.attachInjectFlag)(makeParamDecorator('Self'), 2);
const SkipSelf = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.attachInjectFlag)(makeParamDecorator('SkipSelf'), 4);
const Host = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.attachInjectFlag)(makeParamDecorator('Host'), 1);
function getCompilerFacade(request) {
  const globalNg = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__._global['ng'];
  if (globalNg && globalNg.ɵcompilerFacade) {
    return globalNg.ɵcompilerFacade;
  }
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
    console.error(`JIT compilation failed for ${request.kind}`, request.type);
    let message = `The ${request.kind} '${request.type.name}' needs to be compiled using the JIT compiler, but '@angular/compiler' is not available.\n\n`;
    if (request.usage === 1) {
      message += `The ${request.kind} is part of a library that has been partially compiled.\n`;
      message += `However, the Angular Linker has not processed the library such that JIT compilation is used as fallback.\n`;
      message += '\n';
      message += `Ideally, the library is processed using the Angular Linker to become fully AOT compiled.\n`;
    } else {
      message += `JIT compilation is discouraged for production use-cases! Consider using AOT mode instead.\n`;
    }
    message += `Alternatively, the JIT compiler should be loaded by bootstrapping using '@angular/platform-browser-dynamic' or '@angular/platform-server',\n`;
    message += `or manually provide the compiler with 'import "@angular/compiler";' before bootstrapping.`;
    throw new Error(message);
  } else {
    throw new Error('JIT compiler unavailable');
  }
}
const angularCoreDiEnv = {
  'ɵɵdefineInjectable': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"],
  'ɵɵdefineInjector': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"],
  'ɵɵinject': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"],
  'ɵɵinvalidFactoryDep': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵinvalidFactoryDep"],
  'resolveForwardRef': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef
};
const Type = Function;
function isType(v) {
  return typeof v === 'function';
}
const ES5_DELEGATE_CTOR = /^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*(arguments|(?:[^()]+\(\[\],)?[^()]+\(arguments\).*)\)/;
const ES2015_INHERITED_CLASS = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/;
const ES2015_INHERITED_CLASS_WITH_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/;
const ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{[^}]*super\(\.\.\.arguments\)/;
function isDelegateCtor(typeStr) {
  return ES5_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr);
}
class ReflectionCapabilities {
  _reflect;
  constructor(reflect) {
    this._reflect = reflect || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__._global['Reflect'];
  }
  factory(t) {
    return (...args) => new t(...args);
  }
  _zipTypesAndAnnotations(paramTypes, paramAnnotations) {
    let result;
    if (typeof paramTypes === 'undefined') {
      result = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.newArray)(paramAnnotations.length);
    } else {
      result = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.newArray)(paramTypes.length);
    }
    for (let i = 0; i < result.length; i++) {
      if (typeof paramTypes === 'undefined') {
        result[i] = [];
      } else if (paramTypes[i] && paramTypes[i] != Object) {
        result[i] = [paramTypes[i]];
      } else {
        result[i] = [];
      }
      if (paramAnnotations && paramAnnotations[i] != null) {
        result[i] = result[i].concat(paramAnnotations[i]);
      }
    }
    return result;
  }
  _ownParameters(type, parentCtor) {
    const typeStr = type.toString();
    if (isDelegateCtor(typeStr)) {
      return null;
    }
    if (type.parameters && type.parameters !== parentCtor.parameters) {
      return type.parameters;
    }
    const tsickleCtorParams = type.ctorParameters;
    if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {
      const ctorParameters = typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;
      const paramTypes = ctorParameters.map(ctorParam => ctorParam && ctorParam.type);
      const paramAnnotations = ctorParameters.map(ctorParam => ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));
      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
    }
    const paramAnnotations = type.hasOwnProperty(PARAMETERS) && type[PARAMETERS];
    const paramTypes = this._reflect && this._reflect.getOwnMetadata && this._reflect.getOwnMetadata('design:paramtypes', type);
    if (paramTypes || paramAnnotations) {
      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
    }
    return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.newArray)(type.length);
  }
  parameters(type) {
    if (!isType(type)) {
      return [];
    }
    const parentCtor = getParentCtor(type);
    let parameters = this._ownParameters(type, parentCtor);
    if (!parameters && parentCtor !== Object) {
      parameters = this.parameters(parentCtor);
    }
    return parameters || [];
  }
  _ownAnnotations(typeOrFunc, parentCtor) {
    if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {
      let annotations = typeOrFunc.annotations;
      if (typeof annotations === 'function' && annotations.annotations) {
        annotations = annotations.annotations;
      }
      return annotations;
    }
    if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) {
      return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);
    }
    if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {
      return typeOrFunc[ANNOTATIONS];
    }
    return null;
  }
  annotations(typeOrFunc) {
    if (!isType(typeOrFunc)) {
      return [];
    }
    const parentCtor = getParentCtor(typeOrFunc);
    const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];
    const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];
    return parentAnnotations.concat(ownAnnotations);
  }
  _ownPropMetadata(typeOrFunc, parentCtor) {
    if (typeOrFunc.propMetadata && typeOrFunc.propMetadata !== parentCtor.propMetadata) {
      let propMetadata = typeOrFunc.propMetadata;
      if (typeof propMetadata === 'function' && propMetadata.propMetadata) {
        propMetadata = propMetadata.propMetadata;
      }
      return propMetadata;
    }
    if (typeOrFunc.propDecorators && typeOrFunc.propDecorators !== parentCtor.propDecorators) {
      const propDecorators = typeOrFunc.propDecorators;
      const propMetadata = {};
      Object.keys(propDecorators).forEach(prop => {
        propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);
      });
      return propMetadata;
    }
    if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {
      return typeOrFunc[PROP_METADATA];
    }
    return null;
  }
  propMetadata(typeOrFunc) {
    if (!isType(typeOrFunc)) {
      return {};
    }
    const parentCtor = getParentCtor(typeOrFunc);
    const propMetadata = {};
    if (parentCtor !== Object) {
      const parentPropMetadata = this.propMetadata(parentCtor);
      Object.keys(parentPropMetadata).forEach(propName => {
        propMetadata[propName] = parentPropMetadata[propName];
      });
    }
    const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);
    if (ownPropMetadata) {
      Object.keys(ownPropMetadata).forEach(propName => {
        const decorators = [];
        if (propMetadata.hasOwnProperty(propName)) {
          decorators.push(...propMetadata[propName]);
        }
        decorators.push(...ownPropMetadata[propName]);
        propMetadata[propName] = decorators;
      });
    }
    return propMetadata;
  }
  ownPropMetadata(typeOrFunc) {
    if (!isType(typeOrFunc)) {
      return {};
    }
    return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};
  }
  hasLifecycleHook(type, lcProperty) {
    return type instanceof Type && lcProperty in type.prototype;
  }
}
function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
  if (!decoratorInvocations) {
    return [];
  }
  return decoratorInvocations.map(decoratorInvocation => {
    const decoratorType = decoratorInvocation.type;
    const annotationCls = decoratorType.annotationCls;
    const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
    return new annotationCls(...annotationArgs);
  });
}
function getParentCtor(ctor) {
  const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;
  const parentCtor = parentProto ? parentProto.constructor : null;
  return parentCtor || Object;
}
function applyValueToInputField(instance, inputSignalNode, privateName, value) {
  if (inputSignalNode !== null) {
    inputSignalNode.applyValueToInputSignal(inputSignalNode, value);
  } else {
    instance[privateName] = value;
  }
}
class SimpleChange {
  previousValue;
  currentValue;
  firstChange;
  constructor(previousValue, currentValue, firstChange) {
    this.previousValue = previousValue;
    this.currentValue = currentValue;
    this.firstChange = firstChange;
  }
  isFirstChange() {
    return this.firstChange;
  }
}
const ɵɵNgOnChangesFeature = /* @__PURE__ */(() => {
  const ɵɵNgOnChangesFeatureImpl = () => NgOnChangesFeatureImpl;
  ɵɵNgOnChangesFeatureImpl.ngInherit = true;
  return ɵɵNgOnChangesFeatureImpl;
})();
function NgOnChangesFeatureImpl(definition) {
  if (definition.type.prototype.ngOnChanges) {
    definition.setInput = ngOnChangesSetInput;
  }
  return rememberChangeHistoryAndInvokeOnChangesHook;
}
function rememberChangeHistoryAndInvokeOnChangesHook() {
  const simpleChangesStore = getSimpleChangesStore(this);
  const current = simpleChangesStore?.current;
  if (current) {
    const previous = simpleChangesStore.previous;
    if (previous === _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
      simpleChangesStore.previous = current;
    } else {
      for (let key in current) {
        previous[key] = current[key];
      }
    }
    simpleChangesStore.current = null;
    this.ngOnChanges(current);
  }
}
function ngOnChangesSetInput(instance, inputSignalNode, value, publicName, privateName) {
  const declaredName = this.declaredInputs[publicName];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertString)(declaredName, 'Name of input in ngOnChanges has to be a string');
  const simpleChangesStore = getSimpleChangesStore(instance) || setSimpleChangesStore(instance, {
    previous: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    current: null
  });
  const current = simpleChangesStore.current || (simpleChangesStore.current = {});
  const previous = simpleChangesStore.previous;
  const previousChange = previous[declaredName];
  current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ);
  applyValueToInputField(instance, inputSignalNode, privateName, value);
}
const SIMPLE_CHANGES_STORE = '__ngSimpleChanges__';
function getSimpleChangesStore(instance) {
  return instance[SIMPLE_CHANGES_STORE] || null;
}
function setSimpleChangesStore(instance, store) {
  return instance[SIMPLE_CHANGES_STORE] = store;
}
const profilerCallbacks = [];
const NOOP_PROFILER_REMOVAL = () => {};
function removeProfiler(profiler) {
  const profilerIdx = profilerCallbacks.indexOf(profiler);
  if (profilerIdx !== -1) {
    profilerCallbacks.splice(profilerIdx, 1);
  }
}
function setProfiler(profiler) {
  if (profiler !== null) {
    if (!profilerCallbacks.includes(profiler)) {
      profilerCallbacks.push(profiler);
    }
    return () => removeProfiler(profiler);
  } else {
    profilerCallbacks.length = 0;
    return NOOP_PROFILER_REMOVAL;
  }
}
const profiler = function (event, instance = null, eventFn) {
  for (let i = 0; i < profilerCallbacks.length; i++) {
    const profilerCallback = profilerCallbacks[i];
    profilerCallback(event, instance, eventFn);
  }
};
var ProfilerEvent;
(function (ProfilerEvent) {
  ProfilerEvent[ProfilerEvent["TemplateCreateStart"] = 0] = "TemplateCreateStart";
  ProfilerEvent[ProfilerEvent["TemplateCreateEnd"] = 1] = "TemplateCreateEnd";
  ProfilerEvent[ProfilerEvent["TemplateUpdateStart"] = 2] = "TemplateUpdateStart";
  ProfilerEvent[ProfilerEvent["TemplateUpdateEnd"] = 3] = "TemplateUpdateEnd";
  ProfilerEvent[ProfilerEvent["LifecycleHookStart"] = 4] = "LifecycleHookStart";
  ProfilerEvent[ProfilerEvent["LifecycleHookEnd"] = 5] = "LifecycleHookEnd";
  ProfilerEvent[ProfilerEvent["OutputStart"] = 6] = "OutputStart";
  ProfilerEvent[ProfilerEvent["OutputEnd"] = 7] = "OutputEnd";
  ProfilerEvent[ProfilerEvent["BootstrapApplicationStart"] = 8] = "BootstrapApplicationStart";
  ProfilerEvent[ProfilerEvent["BootstrapApplicationEnd"] = 9] = "BootstrapApplicationEnd";
  ProfilerEvent[ProfilerEvent["BootstrapComponentStart"] = 10] = "BootstrapComponentStart";
  ProfilerEvent[ProfilerEvent["BootstrapComponentEnd"] = 11] = "BootstrapComponentEnd";
  ProfilerEvent[ProfilerEvent["ChangeDetectionStart"] = 12] = "ChangeDetectionStart";
  ProfilerEvent[ProfilerEvent["ChangeDetectionEnd"] = 13] = "ChangeDetectionEnd";
  ProfilerEvent[ProfilerEvent["ChangeDetectionSyncStart"] = 14] = "ChangeDetectionSyncStart";
  ProfilerEvent[ProfilerEvent["ChangeDetectionSyncEnd"] = 15] = "ChangeDetectionSyncEnd";
  ProfilerEvent[ProfilerEvent["AfterRenderHooksStart"] = 16] = "AfterRenderHooksStart";
  ProfilerEvent[ProfilerEvent["AfterRenderHooksEnd"] = 17] = "AfterRenderHooksEnd";
  ProfilerEvent[ProfilerEvent["ComponentStart"] = 18] = "ComponentStart";
  ProfilerEvent[ProfilerEvent["ComponentEnd"] = 19] = "ComponentEnd";
  ProfilerEvent[ProfilerEvent["DeferBlockStateStart"] = 20] = "DeferBlockStateStart";
  ProfilerEvent[ProfilerEvent["DeferBlockStateEnd"] = 21] = "DeferBlockStateEnd";
  ProfilerEvent[ProfilerEvent["DynamicComponentStart"] = 22] = "DynamicComponentStart";
  ProfilerEvent[ProfilerEvent["DynamicComponentEnd"] = 23] = "DynamicComponentEnd";
  ProfilerEvent[ProfilerEvent["HostBindingsUpdateStart"] = 24] = "HostBindingsUpdateStart";
  ProfilerEvent[ProfilerEvent["HostBindingsUpdateEnd"] = 25] = "HostBindingsUpdateEnd";
})(ProfilerEvent || (ProfilerEvent = {}));
function registerPreOrderHooks(directiveIndex, directiveDef, tView) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView);
  const {
    ngOnChanges,
    ngOnInit,
    ngDoCheck
  } = directiveDef.type.prototype;
  if (ngOnChanges) {
    const wrappedOnChanges = NgOnChangesFeatureImpl(directiveDef);
    (tView.preOrderHooks ??= []).push(directiveIndex, wrappedOnChanges);
    (tView.preOrderCheckHooks ??= []).push(directiveIndex, wrappedOnChanges);
  }
  if (ngOnInit) {
    (tView.preOrderHooks ??= []).push(0 - directiveIndex, ngOnInit);
  }
  if (ngDoCheck) {
    (tView.preOrderHooks ??= []).push(directiveIndex, ngDoCheck);
    (tView.preOrderCheckHooks ??= []).push(directiveIndex, ngDoCheck);
  }
}
function registerPostOrderHooks(tView, tNode) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView);
  for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {
    const directiveDef = tView.data[i];
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(directiveDef, 'Expecting DirectiveDef');
    const lifecycleHooks = directiveDef.type.prototype;
    const {
      ngAfterContentInit,
      ngAfterContentChecked,
      ngAfterViewInit,
      ngAfterViewChecked,
      ngOnDestroy
    } = lifecycleHooks;
    if (ngAfterContentInit) {
      (tView.contentHooks ??= []).push(-i, ngAfterContentInit);
    }
    if (ngAfterContentChecked) {
      (tView.contentHooks ??= []).push(i, ngAfterContentChecked);
      (tView.contentCheckHooks ??= []).push(i, ngAfterContentChecked);
    }
    if (ngAfterViewInit) {
      (tView.viewHooks ??= []).push(-i, ngAfterViewInit);
    }
    if (ngAfterViewChecked) {
      (tView.viewHooks ??= []).push(i, ngAfterViewChecked);
      (tView.viewCheckHooks ??= []).push(i, ngAfterViewChecked);
    }
    if (ngOnDestroy != null) {
      (tView.destroyHooks ??= []).push(i, ngOnDestroy);
    }
  }
}
function executeCheckHooks(lView, hooks, nodeIndex) {
  callHooks(lView, hooks, 3, nodeIndex);
}
function executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotEqual)(initPhase, 3, 'Init pre-order hooks should not be called more than once');
  if ((lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] & 3) === initPhase) {
    callHooks(lView, hooks, initPhase, nodeIndex);
  }
}
function incrementInitPhaseFlags(lView, initPhase) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotEqual)(initPhase, 3, 'Init hooks phase should not be incremented after all init hooks have been run.');
  let flags = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS];
  if ((flags & 3) === initPhase) {
    flags &= 16383;
    flags += 1;
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] = flags;
  }
}
function callHooks(currentView, arr, initPhase, currentNodeIndex) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isInCheckNoChangesMode)(), false, 'Hooks should never be run when in check no changes mode.');
  const startIndex = currentNodeIndex !== undefined ? currentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PREORDER_HOOK_FLAGS] & 65535 : 0;
  const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;
  const max = arr.length - 1;
  let lastNodeIndexFound = 0;
  for (let i = startIndex; i < max; i++) {
    const hook = arr[i + 1];
    if (typeof hook === 'number') {
      lastNodeIndexFound = arr[i];
      if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {
        break;
      }
    } else {
      const isInitHook = arr[i] < 0;
      if (isInitHook) {
        currentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PREORDER_HOOK_FLAGS] += 65536;
      }
      if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {
        callHook(currentView, initPhase, arr, i);
        currentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PREORDER_HOOK_FLAGS] = (currentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PREORDER_HOOK_FLAGS] & 4294901760) + i + 2;
      }
      i++;
    }
  }
}
function callHookInternal(directive, hook) {
  profiler(ProfilerEvent.LifecycleHookStart, directive, hook);
  const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
  try {
    hook.call(directive);
  } finally {
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
    profiler(ProfilerEvent.LifecycleHookEnd, directive, hook);
  }
}
function callHook(currentView, initPhase, arr, i) {
  const isInitHook = arr[i] < 0;
  const hook = arr[i + 1];
  const directiveIndex = isInitHook ? -arr[i] : arr[i];
  const directive = currentView[directiveIndex];
  if (isInitHook) {
    const indexWithintInitPhase = currentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] >> 14;
    if (indexWithintInitPhase < currentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PREORDER_HOOK_FLAGS] >> 16 && (currentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] & 3) === initPhase) {
      currentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] += 16384;
      callHookInternal(directive, hook);
    }
  } else {
    callHookInternal(directive, hook);
  }
}
const NO_PARENT_INJECTOR = -1;
class NodeInjectorFactory {
  factory;
  name;
  injectImpl;
  resolving = false;
  canSeeViewProviders;
  multi;
  componentProviders;
  index;
  providerFactory;
  constructor(factory, isViewProvider, injectImplementation, name) {
    this.factory = factory;
    this.name = name;
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(factory, 'Factory not specified');
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(typeof factory, 'function', 'Expected factory function.');
    this.canSeeViewProviders = isViewProvider;
    this.injectImpl = injectImplementation;
  }
}
function toTNodeTypeAsString(tNodeType) {
  let text = '';
  tNodeType & 1 && (text += '|Text');
  tNodeType & 2 && (text += '|Element');
  tNodeType & 4 && (text += '|Container');
  tNodeType & 8 && (text += '|ElementContainer');
  tNodeType & 16 && (text += '|Projection');
  tNodeType & 32 && (text += '|IcuContainer');
  tNodeType & 64 && (text += '|Placeholder');
  tNodeType & 128 && (text += '|LetDeclaration');
  return text.length > 0 ? text.substring(1) : text;
}
function isTNodeShape(value) {
  return value != null && typeof value === 'object' && (value.insertBeforeIndex === null || typeof value.insertBeforeIndex === 'number' || Array.isArray(value.insertBeforeIndex));
}
function isLetDeclaration(tNode) {
  return !!(tNode.type & 128);
}
function hasClassInput(tNode) {
  return (tNode.flags & 8) !== 0;
}
function hasStyleInput(tNode) {
  return (tNode.flags & 16) !== 0;
}
function assertTNodeType(tNode, expectedTypes, message) {
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(tNode, 'should be called with a TNode');
  if ((tNode.type & expectedTypes) === 0) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)(message || `Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`);
  }
}
function assertPureTNodeType(type) {
  if (!(type === 2 || type === 1 || type === 4 || type === 8 || type === 32 || type === 16 || type === 64 || type === 128)) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type)}.`);
  }
}
function setUpAttributes(renderer, native, attrs) {
  let i = 0;
  while (i < attrs.length) {
    const value = attrs[i];
    if (typeof value === 'number') {
      if (value !== 0) {
        break;
      }
      i++;
      const namespaceURI = attrs[i++];
      const attrName = attrs[i++];
      const attrVal = attrs[i++];
      renderer.setAttribute(native, attrName, attrVal, namespaceURI);
    } else {
      const attrName = value;
      const attrVal = attrs[++i];
      if (isAnimationProp(attrName)) {
        renderer.setProperty(native, attrName, attrVal);
      } else {
        renderer.setAttribute(native, attrName, attrVal);
      }
      i++;
    }
  }
  return i;
}
function isNameOnlyAttributeMarker(marker) {
  return marker === 3 || marker === 4 || marker === 6;
}
function isAnimationProp(name) {
  return name.charCodeAt(0) === 64;
}
function mergeHostAttrs(dst, src) {
  if (src === null || src.length === 0) ;else if (dst === null || dst.length === 0) {
    dst = src.slice();
  } else {
    let srcMarker = -1;
    for (let i = 0; i < src.length; i++) {
      const item = src[i];
      if (typeof item === 'number') {
        srcMarker = item;
      } else {
        if (srcMarker === 0) ;else if (srcMarker === -1 || srcMarker === 2) {
          mergeHostAttribute(dst, srcMarker, item, null, src[++i]);
        } else {
          mergeHostAttribute(dst, srcMarker, item, null, null);
        }
      }
    }
  }
  return dst;
}
function mergeHostAttribute(dst, marker, key1, key2, value) {
  let i = 0;
  let markerInsertPosition = dst.length;
  if (marker === -1) {
    markerInsertPosition = -1;
  } else {
    while (i < dst.length) {
      const dstValue = dst[i++];
      if (typeof dstValue === 'number') {
        if (dstValue === marker) {
          markerInsertPosition = -1;
          break;
        } else if (dstValue > marker) {
          markerInsertPosition = i - 1;
          break;
        }
      }
    }
  }
  while (i < dst.length) {
    const item = dst[i];
    if (typeof item === 'number') {
      break;
    } else if (item === key1) {
      {
        if (value !== null) {
          dst[i + 1] = value;
        }
        return;
      }
    }
    i++;
    if (value !== null) i++;
  }
  if (markerInsertPosition !== -1) {
    dst.splice(markerInsertPosition, 0, marker);
    i = markerInsertPosition + 1;
  }
  dst.splice(i++, 0, key1);
  if (value !== null) {
    dst.splice(i++, 0, value);
  }
}
function hasParentInjector(parentLocation) {
  return parentLocation !== NO_PARENT_INJECTOR;
}
function getParentInjectorIndex(parentLocation) {
  if (ngDevMode) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(parentLocation, 'Number expected');
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotEqual)(parentLocation, -1, 'Not a valid state.');
    const parentInjectorIndex = parentLocation & 32767;
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertGreaterThan)(parentInjectorIndex, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET, 'Parent injector must be pointing past HEADER_OFFSET.');
  }
  return parentLocation & 32767;
}
function getParentInjectorViewOffset(parentLocation) {
  return parentLocation >> 16;
}
function getParentInjectorView(location, startView) {
  let viewOffset = getParentInjectorViewOffset(location);
  let parentView = startView;
  while (viewOffset > 0) {
    parentView = parentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_VIEW];
    viewOffset--;
  }
  return parentView;
}
let includeViewProviders = true;
function setIncludeViewProviders(v) {
  const oldValue = includeViewProviders;
  includeViewProviders = v;
  return oldValue;
}
const BLOOM_SIZE = 256;
const BLOOM_MASK = BLOOM_SIZE - 1;
const BLOOM_BUCKET_BITS = 5;
let nextNgElementId = 0;
const NOT_FOUND = {};
function bloomAdd(injectorIndex, tView, type) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(tView.firstCreatePass, true, 'expected firstCreatePass to be true');
  let id;
  if (typeof type === 'string') {
    id = type.charCodeAt(0) || 0;
  } else if (type.hasOwnProperty(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_ELEMENT_ID)) {
    id = type[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_ELEMENT_ID];
  }
  if (id == null) {
    id = type[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_ELEMENT_ID] = nextNgElementId++;
  }
  const bloomHash = id & BLOOM_MASK;
  const mask = 1 << bloomHash;
  tView.data[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)] |= mask;
}
function getOrCreateNodeInjectorForNode(tNode, lView) {
  const existingInjectorIndex = getInjectorIndex(tNode, lView);
  if (existingInjectorIndex !== -1) {
    return existingInjectorIndex;
  }
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  if (tView.firstCreatePass) {
    tNode.injectorIndex = lView.length;
    insertBloom(tView.data, tNode);
    insertBloom(lView, null);
    insertBloom(tView.blueprint, null);
  }
  const parentLoc = getParentInjectorLocation(tNode, lView);
  const injectorIndex = tNode.injectorIndex;
  if (hasParentInjector(parentLoc)) {
    const parentIndex = getParentInjectorIndex(parentLoc);
    const parentLView = getParentInjectorView(parentLoc, lView);
    const parentData = parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data;
    for (let i = 0; i < 8; i++) {
      lView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];
    }
  }
  lView[injectorIndex + 8] = parentLoc;
  return injectorIndex;
}
function insertBloom(arr, footer) {
  arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);
}
function getInjectorIndex(tNode, lView) {
  if (tNode.injectorIndex === -1 || tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex || lView[tNode.injectorIndex + 8] === null) {
    return -1;
  } else {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, tNode.injectorIndex);
    return tNode.injectorIndex;
  }
}
function getParentInjectorLocation(tNode, lView) {
  if (tNode.parent && tNode.parent.injectorIndex !== -1) {
    return tNode.parent.injectorIndex;
  }
  let declarationViewOffset = 0;
  let parentTNode = null;
  let lViewCursor = lView;
  while (lViewCursor !== null) {
    parentTNode = getTNodeFromLView(lViewCursor);
    if (parentTNode === null) {
      return NO_PARENT_INJECTOR;
    }
    ngDevMode && parentTNode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForLView)(parentTNode, lViewCursor[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_VIEW]);
    declarationViewOffset++;
    lViewCursor = lViewCursor[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_VIEW];
    if (parentTNode.injectorIndex !== -1) {
      return parentTNode.injectorIndex | declarationViewOffset << 16;
    }
  }
  return NO_PARENT_INJECTOR;
}
function diPublicInInjector(injectorIndex, tView, token) {
  bloomAdd(injectorIndex, tView, token);
}
function injectAttributeImpl(tNode, attrNameToInject) {
  ngDevMode && assertTNodeType(tNode, 12 | 3);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(tNode, 'expecting tNode');
  if (attrNameToInject === 'class') {
    return tNode.classes;
  }
  if (attrNameToInject === 'style') {
    return tNode.styles;
  }
  const attrs = tNode.attrs;
  if (attrs) {
    const attrsLength = attrs.length;
    let i = 0;
    while (i < attrsLength) {
      const value = attrs[i];
      if (isNameOnlyAttributeMarker(value)) break;
      if (value === 0) {
        i = i + 2;
      } else if (typeof value === 'number') {
        i++;
        while (i < attrsLength && typeof attrs[i] === 'string') {
          i++;
        }
      } else if (value === attrNameToInject) {
        return attrs[i + 1];
      } else {
        i = i + 2;
      }
    }
  }
  return null;
}
function notFoundValueOrThrow(notFoundValue, token, flags) {
  if (flags & 8 || notFoundValue !== undefined) {
    return notFoundValue;
  } else {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwProviderNotFoundError)(token, 'NodeInjector');
  }
}
function lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue) {
  if (flags & 8 && notFoundValue === undefined) {
    notFoundValue = null;
  }
  if ((flags & (2 | 1)) === 0) {
    const moduleInjector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
    const previousInjectImplementation = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInjectImplementation)(undefined);
    try {
      if (moduleInjector) {
        return moduleInjector.get(token, notFoundValue, flags & 8);
      } else {
        return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.injectRootLimpMode)(token, notFoundValue, flags & 8);
      }
    } finally {
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInjectImplementation)(previousInjectImplementation);
    }
  }
  return notFoundValueOrThrow(notFoundValue, token, flags);
}
function getOrCreateInjectable(tNode, lView, token, flags = 0, notFoundValue) {
  if (tNode !== null) {
    if (lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] & 2048 && !(flags & 2)) {
      const embeddedInjectorValue = lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, NOT_FOUND);
      if (embeddedInjectorValue !== NOT_FOUND) {
        return embeddedInjectorValue;
      }
    }
    const value = lookupTokenUsingNodeInjector(tNode, lView, token, flags, NOT_FOUND);
    if (value !== NOT_FOUND) {
      return value;
    }
  }
  return lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
}
function lookupTokenUsingNodeInjector(tNode, lView, token, flags, notFoundValue) {
  const bloomHash = bloomHashBitOrFactory(token);
  if (typeof bloomHash === 'function') {
    if (!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.enterDI)(lView, tNode, flags)) {
      return flags & 1 ? notFoundValueOrThrow(notFoundValue, token, flags) : lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
    }
    try {
      let value;
      if (ngDevMode) {
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.runInInjectorProfilerContext)(new NodeInjector((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)()), token, () => {
          (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.emitInjectorToCreateInstanceEvent)(token);
          value = bloomHash(flags);
          (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.emitInstanceCreatedByInjectorEvent)(value);
        });
      } else {
        value = bloomHash(flags);
      }
      if (value == null && !(flags & 8)) {
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwProviderNotFoundError)(token);
      } else {
        return value;
      }
    } finally {
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.leaveDI)();
    }
  } else if (typeof bloomHash === 'number') {
    let previousTView = null;
    let injectorIndex = getInjectorIndex(tNode, lView);
    let parentLocation = NO_PARENT_INJECTOR;
    let hostTElementNode = flags & 1 ? lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST] : null;
    if (injectorIndex === -1 || flags & 4) {
      parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) : lView[injectorIndex + 8];
      if (parentLocation === NO_PARENT_INJECTOR || !shouldSearchParent(flags, false)) {
        injectorIndex = -1;
      } else {
        previousTView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
        injectorIndex = getParentInjectorIndex(parentLocation);
        lView = getParentInjectorView(parentLocation, lView);
      }
    }
    while (injectorIndex !== -1) {
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNodeInjector)(lView, injectorIndex);
      const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForLView)(tView.data[injectorIndex + 8], lView);
      if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {
        const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);
        if (instance !== NOT_FOUND) {
          return instance;
        }
      }
      parentLocation = lView[injectorIndex + 8];
      if (parentLocation !== NO_PARENT_INJECTOR && shouldSearchParent(flags, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data[injectorIndex + 8] === hostTElementNode) && bloomHasToken(bloomHash, injectorIndex, lView)) {
        previousTView = tView;
        injectorIndex = getParentInjectorIndex(parentLocation);
        lView = getParentInjectorView(parentLocation, lView);
      } else {
        injectorIndex = -1;
      }
    }
  }
  return notFoundValue;
}
function searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {
  const currentTView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const tNode = currentTView.data[injectorIndex + 8];
  const canAccessViewProviders = previousTView == null ? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentHost)(tNode) && includeViewProviders : previousTView != currentTView && (tNode.type & 3) !== 0;
  const isHostSpecialCase = flags & 1 && hostTElementNode === tNode;
  const injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);
  if (injectableIdx !== null) {
    return getNodeInjectable(lView, currentTView, injectableIdx, tNode, flags);
  } else {
    return NOT_FOUND;
  }
}
function locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {
  const nodeProviderIndexes = tNode.providerIndexes;
  const tInjectables = tView.data;
  const injectablesStart = nodeProviderIndexes & 1048575;
  const directivesStart = tNode.directiveStart;
  const directiveEnd = tNode.directiveEnd;
  const cptViewProvidersCount = nodeProviderIndexes >> 20;
  const startingIndex = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;
  const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;
  for (let i = startingIndex; i < endIndex; i++) {
    const providerTokenOrDef = tInjectables[i];
    if (i < directivesStart && token === providerTokenOrDef || i >= directivesStart && providerTokenOrDef.type === token) {
      return i;
    }
  }
  if (isHostSpecialCase) {
    const dirDef = tInjectables[directivesStart];
    if (dirDef && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentDef)(dirDef) && dirDef.type === token) {
      return directivesStart;
    }
  }
  return null;
}
let injectionPath = [];
function getNodeInjectable(lView, tView, index, tNode, flags) {
  let value = lView[index];
  const tData = tView.data;
  if (value instanceof NodeInjectorFactory) {
    const factory = value;
    ngDevMode && injectionPath.push(factory.name ?? 'unknown');
    if (factory.resolving) {
      const token = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(tData[index]);
      if (ngDevMode) {
        throw (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.cyclicDependencyErrorWithDetails)(token, injectionPath);
      } else {
        throw (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.cyclicDependencyError)(token);
      }
    }
    const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);
    factory.resolving = true;
    const token = tData[index].type || tData[index];
    let prevInjectContext;
    if (ngDevMode) {
      const injector = new NodeInjector(tNode, lView);
      prevInjectContext = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInjectorProfilerContext)({
        injector,
        token
      });
    }
    const previousInjectImplementation = factory.injectImpl ? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInjectImplementation)(factory.injectImpl) : null;
    const success = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.enterDI)(lView, tNode, 0);
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(success, true, "Because flags do not contain `SkipSelf' we expect this to always succeed.");
    try {
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.emitInjectorToCreateInstanceEvent)(token);
      value = lView[index] = factory.factory(undefined, flags, tData, lView, tNode);
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.emitInstanceCreatedByInjectorEvent)(value);
      if (tView.firstCreatePass && index >= tNode.directiveStart) {
        ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDirectiveDef)(tData[index]);
        registerPreOrderHooks(index, tData[index], tView);
      }
    } finally {
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInjectorProfilerContext)(prevInjectContext);
      previousInjectImplementation !== null && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInjectImplementation)(previousInjectImplementation);
      setIncludeViewProviders(previousIncludeViewProviders);
      factory.resolving = false;
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.leaveDI)();
      ngDevMode && (injectionPath = []);
    }
  }
  return value;
}
function bloomHashBitOrFactory(token) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(token, 'token must be defined');
  if (typeof token === 'string') {
    return token.charCodeAt(0) || 0;
  }
  const tokenId = token.hasOwnProperty(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_ELEMENT_ID) ? token[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_ELEMENT_ID] : undefined;
  if (typeof tokenId === 'number') {
    if (tokenId >= 0) {
      return tokenId & BLOOM_MASK;
    } else {
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(tokenId, -1, 'Expecting to get Special Injector Id');
      return createNodeInjector;
    }
  } else {
    return tokenId;
  }
}
function bloomHasToken(bloomHash, injectorIndex, injectorView) {
  const mask = 1 << bloomHash;
  const value = injectorView[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)];
  return !!(value & mask);
}
function shouldSearchParent(flags, isFirstHostTNode) {
  return !(flags & 2) && !(flags & 1 && isFirstHostTNode);
}
function getNodeInjectorLView(nodeInjector) {
  return nodeInjector._lView;
}
function getNodeInjectorTNode(nodeInjector) {
  return nodeInjector._tNode;
}
class NodeInjector {
  _tNode;
  _lView;
  constructor(_tNode, _lView) {
    this._tNode = _tNode;
    this._lView = _lView;
  }
  get(token, notFoundValue, flags) {
    return getOrCreateInjectable(this._tNode, this._lView, token, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.convertToBitFlags)(flags), notFoundValue);
  }
}
function createNodeInjector() {
  return new NodeInjector((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)());
}
function ɵɵgetInheritedFactory(type) {
  return noSideEffects(() => {
    const ownConstructor = type.prototype.constructor;
    const ownFactory = ownConstructor[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_FACTORY_DEF] || getFactoryOf(ownConstructor);
    const objectPrototype = Object.prototype;
    let parent = Object.getPrototypeOf(type.prototype).constructor;
    while (parent && parent !== objectPrototype) {
      const factory = parent[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_FACTORY_DEF] || getFactoryOf(parent);
      if (factory && factory !== ownFactory) {
        return factory;
      }
      parent = Object.getPrototypeOf(parent);
    }
    return t => new t();
  });
}
function getFactoryOf(type) {
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isForwardRef)(type)) {
    return () => {
      const factory = getFactoryOf((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(type));
      return factory && factory();
    };
  }
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getFactoryDef)(type);
}
function lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, notFoundValue) {
  let currentTNode = tNode;
  let currentLView = lView;
  while (currentTNode !== null && currentLView !== null && currentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] & 2048 && !(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isRootView)(currentLView)) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForLView)(currentTNode, currentLView);
    const nodeInjectorValue = lookupTokenUsingNodeInjector(currentTNode, currentLView, token, flags | 2, NOT_FOUND);
    if (nodeInjectorValue !== NOT_FOUND) {
      return nodeInjectorValue;
    }
    let parentTNode = currentTNode.parent;
    if (!parentTNode) {
      const embeddedViewInjector = currentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMBEDDED_VIEW_INJECTOR];
      if (embeddedViewInjector) {
        const embeddedViewInjectorValue = embeddedViewInjector.get(token, NOT_FOUND, flags);
        if (embeddedViewInjectorValue !== NOT_FOUND) {
          return embeddedViewInjectorValue;
        }
      }
      parentTNode = getTNodeFromLView(currentLView);
      currentLView = currentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_VIEW];
    }
    currentTNode = parentTNode;
  }
  return notFoundValue;
}
function getTNodeFromLView(lView) {
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const tViewType = tView.type;
  if (tViewType === 2) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(tView.declTNode, 'Embedded TNodes should have declaration parents.');
    return tView.declTNode;
  } else if (tViewType === 1) {
    return lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST];
  }
  return null;
}
function ɵɵinjectAttribute(attrNameToInject) {
  return injectAttributeImpl((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)(), attrNameToInject);
}
const Attribute = makeParamDecorator('Attribute', attributeName => ({
  attributeName,
  __NG_ELEMENT_ID__: () => ɵɵinjectAttribute(attributeName)
}));
let _reflect = null;
function getReflect() {
  return _reflect = _reflect || new ReflectionCapabilities();
}
function reflectDependencies(type) {
  return convertDependencies(getReflect().parameters(type));
}
function convertDependencies(deps) {
  return deps.map(dep => reflectDependency(dep));
}
function reflectDependency(dep) {
  const meta = {
    token: null,
    attribute: null,
    host: false,
    optional: false,
    self: false,
    skipSelf: false
  };
  if (Array.isArray(dep) && dep.length > 0) {
    for (let j = 0; j < dep.length; j++) {
      const param = dep[j];
      if (param === undefined) {
        continue;
      }
      const proto = Object.getPrototypeOf(param);
      if (param instanceof Optional || proto.ngMetadataName === 'Optional') {
        meta.optional = true;
      } else if (param instanceof SkipSelf || proto.ngMetadataName === 'SkipSelf') {
        meta.skipSelf = true;
      } else if (param instanceof Self || proto.ngMetadataName === 'Self') {
        meta.self = true;
      } else if (param instanceof Host || proto.ngMetadataName === 'Host') {
        meta.host = true;
      } else if (param instanceof Inject) {
        meta.token = param.token;
      } else if (param instanceof Attribute) {
        if (param.attributeName === undefined) {
          throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(204, ngDevMode && `Attribute name must be defined.`);
        }
        meta.attribute = param.attributeName;
      } else {
        meta.token = param;
      }
    }
  } else if (dep === undefined || Array.isArray(dep) && dep.length === 0) {
    meta.token = null;
  } else {
    meta.token = dep;
  }
  return meta;
}
function compileInjectable(type, meta) {
  let ngInjectableDef = null;
  let ngFactoryDef = null;
  if (!type.hasOwnProperty(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_PROV_DEF)) {
    Object.defineProperty(type, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_PROV_DEF, {
      get: () => {
        if (ngInjectableDef === null) {
          const compiler = getCompilerFacade({
            usage: 0,
            kind: 'injectable',
            type
          });
          ngInjectableDef = compiler.compileInjectable(angularCoreDiEnv, `ng:///${type.name}/ɵprov.js`, getInjectableMetadata(type, meta));
        }
        return ngInjectableDef;
      }
    });
  }
  if (!type.hasOwnProperty(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_FACTORY_DEF)) {
    Object.defineProperty(type, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_FACTORY_DEF, {
      get: () => {
        if (ngFactoryDef === null) {
          const compiler = getCompilerFacade({
            usage: 0,
            kind: 'injectable',
            type
          });
          ngFactoryDef = compiler.compileFactory(angularCoreDiEnv, `ng:///${type.name}/ɵfac.js`, {
            name: type.name,
            type,
            typeArgumentCount: 0,
            deps: reflectDependencies(type),
            target: compiler.FactoryTarget.Injectable
          });
        }
        return ngFactoryDef;
      },
      configurable: true
    });
  }
}
const USE_VALUE = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty)({
  provide: String,
  useValue: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty
});
function isUseClassProvider(meta) {
  return meta.useClass !== undefined;
}
function isUseValueProvider(meta) {
  return USE_VALUE in meta;
}
function isUseFactoryProvider(meta) {
  return meta.useFactory !== undefined;
}
function isUseExistingProvider(meta) {
  return meta.useExisting !== undefined;
}
function getInjectableMetadata(type, srcMeta) {
  const meta = srcMeta || {
    providedIn: null
  };
  const compilerMeta = {
    name: type.name,
    type: type,
    typeArgumentCount: 0,
    providedIn: meta.providedIn
  };
  if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== undefined) {
    compilerMeta.deps = convertDependencies(meta.deps);
  }
  if (isUseClassProvider(meta)) {
    compilerMeta.useClass = meta.useClass;
  } else if (isUseValueProvider(meta)) {
    compilerMeta.useValue = meta.useValue;
  } else if (isUseFactoryProvider(meta)) {
    compilerMeta.useFactory = meta.useFactory;
  } else if (isUseExistingProvider(meta)) {
    compilerMeta.useExisting = meta.useExisting;
  }
  return compilerMeta;
}
const Injectable = makeDecorator('Injectable', undefined, undefined, undefined, (type, meta) => compileInjectable(type, meta));
function injectElementRef() {
  return createElementRef((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)());
}
function createElementRef(tNode, lView) {
  return new ElementRef((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView));
}
class ElementRef {
  nativeElement;
  constructor(nativeElement) {
    this.nativeElement = nativeElement;
  }
  static __NG_ELEMENT_ID__ = injectElementRef;
}
function unwrapElementRef(value) {
  return value instanceof ElementRef ? value.nativeElement : value;
}
function symbolIterator() {
  return this._results[Symbol.iterator]();
}
class QueryList {
  _emitDistinctChangesOnly;
  dirty = true;
  _onDirty = undefined;
  _results = [];
  _changesDetected = false;
  _changes = undefined;
  length = 0;
  first = undefined;
  last = undefined;
  get changes() {
    return this._changes ??= new rxjs__WEBPACK_IMPORTED_MODULE_3__.Subject();
  }
  constructor(_emitDistinctChangesOnly = false) {
    this._emitDistinctChangesOnly = _emitDistinctChangesOnly;
  }
  get(index) {
    return this._results[index];
  }
  map(fn) {
    return this._results.map(fn);
  }
  filter(fn) {
    return this._results.filter(fn);
  }
  find(fn) {
    return this._results.find(fn);
  }
  reduce(fn, init) {
    return this._results.reduce(fn, init);
  }
  forEach(fn) {
    this._results.forEach(fn);
  }
  some(fn) {
    return this._results.some(fn);
  }
  toArray() {
    return this._results.slice();
  }
  toString() {
    return this._results.toString();
  }
  reset(resultsTree, identityAccessor) {
    this.dirty = false;
    const newResultFlat = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(resultsTree);
    if (this._changesDetected = !(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.arrayEquals)(this._results, newResultFlat, identityAccessor)) {
      this._results = newResultFlat;
      this.length = newResultFlat.length;
      this.last = newResultFlat[this.length - 1];
      this.first = newResultFlat[0];
    }
  }
  notifyOnChanges() {
    if (this._changes !== undefined && (this._changesDetected || !this._emitDistinctChangesOnly)) this._changes.next(this);
  }
  onDirty(cb) {
    this._onDirty = cb;
  }
  setDirty() {
    this.dirty = true;
    this._onDirty?.();
  }
  destroy() {
    if (this._changes !== undefined) {
      this._changes.complete();
      this._changes.unsubscribe();
    }
  }
  [Symbol.iterator] = (() => symbolIterator)();
}
const SKIP_HYDRATION_ATTR_NAME = 'ngSkipHydration';
const SKIP_HYDRATION_ATTR_NAME_LOWER_CASE = 'ngskiphydration';
function hasSkipHydrationAttrOnTNode(tNode) {
  const attrs = tNode.mergedAttrs;
  if (attrs === null) return false;
  for (let i = 0; i < attrs.length; i += 2) {
    const value = attrs[i];
    if (typeof value === 'number') return false;
    if (typeof value === 'string' && value.toLowerCase() === SKIP_HYDRATION_ATTR_NAME_LOWER_CASE) {
      return true;
    }
  }
  return false;
}
function hasSkipHydrationAttrOnRElement(rNode) {
  return rNode.hasAttribute(SKIP_HYDRATION_ATTR_NAME);
}
function hasInSkipHydrationBlockFlag(tNode) {
  return (tNode.flags & 128) === 128;
}
function isInSkipHydrationBlock(tNode) {
  if (hasInSkipHydrationBlockFlag(tNode)) {
    return true;
  }
  let currentTNode = tNode.parent;
  while (currentTNode) {
    if (hasInSkipHydrationBlockFlag(tNode) || hasSkipHydrationAttrOnTNode(currentTNode)) {
      return true;
    }
    currentTNode = currentTNode.parent;
  }
  return false;
}
function isI18nInSkipHydrationBlock(parentTNode) {
  return hasInSkipHydrationBlockFlag(parentTNode) || hasSkipHydrationAttrOnTNode(parentTNode) || isInSkipHydrationBlock(parentTNode);
}
var ChangeDetectionStrategy;
(function (ChangeDetectionStrategy) {
  ChangeDetectionStrategy[ChangeDetectionStrategy["OnPush"] = 0] = "OnPush";
  ChangeDetectionStrategy[ChangeDetectionStrategy["Default"] = 1] = "Default";
})(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));
const TRACKED_LVIEWS = new Map();
let uniqueIdCounter = 0;
function getUniqueLViewId() {
  return uniqueIdCounter++;
}
function registerLView(lView) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ID], 'LView must have an ID in order to be registered');
  TRACKED_LVIEWS.set(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ID], lView);
}
function getLViewById(id) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(id, 'ID used for LView lookup must be a number');
  return TRACKED_LVIEWS.get(id) || null;
}
function unregisterLView(lView) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ID], 'Cannot stop tracking an LView that does not have an ID');
  TRACKED_LVIEWS.delete(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ID]);
}
function getTrackedLViews() {
  return TRACKED_LVIEWS;
}
class LContext {
  lViewId;
  nodeIndex;
  native;
  component;
  directives;
  localRefs;
  get lView() {
    return getLViewById(this.lViewId);
  }
  constructor(lViewId, nodeIndex, native) {
    this.lViewId = lViewId;
    this.nodeIndex = nodeIndex;
    this.native = native;
  }
}
function getLContext(target) {
  let mpValue = readPatchedData(target);
  if (mpValue) {
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(mpValue)) {
      const lView = mpValue;
      let nodeIndex;
      let component = undefined;
      let directives = undefined;
      if (isComponentInstance(target)) {
        nodeIndex = findViaComponent(lView, target);
        if (nodeIndex == -1) {
          throw new Error('The provided component was not found in the application');
        }
        component = target;
      } else if (isDirectiveInstance(target)) {
        nodeIndex = findViaDirective(lView, target);
        if (nodeIndex == -1) {
          throw new Error('The provided directive was not found in the application');
        }
        directives = getDirectivesAtNodeIndex(nodeIndex, lView);
      } else {
        nodeIndex = findViaNativeElement(lView, target);
        if (nodeIndex == -1) {
          return null;
        }
      }
      const native = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[nodeIndex]);
      const existingCtx = readPatchedData(native);
      const context = existingCtx && !Array.isArray(existingCtx) ? existingCtx : createLContext(lView, nodeIndex, native);
      if (component && context.component === undefined) {
        context.component = component;
        attachPatchData(context.component, context);
      }
      if (directives && context.directives === undefined) {
        context.directives = directives;
        for (let i = 0; i < directives.length; i++) {
          attachPatchData(directives[i], context);
        }
      }
      attachPatchData(context.native, context);
      mpValue = context;
    }
  } else {
    const rElement = target;
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDomNode)(rElement);
    let parent = rElement;
    while (parent = parent.parentNode) {
      const parentContext = readPatchedData(parent);
      if (parentContext) {
        const lView = Array.isArray(parentContext) ? parentContext : parentContext.lView;
        if (!lView) {
          return null;
        }
        const index = findViaNativeElement(lView, rElement);
        if (index >= 0) {
          const native = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[index]);
          const context = createLContext(lView, index, native);
          attachPatchData(native, context);
          mpValue = context;
          break;
        }
      }
    }
  }
  return mpValue || null;
}
function createLContext(lView, nodeIndex, native) {
  return new LContext(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ID], nodeIndex, native);
}
function getComponentViewByInstance(componentInstance) {
  let patchedData = readPatchedData(componentInstance);
  let lView;
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(patchedData)) {
    const contextLView = patchedData;
    const nodeIndex = findViaComponent(contextLView, componentInstance);
    lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(nodeIndex, contextLView);
    const context = createLContext(contextLView, nodeIndex, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST]);
    context.component = componentInstance;
    attachPatchData(componentInstance, context);
    attachPatchData(context.native, context);
  } else {
    const context = patchedData;
    const contextLView = context.lView;
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLView)(contextLView);
    lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(context.nodeIndex, contextLView);
  }
  return lView;
}
const MONKEY_PATCH_KEY_NAME = '__ngContext__';
function attachPatchData(target, data) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(target, 'Target expected');
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(data)) {
    target[MONKEY_PATCH_KEY_NAME] = data[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ID];
    registerLView(data);
  } else {
    target[MONKEY_PATCH_KEY_NAME] = data;
  }
}
function readPatchedData(target) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(target, 'Target expected');
  const data = target[MONKEY_PATCH_KEY_NAME];
  return typeof data === 'number' ? getLViewById(data) : data || null;
}
function readPatchedLView(target) {
  const value = readPatchedData(target);
  if (value) {
    return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(value) ? value : value.lView;
  }
  return null;
}
function isComponentInstance(instance) {
  return instance && instance.constructor && instance.constructor.ɵcmp;
}
function isDirectiveInstance(instance) {
  return instance && instance.constructor && instance.constructor.ɵdir;
}
function findViaNativeElement(lView, target) {
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[i]) === target) {
      return i;
    }
  }
  return -1;
}
function traverseNextElement(tNode) {
  if (tNode.child) {
    return tNode.child;
  } else if (tNode.next) {
    return tNode.next;
  } else {
    while (tNode.parent && !tNode.parent.next) {
      tNode = tNode.parent;
    }
    return tNode.parent && tNode.parent.next;
  }
}
function findViaComponent(lView, componentInstance) {
  const componentIndices = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].components;
  if (componentIndices) {
    for (let i = 0; i < componentIndices.length; i++) {
      const elementComponentIndex = componentIndices[i];
      const componentView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(elementComponentIndex, lView);
      if (componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT] === componentInstance) {
        return elementComponentIndex;
      }
    }
  } else {
    const rootComponentView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET, lView);
    const rootComponent = rootComponentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT];
    if (rootComponent === componentInstance) {
      return _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
    }
  }
  return -1;
}
function findViaDirective(lView, directiveInstance) {
  let tNode = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].firstChild;
  while (tNode) {
    const directiveIndexStart = tNode.directiveStart;
    const directiveIndexEnd = tNode.directiveEnd;
    for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {
      if (lView[i] === directiveInstance) {
        return tNode.index;
      }
    }
    tNode = traverseNextElement(tNode);
  }
  return -1;
}
function getDirectivesAtNodeIndex(nodeIndex, lView) {
  const tNode = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data[nodeIndex];
  if (tNode.directiveStart === 0) return _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY;
  const results = [];
  for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {
    const directiveInstance = lView[i];
    if (!isComponentInstance(directiveInstance)) {
      results.push(directiveInstance);
    }
  }
  return results;
}
function getComponentAtNodeIndex(nodeIndex, lView) {
  const tNode = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data[nodeIndex];
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentHost)(tNode) ? lView[tNode.directiveStart + tNode.componentOffset] : null;
}
function discoverLocalRefs(lView, nodeIndex) {
  const tNode = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data[nodeIndex];
  if (tNode && tNode.localNames) {
    const result = {};
    let localIndex = tNode.index + 1;
    for (let i = 0; i < tNode.localNames.length; i += 2) {
      result[tNode.localNames[i]] = lView[localIndex];
      localIndex++;
    }
    return result;
  }
  return null;
}
function getRootView(componentOrLView) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(componentOrLView, 'component');
  let lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView);
  while (lView && !(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isRootView)(lView)) {
    lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLViewParent)(lView);
  }
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLView)(lView);
  return lView;
}
function getRootContext(viewOrComponent) {
  const rootView = getRootView(viewOrComponent);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(rootView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT], 'Root view has no context. Perhaps it is disconnected?');
  return rootView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT];
}
function getFirstLContainer(lView) {
  return getNearestLContainer(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CHILD_HEAD]);
}
function getNextLContainer(container) {
  return getNearestLContainer(container[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT]);
}
function getNearestLContainer(viewOrContainer) {
  while (viewOrContainer !== null && !(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(viewOrContainer)) {
    viewOrContainer = viewOrContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT];
  }
  return viewOrContainer;
}
function getComponent(element) {
  ngDevMode && assertDomElement(element);
  const context = getLContext(element);
  if (context === null) return null;
  if (context.component === undefined) {
    const lView = context.lView;
    if (lView === null) {
      return null;
    }
    context.component = getComponentAtNodeIndex(context.nodeIndex, lView);
  }
  return context.component;
}
function getContext(element) {
  assertDomElement(element);
  const context = getLContext(element);
  const lView = context ? context.lView : null;
  return lView === null ? null : lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT];
}
function getOwningComponent(elementOrDir) {
  const context = getLContext(elementOrDir);
  let lView = context ? context.lView : null;
  if (lView === null) return null;
  let parent;
  while (lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].type === 2 && (parent = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLViewParent)(lView))) {
    lView = parent;
  }
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isRootView)(lView) ? null : lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT];
}
function getRootComponents(elementOrDir) {
  const lView = readPatchedLView(elementOrDir);
  return lView !== null ? [getRootContext(lView)] : [];
}
function getInjector(elementOrDir) {
  const context = getLContext(elementOrDir);
  const lView = context ? context.lView : null;
  if (lView === null) return _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.Injector.NULL;
  const tNode = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data[context.nodeIndex];
  return new NodeInjector(tNode, lView);
}
function getInjectionTokens(element) {
  const context = getLContext(element);
  const lView = context ? context.lView : null;
  if (lView === null) return [];
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const tNode = tView.data[context.nodeIndex];
  const providerTokens = [];
  const startIndex = tNode.providerIndexes & 1048575;
  const endIndex = tNode.directiveEnd;
  for (let i = startIndex; i < endIndex; i++) {
    let value = tView.data[i];
    if (isDirectiveDefHack(value)) {
      value = value.type;
    }
    providerTokens.push(value);
  }
  return providerTokens;
}
function getDirectives(node) {
  if (node instanceof Text) {
    return [];
  }
  const context = getLContext(node);
  const lView = context ? context.lView : null;
  if (lView === null) {
    return [];
  }
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const nodeIndex = context.nodeIndex;
  if (!tView?.data[nodeIndex]) {
    return [];
  }
  if (context.directives === undefined) {
    context.directives = getDirectivesAtNodeIndex(nodeIndex, lView);
  }
  return context.directives === null ? [] : [...context.directives];
}
var AcxChangeDetectionStrategy;
(function (AcxChangeDetectionStrategy) {
  AcxChangeDetectionStrategy[AcxChangeDetectionStrategy["Default"] = 0] = "Default";
  AcxChangeDetectionStrategy[AcxChangeDetectionStrategy["OnPush"] = 1] = "OnPush";
})(AcxChangeDetectionStrategy || (AcxChangeDetectionStrategy = {}));
var AcxViewEncapsulation;
(function (AcxViewEncapsulation) {
  AcxViewEncapsulation[AcxViewEncapsulation["Emulated"] = 0] = "Emulated";
  AcxViewEncapsulation[AcxViewEncapsulation["None"] = 1] = "None";
})(AcxViewEncapsulation || (AcxViewEncapsulation = {}));
function getDirectiveMetadata$1(directiveOrComponentInstance) {
  const {
    constructor
  } = directiveOrComponentInstance;
  if (!constructor) {
    throw new Error('Unable to find the instance constructor');
  }
  const componentDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(constructor);
  if (componentDef) {
    const inputs = extractInputDebugMetadata(componentDef.inputs);
    return {
      inputs,
      outputs: componentDef.outputs,
      encapsulation: componentDef.encapsulation,
      changeDetection: componentDef.onPush ? ChangeDetectionStrategy.OnPush : ChangeDetectionStrategy.Default
    };
  }
  const directiveDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(constructor);
  if (directiveDef) {
    const inputs = extractInputDebugMetadata(directiveDef.inputs);
    return {
      inputs,
      outputs: directiveDef.outputs
    };
  }
  return null;
}
function getLocalRefs(target) {
  const context = getLContext(target);
  if (context === null) return {};
  if (context.localRefs === undefined) {
    const lView = context.lView;
    if (lView === null) {
      return {};
    }
    context.localRefs = discoverLocalRefs(lView, context.nodeIndex);
  }
  return context.localRefs || {};
}
function getHostElement(componentOrDirective) {
  return getLContext(componentOrDirective).native;
}
function getListeners(element) {
  ngDevMode && assertDomElement(element);
  const lContext = getLContext(element);
  const lView = lContext === null ? null : lContext.lView;
  if (lView === null) return [];
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const lCleanup = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CLEANUP];
  const tCleanup = tView.cleanup;
  const listeners = [];
  if (tCleanup && lCleanup) {
    for (let i = 0; i < tCleanup.length;) {
      const firstParam = tCleanup[i++];
      const secondParam = tCleanup[i++];
      if (typeof firstParam === 'string') {
        const name = firstParam;
        const listenerElement = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[secondParam]);
        const callback = lCleanup[tCleanup[i++]];
        const useCaptureOrIndx = tCleanup[i++];
        const type = typeof useCaptureOrIndx === 'boolean' || useCaptureOrIndx >= 0 ? 'dom' : 'output';
        const useCapture = typeof useCaptureOrIndx === 'boolean' ? useCaptureOrIndx : false;
        if (element == listenerElement) {
          listeners.push({
            element,
            name,
            callback,
            useCapture,
            type
          });
        }
      }
    }
  }
  listeners.sort(sortListeners);
  return listeners;
}
function sortListeners(a, b) {
  if (a.name == b.name) return 0;
  return a.name < b.name ? -1 : 1;
}
function isDirectiveDefHack(obj) {
  return obj.type !== undefined && obj.declaredInputs !== undefined && obj.resolveHostDirectives !== undefined;
}
function assertDomElement(value) {
  if (typeof Element !== 'undefined' && !(value instanceof Element)) {
    throw new Error('Expecting instance of DOM Element');
  }
}
function extractInputDebugMetadata(inputs) {
  const res = {};
  for (const key in inputs) {
    if (inputs.hasOwnProperty(key)) {
      const value = inputs[key];
      if (value !== undefined) {
        res[key] = value[0];
      }
    }
  }
  return res;
}
let DOCUMENT = undefined;
function setDocument(document) {
  DOCUMENT = document;
}
function getDocument() {
  if (DOCUMENT !== undefined) {
    return DOCUMENT;
  } else if (typeof document !== 'undefined') {
    return document;
  }
  throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(210, (typeof ngDevMode === 'undefined' || ngDevMode) && `The document object is not available in this context. Make sure the DOCUMENT injection token is provided.`);
}
const APP_ID = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'AppId' : '', {
  factory: () => DEFAULT_APP_ID
});
const DEFAULT_APP_ID = 'ng';
const validAppIdInitializer = {
  provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT_INITIALIZER,
  multi: true,
  useValue: () => {
    const appId = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(APP_ID);
    const isAlphanumeric = /^[a-zA-Z0-9\-_]+$/.test(appId);
    if (!isAlphanumeric) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(211, `APP_ID value "${appId}" is not alphanumeric. ` + `The APP_ID must be a string of alphanumeric characters. (a-zA-Z0-9), hyphens (-) and underscores (_) are allowed.`);
    }
  }
};
const PLATFORM_INITIALIZER = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Platform Initializer' : '');
const PLATFORM_ID = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Platform ID' : '', {
  providedIn: 'platform',
  factory: () => 'unknown'
});
const ANIMATION_MODULE_TYPE = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'AnimationModuleType' : '');
const CSP_NONCE = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'CSP nonce' : '', {
  factory: () => {
    return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT).body?.querySelector('[ngCspNonce]')?.getAttribute('ngCspNonce') || null;
  }
});
const IMAGE_CONFIG_DEFAULTS = {
  breakpoints: [16, 32, 48, 64, 96, 128, 256, 384, 640, 750, 828, 1080, 1200, 1920, 2048, 3840],
  placeholderResolution: 30,
  disableImageSizeWarning: false,
  disableImageLazyLoadWarning: false
};
const IMAGE_CONFIG = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'ImageConfig' : '', {
  factory: () => IMAGE_CONFIG_DEFAULTS
});
function makeStateKey(key) {
  return key;
}
class TransferState {
  static ɵprov = /* @__PURE__ */
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
    token: TransferState,
    providedIn: 'root',
    factory: () => {
      const transferState = new TransferState();
      if (typeof ngServerMode === 'undefined' || !ngServerMode) {
        transferState.store = retrieveTransferredState((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(APP_ID));
      }
      return transferState;
    }
  });
  store = {};
  onSerializeCallbacks = {};
  get(key, defaultValue) {
    return this.store[key] !== undefined ? this.store[key] : defaultValue;
  }
  set(key, value) {
    this.store[key] = value;
  }
  remove(key) {
    delete this.store[key];
  }
  hasKey(key) {
    return this.store.hasOwnProperty(key);
  }
  get isEmpty() {
    return Object.keys(this.store).length === 0;
  }
  onSerialize(key, callback) {
    this.onSerializeCallbacks[key] = callback;
  }
  toJson() {
    for (const key in this.onSerializeCallbacks) {
      if (this.onSerializeCallbacks.hasOwnProperty(key)) {
        try {
          this.store[key] = this.onSerializeCallbacks[key]();
        } catch (e) {
          console.warn('Exception in onSerialize callback: ', e);
        }
      }
    }
    return JSON.stringify(this.store).replace(/</g, '\\u003C');
  }
}
function retrieveTransferredState(doc, appId) {
  const script = doc.getElementById(appId + '-state');
  if (script?.textContent) {
    try {
      return JSON.parse(script.textContent);
    } catch (e) {
      console.warn('Exception while restoring TransferState for app ' + appId, e);
    }
  }
  return {};
}
const REFERENCE_NODE_HOST = 'h';
const REFERENCE_NODE_BODY = 'b';
const NODE_NAVIGATION_STEP_FIRST_CHILD = 'f';
const NODE_NAVIGATION_STEP_NEXT_SIBLING = 'n';
const ELEMENT_CONTAINERS = 'e';
const TEMPLATES = 't';
const CONTAINERS = 'c';
const MULTIPLIER = 'x';
const NUM_ROOT_NODES = 'r';
const TEMPLATE_ID = 'i';
const NODES = 'n';
const DISCONNECTED_NODES = 'd';
const I18N_DATA = 'l';
const DEFER_BLOCK_ID = 'di';
const DEFER_BLOCK_STATE$1 = 's';
const DEFER_PARENT_BLOCK_ID = 'p';
const DEFER_HYDRATE_TRIGGERS = 't';
const IS_HYDRATION_DOM_REUSE_ENABLED = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'IS_HYDRATION_DOM_REUSE_ENABLED' : '');
const PRESERVE_HOST_CONTENT_DEFAULT = false;
const PRESERVE_HOST_CONTENT = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'PRESERVE_HOST_CONTENT' : '', {
  factory: () => PRESERVE_HOST_CONTENT_DEFAULT
});
const IS_I18N_HYDRATION_ENABLED = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'IS_I18N_HYDRATION_ENABLED' : '');
const IS_EVENT_REPLAY_ENABLED = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'IS_EVENT_REPLAY_ENABLED' : '');
const EVENT_REPLAY_ENABLED_DEFAULT = false;
const IS_INCREMENTAL_HYDRATION_ENABLED = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'IS_INCREMENTAL_HYDRATION_ENABLED' : '');
const JSACTION_BLOCK_ELEMENT_MAP = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'JSACTION_BLOCK_ELEMENT_MAP' : '', {
  factory: () => new Map()
});
const IS_ENABLED_BLOCKING_INITIAL_NAVIGATION = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'IS_ENABLED_BLOCKING_INITIAL_NAVIGATION' : '');
const eventListenerOptions = {
  passive: true,
  capture: true
};
const hoverTriggers = new WeakMap();
const interactionTriggers = new WeakMap();
const viewportTriggers = new WeakMap();
const interactionEventNames = ['click', 'keydown'];
const hoverEventNames = ['mouseenter', 'mouseover', 'focusin'];
const intersectionObservers = new Map();
class DeferEventEntry {
  callbacks = new Set();
  listener = () => {
    for (const callback of this.callbacks) {
      callback();
    }
  };
}
function onInteraction(trigger, callback) {
  let entry = interactionTriggers.get(trigger);
  if (!entry) {
    entry = new DeferEventEntry();
    interactionTriggers.set(trigger, entry);
    for (const name of interactionEventNames) {
      trigger.addEventListener(name, entry.listener, eventListenerOptions);
    }
  }
  entry.callbacks.add(callback);
  return () => {
    const {
      callbacks,
      listener
    } = entry;
    callbacks.delete(callback);
    if (callbacks.size === 0) {
      interactionTriggers.delete(trigger);
      for (const name of interactionEventNames) {
        trigger.removeEventListener(name, listener, eventListenerOptions);
      }
    }
  };
}
function onHover(trigger, callback) {
  let entry = hoverTriggers.get(trigger);
  if (!entry) {
    entry = new DeferEventEntry();
    hoverTriggers.set(trigger, entry);
    for (const name of hoverEventNames) {
      trigger.addEventListener(name, entry.listener, eventListenerOptions);
    }
  }
  entry.callbacks.add(callback);
  return () => {
    const {
      callbacks,
      listener
    } = entry;
    callbacks.delete(callback);
    if (callbacks.size === 0) {
      for (const name of hoverEventNames) {
        trigger.removeEventListener(name, listener, eventListenerOptions);
      }
      hoverTriggers.delete(trigger);
    }
  };
}
function createIntersectionObserver(options) {
  const key = getIntersectionObserverKey(options);
  return new IntersectionObserver(entries => {
    for (const current of entries) {
      if (current.isIntersecting && viewportTriggers.has(current.target)) {
        viewportTriggers.get(current.target)?.get(key)?.listener();
      }
    }
  }, options);
}
function onViewport(trigger, callback, observerFactoryFn, options) {
  const key = getIntersectionObserverKey(options);
  let entry = viewportTriggers.get(trigger)?.get(key);
  if (!intersectionObservers.has(key)) {
    intersectionObservers.set(key, {
      observer: observerFactoryFn(options),
      count: 0
    });
  }
  const config = intersectionObservers.get(key);
  if (!entry) {
    entry = new DeferEventEntry();
    config.observer.observe(trigger);
    let triggerConfig = viewportTriggers.get(trigger);
    if (triggerConfig) {
      triggerConfig.set(key, entry);
    } else {
      triggerConfig = new Map();
      viewportTriggers.set(trigger, triggerConfig);
    }
    triggerConfig.set(key, entry);
    config.count++;
  }
  entry.callbacks.add(callback);
  return () => {
    if (!viewportTriggers.get(trigger)?.has(key)) {
      return;
    }
    entry.callbacks.delete(callback);
    if (entry.callbacks.size === 0) {
      config.observer.unobserve(trigger);
      config.count--;
      const triggerConfig = viewportTriggers.get(trigger);
      if (triggerConfig) {
        triggerConfig.delete(key);
        if (triggerConfig.size === 0) {
          viewportTriggers.delete(trigger);
        }
      }
    }
    if (config.count === 0) {
      config.observer.disconnect();
      intersectionObservers.delete(key);
    }
  };
}
function getIntersectionObserverKey(options) {
  if (!options) {
    return '';
  }
  return `${options.rootMargin}/${typeof options.threshold === 'number' ? options.threshold : options.threshold?.join('\n')}`;
}
const DEFER_BLOCK_SSR_ID_ATTRIBUTE = 'ngb';
function setJSActionAttributes(nativeElement, eventTypes, parentDeferBlockId = null) {
  if (eventTypes.length === 0 || nativeElement.nodeType !== Node.ELEMENT_NODE) {
    return;
  }
  const existingAttr = nativeElement.getAttribute(_attribute_chunk_mjs__WEBPACK_IMPORTED_MODULE_6__.Attribute.JSACTION);
  const parts = eventTypes.reduce((prev, curr) => {
    return (existingAttr?.indexOf(curr) ?? -1) === -1 ? prev + curr + ':;' : prev;
  }, '');
  nativeElement.setAttribute(_attribute_chunk_mjs__WEBPACK_IMPORTED_MODULE_6__.Attribute.JSACTION, `${existingAttr ?? ''}${parts}`);
  const blockName = parentDeferBlockId ?? '';
  if (blockName !== '' && parts.length > 0) {
    nativeElement.setAttribute(DEFER_BLOCK_SSR_ID_ATTRIBUTE, blockName);
  }
}
const sharedStashFunction = (rEl, eventType, listenerFn) => {
  const el = rEl;
  const eventListenerMap = el.__jsaction_fns ?? new Map();
  const eventListeners = eventListenerMap.get(eventType) ?? [];
  eventListeners.push(listenerFn);
  eventListenerMap.set(eventType, eventListeners);
  el.__jsaction_fns = eventListenerMap;
};
const sharedMapFunction = (rEl, jsActionMap) => {
  const el = rEl;
  let blockName = el.getAttribute(DEFER_BLOCK_SSR_ID_ATTRIBUTE) ?? '';
  const blockSet = jsActionMap.get(blockName) ?? new Set();
  if (!blockSet.has(el)) {
    blockSet.add(el);
  }
  jsActionMap.set(blockName, blockSet);
};
function removeListenersFromBlocks(blockNames, jsActionMap) {
  if (blockNames.length > 0) {
    let blockList = [];
    for (let blockName of blockNames) {
      if (jsActionMap.has(blockName)) {
        blockList = [...blockList, ...jsActionMap.get(blockName)];
      }
    }
    const replayList = new Set(blockList);
    replayList.forEach(removeListeners);
  }
}
const removeListeners = el => {
  el.removeAttribute(_attribute_chunk_mjs__WEBPACK_IMPORTED_MODULE_6__.Attribute.JSACTION);
  el.removeAttribute(DEFER_BLOCK_SSR_ID_ATTRIBUTE);
  el.__jsaction_fns = undefined;
};
const JSACTION_EVENT_CONTRACT = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'EVENT_CONTRACT_DETAILS' : '', {
  factory: () => ({})
});
function invokeListeners(event, currentTarget) {
  const handlerFns = currentTarget?.__jsaction_fns?.get(event.type);
  if (!handlerFns || !currentTarget?.isConnected) {
    return;
  }
  for (const handler of handlerFns) {
    handler(event);
  }
}
const stashEventListeners = new Map();
function setStashFn(appId, fn) {
  stashEventListeners.set(appId, fn);
  return () => stashEventListeners.delete(appId);
}
let isStashEventListenerImplEnabled = false;
let _stashEventListenerImpl = (lView, target, eventName, wrappedListener) => {};
function stashEventListenerImpl(lView, target, eventName, wrappedListener) {
  _stashEventListenerImpl(lView, target, eventName, wrappedListener);
}
function enableStashEventListenerImpl() {
  if (!isStashEventListenerImplEnabled) {
    _stashEventListenerImpl = (lView, target, eventName, wrappedListener) => {
      const appId = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1].get(APP_ID);
      const stashEventListener = stashEventListeners.get(appId);
      stashEventListener?.(target, eventName, wrappedListener);
    };
    isStashEventListenerImplEnabled = true;
  }
}
const DEHYDRATED_BLOCK_REGISTRY = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'DEHYDRATED_BLOCK_REGISTRY' : '');
class DehydratedBlockRegistry {
  registry = new Map();
  cleanupFns = new Map();
  jsActionMap = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(JSACTION_BLOCK_ELEMENT_MAP);
  contract = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(JSACTION_EVENT_CONTRACT);
  add(blockId, info) {
    this.registry.set(blockId, info);
    if (this.awaitingCallbacks.has(blockId)) {
      const awaitingCallbacks = this.awaitingCallbacks.get(blockId);
      for (const cb of awaitingCallbacks) {
        cb();
      }
    }
  }
  get(blockId) {
    return this.registry.get(blockId) ?? null;
  }
  has(blockId) {
    return this.registry.has(blockId);
  }
  cleanup(hydratedBlocks) {
    removeListenersFromBlocks(hydratedBlocks, this.jsActionMap);
    for (let blockId of hydratedBlocks) {
      this.registry.delete(blockId);
      this.jsActionMap.delete(blockId);
      this.invokeTriggerCleanupFns(blockId);
      this.hydrating.delete(blockId);
      this.awaitingCallbacks.delete(blockId);
    }
    if (this.size === 0) {
      this.contract.instance?.cleanUp();
    }
  }
  get size() {
    return this.registry.size;
  }
  addCleanupFn(blockId, fn) {
    let cleanupFunctions = [];
    if (this.cleanupFns.has(blockId)) {
      cleanupFunctions = this.cleanupFns.get(blockId);
    }
    cleanupFunctions.push(fn);
    this.cleanupFns.set(blockId, cleanupFunctions);
  }
  invokeTriggerCleanupFns(blockId) {
    const fns = this.cleanupFns.get(blockId) ?? [];
    for (let fn of fns) {
      fn();
    }
    this.cleanupFns.delete(blockId);
  }
  hydrating = new Map();
  awaitingCallbacks = new Map();
  awaitParentBlock(topmostParentBlock, callback) {
    const parentBlockAwaitCallbacks = this.awaitingCallbacks.get(topmostParentBlock) ?? [];
    parentBlockAwaitCallbacks.push(callback);
    this.awaitingCallbacks.set(topmostParentBlock, parentBlockAwaitCallbacks);
  }
  static ɵprov = /* @__PURE__ */
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
    token: DehydratedBlockRegistry,
    providedIn: null,
    factory: () => new DehydratedBlockRegistry()
  });
}
function isDetachedByI18n(tNode) {
  return (tNode.flags & 32) === 32;
}
const TRANSFER_STATE_TOKEN_ID = '__nghData__';
const NGH_DATA_KEY = makeStateKey(TRANSFER_STATE_TOKEN_ID);
const TRANSFER_STATE_DEFER_BLOCKS_INFO = '__nghDeferData__';
const NGH_DEFER_BLOCKS_KEY = makeStateKey(TRANSFER_STATE_DEFER_BLOCKS_INFO);
function isInternalHydrationTransferStateKey(key) {
  return key === TRANSFER_STATE_TOKEN_ID || key === TRANSFER_STATE_DEFER_BLOCKS_INFO;
}
const NGH_ATTR_NAME = 'ngh';
const SSR_CONTENT_INTEGRITY_MARKER = 'nghm';
let _retrieveHydrationInfoImpl = () => null;
function retrieveHydrationInfoImpl(rNode, injector, isRootView = false) {
  let nghAttrValue = rNode.getAttribute(NGH_ATTR_NAME);
  if (nghAttrValue == null) return null;
  const [componentViewNgh, rootViewNgh] = nghAttrValue.split('|');
  nghAttrValue = isRootView ? rootViewNgh : componentViewNgh;
  if (!nghAttrValue) return null;
  const rootNgh = rootViewNgh ? `|${rootViewNgh}` : '';
  const remainingNgh = isRootView ? componentViewNgh : rootNgh;
  let data = {};
  if (nghAttrValue !== '') {
    const transferState = injector.get(TransferState, null, {
      optional: true
    });
    if (transferState !== null) {
      const nghData = transferState.get(NGH_DATA_KEY, []);
      data = nghData[Number(nghAttrValue)];
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(data, 'Unable to retrieve hydration info from the TransferState.');
    }
  }
  const dehydratedView = {
    data,
    firstChild: rNode.firstChild ?? null
  };
  if (isRootView) {
    dehydratedView.firstChild = rNode;
    setSegmentHead(dehydratedView, 0, rNode.nextSibling);
  }
  if (remainingNgh) {
    rNode.setAttribute(NGH_ATTR_NAME, remainingNgh);
  } else {
    rNode.removeAttribute(NGH_ATTR_NAME);
  }
  ngDevMode && markRNodeAsClaimedByHydration(rNode, false);
  ngDevMode && ngDevMode.hydratedComponents++;
  return dehydratedView;
}
function enableRetrieveHydrationInfoImpl() {
  _retrieveHydrationInfoImpl = retrieveHydrationInfoImpl;
}
function retrieveHydrationInfo(rNode, injector, isRootView = false) {
  return _retrieveHydrationInfoImpl(rNode, injector, isRootView);
}
function getLNodeForHydration(viewRef) {
  let lView = viewRef._lView;
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  if (tView.type === 2) {
    return null;
  }
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isRootView)(lView)) {
    lView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET];
  }
  return lView;
}
function getTextNodeContent(node) {
  return node.textContent?.replace(/\s/gm, '');
}
function processTextNodeMarkersBeforeHydration(node) {
  const doc = getDocument();
  const commentNodesIterator = doc.createNodeIterator(node, NodeFilter.SHOW_COMMENT, {
    acceptNode(node) {
      const content = getTextNodeContent(node);
      const isTextNodeMarker = content === "ngetn" || content === "ngtns";
      return isTextNodeMarker ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
    }
  });
  let currentNode;
  const nodes = [];
  while (currentNode = commentNodesIterator.nextNode()) {
    nodes.push(currentNode);
  }
  for (const node of nodes) {
    if (node.textContent === "ngetn") {
      node.replaceWith(doc.createTextNode(''));
    } else {
      node.remove();
    }
  }
}
var HydrationStatus;
(function (HydrationStatus) {
  HydrationStatus["Hydrated"] = "hydrated";
  HydrationStatus["Skipped"] = "skipped";
  HydrationStatus["Mismatched"] = "mismatched";
})(HydrationStatus || (HydrationStatus = {}));
const HYDRATION_INFO_KEY = '__ngDebugHydrationInfo__';
function patchHydrationInfo(node, info) {
  node[HYDRATION_INFO_KEY] = info;
}
function readHydrationInfo(node) {
  return node[HYDRATION_INFO_KEY] ?? null;
}
function markRNodeAsClaimedByHydration(node, checkIfAlreadyClaimed = true) {
  if (!ngDevMode) {
    throw new Error('Calling `markRNodeAsClaimedByHydration` in prod mode ' + 'is not supported and likely a mistake.');
  }
  if (checkIfAlreadyClaimed && isRNodeClaimedForHydration(node)) {
    throw new Error('Trying to claim a node, which was claimed already.');
  }
  patchHydrationInfo(node, {
    status: HydrationStatus.Hydrated
  });
  ngDevMode.hydratedNodes++;
}
function markRNodeAsSkippedByHydration(node) {
  if (!ngDevMode) {
    throw new Error('Calling `markRNodeAsSkippedByHydration` in prod mode ' + 'is not supported and likely a mistake.');
  }
  patchHydrationInfo(node, {
    status: HydrationStatus.Skipped
  });
  ngDevMode.componentsSkippedHydration++;
}
function countBlocksSkippedByHydration(injector) {
  const transferState = injector.get(TransferState);
  const nghDeferData = transferState.get(NGH_DEFER_BLOCKS_KEY, {});
  if (ngDevMode) {
    ngDevMode.deferBlocksWithIncrementalHydration = Object.keys(nghDeferData).length;
  }
}
function markRNodeAsHavingHydrationMismatch(node, expectedNodeDetails = null, actualNodeDetails = null) {
  if (!ngDevMode) {
    throw new Error('Calling `markRNodeAsMismatchedByHydration` in prod mode ' + 'is not supported and likely a mistake.');
  }
  while (node && !getComponent(node)) {
    node = node?.parentNode;
  }
  if (node) {
    patchHydrationInfo(node, {
      status: HydrationStatus.Mismatched,
      expectedNodeDetails,
      actualNodeDetails
    });
  }
}
function isRNodeClaimedForHydration(node) {
  return readHydrationInfo(node)?.status === HydrationStatus.Hydrated;
}
function setSegmentHead(hydrationInfo, index, node) {
  hydrationInfo.segmentHeads ??= {};
  hydrationInfo.segmentHeads[index] = node;
}
function getSegmentHead(hydrationInfo, index) {
  return hydrationInfo.segmentHeads?.[index] ?? null;
}
function isIncrementalHydrationEnabled(injector) {
  return injector.get(IS_INCREMENTAL_HYDRATION_ENABLED, false, {
    optional: true
  });
}
let incrementalHydrationEnabledWarned = false;
function resetIncrementalHydrationEnabledWarnedForTests() {
  incrementalHydrationEnabledWarned = false;
}
function warnIncrementalHydrationNotConfigured() {
  if (!incrementalHydrationEnabledWarned) {
    incrementalHydrationEnabledWarned = true;
    console.warn((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(508, 'Angular has detected that some `@defer` blocks use `hydrate` triggers, ' + 'but incremental hydration was not enabled. Please ensure that the `withIncrementalHydration()` ' + 'call is added as an argument for the `provideClientHydration()` function call ' + 'in your application config.'));
  }
}
function assertSsrIdDefined(ssrUniqueId) {
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(ssrUniqueId, 'Internal error: expecting an SSR id for a defer block that should be hydrated, but the id is not present');
}
function getNgContainerSize(hydrationInfo, index) {
  const data = hydrationInfo.data;
  let size = data[ELEMENT_CONTAINERS]?.[index] ?? null;
  if (size === null && data[CONTAINERS]?.[index]) {
    size = calcSerializedContainerSize(hydrationInfo, index);
  }
  return size;
}
function isSerializedElementContainer(hydrationInfo, index) {
  return hydrationInfo.data[ELEMENT_CONTAINERS]?.[index] !== undefined;
}
function getSerializedContainerViews(hydrationInfo, index) {
  return hydrationInfo.data[CONTAINERS]?.[index] ?? null;
}
function calcSerializedContainerSize(hydrationInfo, index) {
  const views = getSerializedContainerViews(hydrationInfo, index) ?? [];
  let numNodes = 0;
  for (let view of views) {
    numNodes += view[NUM_ROOT_NODES] * (view[MULTIPLIER] ?? 1);
  }
  return numNodes;
}
function initDisconnectedNodes(hydrationInfo) {
  if (typeof hydrationInfo.disconnectedNodes === 'undefined') {
    const nodeIds = hydrationInfo.data[DISCONNECTED_NODES];
    hydrationInfo.disconnectedNodes = nodeIds ? new Set(nodeIds) : null;
  }
  return hydrationInfo.disconnectedNodes;
}
function isDisconnectedNode$1(hydrationInfo, index) {
  if (typeof hydrationInfo.disconnectedNodes === 'undefined') {
    const nodeIds = hydrationInfo.data[DISCONNECTED_NODES];
    hydrationInfo.disconnectedNodes = nodeIds ? new Set(nodeIds) : null;
  }
  return !!initDisconnectedNodes(hydrationInfo)?.has(index);
}
function canHydrateNode(lView, tNode) {
  const hydrationInfo = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION];
  return hydrationInfo !== null && !(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isInSkipHydrationBlock)() && !isDetachedByI18n(tNode) && !isDisconnectedNode$1(hydrationInfo, tNode.index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET);
}
function processTextNodeBeforeSerialization(context, node) {
  const el = node;
  const corruptedTextNodes = context.corruptedTextNodes;
  if (el.textContent === '') {
    corruptedTextNodes.set(el, "ngetn");
  } else if (el.nextSibling?.nodeType === Node.TEXT_NODE) {
    corruptedTextNodes.set(el, "ngtns");
  }
}
function convertHydrateTriggersToJsAction(triggers) {
  let actionList = [];
  if (triggers !== null) {
    if (triggers.has(4)) {
      actionList.push(...hoverEventNames);
    }
    if (triggers.has(3)) {
      actionList.push(...interactionEventNames);
    }
  }
  return actionList;
}
function getParentBlockHydrationQueue(deferBlockId, injector) {
  const dehydratedBlockRegistry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
  const transferState = injector.get(TransferState);
  const deferBlockParents = transferState.get(NGH_DEFER_BLOCKS_KEY, {});
  let isTopMostDeferBlock = false;
  let currentBlockId = deferBlockId;
  let parentBlockPromise = null;
  const hydrationQueue = [];
  while (!isTopMostDeferBlock && currentBlockId) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(hydrationQueue.indexOf(currentBlockId), -1, 'Internal error: defer block hierarchy has a cycle.');
    isTopMostDeferBlock = dehydratedBlockRegistry.has(currentBlockId);
    const hydratingParentBlock = dehydratedBlockRegistry.hydrating.get(currentBlockId);
    if (parentBlockPromise === null && hydratingParentBlock != null) {
      parentBlockPromise = hydratingParentBlock.promise;
      break;
    }
    hydrationQueue.unshift(currentBlockId);
    currentBlockId = deferBlockParents[currentBlockId][DEFER_PARENT_BLOCK_ID];
  }
  return {
    parentBlockPromise,
    hydrationQueue
  };
}
function gatherDeferBlocksByJSActionAttribute(doc) {
  const jsactionNodes = doc.body.querySelectorAll('[jsaction]');
  const blockMap = new Set();
  const eventTypes = [hoverEventNames.join(':;'), interactionEventNames.join(':;')].join('|');
  for (let node of jsactionNodes) {
    const attr = node.getAttribute('jsaction');
    const blockId = node.getAttribute('ngb');
    if (attr?.match(eventTypes) && blockId !== null) {
      blockMap.add(node);
    }
  }
  return blockMap;
}
function appendDeferBlocksToJSActionMap(doc, injector) {
  const blockMap = gatherDeferBlocksByJSActionAttribute(doc);
  const jsActionMap = injector.get(JSACTION_BLOCK_ELEMENT_MAP);
  for (let rNode of blockMap) {
    sharedMapFunction(rNode, jsActionMap);
  }
}
let _retrieveDeferBlockDataImpl = () => {
  return {};
};
function retrieveDeferBlockDataImpl(injector) {
  const transferState = injector.get(TransferState, null, {
    optional: true
  });
  if (transferState !== null) {
    const nghDeferData = transferState.get(NGH_DEFER_BLOCKS_KEY, {});
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(nghDeferData, 'Unable to retrieve defer block info from the TransferState.');
    return nghDeferData;
  }
  return {};
}
function enableRetrieveDeferBlockDataImpl() {
  _retrieveDeferBlockDataImpl = retrieveDeferBlockDataImpl;
}
function retrieveDeferBlockData(injector) {
  return _retrieveDeferBlockDataImpl(injector);
}
function isTimerTrigger(triggerInfo) {
  return typeof triggerInfo === 'object' && triggerInfo.trigger === 5;
}
function getHydrateTimerTrigger(blockData) {
  const trigger = blockData[DEFER_HYDRATE_TRIGGERS]?.find(t => isTimerTrigger(t));
  return trigger?.delay ?? null;
}
function getHydrateViewportTrigger(blockData) {
  const details = blockData[DEFER_HYDRATE_TRIGGERS];
  if (details) {
    for (const current of details) {
      if (current === 2) {
        return true;
      } else if (typeof current === 'object' && current.trigger === 2) {
        return current.intersectionObserverOptions || true;
      }
    }
  }
  return null;
}
function hasHydrateTrigger(blockData, trigger) {
  return blockData[DEFER_HYDRATE_TRIGGERS]?.includes(trigger) ?? false;
}
function createBlockSummary(blockInfo) {
  return {
    data: blockInfo,
    hydrate: {
      idle: hasHydrateTrigger(blockInfo, 0),
      immediate: hasHydrateTrigger(blockInfo, 1),
      timer: getHydrateTimerTrigger(blockInfo),
      viewport: getHydrateViewportTrigger(blockInfo)
    }
  };
}
function processBlockData(injector) {
  const blockData = retrieveDeferBlockData(injector);
  let blockDetails = new Map();
  for (let blockId in blockData) {
    blockDetails.set(blockId, createBlockSummary(blockData[blockId]));
  }
  return blockDetails;
}
function isSsrContentsIntegrity(node) {
  return !!node && node.nodeType === Node.COMMENT_NODE && node.textContent?.trim() === SSR_CONTENT_INTEGRITY_MARKER;
}
function skipTextNodes(node) {
  while (node && node.nodeType === Node.TEXT_NODE) {
    node = node.previousSibling;
  }
  return node;
}
function verifySsrContentsIntegrity(doc) {
  for (const node of doc.body.childNodes) {
    if (isSsrContentsIntegrity(node)) {
      return;
    }
  }
  const beforeBody = skipTextNodes(doc.body.previousSibling);
  if (isSsrContentsIntegrity(beforeBody)) {
    return;
  }
  let endOfHead = skipTextNodes(doc.head.lastChild);
  if (isSsrContentsIntegrity(endOfHead)) {
    return;
  }
  throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-507, typeof ngDevMode !== 'undefined' && ngDevMode && 'Angular hydration logic detected that HTML content of this page was modified after it ' + 'was produced during server side rendering. Make sure that there are no optimizations ' + 'that remove comment nodes from HTML enabled on your CDN. Angular hydration ' + 'relies on HTML produced by the server, including whitespaces and comment nodes.');
}
function refreshContentQueries(tView, lView) {
  const contentQueries = tView.contentQueries;
  if (contentQueries !== null) {
    const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
    try {
      for (let i = 0; i < contentQueries.length; i += 2) {
        const queryStartIdx = contentQueries[i];
        const directiveDefIdx = contentQueries[i + 1];
        if (directiveDefIdx !== -1) {
          const directiveDef = tView.data[directiveDefIdx];
          ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(directiveDef, 'DirectiveDef not found.');
          ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(directiveDef.contentQueries, 'contentQueries function should be defined');
          (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentQueryIndex)(queryStartIdx);
          directiveDef.contentQueries(2, lView[directiveDefIdx], directiveDefIdx);
        }
      }
    } finally {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
    }
  }
}
function executeViewQueryFn(flags, viewQueryFn, component) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(viewQueryFn, 'View queries function to execute must be defined.');
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentQueryIndex)(0);
  const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
  try {
    viewQueryFn(flags, component);
  } finally {
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
  }
}
function executeContentQueries(tView, tNode, lView) {
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isContentQueryHost)(tNode)) {
    const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
    try {
      const start = tNode.directiveStart;
      const end = tNode.directiveEnd;
      for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {
        const def = tView.data[directiveIndex];
        if (def.contentQueries) {
          const directiveInstance = lView[directiveIndex];
          ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(directiveIndex, 'Incorrect reference to a directive defining a content query');
          def.contentQueries(1, directiveInstance, directiveIndex);
        }
      }
    } finally {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
    }
  }
}
var ViewEncapsulation;
(function (ViewEncapsulation) {
  ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated";
  ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
  ViewEncapsulation[ViewEncapsulation["ShadowDom"] = 3] = "ShadowDom";
  ViewEncapsulation[ViewEncapsulation["ExperimentalIsolatedShadowDom"] = 4] = "ExperimentalIsolatedShadowDom";
})(ViewEncapsulation || (ViewEncapsulation = {}));
const CUSTOM_ELEMENTS_SCHEMA = {
  name: 'custom-elements'
};
const NO_ERRORS_SCHEMA = {
  name: 'no-errors-schema'
};
let shouldThrowErrorOnUnknownElement = false;
function ɵsetUnknownElementStrictMode(shouldThrow) {
  shouldThrowErrorOnUnknownElement = shouldThrow;
}
function ɵgetUnknownElementStrictMode() {
  return shouldThrowErrorOnUnknownElement;
}
let shouldThrowErrorOnUnknownProperty = false;
function ɵsetUnknownPropertyStrictMode(shouldThrow) {
  shouldThrowErrorOnUnknownProperty = shouldThrow;
}
function ɵgetUnknownPropertyStrictMode() {
  return shouldThrowErrorOnUnknownProperty;
}
function validateElementIsKnown(lView, tNode) {
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  if (tView.schemas === null) return;
  const tagName = tNode.value;
  if (!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isDirectiveHost)(tNode) && tagName !== null) {
    const isUnknown = typeof HTMLUnknownElement !== 'undefined' && HTMLUnknownElement && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView) instanceof HTMLUnknownElement || typeof customElements !== 'undefined' && tagName.indexOf('-') > -1 && !customElements.get(tagName);
    if (isUnknown && !matchingSchemas(tView.schemas, tagName)) {
      const isHostStandalone = isHostComponentStandalone(lView);
      const templateLocation = getTemplateLocationDetails(lView);
      const schemas = `'${isHostStandalone ? '@Component' : '@NgModule'}.schemas'`;
      let message = `'${tagName}' is not a known element${templateLocation}:\n`;
      message += `1. If '${tagName}' is an Angular component, then verify that it is ${isHostStandalone ? "included in the '@Component.imports' of this component" : 'a part of an @NgModule where this component is declared'}.\n`;
      if (tagName && tagName.indexOf('-') > -1) {
        message += `2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`;
      } else {
        message += `2. To allow any element add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
      }
      if (shouldThrowErrorOnUnknownElement) {
        throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(304, message);
      } else {
        console.error((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(304, message));
      }
    }
  }
}
function isPropertyValid(element, propName, tagName, schemas) {
  if (schemas === null) return true;
  if (matchingSchemas(schemas, tagName) || propName in element || isAnimationProp(propName)) {
    return true;
  }
  return typeof Node === 'undefined' || Node === null || !(element instanceof Node);
}
function handleUnknownPropertyError(propName, tagName, nodeType, lView) {
  if (!tagName && nodeType === 4) {
    tagName = 'ng-template';
  }
  const isHostStandalone = isHostComponentStandalone(lView);
  const templateLocation = getTemplateLocationDetails(lView);
  let message = `Can't bind to '${propName}' since it isn't a known property of '${tagName}'${templateLocation}.`;
  const schemas = `'${isHostStandalone ? '@Component' : '@NgModule'}.schemas'`;
  const importLocation = isHostStandalone ? "included in the '@Component.imports' of this component" : 'a part of an @NgModule where this component is declared';
  if (KNOWN_CONTROL_FLOW_DIRECTIVES.has(propName)) {
    const correspondingImport = KNOWN_CONTROL_FLOW_DIRECTIVES.get(propName);
    message += `\nIf the '${propName}' is an Angular control flow directive, ` + `please make sure that either the '${correspondingImport}' directive or the 'CommonModule' is ${importLocation}.`;
  } else {
    message += `\n1. If '${tagName}' is an Angular component and it has the ` + `'${propName}' input, then verify that it is ${importLocation}.`;
    if (tagName && tagName.indexOf('-') > -1) {
      message += `\n2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' ` + `to the ${schemas} of this component to suppress this message.`;
      message += `\n3. To allow any property add 'NO_ERRORS_SCHEMA' to ` + `the ${schemas} of this component.`;
    } else {
      message += `\n2. To allow any property add 'NO_ERRORS_SCHEMA' to ` + `the ${schemas} of this component.`;
    }
  }
  reportUnknownPropertyError(message);
}
function reportUnknownPropertyError(message) {
  if (shouldThrowErrorOnUnknownProperty) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(303, message);
  } else {
    console.error((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(303, message));
  }
}
function getDeclarationComponentDef(lView) {
  !ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('Must never be called in production mode');
  const declarationLView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW];
  const context = declarationLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT];
  if (!context) return null;
  return context.constructor ? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(context.constructor) : null;
}
function isHostComponentStandalone(lView) {
  !ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('Must never be called in production mode');
  const componentDef = getDeclarationComponentDef(lView);
  return !!componentDef?.standalone;
}
function getTemplateLocationDetails(lView) {
  !ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('Must never be called in production mode');
  const hostComponentDef = getDeclarationComponentDef(lView);
  const componentClassName = hostComponentDef?.type?.name;
  return componentClassName ? ` (used in the '${componentClassName}' component template)` : '';
}
const KNOWN_CONTROL_FLOW_DIRECTIVES = new Map([['ngIf', 'NgIf'], ['ngFor', 'NgFor'], ['ngSwitchCase', 'NgSwitchCase'], ['ngSwitchDefault', 'NgSwitchDefault']]);
function matchingSchemas(schemas, tagName) {
  if (schemas !== null) {
    for (let i = 0; i < schemas.length; i++) {
      const schema = schemas[i];
      if (schema === NO_ERRORS_SCHEMA || schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf('-') > -1) {
        return true;
      }
    }
  }
  return false;
}
let policy$1;
function getPolicy$1() {
  if (policy$1 === undefined) {
    policy$1 = null;
    if (_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__._global.trustedTypes) {
      try {
        policy$1 = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__._global.trustedTypes.createPolicy('angular', {
          createHTML: s => s,
          createScript: s => s,
          createScriptURL: s => s
        });
      } catch {}
    }
  }
  return policy$1;
}
function trustedHTMLFromString(html) {
  return getPolicy$1()?.createHTML(html) || html;
}
function trustedScriptURLFromString(url) {
  return getPolicy$1()?.createScriptURL(url) || url;
}
let policy;
function getPolicy() {
  if (policy === undefined) {
    policy = null;
    if (_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__._global.trustedTypes) {
      try {
        policy = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__._global.trustedTypes.createPolicy('angular#unsafe-bypass', {
          createHTML: s => s,
          createScript: s => s,
          createScriptURL: s => s
        });
      } catch {}
    }
  }
  return policy;
}
function trustedHTMLFromStringBypass(html) {
  return getPolicy()?.createHTML(html) || html;
}
function trustedScriptFromStringBypass(script) {
  return getPolicy()?.createScript(script) || script;
}
function trustedScriptURLFromStringBypass(url) {
  return getPolicy()?.createScriptURL(url) || url;
}
class SafeValueImpl {
  changingThisBreaksApplicationSecurity;
  constructor(changingThisBreaksApplicationSecurity) {
    this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
  }
  toString() {
    return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity}` + ` (see ${_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.XSS_SECURITY_URL})`;
  }
}
class SafeHtmlImpl extends SafeValueImpl {
  getTypeName() {
    return "HTML";
  }
}
class SafeStyleImpl extends SafeValueImpl {
  getTypeName() {
    return "Style";
  }
}
class SafeScriptImpl extends SafeValueImpl {
  getTypeName() {
    return "Script";
  }
}
class SafeUrlImpl extends SafeValueImpl {
  getTypeName() {
    return "URL";
  }
}
class SafeResourceUrlImpl extends SafeValueImpl {
  getTypeName() {
    return "ResourceURL";
  }
}
function unwrapSafeValue(value) {
  return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity : value;
}
function allowSanitizationBypassAndThrow(value, type) {
  const actualType = getSanitizationBypassType(value);
  if (actualType != null && actualType !== type) {
    if (actualType === "ResourceURL" && type === "URL") return true;
    throw new Error(`Required a safe ${type}, got a ${actualType} (see ${_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.XSS_SECURITY_URL})`);
  }
  return actualType === type;
}
function getSanitizationBypassType(value) {
  return value instanceof SafeValueImpl && value.getTypeName() || null;
}
function bypassSanitizationTrustHtml(trustedHtml) {
  return new SafeHtmlImpl(trustedHtml);
}
function bypassSanitizationTrustStyle(trustedStyle) {
  return new SafeStyleImpl(trustedStyle);
}
function bypassSanitizationTrustScript(trustedScript) {
  return new SafeScriptImpl(trustedScript);
}
function bypassSanitizationTrustUrl(trustedUrl) {
  return new SafeUrlImpl(trustedUrl);
}
function bypassSanitizationTrustResourceUrl(trustedResourceUrl) {
  return new SafeResourceUrlImpl(trustedResourceUrl);
}
function getInertBodyHelper(defaultDoc) {
  const inertDocumentHelper = new InertDocumentHelper(defaultDoc);
  return isDOMParserAvailable() ? new DOMParserHelper(inertDocumentHelper) : inertDocumentHelper;
}
class DOMParserHelper {
  inertDocumentHelper;
  constructor(inertDocumentHelper) {
    this.inertDocumentHelper = inertDocumentHelper;
  }
  getInertBodyElement(html) {
    html = '<body><remove></remove>' + html;
    try {
      const body = new window.DOMParser().parseFromString(trustedHTMLFromString(html), 'text/html').body;
      if (body === null) {
        return this.inertDocumentHelper.getInertBodyElement(html);
      }
      body.firstChild?.remove();
      return body;
    } catch {
      return null;
    }
  }
}
class InertDocumentHelper {
  defaultDoc;
  inertDocument;
  constructor(defaultDoc) {
    this.defaultDoc = defaultDoc;
    this.inertDocument = this.defaultDoc.implementation.createHTMLDocument('sanitization-inert');
  }
  getInertBodyElement(html) {
    const templateEl = this.inertDocument.createElement('template');
    templateEl.innerHTML = trustedHTMLFromString(html);
    return templateEl;
  }
}
function isDOMParserAvailable() {
  try {
    return !!new window.DOMParser().parseFromString(trustedHTMLFromString(''), 'text/html');
  } catch {
    return false;
  }
}
const SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;
function _sanitizeUrl(url) {
  url = String(url);
  if (url.match(SAFE_URL_PATTERN)) return url;
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
    console.warn(`WARNING: sanitizing unsafe URL value ${url} (see ${_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.XSS_SECURITY_URL})`);
  }
  return 'unsafe:' + url;
}
function tagSet(tags) {
  const res = {};
  for (const t of tags.split(',')) res[t] = true;
  return res;
}
function merge(...sets) {
  const res = {};
  for (const s of sets) {
    for (const v in s) {
      if (s.hasOwnProperty(v)) res[v] = true;
    }
  }
  return res;
}
const VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');
const OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');
const OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');
const OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
const BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet('address,article,' + 'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' + 'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));
const INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet('a,abbr,acronym,audio,b,' + 'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' + 'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));
const VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
const URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');
const HTML_ATTRS = tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' + 'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' + 'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' + 'scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,' + 'valign,value,vspace,width');
const ARIA_ATTRS = tagSet('aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,' + 'aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,' + 'aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,' + 'aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,' + 'aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,' + 'aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,' + 'aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext');
const VALID_ATTRS = merge(URI_ATTRS, HTML_ATTRS, ARIA_ATTRS);
const SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet('script,style,template');
class SanitizingHtmlSerializer {
  sanitizedSomething = false;
  buf = [];
  sanitizeChildren(el) {
    let current = el.firstChild;
    let traverseContent = true;
    let parentNodes = [];
    while (current) {
      if (current.nodeType === Node.ELEMENT_NODE) {
        traverseContent = this.startElement(current);
      } else if (current.nodeType === Node.TEXT_NODE) {
        this.chars(current.nodeValue);
      } else {
        this.sanitizedSomething = true;
      }
      if (traverseContent && current.firstChild) {
        parentNodes.push(current);
        current = getFirstChild(current);
        continue;
      }
      while (current) {
        if (current.nodeType === Node.ELEMENT_NODE) {
          this.endElement(current);
        }
        let next = getNextSibling(current);
        if (next) {
          current = next;
          break;
        }
        current = parentNodes.pop();
      }
    }
    return this.buf.join('');
  }
  startElement(element) {
    const tagName = getNodeName(element).toLowerCase();
    if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
      this.sanitizedSomething = true;
      return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);
    }
    this.buf.push('<');
    this.buf.push(tagName);
    const elAttrs = element.attributes;
    for (let i = 0; i < elAttrs.length; i++) {
      const elAttr = elAttrs.item(i);
      const attrName = elAttr.name;
      const lower = attrName.toLowerCase();
      if (!VALID_ATTRS.hasOwnProperty(lower)) {
        this.sanitizedSomething = true;
        continue;
      }
      let value = elAttr.value;
      if (URI_ATTRS[lower]) value = _sanitizeUrl(value);
      this.buf.push(' ', attrName, '="', encodeEntities(value), '"');
    }
    this.buf.push('>');
    return true;
  }
  endElement(current) {
    const tagName = getNodeName(current).toLowerCase();
    if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
      this.buf.push('</');
      this.buf.push(tagName);
      this.buf.push('>');
    }
  }
  chars(chars) {
    this.buf.push(encodeEntities(chars));
  }
}
function isClobberedElement(parentNode, childNode) {
  return (parentNode.compareDocumentPosition(childNode) & Node.DOCUMENT_POSITION_CONTAINED_BY) !== Node.DOCUMENT_POSITION_CONTAINED_BY;
}
function getNextSibling(node) {
  const nextSibling = node.nextSibling;
  if (nextSibling && node !== nextSibling.previousSibling) {
    throw clobberedElementError(nextSibling);
  }
  return nextSibling;
}
function getFirstChild(node) {
  const firstChild = node.firstChild;
  if (firstChild && isClobberedElement(node, firstChild)) {
    throw clobberedElementError(firstChild);
  }
  return firstChild;
}
function getNodeName(node) {
  const nodeName = node.nodeName;
  return typeof nodeName === 'string' ? nodeName : 'FORM';
}
function clobberedElementError(node) {
  return new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`);
}
const SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
const NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
function encodeEntities(value) {
  return value.replace(/&/g, '&amp;').replace(SURROGATE_PAIR_REGEXP, function (match) {
    const hi = match.charCodeAt(0);
    const low = match.charCodeAt(1);
    return '&#' + ((hi - 0xd800) * 0x400 + (low - 0xdc00) + 0x10000) + ';';
  }).replace(NON_ALPHANUMERIC_REGEXP, function (match) {
    return '&#' + match.charCodeAt(0) + ';';
  }).replace(/</g, '&lt;').replace(/>/g, '&gt;');
}
let inertBodyHelper;
function _sanitizeHtml(defaultDoc, unsafeHtmlInput) {
  let inertBodyElement = null;
  try {
    inertBodyHelper = inertBodyHelper || getInertBodyHelper(defaultDoc);
    let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';
    inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
    let mXSSAttempts = 5;
    let parsedHtml = unsafeHtml;
    do {
      if (mXSSAttempts === 0) {
        throw new Error('Failed to sanitize html because the input is unstable');
      }
      mXSSAttempts--;
      unsafeHtml = parsedHtml;
      parsedHtml = inertBodyElement.innerHTML;
      inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
    } while (unsafeHtml !== parsedHtml);
    const sanitizer = new SanitizingHtmlSerializer();
    const safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);
    if ((typeof ngDevMode === 'undefined' || ngDevMode) && sanitizer.sanitizedSomething) {
      console.warn(`WARNING: sanitizing HTML stripped some content, see ${_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.XSS_SECURITY_URL}`);
    }
    return trustedHTMLFromString(safeHtml);
  } finally {
    if (inertBodyElement) {
      const parent = getTemplateContent(inertBodyElement) || inertBodyElement;
      while (parent.firstChild) {
        parent.firstChild.remove();
      }
    }
  }
}
function getTemplateContent(el) {
  return 'content' in el && isTemplateElement(el) ? el.content : null;
}
function isTemplateElement(el) {
  return el.nodeType === Node.ELEMENT_NODE && el.nodeName === 'TEMPLATE';
}
const COMMENT_DISALLOWED = /^>|^->|<!--|-->|--!>|<!-$/g;
const COMMENT_DELIMITER = /(<|>)/g;
const COMMENT_DELIMITER_ESCAPED = '\u200B$1\u200B';
function escapeCommentText(value) {
  return value.replace(COMMENT_DISALLOWED, text => text.replace(COMMENT_DELIMITER, COMMENT_DELIMITER_ESCAPED));
}
function createTextNode(renderer, value) {
  return renderer.createText(value);
}
function updateTextNode(renderer, rNode, value) {
  renderer.setValue(rNode, value);
}
function createCommentNode(renderer, value) {
  return renderer.createComment(escapeCommentText(value));
}
function createElementNode(renderer, name, namespace) {
  return renderer.createElement(name, namespace);
}
function nativeInsertBefore(renderer, parent, child, beforeNode, isMove) {
  renderer.insertBefore(parent, child, beforeNode, isMove);
}
function nativeAppendChild(renderer, parent, child) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(parent, 'parent node must be defined');
  renderer.appendChild(parent, child);
}
function nativeAppendOrInsertBefore(renderer, parent, child, beforeNode, isMove) {
  if (beforeNode !== null) {
    nativeInsertBefore(renderer, parent, child, beforeNode, isMove);
  } else {
    nativeAppendChild(renderer, parent, child);
  }
}
function nativeRemoveNode(renderer, rNode, isHostElement, requireSynchronousElementRemoval) {
  renderer.removeChild(null, rNode, isHostElement, requireSynchronousElementRemoval);
}
function clearElementContents(rElement) {
  rElement.textContent = '';
}
function writeDirectStyle(renderer, element, newValue) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertString)(newValue, "'newValue' should be a string");
  renderer.setAttribute(element, 'style', newValue);
}
function writeDirectClass(renderer, element, newValue) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertString)(newValue, "'newValue' should be a string");
  if (newValue === '') {
    renderer.removeAttribute(element, 'class');
  } else {
    renderer.setAttribute(element, 'class', newValue);
  }
}
function setupStaticAttributes(renderer, element, tNode) {
  const {
    mergedAttrs,
    classes,
    styles
  } = tNode;
  if (mergedAttrs !== null) {
    setUpAttributes(renderer, element, mergedAttrs);
  }
  if (classes !== null) {
    writeDirectClass(renderer, element, classes);
  }
  if (styles !== null) {
    writeDirectStyle(renderer, element, styles);
  }
}
function enforceIframeSecurity(iframe) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  iframe.src = '';
  iframe.srcdoc = trustedHTMLFromString('');
  nativeRemoveNode(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], iframe);
}
var SecurityContext;
(function (SecurityContext) {
  SecurityContext[SecurityContext["NONE"] = 0] = "NONE";
  SecurityContext[SecurityContext["HTML"] = 1] = "HTML";
  SecurityContext[SecurityContext["STYLE"] = 2] = "STYLE";
  SecurityContext[SecurityContext["SCRIPT"] = 3] = "SCRIPT";
  SecurityContext[SecurityContext["URL"] = 4] = "URL";
  SecurityContext[SecurityContext["RESOURCE_URL"] = 5] = "RESOURCE_URL";
})(SecurityContext || (SecurityContext = {}));
function ɵɵsanitizeHtml(unsafeHtml) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedHTMLFromStringBypass(sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || '');
  }
  if (allowSanitizationBypassAndThrow(unsafeHtml, "HTML")) {
    return trustedHTMLFromStringBypass(unwrapSafeValue(unsafeHtml));
  }
  return _sanitizeHtml(getDocument(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(unsafeHtml));
}
function ɵɵsanitizeStyle(unsafeStyle) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || '';
  }
  if (allowSanitizationBypassAndThrow(unsafeStyle, "Style")) {
    return unwrapSafeValue(unsafeStyle);
  }
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(unsafeStyle);
}
function ɵɵsanitizeUrl(unsafeUrl) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || '';
  }
  if (allowSanitizationBypassAndThrow(unsafeUrl, "URL")) {
    return unwrapSafeValue(unsafeUrl);
  }
  return _sanitizeUrl((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(unsafeUrl));
}
function ɵɵsanitizeResourceUrl(unsafeResourceUrl) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedScriptURLFromStringBypass(sanitizer.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || '');
  }
  if (allowSanitizationBypassAndThrow(unsafeResourceUrl, "ResourceURL")) {
    return trustedScriptURLFromStringBypass(unwrapSafeValue(unsafeResourceUrl));
  }
  throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(904, ngDevMode && `unsafe value used in a resource URL context (see ${_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.XSS_SECURITY_URL})`);
}
function ɵɵsanitizeScript(unsafeScript) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedScriptFromStringBypass(sanitizer.sanitize(SecurityContext.SCRIPT, unsafeScript) || '');
  }
  if (allowSanitizationBypassAndThrow(unsafeScript, "Script")) {
    return trustedScriptFromStringBypass(unwrapSafeValue(unsafeScript));
  }
  throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(905, ngDevMode && 'unsafe value used in a script context');
}
function ɵɵtrustConstantHtml(html) {
  if (ngDevMode && (!Array.isArray(html) || !Array.isArray(html.raw) || html.length !== 1)) {
    throw new Error(`Unexpected interpolation in trusted HTML constant: ${html.join('?')}`);
  }
  return trustedHTMLFromString(html[0]);
}
function ɵɵtrustConstantResourceUrl(url) {
  if (ngDevMode && (!Array.isArray(url) || !Array.isArray(url.raw) || url.length !== 1)) {
    throw new Error(`Unexpected interpolation in trusted URL constant: ${url.join('?')}`);
  }
  return trustedScriptURLFromString(url[0]);
}
function getUrlSanitizer(tag, prop) {
  if (prop === 'src' && (tag === 'embed' || tag === 'frame' || tag === 'iframe' || tag === 'media' || tag === 'script') || prop === 'href' && (tag === 'base' || tag === 'link')) {
    return ɵɵsanitizeResourceUrl;
  }
  return ɵɵsanitizeUrl;
}
function ɵɵsanitizeUrlOrResourceUrl(unsafeUrl, tag, prop) {
  return getUrlSanitizer(tag, prop)(unsafeUrl);
}
function validateAgainstEventProperties(name) {
  if (name.toLowerCase().startsWith('on')) {
    const errorMessage = `Binding to event property '${name}' is disallowed for security reasons, ` + `please use (${name.slice(2)})=...` + `\nIf '${name}' is a directive input, make sure the directive is imported by the` + ` current module.`;
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(306, errorMessage);
  }
}
function validateAgainstEventAttributes(name) {
  if (name.toLowerCase().startsWith('on')) {
    const errorMessage = `Binding to event attribute '${name}' is disallowed for security reasons, ` + `please use (${name.slice(2)})=...`;
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(306, errorMessage);
  }
}
function getSanitizer() {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  return lView && lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT].sanitizer;
}
const attributeName = new Set(['attributename']);
const SECURITY_SENSITIVE_ELEMENTS = {
  'iframe': new Set(['sandbox', 'allow', 'allowfullscreen', 'referrerpolicy', 'csp', 'fetchpriority']),
  'animate': attributeName,
  'set': attributeName,
  'animatemotion': attributeName,
  'animatetransform': attributeName
};
function ɵɵvalidateAttribute(value, tagName, attributeName) {
  const lowerCaseTagName = tagName.toLowerCase();
  const lowerCaseAttrName = attributeName.toLowerCase();
  if (!SECURITY_SENSITIVE_ELEMENTS[lowerCaseTagName]?.has(lowerCaseAttrName)) {
    return value;
  }
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)();
  if (tNode.type !== 2) {
    return value;
  }
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  if (lowerCaseTagName === 'iframe') {
    const element = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
    enforceIframeSecurity(element);
  }
  const errorMessage = ngDevMode && `Angular has detected that the \`${attributeName}\` was applied ` + `as a binding to the <${tagName}> element${getTemplateLocationDetails(lView)}. ` + `For security reasons, the \`${attributeName}\` can be set on the <${tagName}> element ` + `as a static attribute only. \n` + `To fix this, switch the \`${attributeName}\` binding to a static attribute ` + `in a template or in host bindings section.`;
  throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-910, errorMessage);
}
const NG_REFLECT_ATTRS_FLAG_DEFAULT = false;
const NG_REFLECT_ATTRS_FLAG = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'NG_REFLECT_FLAG' : '', {
  factory: () => NG_REFLECT_ATTRS_FLAG_DEFAULT
});
function provideNgReflectAttributes() {
  const providers = typeof ngDevMode === 'undefined' || ngDevMode ? [{
    provide: NG_REFLECT_ATTRS_FLAG,
    useValue: true
  }] : [];
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.makeEnvironmentProviders)(providers);
}
function normalizeDebugBindingName(name) {
  name = camelCaseToDashCase(name.replace(/[$@]/g, '_'));
  return `ng-reflect-${name}`;
}
const CAMEL_CASE_REGEXP = /([A-Z])/g;
function camelCaseToDashCase(input) {
  return input.replace(CAMEL_CASE_REGEXP, (...m) => '-' + m[1].toLowerCase());
}
function normalizeDebugBindingValue(value) {
  try {
    return value != null ? value.toString().slice(0, 30) : value;
  } catch (e) {
    return '[ERROR] Exception while trying to serialize the value';
  }
}
function ɵɵresolveWindow(element) {
  return element.ownerDocument.defaultView;
}
function ɵɵresolveDocument(element) {
  return element.ownerDocument;
}
function ɵɵresolveBody(element) {
  return element.ownerDocument.body;
}
const INTERPOLATION_DELIMITER = `�`;
function maybeUnwrapFn(value) {
  if (value instanceof Function) {
    return value();
  } else {
    return value;
  }
}
const VALUE_STRING_LENGTH_LIMIT = 200;
function assertStandaloneComponentType(type) {
  assertComponentDef(type);
  const componentDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type);
  if (!componentDef.standalone) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(907, `The ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)} component is not marked as standalone, ` + `but Angular expects to have a standalone component here. ` + `Please make sure the ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)} component does not have ` + `the \`standalone: false\` flag in the decorator.`);
  }
}
function assertComponentDef(type) {
  if (!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type)) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(906, `The ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)} is not an Angular component, ` + `make sure it has the \`@Component\` decorator.`);
  }
}
function throwMultipleComponentError(tNode, first, second) {
  throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-300, `Multiple components match node with tagname ${tNode.value}: ` + `${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(first)} and ` + `${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(second)}`);
}
function throwErrorIfNoChangesMode(creationMode, oldValue, currValue, propName, lView) {
  const hostComponentDef = getDeclarationComponentDef(lView);
  const componentClassName = hostComponentDef?.type?.name;
  const field = propName ? ` for '${propName}'` : '';
  let msg = `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value${field}: '${formatValue(oldValue)}'. Current value: '${formatValue(currValue)}'.${componentClassName ? ` Expression location: ${componentClassName} component` : ''}`;
  if (creationMode) {
    msg += ` It seems like the view has been created after its parent and its children have been dirty checked.` + ` Has it been created in a change detection hook?`;
  }
  throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-100, msg);
}
function formatValue(value) {
  let strValue = String(value);
  try {
    if (Array.isArray(value) || strValue === '[object Object]') {
      strValue = JSON.stringify(value);
    }
  } catch (error) {}
  return strValue.length > VALUE_STRING_LENGTH_LIMIT ? strValue.substring(0, VALUE_STRING_LENGTH_LIMIT) + '…' : strValue;
}
function constructDetailsForInterpolation(lView, rootIndex, expressionIndex, meta, changedValue) {
  const [propName, prefix, ...chunks] = meta.split(INTERPOLATION_DELIMITER);
  let oldValue = prefix,
    newValue = prefix;
  for (let i = 0; i < chunks.length; i++) {
    const slotIdx = rootIndex + i;
    oldValue += `${lView[slotIdx]}${chunks[i]}`;
    newValue += `${slotIdx === expressionIndex ? changedValue : lView[slotIdx]}${chunks[i]}`;
  }
  return {
    propName,
    oldValue,
    newValue
  };
}
function getExpressionChangedErrorDetails(lView, bindingIndex, oldValue, newValue) {
  const tData = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data;
  const metadata = tData[bindingIndex];
  if (typeof metadata === 'string') {
    if (metadata.indexOf(INTERPOLATION_DELIMITER) > -1) {
      return constructDetailsForInterpolation(lView, bindingIndex, bindingIndex, metadata, newValue);
    }
    return {
      propName: metadata,
      oldValue,
      newValue
    };
  }
  if (metadata === null) {
    let idx = bindingIndex - 1;
    while (typeof tData[idx] !== 'string' && tData[idx + 1] === null) {
      idx--;
    }
    const meta = tData[idx];
    if (typeof meta === 'string') {
      const matches = meta.match(new RegExp(INTERPOLATION_DELIMITER, 'g'));
      if (matches && matches.length - 1 > bindingIndex - idx) {
        return constructDetailsForInterpolation(lView, idx, bindingIndex, meta, newValue);
      }
    }
  }
  return {
    propName: undefined,
    oldValue,
    newValue
  };
}
function classIndexOf(className, classToSearch, startingIndex) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotEqual)(classToSearch, '', 'can not look for "" string.');
  let end = className.length;
  while (true) {
    const foundIndex = className.indexOf(classToSearch, startingIndex);
    if (foundIndex === -1) return foundIndex;
    if (foundIndex === 0 || className.charCodeAt(foundIndex - 1) <= 32) {
      const length = classToSearch.length;
      if (foundIndex + length === end || className.charCodeAt(foundIndex + length) <= 32) {
        return foundIndex;
      }
    }
    startingIndex = foundIndex + 1;
  }
}
const NG_TEMPLATE_SELECTOR = 'ng-template';
function isCssClassMatching(tNode, attrs, cssClassToMatch, isProjectionMode) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(cssClassToMatch, cssClassToMatch.toLowerCase(), 'Class name expected to be lowercase.');
  let i = 0;
  if (isProjectionMode) {
    for (; i < attrs.length && typeof attrs[i] === 'string'; i += 2) {
      if (attrs[i] === 'class' && classIndexOf(attrs[i + 1].toLowerCase(), cssClassToMatch, 0) !== -1) {
        return true;
      }
    }
  } else if (isInlineTemplate(tNode)) {
    return false;
  }
  i = attrs.indexOf(1, i);
  if (i > -1) {
    let item;
    while (++i < attrs.length && typeof (item = attrs[i]) === 'string') {
      if (item.toLowerCase() === cssClassToMatch) {
        return true;
      }
    }
  }
  return false;
}
function isInlineTemplate(tNode) {
  return tNode.type === 4 && tNode.value !== NG_TEMPLATE_SELECTOR;
}
function hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {
  const tagNameToCompare = tNode.type === 4 && !isProjectionMode ? NG_TEMPLATE_SELECTOR : tNode.value;
  return currentSelector === tagNameToCompare;
}
function isNodeMatchingSelector(tNode, selector, isProjectionMode) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(selector[0], 'Selector should have a tag name');
  let mode = 4;
  const nodeAttrs = tNode.attrs;
  const nameOnlyMarkerIdx = nodeAttrs !== null ? getNameOnlyMarkerIndex(nodeAttrs) : 0;
  let skipToNextSelector = false;
  for (let i = 0; i < selector.length; i++) {
    const current = selector[i];
    if (typeof current === 'number') {
      if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {
        return false;
      }
      if (skipToNextSelector && isPositive(current)) continue;
      skipToNextSelector = false;
      mode = current | mode & 1;
      continue;
    }
    if (skipToNextSelector) continue;
    if (mode & 4) {
      mode = 2 | mode & 1;
      if (current !== '' && !hasTagAndTypeMatch(tNode, current, isProjectionMode) || current === '' && selector.length === 1) {
        if (isPositive(mode)) return false;
        skipToNextSelector = true;
      }
    } else if (mode & 8) {
      if (nodeAttrs === null || !isCssClassMatching(tNode, nodeAttrs, current, isProjectionMode)) {
        if (isPositive(mode)) return false;
        skipToNextSelector = true;
      }
    } else {
      const selectorAttrValue = selector[++i];
      const attrIndexInNode = findAttrIndexInNode(current, nodeAttrs, isInlineTemplate(tNode), isProjectionMode);
      if (attrIndexInNode === -1) {
        if (isPositive(mode)) return false;
        skipToNextSelector = true;
        continue;
      }
      if (selectorAttrValue !== '') {
        let nodeAttrValue;
        if (attrIndexInNode > nameOnlyMarkerIdx) {
          nodeAttrValue = '';
        } else {
          ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotEqual)(nodeAttrs[attrIndexInNode], 0, 'We do not match directives on namespaced attributes');
          nodeAttrValue = nodeAttrs[attrIndexInNode + 1].toLowerCase();
        }
        if (mode & 2 && selectorAttrValue !== nodeAttrValue) {
          if (isPositive(mode)) return false;
          skipToNextSelector = true;
        }
      }
    }
  }
  return isPositive(mode) || skipToNextSelector;
}
function isPositive(mode) {
  return (mode & 1) === 0;
}
function findAttrIndexInNode(name, attrs, isInlineTemplate, isProjectionMode) {
  if (attrs === null) return -1;
  let i = 0;
  if (isProjectionMode || !isInlineTemplate) {
    let bindingsMode = false;
    while (i < attrs.length) {
      const maybeAttrName = attrs[i];
      if (maybeAttrName === name) {
        return i;
      } else if (maybeAttrName === 3 || maybeAttrName === 6) {
        bindingsMode = true;
      } else if (maybeAttrName === 1 || maybeAttrName === 2) {
        let value = attrs[++i];
        while (typeof value === 'string') {
          value = attrs[++i];
        }
        continue;
      } else if (maybeAttrName === 4) {
        break;
      } else if (maybeAttrName === 0) {
        i += 4;
        continue;
      }
      i += bindingsMode ? 1 : 2;
    }
    return -1;
  } else {
    return matchTemplateAttribute(attrs, name);
  }
}
function isNodeMatchingSelectorList(tNode, selector, isProjectionMode = false) {
  for (let i = 0; i < selector.length; i++) {
    if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) {
      return true;
    }
  }
  return false;
}
function getProjectAsAttrValue(tNode) {
  const nodeAttrs = tNode.attrs;
  if (nodeAttrs != null) {
    const ngProjectAsAttrIdx = nodeAttrs.indexOf(5);
    if ((ngProjectAsAttrIdx & 1) === 0) {
      return nodeAttrs[ngProjectAsAttrIdx + 1];
    }
  }
  return null;
}
function getNameOnlyMarkerIndex(nodeAttrs) {
  for (let i = 0; i < nodeAttrs.length; i++) {
    const nodeAttr = nodeAttrs[i];
    if (isNameOnlyAttributeMarker(nodeAttr)) {
      return i;
    }
  }
  return nodeAttrs.length;
}
function matchTemplateAttribute(attrs, name) {
  let i = attrs.indexOf(4);
  if (i > -1) {
    i++;
    while (i < attrs.length) {
      const attr = attrs[i];
      if (typeof attr === 'number') return -1;
      if (attr === name) return i;
      i++;
    }
  }
  return -1;
}
function isSelectorInSelectorList(selector, list) {
  selectorListLoop: for (let i = 0; i < list.length; i++) {
    const currentSelectorInList = list[i];
    if (selector.length !== currentSelectorInList.length) {
      continue;
    }
    for (let j = 0; j < selector.length; j++) {
      if (selector[j] !== currentSelectorInList[j]) {
        continue selectorListLoop;
      }
    }
    return true;
  }
  return false;
}
function maybeWrapInNotSelector(isNegativeMode, chunk) {
  return isNegativeMode ? ':not(' + chunk.trim() + ')' : chunk;
}
function stringifyCSSSelector(selector) {
  let result = selector[0];
  let i = 1;
  let mode = 2;
  let currentChunk = '';
  let isNegativeMode = false;
  while (i < selector.length) {
    let valueOrMarker = selector[i];
    if (typeof valueOrMarker === 'string') {
      if (mode & 2) {
        const attrValue = selector[++i];
        currentChunk += '[' + valueOrMarker + (attrValue.length > 0 ? '="' + attrValue + '"' : '') + ']';
      } else if (mode & 8) {
        currentChunk += '.' + valueOrMarker;
      } else if (mode & 4) {
        currentChunk += ' ' + valueOrMarker;
      }
    } else {
      if (currentChunk !== '' && !isPositive(valueOrMarker)) {
        result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
        currentChunk = '';
      }
      mode = valueOrMarker;
      isNegativeMode = isNegativeMode || !isPositive(mode);
    }
    i++;
  }
  if (currentChunk !== '') {
    result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
  }
  return result;
}
function stringifyCSSSelectorList(selectorList) {
  return selectorList.map(stringifyCSSSelector).join(',');
}
function extractAttrsAndClassesFromSelector(selector) {
  const attrs = [];
  const classes = [];
  let i = 1;
  let mode = 2;
  while (i < selector.length) {
    let valueOrMarker = selector[i];
    if (typeof valueOrMarker === 'string') {
      if (mode === 2) {
        if (valueOrMarker !== '') {
          attrs.push(valueOrMarker, selector[++i]);
        }
      } else if (mode === 8) {
        classes.push(valueOrMarker);
      }
    } else {
      if (!isPositive(mode)) break;
      mode = valueOrMarker;
    }
    i++;
  }
  if (classes.length) {
    attrs.push(1, ...classes);
  }
  return attrs;
}
const NO_CHANGE = typeof ngDevMode === 'undefined' || ngDevMode ? {
  __brand__: 'NO_CHANGE'
} : {};
function createTView(type, declTNode, templateFn, decls, vars, directives, pipes, viewQuery, schemas, constsOrFactory, ssrId) {
  const bindingStartIndex = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET + decls;
  const initialViewLength = bindingStartIndex + vars;
  const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);
  const consts = typeof constsOrFactory === 'function' ? constsOrFactory() : constsOrFactory;
  const tView = blueprint[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW] = {
    type: type,
    blueprint: blueprint,
    template: templateFn,
    queries: null,
    viewQuery: viewQuery,
    declTNode: declTNode,
    data: blueprint.slice().fill(null, bindingStartIndex),
    bindingStartIndex: bindingStartIndex,
    expandoStartIndex: initialViewLength,
    hostBindingOpCodes: null,
    firstCreatePass: true,
    firstUpdatePass: true,
    staticViewQueries: false,
    staticContentQueries: false,
    preOrderHooks: null,
    preOrderCheckHooks: null,
    contentHooks: null,
    contentCheckHooks: null,
    viewHooks: null,
    viewCheckHooks: null,
    destroyHooks: null,
    cleanup: null,
    contentQueries: null,
    components: null,
    directiveRegistry: typeof directives === 'function' ? directives() : directives,
    pipeRegistry: typeof pipes === 'function' ? pipes() : pipes,
    firstChild: null,
    schemas: schemas,
    consts: consts,
    incompleteFirstPass: false,
    ssrId
  };
  if (ngDevMode) {
    Object.seal(tView);
  }
  return tView;
}
function createViewBlueprint(bindingStartIndex, initialViewLength) {
  const blueprint = [];
  for (let i = 0; i < initialViewLength; i++) {
    blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);
  }
  return blueprint;
}
function getOrCreateComponentTView(def) {
  const tView = def.tView;
  if (tView === null || tView.incompleteFirstPass) {
    const declTNode = null;
    return def.tView = createTView(1, declTNode, def.template, def.decls, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas, def.consts, def.id);
  }
  return tView;
}
function createLView(parentLView, tView, context, flags, host, tHostNode, environment, renderer, injector, embeddedViewInjector, hydrationInfo) {
  const lView = tView.blueprint.slice();
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST] = host;
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] = flags | 4 | 128 | 8 | 64 | 1024;
  if (embeddedViewInjector !== null || parentLView && parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] & 2048) {
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] |= 2048;
  }
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resetPreOrderHookFlags)(lView);
  ngDevMode && tView.declTNode && parentLView && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForLView)(tView.declTNode, parentLView);
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT] = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_VIEW] = parentLView;
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT] = context;
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT] = environment || parentLView && parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT], 'LViewEnvironment is required');
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER] = renderer || parentLView && parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], 'Renderer is required');
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1] = injector || parentLView && parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1] || null;
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST] = tHostNode;
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ID] = getUniqueLViewId();
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION] = hydrationInfo;
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMBEDDED_VIEW_INJECTOR] = embeddedViewInjector;
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(tView.type == 2 ? parentLView !== null : true, true, 'Embedded views must have parentLView');
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW] = tView.type == 2 ? parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW] : lView;
  return lView;
}
function createComponentLView(lView, hostTNode, def) {
  const native = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(hostTNode, lView);
  const tView = getOrCreateComponentTView(def);
  const rendererFactory = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT].rendererFactory;
  const componentView = addToEndOfViewTree(lView, createLView(lView, tView, null, getInitialLViewFlagsFromDef(def), native, hostTNode, null, rendererFactory.createRenderer(native, def), null, null, null));
  return lView[hostTNode.index] = componentView;
}
function getInitialLViewFlagsFromDef(def) {
  let flags = 16;
  if (def.signals) {
    flags = 4096;
  } else if (def.onPush) {
    flags = 64;
  }
  return flags;
}
function allocExpando(tView, lView, numSlotsToAlloc, initialValue) {
  if (numSlotsToAlloc === 0) return -1;
  if (ngDevMode) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView);
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertSame)(tView, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], '`LView` must be associated with `TView`!');
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(tView.data.length, lView.length, 'Expecting LView to be same size as TView');
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(tView.data.length, tView.blueprint.length, 'Expecting Blueprint to be same size as TView');
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstUpdatePass)(tView);
  }
  const allocIdx = lView.length;
  for (let i = 0; i < numSlotsToAlloc; i++) {
    lView.push(initialValue);
    tView.blueprint.push(initialValue);
    tView.data.push(null);
  }
  return allocIdx;
}
function addToEndOfViewTree(lView, lViewOrLContainer) {
  if (lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CHILD_HEAD]) {
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CHILD_TAIL][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT] = lViewOrLContainer;
  } else {
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CHILD_HEAD] = lViewOrLContainer;
  }
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CHILD_TAIL] = lViewOrLContainer;
  return lViewOrLContainer;
}
function ɵɵadvance(delta = 1) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertGreaterThan)(delta, 0, 'Can only advance forward');
  selectIndexInternal((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)() + delta, !!ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isInCheckNoChangesMode)());
}
function selectIndexInternal(tView, lView, index, checkNoChangesMode) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInDeclRange)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], index);
  if (!checkNoChangesMode) {
    const hooksInitPhaseCompleted = (lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] & 3) === 3;
    if (hooksInitPhaseCompleted) {
      const preOrderCheckHooks = tView.preOrderCheckHooks;
      if (preOrderCheckHooks !== null) {
        executeCheckHooks(lView, preOrderCheckHooks, index);
      }
    } else {
      const preOrderHooks = tView.preOrderHooks;
      if (preOrderHooks !== null) {
        executeInitAndCheckHooks(lView, preOrderHooks, 0, index);
      }
    }
  }
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setSelectedIndex)(index);
}
var InputFlags;
(function (InputFlags) {
  InputFlags[InputFlags["None"] = 0] = "None";
  InputFlags[InputFlags["SignalBased"] = 1] = "SignalBased";
  InputFlags[InputFlags["HasDecoratorInputTransform"] = 2] = "HasDecoratorInputTransform";
})(InputFlags || (InputFlags = {}));
function writeToDirectiveInput(def, instance, publicName, value) {
  const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
  try {
    if (ngDevMode) {
      if (!def.inputs.hasOwnProperty(publicName)) {
        throw new Error(`ASSERTION ERROR: Directive ${def.type.name} does not have an input with a public name of "${publicName}"`);
      }
      if (instance instanceof NodeInjectorFactory) {
        throw new Error(`ASSERTION ERROR: Cannot write input to factory for type ${def.type.name}. Directive has not been created yet.`);
      }
    }
    const [privateName, flags, transform] = def.inputs[publicName];
    let inputSignalNode = null;
    if ((flags & InputFlags.SignalBased) !== 0) {
      const field = instance[privateName];
      inputSignalNode = field[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SIGNAL];
    }
    if (inputSignalNode !== null && inputSignalNode.transformFn !== undefined) {
      value = inputSignalNode.transformFn(value);
    } else if (transform !== null) {
      value = transform.call(instance, value);
    }
    if (def.setInput !== null) {
      def.setInput(instance, inputSignalNode, value, publicName, privateName);
    } else {
      applyValueToInputField(instance, inputSignalNode, privateName, value);
    }
  } finally {
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
  }
}
var RendererStyleFlags2;
(function (RendererStyleFlags2) {
  RendererStyleFlags2[RendererStyleFlags2["Important"] = 1] = "Important";
  RendererStyleFlags2[RendererStyleFlags2["DashCase"] = 2] = "DashCase";
})(RendererStyleFlags2 || (RendererStyleFlags2 = {}));
let _icuContainerIterate;
function icuContainerIterate(tIcuContainerNode, lView) {
  return _icuContainerIterate(tIcuContainerNode, lView);
}
function ensureIcuContainerVisitorLoaded(loader) {
  if (_icuContainerIterate === undefined) {
    _icuContainerIterate = loader();
  }
}
function parseCssTimeUnitsToMs(value) {
  if (!value) return 0;
  const multiplier = value.toLowerCase().indexOf('ms') > -1 ? 1 : 1000;
  return parseFloat(value) * multiplier;
}
function parseCssPropertyValue(computedStyle, name) {
  const value = computedStyle.getPropertyValue(name);
  return value.split(',').map(part => part.trim());
}
function getLongestComputedTransition(computedStyle) {
  const transitionedProperties = parseCssPropertyValue(computedStyle, 'transition-property');
  const rawDurations = parseCssPropertyValue(computedStyle, 'transition-duration');
  const rawDelays = parseCssPropertyValue(computedStyle, 'transition-delay');
  const longest = {
    propertyName: '',
    duration: 0,
    animationName: undefined
  };
  for (let i = 0; i < transitionedProperties.length; i++) {
    const duration = parseCssTimeUnitsToMs(rawDelays[i]) + parseCssTimeUnitsToMs(rawDurations[i]);
    if (duration > longest.duration) {
      longest.propertyName = transitionedProperties[i];
      longest.duration = duration;
    }
  }
  return longest;
}
function getLongestComputedAnimation(computedStyle) {
  const rawNames = parseCssPropertyValue(computedStyle, 'animation-name');
  const rawDelays = parseCssPropertyValue(computedStyle, 'animation-delay');
  const rawDurations = parseCssPropertyValue(computedStyle, 'animation-duration');
  const longest = {
    animationName: '',
    propertyName: undefined,
    duration: 0
  };
  for (let i = 0; i < rawNames.length; i++) {
    const duration = parseCssTimeUnitsToMs(rawDelays[i]) + parseCssTimeUnitsToMs(rawDurations[i]);
    if (duration > longest.duration) {
      longest.animationName = rawNames[i];
      longest.duration = duration;
    }
  }
  return longest;
}
function isShorterThanExistingAnimation(existing, longest) {
  return existing !== undefined && existing.duration > longest.duration;
}
function longestExists(longest) {
  return (longest.animationName != undefined || longest.propertyName != undefined) && longest.duration > 0;
}
function determineLongestAnimationFromComputedStyles(el, animationsMap) {
  const computedStyle = getComputedStyle(el);
  const longestAnimation = getLongestComputedAnimation(computedStyle);
  const longestTransition = getLongestComputedTransition(computedStyle);
  const longest = longestAnimation.duration > longestTransition.duration ? longestAnimation : longestTransition;
  if (isShorterThanExistingAnimation(animationsMap.get(el), longest)) return;
  if (longestExists(longest)) {
    animationsMap.set(el, longest);
  }
}
function determineLongestAnimation(el, animationsMap, areAnimationSupported) {
  if (!areAnimationSupported) return;
  const animations = el.getAnimations();
  return animations.length === 0 ? determineLongestAnimationFromComputedStyles(el, animationsMap) : determineLongestAnimationFromElementAnimations(el, animationsMap, animations);
}
function determineLongestAnimationFromElementAnimations(el, animationsMap, animations) {
  let longest = {
    animationName: undefined,
    propertyName: undefined,
    duration: 0
  };
  for (const animation of animations) {
    const timing = animation.effect?.getTiming();
    const animDuration = typeof timing?.duration === 'number' ? timing.duration : 0;
    let duration = (timing?.delay ?? 0) + animDuration;
    let propertyName;
    let animationName;
    if (animation.animationName) {
      animationName = animation.animationName;
    } else {
      propertyName = animation.transitionProperty;
    }
    if (duration >= longest.duration) {
      longest = {
        animationName,
        propertyName,
        duration
      };
    }
  }
  if (isShorterThanExistingAnimation(animationsMap.get(el), longest)) return;
  if (longestExists(longest)) {
    animationsMap.set(el, longest);
  }
}
const allLeavingAnimations = new Set();
var TracingAction;
(function (TracingAction) {
  TracingAction[TracingAction["CHANGE_DETECTION"] = 0] = "CHANGE_DETECTION";
  TracingAction[TracingAction["AFTER_NEXT_RENDER"] = 1] = "AFTER_NEXT_RENDER";
})(TracingAction || (TracingAction = {}));
const TracingService = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'TracingService' : '');
const markedFeatures = new Set();
function performanceMarkFeature(feature) {
  if (markedFeatures.has(feature)) {
    return;
  }
  markedFeatures.add(feature);
  performance?.mark?.('mark_feature_usage', {
    detail: {
      feature
    }
  });
}
class AfterRenderManager {
  impl = null;
  execute() {
    this.impl?.execute();
  }
  static ɵprov = /* @__PURE__ */
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
    token: AfterRenderManager,
    providedIn: 'root',
    factory: () => new AfterRenderManager()
  });
}
const AFTER_RENDER_PHASES = /* @__PURE__ **/(() => [0, 1, 2, 3])();
class AfterRenderImpl {
  ngZone = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone);
  scheduler = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ChangeDetectionScheduler);
  errorHandler = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ErrorHandler, {
    optional: true
  });
  sequences = new Set();
  deferredRegistrations = new Set();
  executing = false;
  constructor() {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(TracingService, {
      optional: true
    });
  }
  execute() {
    const hasSequencesToExecute = this.sequences.size > 0;
    if (hasSequencesToExecute) {
      profiler(ProfilerEvent.AfterRenderHooksStart);
    }
    this.executing = true;
    for (const phase of AFTER_RENDER_PHASES) {
      for (const sequence of this.sequences) {
        if (sequence.erroredOrDestroyed || !sequence.hooks[phase]) {
          continue;
        }
        try {
          sequence.pipelinedValue = this.ngZone.runOutsideAngular(() => this.maybeTrace(() => {
            const hookFn = sequence.hooks[phase];
            const value = hookFn(sequence.pipelinedValue);
            return value;
          }, sequence.snapshot));
        } catch (err) {
          sequence.erroredOrDestroyed = true;
          this.errorHandler?.handleError(err);
        }
      }
    }
    this.executing = false;
    for (const sequence of this.sequences) {
      sequence.afterRun();
      if (sequence.once) {
        this.sequences.delete(sequence);
        sequence.destroy();
      }
    }
    for (const sequence of this.deferredRegistrations) {
      this.sequences.add(sequence);
    }
    if (this.deferredRegistrations.size > 0) {
      this.scheduler.notify(7);
    }
    this.deferredRegistrations.clear();
    if (hasSequencesToExecute) {
      profiler(ProfilerEvent.AfterRenderHooksEnd);
    }
  }
  register(sequence) {
    const {
      view
    } = sequence;
    if (view !== undefined) {
      (view[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.AFTER_RENDER_SEQUENCES_TO_ADD] ??= []).push(sequence);
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.markAncestorsForTraversal)(view);
      view[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] |= 8192;
    } else if (!this.executing) {
      this.addSequence(sequence);
    } else {
      this.deferredRegistrations.add(sequence);
    }
  }
  addSequence(sequence) {
    this.sequences.add(sequence);
    this.scheduler.notify(7);
  }
  unregister(sequence) {
    if (this.executing && this.sequences.has(sequence)) {
      sequence.erroredOrDestroyed = true;
      sequence.pipelinedValue = undefined;
      sequence.once = true;
    } else {
      this.sequences.delete(sequence);
      this.deferredRegistrations.delete(sequence);
    }
  }
  maybeTrace(fn, snapshot) {
    return snapshot ? snapshot.run(TracingAction.AFTER_NEXT_RENDER, fn) : fn();
  }
  static ɵprov = /* @__PURE__ */
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
    token: AfterRenderImpl,
    providedIn: 'root',
    factory: () => new AfterRenderImpl()
  });
}
class AfterRenderSequence {
  impl;
  hooks;
  view;
  once;
  snapshot;
  erroredOrDestroyed = false;
  pipelinedValue = undefined;
  unregisterOnDestroy;
  constructor(impl, hooks, view, once, destroyRef, snapshot = null) {
    this.impl = impl;
    this.hooks = hooks;
    this.view = view;
    this.once = once;
    this.snapshot = snapshot;
    this.unregisterOnDestroy = destroyRef?.onDestroy(() => this.destroy());
  }
  afterRun() {
    this.erroredOrDestroyed = false;
    this.pipelinedValue = undefined;
    this.snapshot?.dispose();
    this.snapshot = null;
  }
  destroy() {
    this.impl.unregister(this);
    this.unregisterOnDestroy?.();
    const scheduled = this.view?.[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.AFTER_RENDER_SEQUENCES_TO_ADD];
    if (scheduled) {
      this.view[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.AFTER_RENDER_SEQUENCES_TO_ADD] = scheduled.filter(s => s !== this);
    }
  }
}
function afterEveryRender(callbackOrSpec, options) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotInReactiveContext)(afterEveryRender, 'Call `afterEveryRender` outside of a reactive context. For example, schedule the render ' + 'callback inside the component constructor`.');
  if (ngDevMode && !options?.injector) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertInInjectionContext)(afterEveryRender);
  }
  const injector = options?.injector ?? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.Injector);
  if (typeof ngServerMode !== 'undefined' && ngServerMode) {
    return NOOP_AFTER_RENDER_REF;
  }
  performanceMarkFeature('NgAfterRender');
  return afterEveryRenderImpl(callbackOrSpec, injector, options, false);
}
function afterNextRender(callbackOrSpec, options) {
  if (ngDevMode && !options?.injector) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertInInjectionContext)(afterNextRender);
  }
  const injector = options?.injector ?? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.Injector);
  if (typeof ngServerMode !== 'undefined' && ngServerMode) {
    return NOOP_AFTER_RENDER_REF;
  }
  performanceMarkFeature('NgAfterNextRender');
  return afterEveryRenderImpl(callbackOrSpec, injector, options, true);
}
function getHooks(callbackOrSpec) {
  if (callbackOrSpec instanceof Function) {
    return [undefined, undefined, callbackOrSpec, undefined];
  } else {
    return [callbackOrSpec.earlyRead, callbackOrSpec.write, callbackOrSpec.mixedReadWrite, callbackOrSpec.read];
  }
}
function afterEveryRenderImpl(callbackOrSpec, injector, options, once) {
  const manager = injector.get(AfterRenderManager);
  manager.impl ??= injector.get(AfterRenderImpl);
  const tracing = injector.get(TracingService, null, {
    optional: true
  });
  const destroyRef = options?.manualCleanup !== true ? injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DestroyRef) : null;
  const viewContext = injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ViewContext, null, {
    optional: true
  });
  const sequence = new AfterRenderSequence(manager.impl, getHooks(callbackOrSpec), viewContext?.view, once, destroyRef, tracing?.snapshot(null));
  manager.impl.register(sequence);
  return sequence;
}
const NOOP_AFTER_RENDER_REF = {
  destroy() {}
};
const ANIMATION_QUEUE = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'AnimationQueue' : '', {
  factory: () => {
    return {
      queue: new Set(),
      isScheduled: false,
      scheduler: null,
      injector: (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EnvironmentInjector)
    };
  }
});
function addToAnimationQueue(injector, animationFns, animationData) {
  const animationQueue = injector.get(ANIMATION_QUEUE);
  if (Array.isArray(animationFns)) {
    for (const animateFn of animationFns) {
      animationQueue.queue.add(animateFn);
      animationData?.detachedLeaveAnimationFns?.push(animateFn);
    }
  } else {
    animationQueue.queue.add(animationFns);
    animationData?.detachedLeaveAnimationFns?.push(animationFns);
  }
  animationQueue.scheduler && animationQueue.scheduler(injector);
}
function removeFromAnimationQueue(injector, animationData) {
  const animationQueue = injector.get(ANIMATION_QUEUE);
  if (animationData.detachedLeaveAnimationFns) {
    for (const animationFn of animationData.detachedLeaveAnimationFns) {
      animationQueue.queue.delete(animationFn);
    }
    animationData.detachedLeaveAnimationFns = undefined;
  }
}
function scheduleAnimationQueue(injector) {
  const animationQueue = injector.get(ANIMATION_QUEUE);
  if (!animationQueue.isScheduled) {
    afterNextRender(() => {
      animationQueue.isScheduled = false;
      for (let animateFn of animationQueue.queue) {
        animateFn();
      }
      animationQueue.queue.clear();
    }, {
      injector: animationQueue.injector
    });
    animationQueue.isScheduled = true;
  }
}
function initializeAnimationQueueScheduler(injector) {
  const animationQueue = injector.get(ANIMATION_QUEUE);
  animationQueue.scheduler = scheduleAnimationQueue;
  animationQueue.scheduler(injector);
}
function queueEnterAnimations(injector, enterAnimations) {
  for (const [_, nodeAnimations] of enterAnimations) {
    addToAnimationQueue(injector, nodeAnimations.animateFns);
  }
}
function maybeQueueEnterAnimation(parentLView, parent, tNode, injector) {
  const enterAnimations = parentLView?.[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ANIMATIONS]?.enter;
  if (parent !== null && enterAnimations && enterAnimations.has(tNode.index)) {
    queueEnterAnimations(injector, enterAnimations);
  }
}
function applyToElementOrContainer(action, renderer, injector, parent, lNodeToHandle, tNode, beforeNode, parentLView) {
  if (lNodeToHandle != null) {
    let lContainer;
    let isComponent = false;
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(lNodeToHandle)) {
      lContainer = lNodeToHandle;
    } else if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(lNodeToHandle)) {
      isComponent = true;
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(lNodeToHandle[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST], 'HOST must be defined for a component LView');
      lNodeToHandle = lNodeToHandle[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST];
    }
    const rNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lNodeToHandle);
    if (action === 0 && parent !== null) {
      maybeQueueEnterAnimation(parentLView, parent, tNode, injector);
      if (beforeNode == null) {
        nativeAppendChild(renderer, parent, rNode);
      } else {
        nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
      }
    } else if (action === 1 && parent !== null) {
      maybeQueueEnterAnimation(parentLView, parent, tNode, injector);
      nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
    } else if (action === 2) {
      runLeaveAnimationsWithCallback(parentLView, tNode, injector, nodeHasLeaveAnimations => {
        nativeRemoveNode(renderer, rNode, isComponent, nodeHasLeaveAnimations);
      });
    } else if (action === 3) {
      runLeaveAnimationsWithCallback(parentLView, tNode, injector, () => {
        renderer.destroyNode(rNode);
      });
    }
    if (lContainer != null) {
      applyContainer(renderer, action, injector, lContainer, tNode, parent, beforeNode);
    }
  }
}
function removeViewFromDOM(tView, lView) {
  detachViewFromDOM(tView, lView);
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST] = null;
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST] = null;
}
function addViewToDOM(tView, parentTNode, renderer, lView, parentNativeNode, beforeNode) {
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST] = parentNativeNode;
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST] = parentTNode;
  applyView(tView, lView, renderer, 1, parentNativeNode, beforeNode);
}
function detachViewFromDOM(tView, lView) {
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT].changeDetectionScheduler?.notify(9);
  applyView(tView, lView, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], 2, null, null);
}
function destroyViewTree(rootView) {
  let lViewOrLContainer = rootView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CHILD_HEAD];
  if (!lViewOrLContainer) {
    return cleanUpView(rootView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], rootView);
  }
  while (lViewOrLContainer) {
    let next = null;
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(lViewOrLContainer)) {
      next = lViewOrLContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CHILD_HEAD];
    } else {
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLContainer)(lViewOrLContainer);
      const firstView = lViewOrLContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET];
      if (firstView) next = firstView;
    }
    if (!next) {
      while (lViewOrLContainer && !lViewOrLContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT] && lViewOrLContainer !== rootView) {
        if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(lViewOrLContainer)) {
          cleanUpView(lViewOrLContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], lViewOrLContainer);
        }
        lViewOrLContainer = lViewOrLContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT];
      }
      if (lViewOrLContainer === null) lViewOrLContainer = rootView;
      if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(lViewOrLContainer)) {
        cleanUpView(lViewOrLContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], lViewOrLContainer);
      }
      next = lViewOrLContainer && lViewOrLContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT];
    }
    lViewOrLContainer = next;
  }
}
function detachMovedView(declarationContainer, lView) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLContainer)(declarationContainer);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(declarationContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.MOVED_VIEWS], 'A projected view should belong to a non-empty projected views collection');
  const movedViews = declarationContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.MOVED_VIEWS];
  const declarationViewIndex = movedViews.indexOf(lView);
  movedViews.splice(declarationViewIndex, 1);
}
function destroyLView(tView, lView) {
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isDestroyed)(lView)) {
    return;
  }
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  if (renderer.destroyNode) {
    applyView(tView, lView, renderer, 3, null, null);
  }
  destroyViewTree(lView);
}
function cleanUpView(tView, lView) {
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isDestroyed)(lView)) {
    return;
  }
  const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
  try {
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] &= ~128;
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] |= 256;
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.REACTIVE_TEMPLATE_CONSUMER] && (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.consumerDestroy)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.REACTIVE_TEMPLATE_CONSUMER]);
    executeOnDestroys(tView, lView);
    processCleanups(tView, lView);
    if (lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].type === 1) {
      lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER].destroy();
    }
    const declarationContainer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_LCONTAINER];
    if (declarationContainer !== null && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT])) {
      if (declarationContainer !== lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT]) {
        detachMovedView(declarationContainer, lView);
      }
      const lQueries = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.QUERIES];
      if (lQueries !== null) {
        lQueries.detachView(tView);
      }
    }
    unregisterLView(lView);
  } finally {
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
  }
}
function runLeaveAnimationsWithCallback(lView, tNode, injector, callback) {
  const animations = lView?.[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ANIMATIONS];
  if (animations == null || animations.leave == undefined || !animations.leave.has(tNode.index)) return callback(false);
  if (lView) allLeavingAnimations.add(lView);
  addToAnimationQueue(injector, () => {
    if (animations.leave && animations.leave.has(tNode.index)) {
      const leaveAnimationMap = animations.leave;
      const leaveAnimations = leaveAnimationMap.get(tNode.index);
      const runningAnimations = [];
      if (leaveAnimations) {
        for (let index = 0; index < leaveAnimations.animateFns.length; index++) {
          const animationFn = leaveAnimations.animateFns[index];
          const {
            promise
          } = animationFn();
          runningAnimations.push(promise);
        }
        animations.detachedLeaveAnimationFns = undefined;
      }
      animations.running = Promise.allSettled(runningAnimations);
      runAfterLeaveAnimations(lView, callback);
    } else {
      if (lView) allLeavingAnimations.delete(lView);
      callback(false);
    }
  }, animations);
}
function runAfterLeaveAnimations(lView, callback) {
  const runningAnimations = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ANIMATIONS]?.running;
  if (runningAnimations) {
    runningAnimations.then(() => {
      lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ANIMATIONS].running = undefined;
      allLeavingAnimations.delete(lView);
      callback(true);
    });
    return;
  }
  callback(false);
}
function processCleanups(tView, lView) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotReactive)(processCleanups.name);
  const tCleanup = tView.cleanup;
  const lCleanup = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CLEANUP];
  if (tCleanup !== null) {
    for (let i = 0; i < tCleanup.length - 1; i += 2) {
      if (typeof tCleanup[i] === 'string') {
        const targetIdx = tCleanup[i + 3];
        ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(targetIdx, 'cleanup target must be a number');
        if (targetIdx >= 0) {
          lCleanup[targetIdx]();
        } else {
          lCleanup[-targetIdx].unsubscribe();
        }
        i += 2;
      } else {
        const context = lCleanup[tCleanup[i + 1]];
        tCleanup[i].call(context);
      }
    }
  }
  if (lCleanup !== null) {
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CLEANUP] = null;
  }
  const destroyHooks = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ON_DESTROY_HOOKS];
  if (destroyHooks !== null) {
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ON_DESTROY_HOOKS] = null;
    for (let i = 0; i < destroyHooks.length; i++) {
      const destroyHooksFn = destroyHooks[i];
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFunction)(destroyHooksFn, 'Expecting destroy hook to be a function.');
      destroyHooksFn();
    }
  }
  const effects = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EFFECTS];
  if (effects !== null) {
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EFFECTS] = null;
    for (const effect of effects) {
      effect.destroy();
    }
  }
}
function executeOnDestroys(tView, lView) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotReactive)(executeOnDestroys.name);
  let destroyHooks;
  if (tView != null && (destroyHooks = tView.destroyHooks) != null) {
    for (let i = 0; i < destroyHooks.length; i += 2) {
      const context = lView[destroyHooks[i]];
      if (!(context instanceof NodeInjectorFactory)) {
        const toCall = destroyHooks[i + 1];
        if (Array.isArray(toCall)) {
          for (let j = 0; j < toCall.length; j += 2) {
            const callContext = context[toCall[j]];
            const hook = toCall[j + 1];
            profiler(ProfilerEvent.LifecycleHookStart, callContext, hook);
            try {
              hook.call(callContext);
            } finally {
              profiler(ProfilerEvent.LifecycleHookEnd, callContext, hook);
            }
          }
        } else {
          profiler(ProfilerEvent.LifecycleHookStart, context, toCall);
          try {
            toCall.call(context);
          } finally {
            profiler(ProfilerEvent.LifecycleHookEnd, context, toCall);
          }
        }
      }
    }
  }
}
function getParentRElement(tView, tNode, lView) {
  return getClosestRElement(tView, tNode.parent, lView);
}
function getClosestRElement(tView, tNode, lView) {
  let parentTNode = tNode;
  while (parentTNode !== null && parentTNode.type & (8 | 32 | 128)) {
    tNode = parentTNode;
    parentTNode = tNode.parent;
  }
  if (parentTNode === null) {
    return lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST];
  } else {
    ngDevMode && assertTNodeType(parentTNode, 3 | 4);
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentHost)(parentTNode)) {
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForLView)(parentTNode, lView);
      const {
        encapsulation
      } = tView.data[parentTNode.directiveStart + parentTNode.componentOffset];
      if (encapsulation === ViewEncapsulation.None || encapsulation === ViewEncapsulation.Emulated) {
        return null;
      }
    }
    return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(parentTNode, lView);
  }
}
function getInsertInFrontOfRNode(parentTNode, currentTNode, lView) {
  return _getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView);
}
function getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView) {
  if (parentTNode.type & (8 | 32)) {
    return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(parentTNode, lView);
  }
  return null;
}
let _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithNoI18n;
let _processI18nInsertBefore;
function setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore) {
  _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithI18n;
  _processI18nInsertBefore = processI18nInsertBefore;
}
function appendChild(tView, lView, childRNode, childTNode) {
  const parentRNode = getParentRElement(tView, childTNode, lView);
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  const parentTNode = childTNode.parent || lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST];
  const anchorNode = getInsertInFrontOfRNode(parentTNode, childTNode, lView);
  if (parentRNode != null) {
    if (Array.isArray(childRNode)) {
      for (let i = 0; i < childRNode.length; i++) {
        nativeAppendOrInsertBefore(renderer, parentRNode, childRNode[i], anchorNode, false);
      }
    } else {
      nativeAppendOrInsertBefore(renderer, parentRNode, childRNode, anchorNode, false);
    }
  }
  _processI18nInsertBefore !== undefined && _processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRNode);
}
function getFirstNativeNode(lView, tNode) {
  if (tNode !== null) {
    ngDevMode && assertTNodeType(tNode, 3 | 12 | 32 | 16 | 128);
    const tNodeType = tNode.type;
    if (tNodeType & 3) {
      return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
    } else if (tNodeType & 4) {
      return getBeforeNodeForView(-1, lView[tNode.index]);
    } else if (tNodeType & 8) {
      const elIcuContainerChild = tNode.child;
      if (elIcuContainerChild !== null) {
        return getFirstNativeNode(lView, elIcuContainerChild);
      } else {
        const rNodeOrLContainer = lView[tNode.index];
        if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(rNodeOrLContainer)) {
          return getBeforeNodeForView(-1, rNodeOrLContainer);
        } else {
          return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(rNodeOrLContainer);
        }
      }
    } else if (tNodeType & 128) {
      return getFirstNativeNode(lView, tNode.next);
    } else if (tNodeType & 32) {
      let nextRNode = icuContainerIterate(tNode, lView);
      let rNode = nextRNode();
      return rNode || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[tNode.index]);
    } else {
      const projectionNodes = getProjectionNodes(lView, tNode);
      if (projectionNodes !== null) {
        if (Array.isArray(projectionNodes)) {
          return projectionNodes[0];
        }
        const parentView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLViewParent)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW]);
        ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertParentView)(parentView);
        return getFirstNativeNode(parentView, projectionNodes);
      } else {
        return getFirstNativeNode(lView, tNode.next);
      }
    }
  }
  return null;
}
function getProjectionNodes(lView, tNode) {
  if (tNode !== null) {
    const componentView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW];
    const componentHost = componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST];
    const slotIdx = tNode.projection;
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertProjectionSlots)(lView);
    return componentHost.projection[slotIdx];
  }
  return null;
}
function getBeforeNodeForView(viewIndexInContainer, lContainer) {
  const nextViewIndex = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;
  if (nextViewIndex < lContainer.length) {
    const lView = lContainer[nextViewIndex];
    const firstTNodeOfView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].firstChild;
    if (firstTNodeOfView !== null) {
      return getFirstNativeNode(lView, firstTNodeOfView);
    }
  }
  return lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NATIVE];
}
function applyNodes(renderer, action, tNode, lView, parentRElement, beforeNode, isProjection) {
  while (tNode != null) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForLView)(tNode, lView);
    const injector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
    if (tNode.type === 128) {
      tNode = tNode.next;
      continue;
    }
    ngDevMode && assertTNodeType(tNode, 3 | 12 | 16 | 32);
    const rawSlotValue = lView[tNode.index];
    const tNodeType = tNode.type;
    if (isProjection) {
      if (action === 0) {
        rawSlotValue && attachPatchData((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(rawSlotValue), lView);
        tNode.flags |= 2;
      }
    }
    if (!isDetachedByI18n(tNode)) {
      if (tNodeType & 8) {
        applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);
        applyToElementOrContainer(action, renderer, injector, parentRElement, rawSlotValue, tNode, beforeNode, lView);
      } else if (tNodeType & 32) {
        const nextRNode = icuContainerIterate(tNode, lView);
        let rNode;
        while (rNode = nextRNode()) {
          applyToElementOrContainer(action, renderer, injector, parentRElement, rNode, tNode, beforeNode, lView);
        }
        applyToElementOrContainer(action, renderer, injector, parentRElement, rawSlotValue, tNode, beforeNode, lView);
      } else if (tNodeType & 16) {
        applyProjectionRecursive(renderer, action, lView, tNode, parentRElement, beforeNode);
      } else {
        ngDevMode && assertTNodeType(tNode, 3 | 4);
        applyToElementOrContainer(action, renderer, injector, parentRElement, rawSlotValue, tNode, beforeNode, lView);
      }
    }
    tNode = isProjection ? tNode.projectionNext : tNode.next;
  }
}
function applyView(tView, lView, renderer, action, parentRElement, beforeNode) {
  applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);
}
function applyProjection(tView, lView, tProjectionNode) {
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  const parentRNode = getParentRElement(tView, tProjectionNode, lView);
  const parentTNode = tProjectionNode.parent || lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST];
  let beforeNode = getInsertInFrontOfRNode(parentTNode, tProjectionNode, lView);
  applyProjectionRecursive(renderer, 0, lView, tProjectionNode, parentRNode, beforeNode);
}
function applyProjectionRecursive(renderer, action, lView, tProjectionNode, parentRElement, beforeNode) {
  const componentLView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW];
  const componentNode = componentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(typeof tProjectionNode.projection, 'number', 'expecting projection index');
  const nodeToProjectOrRNodes = componentNode.projection[tProjectionNode.projection];
  if (Array.isArray(nodeToProjectOrRNodes)) {
    for (let i = 0; i < nodeToProjectOrRNodes.length; i++) {
      const rNode = nodeToProjectOrRNodes[i];
      applyToElementOrContainer(action, renderer, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1], parentRElement, rNode, tProjectionNode, beforeNode, lView);
    }
  } else {
    let nodeToProject = nodeToProjectOrRNodes;
    const projectedComponentLView = componentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT];
    if (hasInSkipHydrationBlockFlag(tProjectionNode)) {
      nodeToProject.flags |= 128;
    }
    applyNodes(renderer, action, nodeToProject, projectedComponentLView, parentRElement, beforeNode, true);
  }
}
function applyContainer(renderer, action, injector, lContainer, tNode, parentRElement, beforeNode) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLContainer)(lContainer);
  const anchor = lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NATIVE];
  const native = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lContainer);
  if (anchor !== native) {
    applyToElementOrContainer(action, renderer, injector, parentRElement, anchor, tNode, beforeNode);
  }
  for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    const lView = lContainer[i];
    applyView(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], lView, renderer, action, parentRElement, anchor);
  }
}
function applyStyling(renderer, isClassBased, rNode, prop, value) {
  if (isClassBased) {
    if (!value) {
      renderer.removeClass(rNode, prop);
    } else {
      renderer.addClass(rNode, prop);
    }
  } else {
    let flags = prop.indexOf('-') === -1 ? undefined : RendererStyleFlags2.DashCase;
    if (value == null) {
      renderer.removeStyle(rNode, prop, flags);
    } else {
      const isImportant = typeof value === 'string' ? value.endsWith('!important') : false;
      if (isImportant) {
        value = value.slice(0, -10);
        flags |= RendererStyleFlags2.Important;
      }
      renderer.setStyle(rNode, prop, value, flags);
    }
  }
}
function executeTemplate(tView, lView, templateFn, rf, context) {
  const prevSelectedIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)();
  const isUpdatePhase = rf & 2;
  try {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setSelectedIndex)(-1);
    if (isUpdatePhase && lView.length > _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET) {
      selectIndexInternal(tView, lView, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET, !!ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isInCheckNoChangesMode)());
    }
    const preHookType = isUpdatePhase ? ProfilerEvent.TemplateUpdateStart : ProfilerEvent.TemplateCreateStart;
    profiler(preHookType, context, templateFn);
    templateFn(rf, context);
  } finally {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setSelectedIndex)(prevSelectedIndex);
    const postHookType = isUpdatePhase ? ProfilerEvent.TemplateUpdateEnd : ProfilerEvent.TemplateCreateEnd;
    profiler(postHookType, context, templateFn);
  }
}
function createDirectivesInstances(tView, lView, tNode) {
  instantiateAllDirectives(tView, lView, tNode);
  if ((tNode.flags & 64) === 64) {
    invokeDirectivesHostBindings(tView, lView, tNode);
  }
}
function saveResolvedLocalsInData(viewData, tNode, localRefExtractor = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode) {
  const localNames = tNode.localNames;
  if (localNames !== null) {
    let localIndex = tNode.index + 1;
    for (let i = 0; i < localNames.length; i += 2) {
      const index = localNames[i + 1];
      const value = index === -1 ? localRefExtractor(tNode, viewData) : viewData[index];
      viewData[localIndex++] = value;
    }
  }
}
function locateHostElement(renderer, elementOrSelector, encapsulation, injector) {
  const preserveHostContent = injector.get(PRESERVE_HOST_CONTENT, PRESERVE_HOST_CONTENT_DEFAULT);
  const preserveContent = preserveHostContent || encapsulation === ViewEncapsulation.ShadowDom || encapsulation === ViewEncapsulation.ExperimentalIsolatedShadowDom;
  const rootElement = renderer.selectRootElement(elementOrSelector, preserveContent);
  applyRootElementTransform(rootElement);
  return rootElement;
}
function applyRootElementTransform(rootElement) {
  _applyRootElementTransformImpl(rootElement);
}
let _applyRootElementTransformImpl = () => null;
function applyRootElementTransformImpl(rootElement) {
  if (hasSkipHydrationAttrOnRElement(rootElement)) {
    clearElementContents(rootElement);
  } else {
    processTextNodeMarkersBeforeHydration(rootElement);
  }
}
function enableApplyRootElementTransformImpl() {
  _applyRootElementTransformImpl = applyRootElementTransformImpl;
}
function mapPropName(name) {
  if (name === 'class') return 'className';
  if (name === 'for') return 'htmlFor';
  if (name === 'formaction') return 'formAction';
  if (name === 'innerHtml') return 'innerHTML';
  if (name === 'readonly') return 'readOnly';
  if (name === 'tabindex') return 'tabIndex';
  return name;
}
function setPropertyAndInputs(tNode, lView, propName, value, renderer, sanitizer) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotSame)(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const hasSetInput = setAllInputsForProperty(tNode, tView, lView, propName, value);
  if (hasSetInput) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentHost)(tNode) && markDirtyIfOnPush(lView, tNode.index);
    ngDevMode && setNgReflectProperties(lView, tView, tNode, propName, value);
    return;
  }
  if (tNode.type & 3) {
    propName = mapPropName(propName);
  }
  setDomProperty(tNode, lView, propName, value, renderer, sanitizer);
}
function setDomProperty(tNode, lView, propName, value, renderer, sanitizer) {
  if (tNode.type & 3) {
    const element = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
    if (ngDevMode) {
      validateAgainstEventProperties(propName);
      if (!isPropertyValid(element, propName, tNode.value, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].schemas)) {
        handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);
      }
    }
    value = sanitizer != null ? sanitizer(value, tNode.value || '', propName) : value;
    renderer.setProperty(element, propName, value);
  } else if (tNode.type & 12) {
    if (ngDevMode && !matchingSchemas(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].schemas, tNode.value)) {
      handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);
    }
  }
}
function markDirtyIfOnPush(lView, viewIndex) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLView)(lView);
  const childComponentLView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(viewIndex, lView);
  if (!(childComponentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] & 16)) {
    childComponentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] |= 64;
  }
}
function setNgReflectProperty(lView, tNode, attrName, value) {
  const environment = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT];
  if (!environment.ngReflect) {
    return;
  }
  const element = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  attrName = normalizeDebugBindingName(attrName);
  const debugValue = normalizeDebugBindingValue(value);
  if (tNode.type & 3) {
    if (value == null) {
      renderer.removeAttribute(element, attrName);
    } else {
      renderer.setAttribute(element, attrName, debugValue);
    }
  } else {
    const textContent = escapeCommentText(`bindings=${JSON.stringify({
      [attrName]: debugValue
    }, null, 2)}`);
    renderer.setValue(element, textContent);
  }
}
function setNgReflectProperties(lView, tView, tNode, publicName, value) {
  const environment = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT];
  if (!environment.ngReflect || !(tNode.type & (3 | 4))) {
    return;
  }
  const inputConfig = tNode.inputs?.[publicName];
  const hostInputConfig = tNode.hostDirectiveInputs?.[publicName];
  if (hostInputConfig) {
    for (let i = 0; i < hostInputConfig.length; i += 2) {
      const index = hostInputConfig[i];
      const publicName = hostInputConfig[i + 1];
      const def = tView.data[index];
      setNgReflectProperty(lView, tNode, def.inputs[publicName][0], value);
    }
  }
  if (inputConfig) {
    for (const index of inputConfig) {
      const def = tView.data[index];
      setNgReflectProperty(lView, tNode, def.inputs[publicName][0], value);
    }
  }
}
function instantiateAllDirectives(tView, lView, tNode) {
  const start = tNode.directiveStart;
  const end = tNode.directiveEnd;
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentHost)(tNode)) {
    ngDevMode && assertTNodeType(tNode, 3);
    createComponentLView(lView, tNode, tView.data[start + tNode.componentOffset]);
  }
  if (!tView.firstCreatePass) {
    getOrCreateNodeInjectorForNode(tNode, lView);
  }
  const initialInputs = tNode.initialInputs;
  for (let i = start; i < end; i++) {
    const def = tView.data[i];
    const directive = getNodeInjectable(lView, tView, i, tNode);
    attachPatchData(directive, lView);
    if (initialInputs !== null) {
      setInputsFromAttrs(lView, i - start, directive, def, tNode, initialInputs);
    }
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentDef)(def)) {
      const componentView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(tNode.index, lView);
      componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT] = getNodeInjectable(lView, tView, i, tNode);
    }
  }
}
function invokeDirectivesHostBindings(tView, lView, tNode) {
  const start = tNode.directiveStart;
  const end = tNode.directiveEnd;
  const elementIndex = tNode.index;
  const currentDirectiveIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentDirectiveIndex)();
  try {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setSelectedIndex)(elementIndex);
    for (let dirIndex = start; dirIndex < end; dirIndex++) {
      const def = tView.data[dirIndex];
      const directive = lView[dirIndex];
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentDirectiveIndex)(dirIndex);
      if (def.hostBindings !== null || def.hostVars !== 0 || def.hostAttrs !== null) {
        invokeHostBindingsInCreationMode(def, directive);
      }
    }
  } finally {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setSelectedIndex)(-1);
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentDirectiveIndex)(currentDirectiveIndex);
  }
}
function invokeHostBindingsInCreationMode(def, directive) {
  if (def.hostBindings !== null) {
    def.hostBindings(1, directive);
  }
}
function findDirectiveDefMatches(tView, tNode) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView);
  ngDevMode && assertTNodeType(tNode, 3 | 12);
  const registry = tView.directiveRegistry;
  let matches = null;
  if (registry) {
    for (let i = 0; i < registry.length; i++) {
      const def = registry[i];
      if (isNodeMatchingSelectorList(tNode, def.selectors, false)) {
        matches ??= [];
        if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentDef)(def)) {
          if (ngDevMode) {
            assertTNodeType(tNode, 2, `"${tNode.value}" tags cannot be used as component hosts. ` + `Please use a different tag to activate the ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringify)(def.type)} component.`);
            if (matches.length && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentDef)(matches[0])) {
              throwMultipleComponentError(tNode, matches.find(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentDef).type, def.type);
            }
          }
          matches.unshift(def);
        } else {
          matches.push(def);
        }
      }
    }
  }
  return matches;
}
function elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace) {
  if (ngDevMode) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotSame)(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');
    validateAgainstEventAttributes(name);
    assertTNodeType(tNode, 2, `Attempted to set attribute \`${name}\` on a container node. ` + `Host bindings are not valid on ng-container or ng-template.`);
  }
  const element = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
  setElementAttribute(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], element, namespace, tNode.value, name, value, sanitizer);
}
function setElementAttribute(renderer, element, namespace, tagName, name, value, sanitizer) {
  if (value == null) {
    renderer.removeAttribute(element, name, namespace);
  } else {
    const strValue = sanitizer == null ? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(value) : sanitizer(value, tagName || '', name);
    renderer.setAttribute(element, name, strValue, namespace);
  }
}
function setInputsFromAttrs(lView, directiveIndex, instance, def, tNode, initialInputData) {
  const initialInputs = initialInputData[directiveIndex];
  if (initialInputs !== null) {
    for (let i = 0; i < initialInputs.length; i += 2) {
      const lookupName = initialInputs[i];
      const value = initialInputs[i + 1];
      writeToDirectiveInput(def, instance, lookupName, value);
      if (ngDevMode) {
        setNgReflectProperty(lView, tNode, def.inputs[lookupName][0], value);
      }
    }
  }
}
function elementLikeStartShared(tNode, lView, index, name, locateOrCreateNativeNode) {
  const adjustedIndex = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET + index;
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const native = locateOrCreateNativeNode(tView, lView, tNode, name, index);
  lView[adjustedIndex] = native;
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentTNode)(tNode, true);
  const isElement = tNode.type === 2;
  if (isElement) {
    setupStaticAttributes(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], native, tNode);
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getElementDepthCount)() === 0 || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isDirectiveHost)(tNode)) {
      attachPatchData(native, lView);
    }
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.increaseElementDepthCount)();
  } else {
    attachPatchData(native, lView);
  }
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.wasLastNodeCreated)() && (!isElement || !isDetachedByI18n(tNode))) {
    appendChild(tView, lView, native, tNode);
  }
  return tNode;
}
function elementLikeEndShared(tNode) {
  let currentTNode = tNode;
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isCurrentTNodeParent)()) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentTNodeAsNotParent)();
  } else {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertHasParent)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)());
    currentTNode = currentTNode.parent;
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentTNode)(currentTNode, false);
  }
  return currentTNode;
}
function storePropertyBindingMetadata(tData, tNode, propertyName, bindingIndex, ...interpolationParts) {
  if (tData[bindingIndex] === null) {
    if (!tNode.inputs?.[propertyName] && !tNode.hostDirectiveInputs?.[propertyName]) {
      const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);
      propBindingIdxs.push(bindingIndex);
      let bindingMetadata = propertyName;
      if (interpolationParts.length > 0) {
        bindingMetadata += INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);
      }
      tData[bindingIndex] = bindingMetadata;
    }
  }
}
function loadComponentRenderer(currentDef, tNode, lView) {
  if (currentDef === null || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentDef)(currentDef)) {
    lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapLView)(lView[tNode.index]);
  }
  return lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
}
function handleUncaughtError(lView, error) {
  const injector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
  if (!injector) {
    return;
  }
  let errorHandler;
  try {
    errorHandler = injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INTERNAL_APPLICATION_ERROR_HANDLER, null);
  } catch {
    errorHandler = null;
  }
  errorHandler?.(error);
}
function setAllInputsForProperty(tNode, tView, lView, publicName, value) {
  const inputs = tNode.inputs?.[publicName];
  const hostDirectiveInputs = tNode.hostDirectiveInputs?.[publicName];
  let hasMatch = false;
  if (hostDirectiveInputs) {
    for (let i = 0; i < hostDirectiveInputs.length; i += 2) {
      const index = hostDirectiveInputs[i];
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, index);
      const publicName = hostDirectiveInputs[i + 1];
      const def = tView.data[index];
      writeToDirectiveInput(def, lView[index], publicName, value);
      hasMatch = true;
    }
  }
  if (inputs) {
    for (const index of inputs) {
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, index);
      const instance = lView[index];
      const def = tView.data[index];
      writeToDirectiveInput(def, instance, publicName, value);
      hasMatch = true;
    }
  }
  return hasMatch;
}
function setDirectiveInput(tNode, tView, lView, target, publicName, value) {
  let hostIndex = null;
  let hostDirectivesStart = null;
  let hostDirectivesEnd = null;
  let hasSet = false;
  if (ngDevMode && !tNode.directiveToIndex?.has(target.type)) {
    throw new Error(`Node does not have a directive with type ${target.type.name}`);
  }
  const data = tNode.directiveToIndex.get(target.type);
  if (typeof data === 'number') {
    hostIndex = data;
  } else {
    [hostIndex, hostDirectivesStart, hostDirectivesEnd] = data;
  }
  if (hostDirectivesStart !== null && hostDirectivesEnd !== null && tNode.hostDirectiveInputs?.hasOwnProperty(publicName)) {
    const hostDirectiveInputs = tNode.hostDirectiveInputs[publicName];
    for (let i = 0; i < hostDirectiveInputs.length; i += 2) {
      const index = hostDirectiveInputs[i];
      if (index >= hostDirectivesStart && index <= hostDirectivesEnd) {
        ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, index);
        const def = tView.data[index];
        const hostDirectivePublicName = hostDirectiveInputs[i + 1];
        writeToDirectiveInput(def, lView[index], hostDirectivePublicName, value);
        hasSet = true;
      } else if (index > hostDirectivesEnd) {
        break;
      }
    }
  }
  if (hostIndex !== null && target.inputs.hasOwnProperty(publicName)) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, hostIndex);
    writeToDirectiveInput(target, lView[hostIndex], publicName, value);
    hasSet = true;
  }
  return hasSet;
}
function renderComponent(hostLView, componentHostIdx) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isCreationMode)(hostLView), true, 'Should be run in creation mode');
  const componentView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(componentHostIdx, hostLView);
  const componentTView = componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  syncViewWithBlueprint(componentTView, componentView);
  const hostRNode = componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST];
  if (hostRNode !== null && componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION] === null) {
    componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION] = retrieveHydrationInfo(hostRNode, componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1]);
  }
  profiler(ProfilerEvent.ComponentStart);
  try {
    renderView(componentTView, componentView, componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT]);
  } finally {
    profiler(ProfilerEvent.ComponentEnd, componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT]);
  }
}
function syncViewWithBlueprint(tView, lView) {
  for (let i = lView.length; i < tView.blueprint.length; i++) {
    lView.push(tView.blueprint[i]);
  }
}
function renderView(tView, lView, context) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isCreationMode)(lView), true, 'Should be run in creation mode');
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotReactive)(renderView.name);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.enterView)(lView);
  try {
    const viewQuery = tView.viewQuery;
    if (viewQuery !== null) {
      executeViewQueryFn(1, viewQuery, context);
    }
    const templateFn = tView.template;
    if (templateFn !== null) {
      executeTemplate(tView, lView, templateFn, 1, context);
    }
    if (tView.firstCreatePass) {
      tView.firstCreatePass = false;
    }
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.QUERIES]?.finishViewCreation(tView);
    if (tView.staticContentQueries) {
      refreshContentQueries(tView, lView);
    }
    if (tView.staticViewQueries) {
      executeViewQueryFn(2, tView.viewQuery, context);
    }
    const components = tView.components;
    if (components !== null) {
      renderChildComponents(lView, components);
    }
  } catch (error) {
    if (tView.firstCreatePass) {
      tView.incompleteFirstPass = true;
      tView.firstCreatePass = false;
    }
    throw error;
  } finally {
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] &= ~4;
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.leaveView)();
  }
}
function renderChildComponents(hostLView, components) {
  for (let i = 0; i < components.length; i++) {
    renderComponent(hostLView, components[i]);
  }
}
function createAndRenderEmbeddedLView(declarationLView, templateTNode, context, options) {
  const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
  try {
    const embeddedTView = templateTNode.tView;
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(embeddedTView, 'TView must be defined for a template node.');
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForLView)(templateTNode, declarationLView);
    const isSignalView = declarationLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] & 4096;
    const viewFlags = isSignalView ? 4096 : 16;
    const embeddedLView = createLView(declarationLView, embeddedTView, context, viewFlags, null, templateTNode, null, null, options?.injector ?? null, options?.embeddedViewInjector ?? null, options?.dehydratedView ?? null);
    const declarationLContainer = declarationLView[templateTNode.index];
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLContainer)(declarationLContainer);
    embeddedLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_LCONTAINER] = declarationLContainer;
    const declarationViewLQueries = declarationLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.QUERIES];
    if (declarationViewLQueries !== null) {
      embeddedLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);
    }
    renderView(embeddedTView, embeddedLView, context);
    return embeddedLView;
  } finally {
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
  }
}
function shouldAddViewToDom(tNode, dehydratedView) {
  return !dehydratedView || dehydratedView.firstChild === null || hasInSkipHydrationBlockFlag(tNode);
}
const USE_EXHAUSTIVE_CHECK_NO_CHANGES_DEFAULT = false;
const UseExhaustiveCheckNoChanges = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'exhaustive checkNoChanges' : '');
function collectNativeNodes(tView, lView, tNode, result, isProjection = false) {
  while (tNode !== null) {
    if (tNode.type === 128) {
      tNode = isProjection ? tNode.projectionNext : tNode.next;
      continue;
    }
    ngDevMode && assertTNodeType(tNode, 3 | 12 | 16 | 32);
    const lNode = lView[tNode.index];
    if (lNode !== null) {
      result.push((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lNode));
    }
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(lNode)) {
      collectNativeNodesInLContainer(lNode, result);
    }
    const tNodeType = tNode.type;
    if (tNodeType & 8) {
      collectNativeNodes(tView, lView, tNode.child, result);
    } else if (tNodeType & 32) {
      const nextRNode = icuContainerIterate(tNode, lView);
      let rNode;
      while (rNode = nextRNode()) {
        result.push(rNode);
      }
    } else if (tNodeType & 16) {
      const nodesInSlot = getProjectionNodes(lView, tNode);
      if (Array.isArray(nodesInSlot)) {
        result.push(...nodesInSlot);
      } else {
        const parentView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLViewParent)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW]);
        ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertParentView)(parentView);
        collectNativeNodes(parentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], parentView, nodesInSlot, result, true);
      }
    }
    tNode = isProjection ? tNode.projectionNext : tNode.next;
  }
  return result;
}
function collectNativeNodesInLContainer(lContainer, result) {
  for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    const lViewInAContainer = lContainer[i];
    const lViewFirstChildTNode = lViewInAContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].firstChild;
    if (lViewFirstChildTNode !== null) {
      collectNativeNodes(lViewInAContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], lViewInAContainer, lViewFirstChildTNode, result);
    }
  }
  if (lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NATIVE] !== lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST]) {
    result.push(lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NATIVE]);
  }
}
function addAfterRenderSequencesForView(lView) {
  if (lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.AFTER_RENDER_SEQUENCES_TO_ADD] !== null) {
    for (const sequence of lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.AFTER_RENDER_SEQUENCES_TO_ADD]) {
      sequence.impl.addSequence(sequence);
    }
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.AFTER_RENDER_SEQUENCES_TO_ADD].length = 0;
  }
}
let freeConsumers = [];
function getOrBorrowReactiveLViewConsumer(lView) {
  return lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.REACTIVE_TEMPLATE_CONSUMER] ?? borrowReactiveLViewConsumer(lView);
}
function borrowReactiveLViewConsumer(lView) {
  const consumer = freeConsumers.pop() ?? Object.create(REACTIVE_LVIEW_CONSUMER_NODE);
  consumer.lView = lView;
  return consumer;
}
function maybeReturnReactiveLViewConsumer(consumer) {
  if (consumer.lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.REACTIVE_TEMPLATE_CONSUMER] === consumer) {
    return;
  }
  consumer.lView = null;
  freeConsumers.push(consumer);
}
const REACTIVE_LVIEW_CONSUMER_NODE = {
  ..._effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.REACTIVE_NODE,
  consumerIsAlwaysLive: true,
  kind: 'template',
  consumerMarkedDirty: node => {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.markAncestorsForTraversal)(node.lView);
  },
  consumerOnSignalRead() {
    this.lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.REACTIVE_TEMPLATE_CONSUMER] = this;
  }
};
function getOrCreateTemporaryConsumer(lView) {
  const consumer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.REACTIVE_TEMPLATE_CONSUMER] ?? Object.create(TEMPORARY_CONSUMER_NODE);
  consumer.lView = lView;
  return consumer;
}
const TEMPORARY_CONSUMER_NODE = {
  ..._effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.REACTIVE_NODE,
  consumerIsAlwaysLive: true,
  kind: 'template',
  consumerMarkedDirty: node => {
    let parent = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLViewParent)(node.lView);
    while (parent && !viewShouldHaveReactiveConsumer(parent[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW])) {
      parent = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLViewParent)(parent);
    }
    if (!parent) {
      return;
    }
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.markViewForRefresh)(parent);
  },
  consumerOnSignalRead() {
    this.lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.REACTIVE_TEMPLATE_CONSUMER] = this;
  }
};
function viewShouldHaveReactiveConsumer(tView) {
  return tView.type !== 2;
}
function isReactiveLViewConsumer(node) {
  return node.kind === 'template';
}
function runEffectsInView(view) {
  if (view[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EFFECTS] === null) {
    return;
  }
  let tryFlushEffects = true;
  while (tryFlushEffects) {
    let foundDirtyEffect = false;
    for (const effect of view[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EFFECTS]) {
      if (!effect.dirty) {
        continue;
      }
      foundDirtyEffect = true;
      if (effect.zone === null || Zone.current === effect.zone) {
        effect.run();
      } else {
        effect.zone.run(() => effect.run());
      }
    }
    tryFlushEffects = foundDirtyEffect && !!(view[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] & 8192);
  }
}
const MAXIMUM_REFRESH_RERUNS$1 = 100;
function detectChangesInternal(lView, mode = 0) {
  const environment = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT];
  const rendererFactory = environment.rendererFactory;
  const checkNoChangesMode = !!ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isInCheckNoChangesMode)();
  if (!checkNoChangesMode) {
    rendererFactory.begin?.();
  }
  try {
    detectChangesInViewWhileDirty(lView, mode);
  } finally {
    if (!checkNoChangesMode) {
      rendererFactory.end?.();
    }
  }
}
function detectChangesInViewWhileDirty(lView, mode) {
  const lastIsRefreshingViewsValue = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isRefreshingViews)();
  try {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setIsRefreshingViews)(true);
    detectChangesInView(lView, mode);
    if (ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isExhaustiveCheckNoChanges)()) {
      return;
    }
    let retries = 0;
    while ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.requiresRefreshOrTraversal)(lView)) {
      if (retries === MAXIMUM_REFRESH_RERUNS$1) {
        throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(103, ngDevMode && 'Infinite change detection while trying to refresh views. ' + 'There may be components which each cause the other to require a refresh, ' + 'causing an infinite loop.');
      }
      retries++;
      detectChangesInView(lView, 1);
    }
  } finally {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setIsRefreshingViews)(lastIsRefreshingViewsValue);
  }
}
function checkNoChangesInternal(lView, exhaustive) {
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setIsInCheckNoChangesMode)(exhaustive ? _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CheckNoChangesMode.Exhaustive : _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CheckNoChangesMode.OnlyDirtyViews);
  try {
    detectChangesInternal(lView);
  } finally {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setIsInCheckNoChangesMode)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CheckNoChangesMode.Off);
  }
}
function refreshView(tView, lView, templateFn, context) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isCreationMode)(lView), false, 'Should be run in update mode');
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isDestroyed)(lView)) return;
  const flags = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS];
  const isInCheckNoChangesPass = ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isInCheckNoChangesMode)();
  const isInExhaustiveCheckNoChangesPass = ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isExhaustiveCheckNoChanges)();
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.enterView)(lView);
  let returnConsumerToPool = true;
  let prevConsumer = null;
  let currentConsumer = null;
  if (!isInCheckNoChangesPass) {
    if (viewShouldHaveReactiveConsumer(tView)) {
      currentConsumer = getOrBorrowReactiveLViewConsumer(lView);
      prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.consumerBeforeComputation)(currentConsumer);
    } else if ((0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getActiveConsumer)() === null) {
      returnConsumerToPool = false;
      currentConsumer = getOrCreateTemporaryConsumer(lView);
      prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.consumerBeforeComputation)(currentConsumer);
    } else if (lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.REACTIVE_TEMPLATE_CONSUMER]) {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.consumerDestroy)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.REACTIVE_TEMPLATE_CONSUMER]);
      lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.REACTIVE_TEMPLATE_CONSUMER] = null;
    }
  }
  try {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resetPreOrderHookFlags)(lView);
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setBindingIndex)(tView.bindingStartIndex);
    if (templateFn !== null) {
      executeTemplate(tView, lView, templateFn, 2, context);
    }
    const hooksInitPhaseCompleted = (flags & 3) === 3;
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const preOrderCheckHooks = tView.preOrderCheckHooks;
        if (preOrderCheckHooks !== null) {
          executeCheckHooks(lView, preOrderCheckHooks, null);
        }
      } else {
        const preOrderHooks = tView.preOrderHooks;
        if (preOrderHooks !== null) {
          executeInitAndCheckHooks(lView, preOrderHooks, 0, null);
        }
        incrementInitPhaseFlags(lView, 0);
      }
    }
    if (!isInExhaustiveCheckNoChangesPass) {
      markTransplantedViewsForRefresh(lView);
    }
    runEffectsInView(lView);
    detectChangesInEmbeddedViews(lView, 0);
    if (tView.contentQueries !== null) {
      refreshContentQueries(tView, lView);
    }
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const contentCheckHooks = tView.contentCheckHooks;
        if (contentCheckHooks !== null) {
          executeCheckHooks(lView, contentCheckHooks);
        }
      } else {
        const contentHooks = tView.contentHooks;
        if (contentHooks !== null) {
          executeInitAndCheckHooks(lView, contentHooks, 1);
        }
        incrementInitPhaseFlags(lView, 1);
      }
    }
    processHostBindingOpCodes(tView, lView);
    const components = tView.components;
    if (components !== null) {
      detectChangesInChildComponents(lView, components, 0);
    }
    const viewQuery = tView.viewQuery;
    if (viewQuery !== null) {
      executeViewQueryFn(2, viewQuery, context);
    }
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const viewCheckHooks = tView.viewCheckHooks;
        if (viewCheckHooks !== null) {
          executeCheckHooks(lView, viewCheckHooks);
        }
      } else {
        const viewHooks = tView.viewHooks;
        if (viewHooks !== null) {
          executeInitAndCheckHooks(lView, viewHooks, 2);
        }
        incrementInitPhaseFlags(lView, 2);
      }
    }
    if (tView.firstUpdatePass === true) {
      tView.firstUpdatePass = false;
    }
    if (lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EFFECTS_TO_SCHEDULE]) {
      for (const notifyEffect of lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EFFECTS_TO_SCHEDULE]) {
        notifyEffect();
      }
      lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EFFECTS_TO_SCHEDULE] = null;
    }
    if (!isInCheckNoChangesPass) {
      addAfterRenderSequencesForView(lView);
      lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] &= ~(64 | 8);
    }
  } catch (e) {
    if (!isInCheckNoChangesPass) {
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.markAncestorsForTraversal)(lView);
    }
    throw e;
  } finally {
    if (currentConsumer !== null) {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.consumerAfterComputation)(currentConsumer, prevConsumer);
      if (returnConsumerToPool) {
        maybeReturnReactiveLViewConsumer(currentConsumer);
      }
    }
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.leaveView)();
  }
}
function detectChangesInEmbeddedViews(lView, mode) {
  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
    for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
      const embeddedLView = lContainer[i];
      detectChangesInViewIfAttached(embeddedLView, mode);
    }
  }
}
function markTransplantedViewsForRefresh(lView) {
  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
    if (!(lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] & 2)) continue;
    const movedViews = lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.MOVED_VIEWS];
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(movedViews, 'Transplanted View flags set but missing MOVED_VIEWS');
    for (let i = 0; i < movedViews.length; i++) {
      const movedLView = movedViews[i];
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.markViewForRefresh)(movedLView);
    }
  }
}
function detectChangesInComponent(hostLView, componentHostIdx, mode) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isCreationMode)(hostLView), false, 'Should be run in update mode');
  profiler(ProfilerEvent.ComponentStart);
  const componentView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(componentHostIdx, hostLView);
  try {
    detectChangesInViewIfAttached(componentView, mode);
  } finally {
    profiler(ProfilerEvent.ComponentEnd, componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT]);
  }
}
function detectChangesInViewIfAttached(lView, mode) {
  if (!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.viewAttachedToChangeDetector)(lView)) {
    return;
  }
  detectChangesInView(lView, mode);
}
function detectChangesInView(lView, mode) {
  const isInCheckNoChangesPass = ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isInCheckNoChangesMode)();
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const flags = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS];
  const consumer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.REACTIVE_TEMPLATE_CONSUMER];
  let shouldRefreshView = !!(mode === 0 && flags & 16);
  shouldRefreshView ||= !!(flags & 64 && mode === 0 && !isInCheckNoChangesPass);
  shouldRefreshView ||= !!(flags & 1024);
  shouldRefreshView ||= !!(consumer?.dirty && (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.consumerPollProducersForChange)(consumer));
  shouldRefreshView ||= !!(ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isExhaustiveCheckNoChanges)());
  if (consumer) {
    consumer.dirty = false;
  }
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] &= ~(8192 | 1024);
  if (shouldRefreshView) {
    refreshView(tView, lView, tView.template, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT]);
  } else if (flags & 8192) {
    const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
    try {
      if (!isInCheckNoChangesPass) {
        runEffectsInView(lView);
      }
      detectChangesInEmbeddedViews(lView, 1);
      const components = tView.components;
      if (components !== null) {
        detectChangesInChildComponents(lView, components, 1);
      }
      if (!isInCheckNoChangesPass) {
        addAfterRenderSequencesForView(lView);
      }
    } finally {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
    }
  }
}
function detectChangesInChildComponents(hostLView, components, mode) {
  for (let i = 0; i < components.length; i++) {
    detectChangesInComponent(hostLView, components[i], mode);
  }
}
function processHostBindingOpCodes(tView, lView) {
  const hostBindingOpCodes = tView.hostBindingOpCodes;
  if (hostBindingOpCodes === null) return;
  try {
    for (let i = 0; i < hostBindingOpCodes.length; i++) {
      const opCode = hostBindingOpCodes[i];
      if (opCode < 0) {
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setSelectedIndex)(~opCode);
      } else {
        const directiveIdx = opCode;
        const bindingRootIndx = hostBindingOpCodes[++i];
        const hostBindingFn = hostBindingOpCodes[++i];
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setBindingRootForHostBindings)(bindingRootIndx, directiveIdx);
        const context = lView[directiveIdx];
        profiler(ProfilerEvent.HostBindingsUpdateStart, context);
        try {
          hostBindingFn(2, context);
        } finally {
          profiler(ProfilerEvent.HostBindingsUpdateEnd, context);
        }
      }
    }
  } finally {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setSelectedIndex)(-1);
  }
}
function markViewDirty(lView, source) {
  const dirtyBitsToUse = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isRefreshingViews)() ? 64 : 1024 | 64;
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT].changeDetectionScheduler?.notify(source);
  while (lView) {
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] |= dirtyBitsToUse;
    const parent = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLViewParent)(lView);
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isRootView)(lView) && !parent) {
      return lView;
    }
    lView = parent;
  }
  return null;
}
function createLContainer(hostNative, currentView, native, tNode) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLView)(currentView);
  const lContainer = [hostNative, true, 0, currentView, null, tNode, null, native, null, null];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(lContainer.length, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET, 'Should allocate correct number of slots for LContainer header.');
  return lContainer;
}
function getLViewFromLContainer(lContainer, index) {
  const adjustedIndex = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET + index;
  if (adjustedIndex < lContainer.length) {
    const lView = lContainer[adjustedIndex];
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLView)(lView);
    return lView;
  }
  return undefined;
}
function addLViewToLContainer(lContainer, lView, index, addToDOM = true) {
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  insertView(tView, lView, lContainer, index);
  if (addToDOM) {
    const beforeNode = getBeforeNodeForView(index, lContainer);
    const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
    const parentRNode = renderer.parentNode(lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NATIVE]);
    if (parentRNode !== null) {
      addViewToDOM(tView, lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST], renderer, lView, parentRNode, beforeNode);
    }
  }
  const hydrationInfo = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION];
  if (hydrationInfo !== null && hydrationInfo.firstChild !== null) {
    hydrationInfo.firstChild = null;
  }
}
function removeLViewFromLContainer(lContainer, index) {
  const lView = detachView(lContainer, index);
  if (lView !== undefined) {
    destroyLView(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], lView);
  }
  return lView;
}
function detachView(lContainer, removeIndex) {
  if (lContainer.length <= _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET) return;
  const indexInContainer = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET + removeIndex;
  const viewToDetach = lContainer[indexInContainer];
  if (viewToDetach) {
    const declarationLContainer = viewToDetach[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_LCONTAINER];
    if (declarationLContainer !== null && declarationLContainer !== lContainer) {
      detachMovedView(declarationLContainer, viewToDetach);
    }
    if (removeIndex > 0) {
      lContainer[indexInContainer - 1][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT] = viewToDetach[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT];
    }
    const removedLView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.removeFromArray)(lContainer, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET + removeIndex);
    removeViewFromDOM(viewToDetach[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], viewToDetach);
    const lQueries = removedLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.QUERIES];
    if (lQueries !== null) {
      lQueries.detachView(removedLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW]);
    }
    viewToDetach[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT] = null;
    viewToDetach[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT] = null;
    viewToDetach[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] &= ~128;
  }
  return viewToDetach;
}
function insertView(tView, lView, lContainer, index) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLView)(lView);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLContainer)(lContainer);
  const indexInContainer = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET + index;
  const containerLength = lContainer.length;
  if (index > 0) {
    lContainer[indexInContainer - 1][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT] = lView;
  }
  if (index < containerLength - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET) {
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT] = lContainer[indexInContainer];
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.addToArray)(lContainer, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET + index, lView);
  } else {
    lContainer.push(lView);
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT] = null;
  }
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT] = lContainer;
  const declarationLContainer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_LCONTAINER];
  if (declarationLContainer !== null && lContainer !== declarationLContainer) {
    trackMovedView(declarationLContainer, lView);
  }
  const lQueries = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.QUERIES];
  if (lQueries !== null) {
    lQueries.insertView(tView);
  }
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.updateAncestorTraversalFlagsOnAttach)(lView);
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] |= 128;
}
function trackMovedView(declarationContainer, lView) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(lView, 'LView required');
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLContainer)(declarationContainer);
  const movedViews = declarationContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.MOVED_VIEWS];
  const parent = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(parent, 'missing parent');
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(parent)) {
    declarationContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] |= 2;
  } else {
    const insertedComponentLView = parent[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW];
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(insertedComponentLView, 'Missing insertedComponentLView');
    const declaredComponentLView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW];
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(declaredComponentLView, 'Missing declaredComponentLView');
    if (declaredComponentLView !== insertedComponentLView) {
      declarationContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] |= 2;
    }
  }
  if (movedViews === null) {
    declarationContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.MOVED_VIEWS] = [lView];
  } else {
    movedViews.push(lView);
  }
}
class ViewRef {
  _lView;
  _cdRefInjectingView;
  _appRef = null;
  _attachedToViewContainer = false;
  exhaustive;
  get rootNodes() {
    const lView = this._lView;
    const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
    return collectNativeNodes(tView, lView, tView.firstChild, []);
  }
  constructor(_lView, _cdRefInjectingView) {
    this._lView = _lView;
    this._cdRefInjectingView = _cdRefInjectingView;
  }
  get context() {
    return this._lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT];
  }
  set context(value) {
    if (ngDevMode) {
      console.warn('Angular: Replacing the `context` object of an `EmbeddedViewRef` is deprecated.');
    }
    this._lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT] = value;
  }
  get destroyed() {
    return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isDestroyed)(this._lView);
  }
  destroy() {
    if (this._appRef) {
      this._appRef.detachView(this);
    } else if (this._attachedToViewContainer) {
      const parent = this._lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT];
      if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(parent)) {
        const viewRefs = parent[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.VIEW_REFS];
        const index = viewRefs ? viewRefs.indexOf(this) : -1;
        if (index > -1) {
          ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(index, parent.indexOf(this._lView) - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET, 'An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array.');
          detachView(parent, index);
          (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.removeFromArray)(viewRefs, index);
        }
      }
      this._attachedToViewContainer = false;
    }
    destroyLView(this._lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], this._lView);
  }
  onDestroy(callback) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.storeLViewOnDestroy)(this._lView, callback);
  }
  markForCheck() {
    markViewDirty(this._cdRefInjectingView || this._lView, 4);
  }
  detach() {
    this._lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] &= ~128;
  }
  reattach() {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.updateAncestorTraversalFlagsOnAttach)(this._lView);
    this._lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] |= 128;
  }
  detectChanges() {
    this._lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] |= 1024;
    detectChangesInternal(this._lView);
  }
  checkNoChanges() {
    if (ngDevMode) {
      try {
        this.exhaustive ??= this._lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1].get(UseExhaustiveCheckNoChanges, USE_EXHAUSTIVE_CHECK_NO_CHANGES_DEFAULT);
      } catch {
        this.exhaustive = USE_EXHAUSTIVE_CHECK_NO_CHANGES_DEFAULT;
      }
      checkNoChangesInternal(this._lView, this.exhaustive);
    }
  }
  attachToViewContainerRef() {
    if (this._appRef) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(902, ngDevMode && 'This view is already attached directly to the ApplicationRef!');
    }
    this._attachedToViewContainer = true;
  }
  detachFromAppRef() {
    this._appRef = null;
    const isRoot = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isRootView)(this._lView);
    const declarationContainer = this._lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_LCONTAINER];
    if (declarationContainer !== null && !isRoot) {
      detachMovedView(declarationContainer, this._lView);
    }
    detachViewFromDOM(this._lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], this._lView);
  }
  attachToAppRef(appRef) {
    if (this._attachedToViewContainer) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(902, ngDevMode && 'This view is already attached to a ViewContainer!');
    }
    this._appRef = appRef;
    const isRoot = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isRootView)(this._lView);
    const declarationContainer = this._lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_LCONTAINER];
    if (declarationContainer !== null && !isRoot) {
      trackMovedView(declarationContainer, this._lView);
    }
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.updateAncestorTraversalFlagsOnAttach)(this._lView);
  }
}
function isViewDirty(view) {
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.requiresRefreshOrTraversal)(view._lView) || !!(view._lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] & 64);
}
function markForRefresh(view) {
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.markViewForRefresh)(view._lView);
}
class TemplateRef {
  _declarationLView;
  _declarationTContainer;
  elementRef;
  static __NG_ELEMENT_ID__ = injectTemplateRef;
  constructor(_declarationLView, _declarationTContainer, elementRef) {
    this._declarationLView = _declarationLView;
    this._declarationTContainer = _declarationTContainer;
    this.elementRef = elementRef;
  }
  get ssrId() {
    return this._declarationTContainer.tView?.ssrId || null;
  }
  createEmbeddedView(context, injector) {
    return this.createEmbeddedViewImpl(context, injector);
  }
  createEmbeddedViewImpl(context, injector, dehydratedView) {
    const embeddedLView = createAndRenderEmbeddedLView(this._declarationLView, this._declarationTContainer, context, {
      embeddedViewInjector: injector,
      dehydratedView
    });
    return new ViewRef(embeddedLView);
  }
}
function injectTemplateRef() {
  return createTemplateRef((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)());
}
function createTemplateRef(hostTNode, hostLView) {
  if (hostTNode.type & 4) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(hostTNode.tView, 'TView must be allocated');
    return new TemplateRef(hostLView, hostTNode, createElementRef(hostTNode, hostLView));
  }
  return null;
}
const AT_THIS_LOCATION = '<-- AT THIS LOCATION';
function getFriendlyStringFromTNodeType(tNodeType) {
  switch (tNodeType) {
    case 4:
      return 'view container';
    case 2:
      return 'element';
    case 8:
      return 'ng-container';
    case 32:
      return 'icu';
    case 64:
      return 'i18n';
    case 16:
      return 'projection';
    case 1:
      return 'text';
    case 128:
      return '@let';
    default:
      return '<unknown>';
  }
}
function validateMatchingNode(node, nodeType, tagName, lView, tNode, isViewContainerAnchor = false) {
  if (!node || node.nodeType !== nodeType || node.nodeType === Node.ELEMENT_NODE && node.tagName.toLowerCase() !== tagName?.toLowerCase()) {
    const expectedNode = shortRNodeDescription(nodeType, tagName, null);
    let header = `During hydration Angular expected ${expectedNode} but `;
    const hostComponentDef = getDeclarationComponentDef(lView);
    const componentClassName = hostComponentDef?.type?.name;
    const expectedDom = describeExpectedDom(lView, tNode, isViewContainerAnchor);
    const expected = `Angular expected this DOM:\n\n${expectedDom}\n\n`;
    let actual = '';
    const componentHostElement = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST]);
    if (!node) {
      header += `the node was not found.\n\n`;
      markRNodeAsHavingHydrationMismatch(componentHostElement, expectedDom);
    } else {
      const actualNode = shortRNodeDescription(node.nodeType, node.tagName ?? null, node.textContent ?? null);
      header += `found ${actualNode}.\n\n`;
      const actualDom = describeDomFromNode(node);
      actual = `Actual DOM is:\n\n${actualDom}\n\n`;
      markRNodeAsHavingHydrationMismatch(componentHostElement, expectedDom, actualDom);
    }
    const footer = getHydrationErrorFooter(componentClassName);
    const message = header + expected + actual + getHydrationAttributeNote() + footer;
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-500, message);
  }
}
function validateSiblingNodeExists(node) {
  validateNodeExists(node);
  if (!node.nextSibling) {
    const header = 'During hydration Angular expected more sibling nodes to be present.\n\n';
    const actual = `Actual DOM is:\n\n${describeDomFromNode(node)}\n\n`;
    const footer = getHydrationErrorFooter();
    const message = header + actual + footer;
    markRNodeAsHavingHydrationMismatch(node, '', actual);
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-501, message);
  }
}
function validateNodeExists(node, lView = null, tNode = null) {
  if (!node) {
    const header = 'During hydration, Angular expected an element to be present at this location.\n\n';
    let expected = '';
    let footer = '';
    if (lView !== null && tNode !== null) {
      expected = describeExpectedDom(lView, tNode, false);
      footer = getHydrationErrorFooter();
      markRNodeAsHavingHydrationMismatch((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST]), expected, '');
    }
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-502, `${header}${expected}\n\n${footer}`);
  }
}
function nodeNotFoundError(lView, tNode) {
  const header = 'During serialization, Angular was unable to find an element in the DOM:\n\n';
  const expected = `${describeExpectedDom(lView, tNode, false)}\n\n`;
  const footer = getHydrationErrorFooter();
  throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-502, header + expected + footer);
}
function nodeNotFoundAtPathError(host, path) {
  const header = `During hydration Angular was unable to locate a node ` + `using the "${path}" path, starting from the ${describeRNode(host)} node.\n\n`;
  const footer = getHydrationErrorFooter();
  markRNodeAsHavingHydrationMismatch(host);
  throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-502, header + footer);
}
function unsupportedProjectionOfDomNodes(rNode) {
  const header = 'During serialization, Angular detected DOM nodes ' + 'that were created outside of Angular context and provided as projectable nodes ' + '(likely via `ViewContainerRef.createComponent` or `createComponent` APIs). ' + 'Hydration is not supported for such cases, consider refactoring the code to avoid ' + 'this pattern or using `ngSkipHydration` on the host element of the component.\n\n';
  const actual = `${describeDomFromNode(rNode)}\n\n`;
  const message = header + actual + getHydrationAttributeNote();
  return new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-503, message);
}
function invalidSkipHydrationHost(rNode) {
  const header = 'The `ngSkipHydration` flag is applied on a node ' + "that doesn't act as a component host. Hydration can be " + 'skipped only on per-component basis.\n\n';
  const actual = `${describeDomFromNode(rNode)}\n\n`;
  const footer = 'Please move the `ngSkipHydration` attribute to the component host element.\n\n';
  const message = header + actual + footer;
  return new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-504, message);
}
function stringifyTNodeAttrs(tNode) {
  const results = [];
  if (tNode.attrs) {
    for (let i = 0; i < tNode.attrs.length;) {
      const attrName = tNode.attrs[i++];
      if (typeof attrName == 'number') {
        break;
      }
      const attrValue = tNode.attrs[i++];
      results.push(`${attrName}="${shorten(attrValue)}"`);
    }
  }
  return results.join(' ');
}
const internalAttrs = new Set(['ngh', 'ng-version', 'ng-server-context']);
function stringifyRNodeAttrs(rNode) {
  const results = [];
  for (let i = 0; i < rNode.attributes.length; i++) {
    const attr = rNode.attributes[i];
    if (internalAttrs.has(attr.name)) continue;
    results.push(`${attr.name}="${shorten(attr.value)}"`);
  }
  return results.join(' ');
}
function describeTNode(tNode, innerContent = '…') {
  switch (tNode.type) {
    case 1:
      const content = tNode.value ? `(${tNode.value})` : '';
      return `#text${content}`;
    case 2:
      const attrs = stringifyTNodeAttrs(tNode);
      const tag = tNode.value.toLowerCase();
      return `<${tag}${attrs ? ' ' + attrs : ''}>${innerContent}</${tag}>`;
    case 8:
      return '<!-- ng-container -->';
    case 4:
      return '<!-- container -->';
    default:
      const typeAsString = getFriendlyStringFromTNodeType(tNode.type);
      return `#node(${typeAsString})`;
  }
}
function describeRNode(rNode, innerContent = '…') {
  const node = rNode;
  switch (node.nodeType) {
    case Node.ELEMENT_NODE:
      const tag = node.tagName.toLowerCase();
      const attrs = stringifyRNodeAttrs(node);
      return `<${tag}${attrs ? ' ' + attrs : ''}>${innerContent}</${tag}>`;
    case Node.TEXT_NODE:
      const content = node.textContent ? shorten(node.textContent) : '';
      return `#text${content ? `(${content})` : ''}`;
    case Node.COMMENT_NODE:
      return `<!-- ${shorten(node.textContent ?? '')} -->`;
    default:
      return `#node(${node.nodeType})`;
  }
}
function describeExpectedDom(lView, tNode, isViewContainerAnchor) {
  const spacer = '  ';
  let content = '';
  if (tNode.prev) {
    content += spacer + '…\n';
    content += spacer + describeTNode(tNode.prev) + '\n';
  } else if (tNode.type && tNode.type & 12) {
    content += spacer + '…\n';
  }
  if (isViewContainerAnchor) {
    content += spacer + describeTNode(tNode) + '\n';
    content += spacer + `<!-- container -->  ${AT_THIS_LOCATION}\n`;
  } else {
    content += spacer + describeTNode(tNode) + `  ${AT_THIS_LOCATION}\n`;
  }
  content += spacer + '…\n';
  const parentRNode = tNode.type ? getParentRElement(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, lView) : null;
  if (parentRNode) {
    content = describeRNode(parentRNode, '\n' + content);
  }
  return content;
}
function describeDomFromNode(node) {
  const spacer = '  ';
  let content = '';
  const currentNode = node;
  if (currentNode.previousSibling) {
    content += spacer + '…\n';
    content += spacer + describeRNode(currentNode.previousSibling) + '\n';
  }
  content += spacer + describeRNode(currentNode) + `  ${AT_THIS_LOCATION}\n`;
  if (node.nextSibling) {
    content += spacer + '…\n';
  }
  if (node.parentNode) {
    content = describeRNode(currentNode.parentNode, '\n' + content);
  }
  return content;
}
function shortRNodeDescription(nodeType, tagName, textContent) {
  switch (nodeType) {
    case Node.ELEMENT_NODE:
      return `<${tagName.toLowerCase()}>`;
    case Node.TEXT_NODE:
      const content = textContent ? ` (with the "${shorten(textContent)}" content)` : '';
      return `a text node${content}`;
    case Node.COMMENT_NODE:
      return 'a comment node';
    default:
      return `#node(nodeType=${nodeType})`;
  }
}
function getHydrationErrorFooter(componentClassName) {
  const componentInfo = componentClassName ? `the "${componentClassName}"` : 'corresponding';
  return `To fix this problem:\n` + `  * check ${componentInfo} component for hydration-related issues\n` + `  * check to see if your template has valid HTML structure\n` + `  * or skip hydration by adding the \`ngSkipHydration\` attribute ` + `to its host node in a template\n\n`;
}
function getHydrationAttributeNote() {
  return 'Note: attributes are only displayed to better represent the DOM' + ' but have no effect on hydration mismatches.\n\n';
}
function stripNewlines(input) {
  return input.replace(/\s+/gm, '');
}
function shorten(input, maxLength = 50) {
  if (!input) {
    return '';
  }
  input = stripNewlines(input);
  return input.length > maxLength ? `${input.substring(0, maxLength - 1)}…` : input;
}
function getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView) {
  const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;
  const insertBeforeIndex = Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;
  if (insertBeforeIndex === null) {
    return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);
  } else {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, insertBeforeIndex);
    return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[insertBeforeIndex]);
  }
}
function processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRElement) {
  const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;
  if (Array.isArray(tNodeInsertBeforeIndex)) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDomNode)(childRNode);
    let i18nParent = childRNode;
    let anchorRNode = null;
    if (!(childTNode.type & 3)) {
      anchorRNode = i18nParent;
      i18nParent = parentRElement;
    }
    if (i18nParent !== null && childTNode.componentOffset === -1) {
      for (let i = 1; i < tNodeInsertBeforeIndex.length; i++) {
        const i18nChild = lView[tNodeInsertBeforeIndex[i]];
        nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);
      }
    }
  }
}
function getOrCreateTNode(tView, index, type, name, attrs) {
  ngDevMode && index !== 0 && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertGreaterThanOrEqual)(index, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET, "TNodes can't be in the LView header.");
  ngDevMode && assertPureTNodeType(type);
  let tNode = tView.data[index];
  if (tNode === null) {
    tNode = createTNodeAtIndex(tView, index, type, name, attrs);
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isInI18nBlock)()) {
      tNode.flags |= 32;
    }
  } else if (tNode.type & 64) {
    tNode.type = type;
    tNode.value = name;
    tNode.attrs = attrs;
    const parent = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentParentTNode)();
    tNode.injectorIndex = parent === null ? -1 : parent.injectorIndex;
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForTView)(tNode, tView);
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(index, tNode.index, 'Expecting same index');
  }
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentTNode)(tNode, true);
  return tNode;
}
function createTNodeAtIndex(tView, index, type, name, attrs) {
  const currentTNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNodePlaceholderOk)();
  const isParent = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isCurrentTNodeParent)();
  const parent = isParent ? currentTNode : currentTNode && currentTNode.parent;
  const tNode = tView.data[index] = createTNode(tView, parent, type, index, name, attrs);
  linkTNodeInTView(tView, tNode, currentTNode, isParent);
  return tNode;
}
function linkTNodeInTView(tView, tNode, currentTNode, isParent) {
  if (tView.firstChild === null) {
    tView.firstChild = tNode;
  }
  if (currentTNode !== null) {
    if (isParent) {
      if (currentTNode.child == null && tNode.parent !== null) {
        currentTNode.child = tNode;
      }
    } else {
      if (currentTNode.next === null) {
        currentTNode.next = tNode;
        tNode.prev = currentTNode;
      }
    }
  }
}
function createTNode(tView, tParent, type, index, value, attrs) {
  ngDevMode && index !== 0 && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertGreaterThanOrEqual)(index, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET, "TNodes can't be in the LView header.");
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotSame)(attrs, undefined, "'undefined' is not valid value for 'attrs'");
  ngDevMode && tParent && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForTView)(tParent, tView);
  let injectorIndex = tParent ? tParent.injectorIndex : -1;
  let flags = 0;
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isInSkipHydrationBlock)()) {
    flags |= 128;
  }
  const tNode = {
    type,
    index,
    insertBeforeIndex: null,
    injectorIndex,
    directiveStart: -1,
    directiveEnd: -1,
    directiveStylingLast: -1,
    componentOffset: -1,
    fieldIndex: -1,
    customControlIndex: -1,
    propertyBindings: null,
    flags,
    providerIndexes: 0,
    value: value,
    attrs: attrs,
    mergedAttrs: null,
    localNames: null,
    initialInputs: null,
    inputs: null,
    hostDirectiveInputs: null,
    outputs: null,
    hostDirectiveOutputs: null,
    directiveToIndex: null,
    tView: null,
    next: null,
    prev: null,
    projectionNext: null,
    child: null,
    parent: tParent,
    projection: null,
    styles: null,
    stylesWithoutHost: null,
    residualStyles: undefined,
    classes: null,
    classesWithoutHost: null,
    residualClasses: undefined,
    classBindings: 0,
    styleBindings: 0
  };
  if (ngDevMode) {
    Object.seal(tNode);
  }
  return tNode;
}
function addTNodeAndUpdateInsertBeforeIndex(previousTNodes, newTNode) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(newTNode.insertBeforeIndex, null, 'We expect that insertBeforeIndex is not set');
  previousTNodes.push(newTNode);
  if (previousTNodes.length > 1) {
    for (let i = previousTNodes.length - 2; i >= 0; i--) {
      const existingTNode = previousTNodes[i];
      if (!isI18nText(existingTNode)) {
        if (isNewTNodeCreatedBefore(existingTNode, newTNode) && getInsertBeforeIndex(existingTNode) === null) {
          setInsertBeforeIndex(existingTNode, newTNode.index);
        }
      }
    }
  }
}
function isI18nText(tNode) {
  return !(tNode.type & 64);
}
function isNewTNodeCreatedBefore(existingTNode, newTNode) {
  return isI18nText(newTNode) || existingTNode.index > newTNode.index;
}
function getInsertBeforeIndex(tNode) {
  const index = tNode.insertBeforeIndex;
  return Array.isArray(index) ? index[0] : index;
}
function setInsertBeforeIndex(tNode, value) {
  const index = tNode.insertBeforeIndex;
  if (Array.isArray(index)) {
    index[0] = value;
  } else {
    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
    tNode.insertBeforeIndex = value;
  }
}
function getTIcu(tView, index) {
  const value = tView.data[index];
  if (value === null || typeof value === 'string') return null;
  if (ngDevMode && !(value.hasOwnProperty('tView') || value.hasOwnProperty('currentCaseLViewIndex'))) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)("We expect to get 'null'|'TIcu'|'TIcuContainer', but got: " + value);
  }
  const tIcu = value.hasOwnProperty('currentCaseLViewIndex') ? value : value.value;
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTIcu)(tIcu);
  return tIcu;
}
function setTIcu(tView, index, tIcu) {
  const tNode = tView.data[index];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(tNode === null || tNode.hasOwnProperty('tView'), true, "We expect to get 'null'|'TIcuContainer'");
  if (tNode === null) {
    tView.data[index] = tIcu;
  } else {
    ngDevMode && assertTNodeType(tNode, 32);
    tNode.value = tIcu;
  }
}
function setTNodeInsertBeforeIndex(tNode, index) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNode)(tNode);
  let insertBeforeIndex = tNode.insertBeforeIndex;
  if (insertBeforeIndex === null) {
    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
    insertBeforeIndex = tNode.insertBeforeIndex = [null, index];
  } else {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(Array.isArray(insertBeforeIndex), true, 'Expecting array here');
    insertBeforeIndex.push(index);
  }
}
function createTNodePlaceholder(tView, previousTNodes, index) {
  const tNode = createTNodeAtIndex(tView, index, 64, null, null);
  addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);
  return tNode;
}
function getCurrentICUCaseIndex(tIcu, lView) {
  const currentCase = lView[tIcu.currentCaseLViewIndex];
  return currentCase === null ? currentCase : currentCase < 0 ? ~currentCase : currentCase;
}
function getParentFromIcuCreateOpCode(mergedCode) {
  return mergedCode >>> 17;
}
function getRefFromIcuCreateOpCode(mergedCode) {
  return (mergedCode & 131070) >>> 1;
}
function getInstructionFromIcuCreateOpCode(mergedCode) {
  return mergedCode & 1;
}
function icuCreateOpCode(opCode, parentIdx, refIdx) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertGreaterThanOrEqual)(parentIdx, 0, 'Missing parent index');
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertGreaterThan)(refIdx, 0, 'Missing ref index');
  return opCode | parentIdx << 17 | refIdx << 1;
}
function isRootTemplateMessage(subTemplateIndex) {
  return subTemplateIndex === -1;
}
function enterIcu(state, tIcu, lView) {
  state.index = 0;
  const currentCase = getCurrentICUCaseIndex(tIcu, lView);
  if (currentCase !== null) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumberInRange)(currentCase, 0, tIcu.cases.length - 1);
    state.removes = tIcu.remove[currentCase];
  } else {
    state.removes = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY;
  }
}
function icuContainerIteratorNext(state) {
  if (state.index < state.removes.length) {
    const removeOpCode = state.removes[state.index++];
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(removeOpCode, 'Expecting OpCode number');
    if (removeOpCode > 0) {
      const rNode = state.lView[removeOpCode];
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDomNode)(rNode);
      return rNode;
    } else {
      state.stack.push(state.index, state.removes);
      const tIcuIndex = ~removeOpCode;
      const tIcu = state.lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data[tIcuIndex];
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTIcu)(tIcu);
      enterIcu(state, tIcu, state.lView);
      return icuContainerIteratorNext(state);
    }
  } else {
    if (state.stack.length === 0) {
      state.lView = undefined;
      return null;
    } else {
      state.removes = state.stack.pop();
      state.index = state.stack.pop();
      return icuContainerIteratorNext(state);
    }
  }
}
function loadIcuContainerVisitor() {
  const _state = {
    stack: [],
    index: -1
  };
  function icuContainerIteratorStart(tIcuContainerNode, lView) {
    _state.lView = lView;
    while (_state.stack.length) _state.stack.pop();
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForLView)(tIcuContainerNode, lView);
    enterIcu(_state, tIcuContainerNode.value, lView);
    return icuContainerIteratorNext.bind(null, _state);
  }
  return icuContainerIteratorStart;
}
function createIcuIterator(tIcu, lView) {
  const state = {
    stack: [],
    index: -1,
    lView
  };
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTIcu)(tIcu);
  enterIcu(state, tIcu, lView);
  return icuContainerIteratorNext.bind(null, state);
}
const REF_EXTRACTOR_REGEXP = /* @__PURE__ */(() => {
  return new RegExp(`^(\\d+)*(${REFERENCE_NODE_BODY}|${REFERENCE_NODE_HOST})*(.*)`);
})();
function compressNodeLocation(referenceNode, path) {
  const result = [referenceNode];
  for (const segment of path) {
    const lastIdx = result.length - 1;
    if (lastIdx > 0 && result[lastIdx - 1] === segment) {
      const value = result[lastIdx] || 1;
      result[lastIdx] = value + 1;
    } else {
      result.push(segment, '');
    }
  }
  return result.join('');
}
function decompressNodeLocation(path) {
  const matches = path.match(REF_EXTRACTOR_REGEXP);
  const [_, refNodeId, refNodeName, rest] = matches;
  const ref = refNodeId ? parseInt(refNodeId, 10) : refNodeName;
  const steps = [];
  for (const [_, step, count] of rest.matchAll(/(f|n)(\d*)/g)) {
    const repeat = parseInt(count, 10) || 1;
    steps.push(step, repeat);
  }
  return [ref, ...steps];
}
function isFirstElementInNgContainer(tNode) {
  return !tNode.prev && tNode.parent?.type === 8;
}
function getNoOffsetIndex(tNode) {
  return tNode.index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
}
function isDisconnectedNode(tNode, lView) {
  return !(tNode.type & (16 | 128)) && !!lView[tNode.index] && isDisconnectedRNode((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[tNode.index]));
}
function isDisconnectedRNode(rNode) {
  return !!rNode && !rNode.isConnected;
}
function locateI18nRNodeByIndex(hydrationInfo, noOffsetIndex) {
  const i18nNodes = hydrationInfo.i18nNodes;
  if (i18nNodes) {
    return i18nNodes.get(noOffsetIndex);
  }
  return undefined;
}
function tryLocateRNodeByPath(hydrationInfo, lView, noOffsetIndex) {
  const nodes = hydrationInfo.data[NODES];
  const path = nodes?.[noOffsetIndex];
  return path ? locateRNodeByPath(path, lView) : null;
}
function locateNextRNode(hydrationInfo, tView, lView, tNode) {
  const noOffsetIndex = getNoOffsetIndex(tNode);
  let native = locateI18nRNodeByIndex(hydrationInfo, noOffsetIndex);
  if (native === undefined) {
    const nodes = hydrationInfo.data[NODES];
    if (nodes?.[noOffsetIndex]) {
      native = locateRNodeByPath(nodes[noOffsetIndex], lView);
    } else if (tView.firstChild === tNode) {
      native = hydrationInfo.firstChild;
    } else {
      const previousTNodeParent = tNode.prev === null;
      const previousTNode = tNode.prev ?? tNode.parent;
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(previousTNode, 'Unexpected state: current TNode does not have a connection ' + 'to the previous node or a parent node.');
      if (isFirstElementInNgContainer(tNode)) {
        const noOffsetParentIndex = getNoOffsetIndex(tNode.parent);
        native = getSegmentHead(hydrationInfo, noOffsetParentIndex);
      } else {
        let previousRElement = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(previousTNode, lView);
        if (previousTNodeParent) {
          native = previousRElement.firstChild;
        } else {
          const noOffsetPrevSiblingIndex = getNoOffsetIndex(previousTNode);
          const segmentHead = getSegmentHead(hydrationInfo, noOffsetPrevSiblingIndex);
          if (previousTNode.type === 2 && segmentHead) {
            const numRootNodesToSkip = calcSerializedContainerSize(hydrationInfo, noOffsetPrevSiblingIndex);
            const nodesToSkip = numRootNodesToSkip + 1;
            native = siblingAfter(nodesToSkip, segmentHead);
          } else {
            native = previousRElement.nextSibling;
          }
        }
      }
    }
  }
  return native;
}
function siblingAfter(skip, from) {
  let currentNode = from;
  for (let i = 0; i < skip; i++) {
    ngDevMode && validateSiblingNodeExists(currentNode);
    currentNode = currentNode.nextSibling;
  }
  return currentNode;
}
function stringifyNavigationInstructions(instructions) {
  const container = [];
  for (let i = 0; i < instructions.length; i += 2) {
    const step = instructions[i];
    const repeat = instructions[i + 1];
    for (let r = 0; r < repeat; r++) {
      container.push(step === NODE_NAVIGATION_STEP_FIRST_CHILD ? 'firstChild' : 'nextSibling');
    }
  }
  return container.join('.');
}
function navigateToNode(from, instructions) {
  let node = from;
  for (let i = 0; i < instructions.length; i += 2) {
    const step = instructions[i];
    const repeat = instructions[i + 1];
    for (let r = 0; r < repeat; r++) {
      if (ngDevMode && !node) {
        throw nodeNotFoundAtPathError(from, stringifyNavigationInstructions(instructions));
      }
      switch (step) {
        case NODE_NAVIGATION_STEP_FIRST_CHILD:
          node = node.firstChild;
          break;
        case NODE_NAVIGATION_STEP_NEXT_SIBLING:
          node = node.nextSibling;
          break;
      }
    }
  }
  if (ngDevMode && !node) {
    throw nodeNotFoundAtPathError(from, stringifyNavigationInstructions(instructions));
  }
  return node;
}
function locateRNodeByPath(path, lView) {
  const [referenceNode, ...navigationInstructions] = decompressNodeLocation(path);
  let ref;
  if (referenceNode === REFERENCE_NODE_HOST) {
    ref = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST];
  } else if (referenceNode === REFERENCE_NODE_BODY) {
    ref = ɵɵresolveBody(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST]);
  } else {
    const parentElementId = Number(referenceNode);
    ref = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[parentElementId + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET]);
  }
  return navigateToNode(ref, navigationInstructions);
}
function navigateBetween(start, finish) {
  if (start === finish) {
    return [];
  } else if (start.parentElement == null || finish.parentElement == null) {
    return null;
  } else if (start.parentElement === finish.parentElement) {
    return navigateBetweenSiblings(start, finish);
  } else {
    const parent = finish.parentElement;
    const parentPath = navigateBetween(start, parent);
    const childPath = navigateBetween(parent.firstChild, finish);
    if (!parentPath || !childPath) return null;
    return [...parentPath, NODE_NAVIGATION_STEP_FIRST_CHILD, ...childPath];
  }
}
function navigateBetweenSiblings(start, finish) {
  const nav = [];
  let node = null;
  for (node = start; node != null && node !== finish; node = node.nextSibling) {
    nav.push(NODE_NAVIGATION_STEP_NEXT_SIBLING);
  }
  return node == null ? null : nav;
}
function calcPathBetween(from, to, fromNodeName) {
  const path = navigateBetween(from, to);
  return path === null ? null : compressNodeLocation(fromNodeName, path);
}
function calcPathForNode(tNode, lView, excludedParentNodes) {
  let parentTNode = tNode.parent;
  let parentIndex;
  let parentRNode;
  let referenceNodeName;
  while (parentTNode !== null && (isDisconnectedNode(parentTNode, lView) || excludedParentNodes?.has(parentTNode.index))) {
    parentTNode = parentTNode.parent;
  }
  if (parentTNode === null || !(parentTNode.type & 3)) {
    parentIndex = referenceNodeName = REFERENCE_NODE_HOST;
    parentRNode = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST];
  } else {
    parentIndex = parentTNode.index;
    parentRNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[parentIndex]);
    referenceNodeName = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(parentIndex - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET);
  }
  let rNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[tNode.index]);
  if (tNode.type & (12 | 32)) {
    const firstRNode = getFirstNativeNode(lView, tNode);
    if (firstRNode) {
      rNode = firstRNode;
    }
  }
  let path = calcPathBetween(parentRNode, rNode, referenceNodeName);
  if (path === null && parentRNode !== rNode) {
    const body = parentRNode.ownerDocument.body;
    path = calcPathBetween(body, rNode, REFERENCE_NODE_BODY);
    if (path === null) {
      throw nodeNotFoundError(lView, tNode);
    }
  }
  return path;
}
function gatherDeferBlocksCommentNodes(doc, node) {
  const commentNodesIterator = doc.createNodeIterator(node, NodeFilter.SHOW_COMMENT, {
    acceptNode
  });
  let currentNode;
  const nodesByBlockId = new Map();
  while (currentNode = commentNodesIterator.nextNode()) {
    const nghPattern = 'ngh=';
    const content = currentNode?.textContent;
    const nghIdx = content?.indexOf(nghPattern) ?? -1;
    if (nghIdx > -1) {
      const nghValue = content.substring(nghIdx + nghPattern.length).trim();
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(nghValue.startsWith('d'), true, 'Invalid defer block id found in a comment node.');
      nodesByBlockId.set(nghValue, currentNode);
    }
  }
  return nodesByBlockId;
}
function acceptNode(node) {
  return node.textContent?.trimStart().startsWith('ngh=') ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
}
let _isI18nHydrationSupportEnabled = false;
let _prepareI18nBlockForHydrationImpl = () => {};
function setIsI18nHydrationSupportEnabled(enabled) {
  _isI18nHydrationSupportEnabled = enabled;
}
function isI18nHydrationSupportEnabled() {
  return _isI18nHydrationSupportEnabled;
}
function prepareI18nBlockForHydration(lView, index, parentTNode, subTemplateIndex) {
  _prepareI18nBlockForHydrationImpl(lView, index, parentTNode, subTemplateIndex);
}
function enablePrepareI18nBlockForHydrationImpl() {
  _prepareI18nBlockForHydrationImpl = prepareI18nBlockForHydrationImpl;
}
function isI18nHydrationEnabled(injector) {
  injector = injector ?? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.Injector);
  return injector.get(IS_I18N_HYDRATION_ENABLED, false);
}
function getOrComputeI18nChildren(tView, context) {
  let i18nChildren = context.i18nChildren.get(tView);
  if (i18nChildren === undefined) {
    i18nChildren = collectI18nChildren(tView);
    context.i18nChildren.set(tView, i18nChildren);
  }
  return i18nChildren;
}
function collectI18nChildren(tView) {
  const children = new Set();
  function collectI18nViews(node) {
    children.add(node.index);
    switch (node.kind) {
      case 1:
      case 2:
        {
          for (const childNode of node.children) {
            collectI18nViews(childNode);
          }
          break;
        }
      case 3:
        {
          for (const caseNodes of node.cases) {
            for (const caseNode of caseNodes) {
              collectI18nViews(caseNode);
            }
          }
          break;
        }
    }
  }
  for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    const tI18n = tView.data[i];
    if (!tI18n || !tI18n.ast) {
      continue;
    }
    for (const node of tI18n.ast) {
      collectI18nViews(node);
    }
  }
  return children.size === 0 ? null : children;
}
function trySerializeI18nBlock(lView, index, context) {
  if (!context.isI18nHydrationEnabled) {
    return null;
  }
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const tI18n = tView.data[index];
  if (!tI18n || !tI18n.ast) {
    return null;
  }
  const parentTNode = tView.data[tI18n.parentTNodeIndex];
  if (parentTNode && isI18nInSkipHydrationBlock(parentTNode)) {
    return null;
  }
  const serializedI18nBlock = {
    caseQueue: [],
    disconnectedNodes: new Set(),
    disjointNodes: new Set()
  };
  serializeI18nBlock(lView, serializedI18nBlock, context, tI18n.ast);
  return serializedI18nBlock.caseQueue.length === 0 && serializedI18nBlock.disconnectedNodes.size === 0 && serializedI18nBlock.disjointNodes.size === 0 ? null : serializedI18nBlock;
}
function serializeI18nBlock(lView, serializedI18nBlock, context, nodes) {
  let prevRNode = null;
  for (const node of nodes) {
    const nextRNode = serializeI18nNode(lView, serializedI18nBlock, context, node);
    if (nextRNode) {
      if (isDisjointNode(prevRNode, nextRNode)) {
        serializedI18nBlock.disjointNodes.add(node.index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET);
      }
      prevRNode = nextRNode;
    }
  }
  return prevRNode;
}
function isDisjointNode(prevNode, nextNode) {
  return prevNode && prevNode.nextSibling !== nextNode;
}
function serializeI18nNode(lView, serializedI18nBlock, context, node) {
  const maybeRNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[node.index]);
  if (!maybeRNode || isDisconnectedRNode(maybeRNode)) {
    serializedI18nBlock.disconnectedNodes.add(node.index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET);
    return null;
  }
  const rNode = maybeRNode;
  switch (node.kind) {
    case 0:
      {
        processTextNodeBeforeSerialization(context, rNode);
        break;
      }
    case 1:
    case 2:
      {
        serializeI18nBlock(lView, serializedI18nBlock, context, node.children);
        break;
      }
    case 3:
      {
        const currentCase = lView[node.currentCaseLViewIndex];
        if (currentCase != null) {
          const caseIdx = currentCase < 0 ? ~currentCase : currentCase;
          serializedI18nBlock.caseQueue.push(caseIdx);
          serializeI18nBlock(lView, serializedI18nBlock, context, node.cases[caseIdx]);
        }
        break;
      }
  }
  return getFirstNativeNodeForI18nNode(lView, node);
}
function getFirstNativeNodeForI18nNode(lView, node) {
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const maybeTNode = tView.data[node.index];
  if (isTNodeShape(maybeTNode)) {
    return getFirstNativeNode(lView, maybeTNode);
  } else if (node.kind === 3) {
    const icuIterator = createIcuIterator(maybeTNode, lView);
    let rNode = icuIterator();
    return rNode ?? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[node.index]);
  } else {
    return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[node.index]) ?? null;
  }
}
function setCurrentNode(state, node) {
  state.currentNode = node;
}
function appendI18nNodeToCollection(context, state, astNode) {
  const noOffsetIndex = astNode.index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const {
    disconnectedNodes
  } = context;
  const currentNode = state.currentNode;
  if (state.isConnected) {
    context.i18nNodes.set(noOffsetIndex, currentNode);
    disconnectedNodes.delete(noOffsetIndex);
  } else {
    disconnectedNodes.add(noOffsetIndex);
  }
  return currentNode;
}
function skipSiblingNodes(state, skip) {
  let currentNode = state.currentNode;
  for (let i = 0; i < skip; i++) {
    if (!currentNode) {
      break;
    }
    currentNode = currentNode?.nextSibling ?? null;
  }
  return currentNode;
}
function forkHydrationState(state, nextNode) {
  return {
    currentNode: nextNode,
    isConnected: state.isConnected
  };
}
function prepareI18nBlockForHydrationImpl(lView, index, parentTNode, subTemplateIndex) {
  const hydrationInfo = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION];
  if (!hydrationInfo) {
    return;
  }
  if (!isI18nHydrationSupportEnabled() || parentTNode && (isI18nInSkipHydrationBlock(parentTNode) || isDisconnectedNode$1(hydrationInfo, parentTNode.index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET))) {
    return;
  }
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const tI18n = tView.data[index];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(tI18n, 'Expected i18n data to be present in a given TView slot during hydration');
  function findHydrationRoot() {
    if (isRootTemplateMessage(subTemplateIndex)) {
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(parentTNode, 'Expected parent TNode while hydrating i18n root');
      const rootNode = locateNextRNode(hydrationInfo, tView, lView, parentTNode);
      return parentTNode.type & 8 ? rootNode : rootNode.firstChild;
    }
    return hydrationInfo?.firstChild;
  }
  const currentNode = findHydrationRoot();
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(currentNode, 'Expected root i18n node during hydration');
  const disconnectedNodes = initDisconnectedNodes(hydrationInfo) ?? new Set();
  const i18nNodes = hydrationInfo.i18nNodes ??= new Map();
  const caseQueue = hydrationInfo.data[I18N_DATA]?.[index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET] ?? [];
  const dehydratedIcuData = hydrationInfo.dehydratedIcuData ??= new Map();
  collectI18nNodesFromDom({
    hydrationInfo,
    lView,
    i18nNodes,
    disconnectedNodes,
    caseQueue,
    dehydratedIcuData
  }, {
    currentNode,
    isConnected: true
  }, tI18n.ast);
  hydrationInfo.disconnectedNodes = disconnectedNodes.size === 0 ? null : disconnectedNodes;
}
function collectI18nNodesFromDom(context, state, nodeOrNodes) {
  if (Array.isArray(nodeOrNodes)) {
    let nextState = state;
    for (const node of nodeOrNodes) {
      const targetNode = tryLocateRNodeByPath(context.hydrationInfo, context.lView, node.index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET);
      if (targetNode) {
        nextState = forkHydrationState(state, targetNode);
      }
      collectI18nNodesFromDom(context, nextState, node);
    }
  } else {
    if (context.disconnectedNodes.has(nodeOrNodes.index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET)) {
      return;
    }
    switch (nodeOrNodes.kind) {
      case 0:
        {
          const currentNode = appendI18nNodeToCollection(context, state, nodeOrNodes);
          setCurrentNode(state, currentNode?.nextSibling ?? null);
          break;
        }
      case 1:
        {
          collectI18nNodesFromDom(context, forkHydrationState(state, state.currentNode?.firstChild ?? null), nodeOrNodes.children);
          const currentNode = appendI18nNodeToCollection(context, state, nodeOrNodes);
          setCurrentNode(state, currentNode?.nextSibling ?? null);
          break;
        }
      case 2:
        {
          const noOffsetIndex = nodeOrNodes.index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
          const {
            hydrationInfo
          } = context;
          const containerSize = getNgContainerSize(hydrationInfo, noOffsetIndex);
          switch (nodeOrNodes.type) {
            case 0:
              {
                const currentNode = appendI18nNodeToCollection(context, state, nodeOrNodes);
                if (isSerializedElementContainer(hydrationInfo, noOffsetIndex)) {
                  collectI18nNodesFromDom(context, state, nodeOrNodes.children);
                  const nextNode = skipSiblingNodes(state, 1);
                  setCurrentNode(state, nextNode);
                } else {
                  collectI18nNodesFromDom(context, forkHydrationState(state, state.currentNode?.firstChild ?? null), nodeOrNodes.children);
                  setCurrentNode(state, currentNode?.nextSibling ?? null);
                  if (containerSize !== null) {
                    const nextNode = skipSiblingNodes(state, containerSize + 1);
                    setCurrentNode(state, nextNode);
                  }
                }
                break;
              }
            case 1:
              {
                ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotEqual)(containerSize, null, 'Expected a container size while hydrating i18n subtemplate');
                appendI18nNodeToCollection(context, state, nodeOrNodes);
                const nextNode = skipSiblingNodes(state, containerSize + 1);
                setCurrentNode(state, nextNode);
                break;
              }
          }
          break;
        }
      case 3:
        {
          const selectedCase = state.isConnected ? context.caseQueue.shift() : null;
          const childState = {
            currentNode: null,
            isConnected: false
          };
          for (let i = 0; i < nodeOrNodes.cases.length; i++) {
            collectI18nNodesFromDom(context, i === selectedCase ? state : childState, nodeOrNodes.cases[i]);
          }
          if (selectedCase !== null) {
            context.dehydratedIcuData.set(nodeOrNodes.index, {
              case: selectedCase,
              node: nodeOrNodes
            });
          }
          const currentNode = appendI18nNodeToCollection(context, state, nodeOrNodes);
          setCurrentNode(state, currentNode?.nextSibling ?? null);
          break;
        }
    }
  }
}
let _claimDehydratedIcuCaseImpl = () => {};
function claimDehydratedIcuCase(lView, icuIndex, caseIndex) {
  _claimDehydratedIcuCaseImpl(lView, icuIndex, caseIndex);
}
function enableClaimDehydratedIcuCaseImpl() {
  _claimDehydratedIcuCaseImpl = claimDehydratedIcuCaseImpl;
}
function claimDehydratedIcuCaseImpl(lView, icuIndex, caseIndex) {
  const dehydratedIcuDataMap = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION]?.dehydratedIcuData;
  if (dehydratedIcuDataMap) {
    const dehydratedIcuData = dehydratedIcuDataMap.get(icuIndex);
    if (dehydratedIcuData?.case === caseIndex) {
      dehydratedIcuDataMap.delete(icuIndex);
    }
  }
}
function cleanupI18nHydrationData(lView) {
  const hydrationInfo = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION];
  if (hydrationInfo) {
    const {
      i18nNodes,
      dehydratedIcuData: dehydratedIcuDataMap
    } = hydrationInfo;
    if (i18nNodes && dehydratedIcuDataMap) {
      const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
      for (const dehydratedIcuData of dehydratedIcuDataMap.values()) {
        cleanupDehydratedIcuData(renderer, i18nNodes, dehydratedIcuData);
      }
    }
    hydrationInfo.i18nNodes = undefined;
    hydrationInfo.dehydratedIcuData = undefined;
  }
}
function cleanupDehydratedIcuData(renderer, i18nNodes, dehydratedIcuData) {
  for (const node of dehydratedIcuData.node.cases[dehydratedIcuData.case]) {
    const rNode = i18nNodes.get(node.index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET);
    if (rNode) {
      nativeRemoveNode(renderer, rNode, false);
    }
  }
}
function removeDehydratedViews(lContainer) {
  const views = lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DEHYDRATED_VIEWS] ?? [];
  const parentLView = lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT];
  const renderer = parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  const retainedViews = [];
  for (const view of views) {
    if (view.data[DEFER_BLOCK_ID] !== undefined) {
      retainedViews.push(view);
    } else {
      removeDehydratedView(view, renderer);
      ngDevMode && ngDevMode.dehydratedViewsRemoved++;
    }
  }
  lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DEHYDRATED_VIEWS] = retainedViews;
}
function removeDehydratedViewList(deferBlock) {
  const {
    lContainer
  } = deferBlock;
  const dehydratedViews = lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DEHYDRATED_VIEWS];
  if (dehydratedViews === null) return;
  const parentLView = lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT];
  const renderer = parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  for (const view of dehydratedViews) {
    removeDehydratedView(view, renderer);
    ngDevMode && ngDevMode.dehydratedViewsRemoved++;
  }
}
function removeDehydratedView(dehydratedView, renderer) {
  let nodesRemoved = 0;
  let currentRNode = dehydratedView.firstChild;
  if (currentRNode) {
    const numNodes = dehydratedView.data[NUM_ROOT_NODES];
    while (nodesRemoved < numNodes) {
      ngDevMode && validateSiblingNodeExists(currentRNode);
      const nextSibling = currentRNode.nextSibling;
      nativeRemoveNode(renderer, currentRNode, false);
      currentRNode = nextSibling;
      nodesRemoved++;
    }
  }
}
function cleanupLContainer(lContainer) {
  removeDehydratedViews(lContainer);
  const hostLView = lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST];
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(hostLView)) {
    cleanupLView(hostLView);
  }
  for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    cleanupLView(lContainer[i]);
  }
}
function cleanupLView(lView) {
  cleanupI18nHydrationData(lView);
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(lView[i])) {
      const lContainer = lView[i];
      cleanupLContainer(lContainer);
    } else if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(lView[i])) {
      cleanupLView(lView[i]);
    }
  }
}
function cleanupDehydratedViews(appRef) {
  const viewRefs = appRef._views;
  for (const viewRef of viewRefs) {
    const lNode = getLNodeForHydration(viewRef);
    if (lNode !== null && lNode[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST] !== null) {
      if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(lNode)) {
        cleanupLView(lNode);
      } else {
        cleanupLContainer(lNode);
      }
      ngDevMode && ngDevMode.dehydratedViewsCleanupRuns++;
    }
  }
}
function cleanupHydratedDeferBlocks(deferBlock, hydratedBlocks, registry, appRef) {
  if (deferBlock !== null) {
    registry.cleanup(hydratedBlocks);
    cleanupLContainer(deferBlock.lContainer);
    cleanupDehydratedViews(appRef);
  }
}
function locateDehydratedViewsInContainer(currentRNode, serializedViews) {
  const dehydratedViews = [];
  for (const serializedView of serializedViews) {
    for (let i = 0; i < (serializedView[MULTIPLIER] ?? 1); i++) {
      const view = {
        data: serializedView,
        firstChild: null
      };
      if (serializedView[NUM_ROOT_NODES] > 0) {
        view.firstChild = currentRNode;
        currentRNode = siblingAfter(serializedView[NUM_ROOT_NODES], currentRNode);
      }
      dehydratedViews.push(view);
    }
  }
  return [currentRNode, dehydratedViews];
}
let _findMatchingDehydratedViewImpl = () => null;
let _findAndReconcileMatchingDehydratedViewsImpl = () => null;
function enableFindMatchingDehydratedViewImpl() {
  _findMatchingDehydratedViewImpl = findMatchingDehydratedViewImpl;
  _findAndReconcileMatchingDehydratedViewsImpl = findAndReconcileMatchingDehydratedViewsImpl;
}
function findMatchingDehydratedViewImpl(lContainer, template) {
  if (hasMatchingDehydratedView(lContainer, template)) {
    return lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DEHYDRATED_VIEWS].shift();
  } else {
    removeDehydratedViews(lContainer);
    return null;
  }
}
function findMatchingDehydratedView(lContainer, template) {
  return _findMatchingDehydratedViewImpl(lContainer, template);
}
function findAndReconcileMatchingDehydratedViewsImpl(lContainer, templateTNode, hostLView) {
  if (templateTNode.tView.ssrId === null) return null;
  const dehydratedView = findMatchingDehydratedView(lContainer, templateTNode.tView.ssrId);
  if (hostLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].firstUpdatePass && dehydratedView === null) {
    removeStaleDehydratedBranch(hostLView, templateTNode);
  }
  return dehydratedView;
}
function findAndReconcileMatchingDehydratedViews(lContainer, templateTNode, hostLView) {
  return _findAndReconcileMatchingDehydratedViewsImpl(lContainer, templateTNode, hostLView);
}
function removeStaleDehydratedBranch(hostLView, tNode) {
  let currentTNode = tNode;
  while (currentTNode) {
    if (cleanupMatchingDehydratedViews(hostLView, currentTNode)) return;
    if ((currentTNode.flags & 256) === 256) {
      break;
    }
    currentTNode = currentTNode.prev;
  }
  currentTNode = tNode.next;
  while (currentTNode) {
    if ((currentTNode.flags & 512) !== 512) {
      break;
    }
    if (cleanupMatchingDehydratedViews(hostLView, currentTNode)) return;
    currentTNode = currentTNode.next;
  }
}
function hasMatchingDehydratedView(lContainer, template) {
  const views = lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DEHYDRATED_VIEWS];
  if (!template || views === null || views.length === 0) {
    return false;
  }
  return views[0].data[TEMPLATE_ID] === template;
}
function cleanupMatchingDehydratedViews(hostLView, currentTNode) {
  const ssrId = currentTNode.tView?.ssrId;
  if (ssrId == null) return false;
  const container = hostLView[currentTNode.index];
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(container) && hasMatchingDehydratedView(container, ssrId)) {
    removeDehydratedViews(container);
    return true;
  }
  return false;
}
let ComponentRef$1 = class ComponentRef {};
let ComponentFactory$1 = class ComponentFactory {};
class _NullComponentFactoryResolver {
  resolveComponentFactory(component) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(917, typeof ngDevMode !== 'undefined' && ngDevMode && `No component factory found for ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringify)(component)}.`);
  }
}
let ComponentFactoryResolver$1 = class ComponentFactoryResolver {
  static NULL = new _NullComponentFactoryResolver();
};
class RendererFactory2 {}
class Renderer2 {
  destroyNode = null;
  static __NG_ELEMENT_ID__ = () => injectRenderer2();
}
function injectRenderer2() {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  const nodeAtIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(tNode.index, lView);
  return ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(nodeAtIndex) ? nodeAtIndex : lView)[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
}
class Sanitizer {
  static ɵprov = /* @__PURE__ */
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
    token: Sanitizer,
    providedIn: 'root',
    factory: () => null
  });
}
function isModuleWithProviders(value) {
  return value.ngModule !== undefined;
}
function isNgModule(value) {
  return !!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNgModuleDef)(value);
}
function isPipe(value) {
  return !!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getPipeDef)(value);
}
function isDirective(value) {
  return !!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(value);
}
function isComponent(value) {
  return !!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(value);
}
function getDependencyTypeForError(type) {
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type)) return 'component';
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(type)) return 'directive';
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getPipeDef)(type)) return 'pipe';
  return 'type';
}
function verifyStandaloneImport(depType, importingType) {
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isForwardRef)(depType)) {
    depType = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(depType);
    if (!depType) {
      throw new Error(`Expected forwardRef function, imported from "${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(importingType)}", to return a standalone entity or NgModule but got "${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(depType) || depType}".`);
    }
  }
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNgModuleDef)(depType) == null) {
    const def = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(depType) || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(depType) || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getPipeDef)(depType);
    if (def != null) {
      if (!def.standalone) {
        const type = getDependencyTypeForError(depType);
        throw new Error(`The "${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(depType)}" ${type}, imported from "${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(importingType)}", is not standalone. Does the ${type} have the standalone: false flag?`);
      }
    } else {
      if (isModuleWithProviders(depType)) {
        throw new Error(`A module with providers was imported from "${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(importingType)}". Modules with providers are not supported in standalone components imports.`);
      } else {
        throw new Error(`The "${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(depType)}" type, imported from "${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(importingType)}", must be a standalone component / directive / pipe or an NgModule. Did you forget to add the required @Component / @Directive / @Pipe or @NgModule annotation?`);
      }
    }
  }
}
class DepsTracker {
  ownerNgModule = new Map();
  ngModulesWithSomeUnresolvedDecls = new Set();
  ngModulesScopeCache = new Map();
  standaloneComponentsScopeCache = new Map();
  resolveNgModulesDecls() {
    if (this.ngModulesWithSomeUnresolvedDecls.size === 0) {
      return;
    }
    for (const moduleType of this.ngModulesWithSomeUnresolvedDecls) {
      const def = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNgModuleDef)(moduleType);
      if (def?.declarations) {
        for (const decl of maybeUnwrapFn(def.declarations)) {
          if (isComponent(decl)) {
            this.ownerNgModule.set(decl, moduleType);
          }
        }
      }
    }
    this.ngModulesWithSomeUnresolvedDecls.clear();
  }
  getComponentDependencies(type, rawImports) {
    this.resolveNgModulesDecls();
    const def = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type);
    if (def === null) {
      throw new Error(`Attempting to get component dependencies for a type that is not a component: ${type}`);
    }
    if (def.standalone) {
      const scope = this.getStandaloneComponentScope(type, rawImports);
      if (scope.compilation.isPoisoned) {
        return {
          dependencies: []
        };
      }
      return {
        dependencies: [...scope.compilation.directives, ...scope.compilation.pipes, ...scope.compilation.ngModules]
      };
    } else {
      if (!this.ownerNgModule.has(type)) {
        return {
          dependencies: []
        };
      }
      const scope = this.getNgModuleScope(this.ownerNgModule.get(type));
      if (scope.compilation.isPoisoned) {
        return {
          dependencies: []
        };
      }
      return {
        dependencies: [...scope.compilation.directives, ...scope.compilation.pipes]
      };
    }
  }
  registerNgModule(type, scopeInfo) {
    if (!isNgModule(type)) {
      throw new Error(`Attempting to register a Type which is not NgModule as NgModule: ${type}`);
    }
    this.ngModulesWithSomeUnresolvedDecls.add(type);
  }
  clearScopeCacheFor(type) {
    this.ngModulesScopeCache.delete(type);
    this.standaloneComponentsScopeCache.delete(type);
  }
  getNgModuleScope(type) {
    if (this.ngModulesScopeCache.has(type)) {
      return this.ngModulesScopeCache.get(type);
    }
    const scope = this.computeNgModuleScope(type);
    this.ngModulesScopeCache.set(type, scope);
    return scope;
  }
  computeNgModuleScope(type) {
    const def = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNgModuleDefOrThrow)(type);
    const scope = {
      exported: {
        directives: new Set(),
        pipes: new Set()
      },
      compilation: {
        directives: new Set(),
        pipes: new Set()
      }
    };
    for (const imported of maybeUnwrapFn(def.imports)) {
      if (isNgModule(imported)) {
        const importedScope = this.getNgModuleScope(imported);
        addSet(importedScope.exported.directives, scope.compilation.directives);
        addSet(importedScope.exported.pipes, scope.compilation.pipes);
      } else if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isStandalone)(imported)) {
        if (isDirective(imported) || isComponent(imported)) {
          scope.compilation.directives.add(imported);
        } else if (isPipe(imported)) {
          scope.compilation.pipes.add(imported);
        } else {
          throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(980, 'The standalone imported type is neither a component nor a directive nor a pipe');
        }
      } else {
        scope.compilation.isPoisoned = true;
        break;
      }
    }
    if (!scope.compilation.isPoisoned) {
      for (const decl of maybeUnwrapFn(def.declarations)) {
        if (isNgModule(decl) || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isStandalone)(decl)) {
          scope.compilation.isPoisoned = true;
          break;
        }
        if (isPipe(decl)) {
          scope.compilation.pipes.add(decl);
        } else {
          scope.compilation.directives.add(decl);
        }
      }
    }
    for (const exported of maybeUnwrapFn(def.exports)) {
      if (isNgModule(exported)) {
        const exportedScope = this.getNgModuleScope(exported);
        addSet(exportedScope.exported.directives, scope.exported.directives);
        addSet(exportedScope.exported.pipes, scope.exported.pipes);
        addSet(exportedScope.exported.directives, scope.compilation.directives);
        addSet(exportedScope.exported.pipes, scope.compilation.pipes);
      } else if (isPipe(exported)) {
        scope.exported.pipes.add(exported);
      } else {
        scope.exported.directives.add(exported);
      }
    }
    return scope;
  }
  getStandaloneComponentScope(type, rawImports) {
    if (this.standaloneComponentsScopeCache.has(type)) {
      return this.standaloneComponentsScopeCache.get(type);
    }
    const ans = this.computeStandaloneComponentScope(type, rawImports);
    this.standaloneComponentsScopeCache.set(type, ans);
    return ans;
  }
  computeStandaloneComponentScope(type, rawImports) {
    const ans = {
      compilation: {
        directives: new Set([type]),
        pipes: new Set(),
        ngModules: new Set()
      }
    };
    for (const rawImport of (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(rawImports ?? [])) {
      const imported = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(rawImport);
      try {
        verifyStandaloneImport(imported, type);
      } catch (e) {
        ans.compilation.isPoisoned = true;
        return ans;
      }
      if (isNgModule(imported)) {
        ans.compilation.ngModules.add(imported);
        const importedScope = this.getNgModuleScope(imported);
        if (importedScope.exported.isPoisoned) {
          ans.compilation.isPoisoned = true;
          return ans;
        }
        addSet(importedScope.exported.directives, ans.compilation.directives);
        addSet(importedScope.exported.pipes, ans.compilation.pipes);
      } else if (isPipe(imported)) {
        ans.compilation.pipes.add(imported);
      } else if (isDirective(imported) || isComponent(imported)) {
        ans.compilation.directives.add(imported);
      } else {
        ans.compilation.isPoisoned = true;
        return ans;
      }
    }
    return ans;
  }
  isOrphanComponent(cmp) {
    const def = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(cmp);
    if (!def || def.standalone) {
      return false;
    }
    this.resolveNgModulesDecls();
    return !this.ownerNgModule.has(cmp);
  }
}
function addSet(sourceSet, targetSet) {
  for (const m of sourceSet) {
    targetSet.add(m);
  }
}
const depsTracker = new DepsTracker();
const NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};
class ChainedInjector {
  injector;
  parentInjector;
  constructor(injector, parentInjector) {
    this.injector = injector;
    this.parentInjector = parentInjector;
  }
  get(token, notFoundValue, options) {
    const value = this.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, options);
    if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR || notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {
      return value;
    }
    return this.parentInjector.get(token, notFoundValue, options);
  }
}
function computeStaticStyling(tNode, attrs, writeToHost) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)(), 'Expecting to be called in first template pass only');
  let styles = writeToHost ? tNode.styles : null;
  let classes = writeToHost ? tNode.classes : null;
  let mode = 0;
  if (attrs !== null) {
    for (let i = 0; i < attrs.length; i++) {
      const value = attrs[i];
      if (typeof value === 'number') {
        mode = value;
      } else if (mode == 1) {
        classes = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.concatStringsWithSpace)(classes, value);
      } else if (mode == 2) {
        const style = value;
        const styleValue = attrs[++i];
        styles = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.concatStringsWithSpace)(styles, style + ': ' + styleValue + ';');
      }
    }
  }
  writeToHost ? tNode.styles = styles : tNode.stylesWithoutHost = styles;
  writeToHost ? tNode.classes = classes : tNode.classesWithoutHost = classes;
}
function ɵɵdirectiveInject(token, flags = 0) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  if (lView === null) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertInjectImplementationNotEqual)(ɵɵdirectiveInject);
    return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(token, flags);
  }
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  const value = getOrCreateInjectable(tNode, lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(token), flags);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.emitInjectEvent)(token, value, flags);
  return value;
}
function ɵɵinvalidFactory() {
  const msg = ngDevMode ? `This constructor was not compatible with Dependency Injection.` : 'invalid';
  throw new Error(msg);
}
function resolveDirectives(tView, lView, tNode, localRefs, directiveMatcher) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView);
  const exportsMap = localRefs === null ? null : {
    '': -1
  };
  const matchedDirectiveDefs = directiveMatcher(tView, tNode);
  if (matchedDirectiveDefs !== null) {
    let directiveDefs = matchedDirectiveDefs;
    let hostDirectiveDefs = null;
    let hostDirectiveRanges = null;
    for (const def of matchedDirectiveDefs) {
      if (def.resolveHostDirectives !== null) {
        [directiveDefs, hostDirectiveDefs, hostDirectiveRanges] = def.resolveHostDirectives(matchedDirectiveDefs);
        break;
      }
    }
    ngDevMode && assertNoDuplicateDirectives(directiveDefs);
    initializeDirectives(tView, lView, tNode, directiveDefs, exportsMap, hostDirectiveDefs, hostDirectiveRanges);
  }
  if (exportsMap !== null && localRefs !== null) {
    cacheMatchingLocalNames(tNode, localRefs, exportsMap);
  }
}
function cacheMatchingLocalNames(tNode, localRefs, exportsMap) {
  const localNames = tNode.localNames = [];
  for (let i = 0; i < localRefs.length; i += 2) {
    const index = exportsMap[localRefs[i + 1]];
    if (index == null) throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-301, ngDevMode && `Export of name '${localRefs[i + 1]}' not found!`);
    localNames.push(localRefs[i], index);
  }
}
function markAsComponentHost(tView, hostTNode, componentOffset) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertGreaterThan)(componentOffset, -1, 'componentOffset must be great than -1');
  hostTNode.componentOffset = componentOffset;
  (tView.components ??= []).push(hostTNode.index);
}
function initializeDirectives(tView, lView, tNode, directives, exportsMap, hostDirectiveDefs, hostDirectiveRanges) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView);
  const directivesLength = directives.length;
  let componentDef = null;
  for (let i = 0; i < directivesLength; i++) {
    const def = directives[i];
    if (componentDef === null && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentDef)(def)) {
      componentDef = def;
      markAsComponentHost(tView, tNode, i);
    }
    diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, def.type);
  }
  initTNodeFlags(tNode, tView.data.length, directivesLength);
  if (componentDef?.viewProvidersResolver) {
    componentDef.viewProvidersResolver(componentDef);
  }
  for (let i = 0; i < directivesLength; i++) {
    const def = directives[i];
    if (def.providersResolver) {
      def.providersResolver(def);
    }
  }
  let preOrderHooksFound = false;
  let preOrderCheckHooksFound = false;
  let directiveIdx = allocExpando(tView, lView, directivesLength, null);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertSame)(directiveIdx, tNode.directiveStart, 'TNode.directiveStart should point to just allocated space');
  if (directivesLength > 0) {
    tNode.directiveToIndex = new Map();
  }
  for (let i = 0; i < directivesLength; i++) {
    const def = directives[i];
    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);
    configureViewWithDirective(tView, tNode, lView, directiveIdx, def);
    saveNameToExportMap(directiveIdx, def, exportsMap);
    if (hostDirectiveRanges !== null && hostDirectiveRanges.has(def)) {
      const [start, end] = hostDirectiveRanges.get(def);
      tNode.directiveToIndex.set(def.type, [directiveIdx, start + tNode.directiveStart, end + tNode.directiveStart]);
    } else if (hostDirectiveDefs === null || !hostDirectiveDefs.has(def)) {
      tNode.directiveToIndex.set(def.type, directiveIdx);
    }
    if (def.contentQueries !== null) tNode.flags |= 4;
    if (def.hostBindings !== null || def.hostAttrs !== null || def.hostVars !== 0) tNode.flags |= 64;
    const lifeCycleHooks = def.type.prototype;
    if (!preOrderHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngOnInit || lifeCycleHooks.ngDoCheck)) {
      (tView.preOrderHooks ??= []).push(tNode.index);
      preOrderHooksFound = true;
    }
    if (!preOrderCheckHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngDoCheck)) {
      (tView.preOrderCheckHooks ??= []).push(tNode.index);
      preOrderCheckHooksFound = true;
    }
    directiveIdx++;
  }
  initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefs);
}
function initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefs) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView);
  for (let index = tNode.directiveStart; index < tNode.directiveEnd; index++) {
    const directiveDef = tView.data[index];
    if (hostDirectiveDefs === null || !hostDirectiveDefs.has(directiveDef)) {
      setupSelectorMatchedInputsOrOutputs(0, tNode, directiveDef, index);
      setupSelectorMatchedInputsOrOutputs(1, tNode, directiveDef, index);
      setupInitialInputs(tNode, index, false);
    } else {
      const hostDirectiveDef = hostDirectiveDefs.get(directiveDef);
      setupHostDirectiveInputsOrOutputs(0, tNode, hostDirectiveDef, index);
      setupHostDirectiveInputsOrOutputs(1, tNode, hostDirectiveDef, index);
      setupInitialInputs(tNode, index, true);
    }
  }
}
function setupSelectorMatchedInputsOrOutputs(mode, tNode, def, directiveIndex) {
  const aliasMap = mode === 0 ? def.inputs : def.outputs;
  for (const publicName in aliasMap) {
    if (aliasMap.hasOwnProperty(publicName)) {
      let bindings;
      if (mode === 0) {
        bindings = tNode.inputs ??= {};
      } else {
        bindings = tNode.outputs ??= {};
      }
      bindings[publicName] ??= [];
      bindings[publicName].push(directiveIndex);
      setShadowStylingInputFlags(tNode, publicName);
    }
  }
}
function setupHostDirectiveInputsOrOutputs(mode, tNode, config, directiveIndex) {
  const aliasMap = mode === 0 ? config.inputs : config.outputs;
  for (const initialName in aliasMap) {
    if (aliasMap.hasOwnProperty(initialName)) {
      const publicName = aliasMap[initialName];
      let bindings;
      if (mode === 0) {
        bindings = tNode.hostDirectiveInputs ??= {};
      } else {
        bindings = tNode.hostDirectiveOutputs ??= {};
      }
      bindings[publicName] ??= [];
      bindings[publicName].push(directiveIndex, initialName);
      setShadowStylingInputFlags(tNode, publicName);
    }
  }
}
function setShadowStylingInputFlags(tNode, publicName) {
  if (publicName === 'class') {
    tNode.flags |= 8;
  } else if (publicName === 'style') {
    tNode.flags |= 16;
  }
}
function setupInitialInputs(tNode, directiveIndex, isHostDirective) {
  const {
    attrs,
    inputs,
    hostDirectiveInputs
  } = tNode;
  if (attrs === null || !isHostDirective && inputs === null || isHostDirective && hostDirectiveInputs === null || isInlineTemplate(tNode)) {
    tNode.initialInputs ??= [];
    tNode.initialInputs.push(null);
    return;
  }
  let inputsToStore = null;
  let i = 0;
  while (i < attrs.length) {
    const attrName = attrs[i];
    if (attrName === 0) {
      i += 4;
      continue;
    } else if (attrName === 5) {
      i += 2;
      continue;
    } else if (typeof attrName === 'number') {
      break;
    }
    if (!isHostDirective && inputs.hasOwnProperty(attrName)) {
      const inputConfig = inputs[attrName];
      for (const index of inputConfig) {
        if (index === directiveIndex) {
          inputsToStore ??= [];
          inputsToStore.push(attrName, attrs[i + 1]);
          break;
        }
      }
    } else if (isHostDirective && hostDirectiveInputs.hasOwnProperty(attrName)) {
      const config = hostDirectiveInputs[attrName];
      for (let j = 0; j < config.length; j += 2) {
        if (config[j] === directiveIndex) {
          inputsToStore ??= [];
          inputsToStore.push(config[j + 1], attrs[i + 1]);
          break;
        }
      }
    }
    i += 2;
  }
  tNode.initialInputs ??= [];
  tNode.initialInputs.push(inputsToStore);
}
function configureViewWithDirective(tView, tNode, lView, directiveIndex, def) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertGreaterThanOrEqual)(directiveIndex, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET, 'Must be in Expando section');
  tView.data[directiveIndex] = def;
  const directiveFactory = def.factory || (def.factory = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getFactoryDef)(def.type, true));
  const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentDef)(def), ɵɵdirectiveInject, ngDevMode ? def.type.name : null);
  tView.blueprint[directiveIndex] = nodeInjectorFactory;
  lView[directiveIndex] = nodeInjectorFactory;
  registerHostBindingOpCodes(tView, tNode, directiveIndex, allocExpando(tView, lView, def.hostVars, NO_CHANGE), def);
}
function registerHostBindingOpCodes(tView, tNode, directiveIdx, directiveVarsIdx, def) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView);
  const hostBindings = def.hostBindings;
  if (hostBindings) {
    let hostBindingOpCodes = tView.hostBindingOpCodes;
    if (hostBindingOpCodes === null) {
      hostBindingOpCodes = tView.hostBindingOpCodes = [];
    }
    const elementIndx = ~tNode.index;
    if (lastSelectedElementIdx(hostBindingOpCodes) != elementIndx) {
      hostBindingOpCodes.push(elementIndx);
    }
    hostBindingOpCodes.push(directiveIdx, directiveVarsIdx, hostBindings);
  }
}
function lastSelectedElementIdx(hostBindingOpCodes) {
  let i = hostBindingOpCodes.length;
  while (i > 0) {
    const value = hostBindingOpCodes[--i];
    if (typeof value === 'number' && value < 0) {
      return value;
    }
  }
  return 0;
}
function saveNameToExportMap(directiveIdx, def, exportsMap) {
  if (exportsMap) {
    if (def.exportAs) {
      for (let i = 0; i < def.exportAs.length; i++) {
        exportsMap[def.exportAs[i]] = directiveIdx;
      }
    }
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentDef)(def)) exportsMap[''] = directiveIdx;
  }
}
function initTNodeFlags(tNode, index, numberOfDirectives) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotEqual)(numberOfDirectives, tNode.directiveEnd - tNode.directiveStart, 'Reached the max number of directives');
  tNode.flags |= 1;
  tNode.directiveStart = index;
  tNode.directiveEnd = index + numberOfDirectives;
  tNode.providerIndexes = index;
}
function assertNoDuplicateDirectives(directives) {
  if (directives.length < 2) {
    return;
  }
  const seenDirectives = new Set();
  for (const current of directives) {
    if (seenDirectives.has(current)) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(309, `Directive ${current.type.name} matches multiple times on the same element. ` + `Directives can only match an element once.`);
    }
    seenDirectives.add(current);
  }
}
function directiveHostFirstCreatePass(index, lView, type, name, directiveMatcher, bindingsEnabled, attrsIndex, localRefsIndex) {
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView);
  const tViewConsts = tView.consts;
  const attrs = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tViewConsts, attrsIndex);
  const tNode = getOrCreateTNode(tView, index, type, name, attrs);
  if (bindingsEnabled) {
    resolveDirectives(tView, lView, tNode, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tViewConsts, localRefsIndex), directiveMatcher);
  }
  tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);
  if (tNode.attrs !== null) {
    computeStaticStyling(tNode, tNode.attrs, false);
  }
  if (tNode.mergedAttrs !== null) {
    computeStaticStyling(tNode, tNode.mergedAttrs, true);
  }
  if (tView.queries !== null) {
    tView.queries.elementStart(tView, tNode);
  }
  return tNode;
}
function directiveHostEndFirstCreatePass(tView, tNode) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView);
  registerPostOrderHooks(tView, tNode);
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isContentQueryHost)(tNode)) {
    tView.queries.elementEnd(tNode);
  }
}
function domOnlyFirstCreatePass(index, tView, type, name, attrsIndex, localRefsIndex) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView);
  const tViewConsts = tView.consts;
  const attrs = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tViewConsts, attrsIndex);
  const tNode = getOrCreateTNode(tView, index, type, name, attrs);
  tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);
  if (localRefsIndex != null) {
    const refs = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tViewConsts, localRefsIndex);
    tNode.localNames = [];
    for (let i = 0; i < refs.length; i += 2) {
      tNode.localNames.push(refs[i], -1);
    }
  }
  if (tNode.attrs !== null) {
    computeStaticStyling(tNode, tNode.attrs, false);
  }
  if (tNode.mergedAttrs !== null) {
    computeStaticStyling(tNode, tNode.mergedAttrs, true);
  }
  if (tView.queries !== null) {
    tView.queries.elementStart(tView, tNode);
  }
  return tNode;
}
function isListLikeIterable(obj) {
  if (!isJsObject(obj)) return false;
  return Array.isArray(obj) || !(obj instanceof Map) && Symbol.iterator in obj;
}
function areIterablesEqual(a, b, comparator) {
  const iterator1 = a[Symbol.iterator]();
  const iterator2 = b[Symbol.iterator]();
  while (true) {
    const item1 = iterator1.next();
    const item2 = iterator2.next();
    if (item1.done && item2.done) return true;
    if (item1.done || item2.done) return false;
    if (!comparator(item1.value, item2.value)) return false;
  }
}
function iterateListLike(obj, fn) {
  if (Array.isArray(obj)) {
    for (let i = 0; i < obj.length; i++) {
      fn(obj[i]);
    }
  } else {
    const iterator = obj[Symbol.iterator]();
    let item;
    while (!(item = iterator.next()).done) {
      fn(item.value);
    }
  }
}
function isJsObject(o) {
  return o !== null && (typeof o === 'function' || typeof o === 'object');
}
function devModeEqual(a, b) {
  const isListLikeIterableA = isListLikeIterable(a);
  const isListLikeIterableB = isListLikeIterable(b);
  if (isListLikeIterableA && isListLikeIterableB) {
    return areIterablesEqual(a, b, devModeEqual);
  } else {
    const isAObject = a && (typeof a === 'object' || typeof a === 'function');
    const isBObject = b && (typeof b === 'object' || typeof b === 'function');
    if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {
      return true;
    } else {
      return Object.is(a, b);
    }
  }
}
function updateBinding(lView, bindingIndex, value) {
  return lView[bindingIndex] = value;
}
function getBinding(lView, bindingIndex) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, bindingIndex);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotSame)(lView[bindingIndex], NO_CHANGE, 'Stored value should never be NO_CHANGE.');
  return lView[bindingIndex];
}
function bindingUpdated(lView, bindingIndex, value) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLessThan)(bindingIndex, lView.length, `Slot should have been initialized to NO_CHANGE`);
  if (value === NO_CHANGE) {
    return false;
  }
  const oldValue = lView[bindingIndex];
  if (Object.is(oldValue, value)) {
    return false;
  } else {
    if (ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isInCheckNoChangesMode)()) {
      const oldValueToCompare = oldValue !== NO_CHANGE ? oldValue : undefined;
      if (!devModeEqual(oldValueToCompare, value)) {
        const details = getExpressionChangedErrorDetails(lView, bindingIndex, oldValueToCompare, value);
        throwErrorIfNoChangesMode(oldValue === NO_CHANGE, details.oldValue, details.newValue, details.propName, lView);
      }
      return false;
    }
    lView[bindingIndex] = value;
    return true;
  }
}
function bindingUpdated2(lView, bindingIndex, exp1, exp2) {
  const different = bindingUpdated(lView, bindingIndex, exp1);
  return bindingUpdated(lView, bindingIndex + 1, exp2) || different;
}
function bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) {
  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
  return bindingUpdated(lView, bindingIndex + 2, exp3) || different;
}
function bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) {
  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
  return bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different;
}
const ɵCONTROL = Symbol('CONTROL');
function wrapListener(tNode, lView, listenerFn) {
  return function wrapListenerIn_markDirtyAndPreventDefault(event) {
    const startView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentHost)(tNode) ? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(tNode.index, lView) : lView;
    markViewDirty(startView, 5);
    const context = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT];
    let result = executeListenerWithErrorHandling(lView, context, listenerFn, event);
    let nextListenerFn = wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;
    while (nextListenerFn) {
      result = executeListenerWithErrorHandling(lView, context, nextListenerFn, event) && result;
      nextListenerFn = nextListenerFn.__ngNextListenerFn__;
    }
    return result;
  };
}
function executeListenerWithErrorHandling(lView, context, listenerFn, e) {
  const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
  try {
    profiler(ProfilerEvent.OutputStart, context, listenerFn);
    return listenerFn(e) !== false;
  } catch (error) {
    handleUncaughtError(lView, error);
    return false;
  } finally {
    profiler(ProfilerEvent.OutputEnd, context, listenerFn);
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
  }
}
function listenToDomEvent(tNode, tView, lView, eventTargetResolver, renderer, eventName, originalListener, wrappedListener) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotSame)(wrappedListener, originalListener, 'Expected wrapped and original listeners to be different.');
  const isTNodeDirectiveHost = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isDirectiveHost)(tNode);
  let hasCoalesced = false;
  let existingListener = null;
  if (!eventTargetResolver && isTNodeDirectiveHost) {
    existingListener = findExistingListener(tView, lView, eventName, tNode.index);
  }
  if (existingListener !== null) {
    const lastListenerFn = existingListener.__ngLastListenerFn__ || existingListener;
    lastListenerFn.__ngNextListenerFn__ = originalListener;
    existingListener.__ngLastListenerFn__ = originalListener;
    hasCoalesced = true;
  } else {
    const native = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
    const target = eventTargetResolver ? eventTargetResolver(native) : native;
    stashEventListenerImpl(lView, target, eventName, wrappedListener);
    const cleanupFn = renderer.listen(target, eventName, wrappedListener);
    if (!isAnimationEventType(eventName)) {
      const idxOrTargetGetter = eventTargetResolver ? _lView => eventTargetResolver((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(_lView[tNode.index])) : tNode.index;
      storeListenerCleanup(idxOrTargetGetter, tView, lView, eventName, wrappedListener, cleanupFn, false);
    }
  }
  return hasCoalesced;
}
function isAnimationEventType(eventName) {
  return eventName.startsWith('animation') || eventName.startsWith('transition');
}
function findExistingListener(tView, lView, eventName, tNodeIndex) {
  const tCleanup = tView.cleanup;
  if (tCleanup != null) {
    for (let i = 0; i < tCleanup.length - 1; i += 2) {
      const cleanupEventName = tCleanup[i];
      if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIndex) {
        const lCleanup = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CLEANUP];
        const listenerIdxInLCleanup = tCleanup[i + 2];
        return lCleanup && lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;
      }
      if (typeof cleanupEventName === 'string') {
        i += 2;
      }
    }
  }
  return null;
}
function storeListenerCleanup(indexOrTargetGetter, tView, lView, eventName, listenerFn, cleanup, isOutput) {
  const tCleanup = tView.firstCreatePass ? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getOrCreateTViewCleanup)(tView) : null;
  const lCleanup = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getOrCreateLViewCleanup)(lView);
  const index = lCleanup.length;
  lCleanup.push(listenerFn, cleanup);
  tCleanup && tCleanup.push(eventName, indexOrTargetGetter, index, (index + 1) * (isOutput ? -1 : 1));
}
function createOutputListener(tNode, lView, listenerFn, targetDef, eventName) {
  const wrappedListener = wrapListener(tNode, lView, listenerFn);
  const hasBound = listenToDirectiveOutput(tNode, lView, targetDef, eventName, wrappedListener);
  if (!hasBound && ngDevMode) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(316, `${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(targetDef.type)} does not have an output with a public name of "${eventName}".`);
  }
}
function listenToDirectiveOutput(tNode, lView, target, eventName, listenerFn) {
  let hostIndex = null;
  let hostDirectivesStart = null;
  let hostDirectivesEnd = null;
  let hasOutput = false;
  if (ngDevMode && !tNode.directiveToIndex?.has(target.type)) {
    throw new Error(`Node does not have a directive with type ${target.type.name}`);
  }
  const data = tNode.directiveToIndex.get(target.type);
  if (typeof data === 'number') {
    hostIndex = data;
  } else {
    [hostIndex, hostDirectivesStart, hostDirectivesEnd] = data;
  }
  if (hostDirectivesStart !== null && hostDirectivesEnd !== null && tNode.hostDirectiveOutputs?.hasOwnProperty(eventName)) {
    const hostDirectiveOutputs = tNode.hostDirectiveOutputs[eventName];
    for (let i = 0; i < hostDirectiveOutputs.length; i += 2) {
      const index = hostDirectiveOutputs[i];
      if (index >= hostDirectivesStart && index <= hostDirectivesEnd) {
        ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, index);
        hasOutput = true;
        listenToOutput(tNode, lView, index, hostDirectiveOutputs[i + 1], eventName, listenerFn);
      } else if (index > hostDirectivesEnd) {
        break;
      }
    }
  }
  if (target.outputs.hasOwnProperty(eventName)) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, hostIndex);
    hasOutput = true;
    listenToOutput(tNode, lView, hostIndex, eventName, eventName, listenerFn);
  }
  return hasOutput;
}
function listenToOutput(tNode, lView, directiveIndex, lookupName, eventName, listenerFn) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, directiveIndex);
  const instance = lView[directiveIndex];
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const def = tView.data[directiveIndex];
  const propertyName = def.outputs[lookupName];
  const output = instance[propertyName];
  if (ngDevMode && !isOutputSubscribable(output)) {
    throw new Error(`@Output ${propertyName} not initialized in '${instance.constructor.name}'.`);
  }
  const subscription = output.subscribe(listenerFn);
  storeListenerCleanup(tNode.index, tView, lView, eventName, listenerFn, subscription, true);
}
function isOutputSubscribable(value) {
  return value != null && typeof value.subscribe === 'function';
}
const BINDING = /* @__PURE__ */Symbol('BINDING');
const INPUT_BINDING_METADATA = {
  kind: 'input',
  requiredVars: 1
};
const FIELD_BINDING_METADATA = {
  kind: 'field',
  requiredVars: 2
};
const OUTPUT_BINDING_METADATA = {
  kind: 'output',
  requiredVars: 0
};
function inputBindingUpdate(targetDirectiveIdx, publicName, value) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
    const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)();
    const componentLView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(tNode.index, lView);
    markViewDirty(componentLView, 1);
    const targetDef = tView.directiveRegistry[targetDirectiveIdx];
    if (ngDevMode && !targetDef) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(315, `Input binding to property "${publicName}" does not have a target.`);
    }
    const hasSet = setDirectiveInput(tNode, tView, lView, targetDef, publicName, value);
    if (ngDevMode) {
      if (!hasSet) {
        throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(315, `${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(targetDef.type)} does not have an input with a public name of "${publicName}".`);
      }
      storePropertyBindingMetadata(tView.data, tNode, publicName, bindingIndex);
    }
  }
}
function controlBinding(binding, tNode) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const directive = lView[tNode.directiveStart + binding.targetIdx];
  return directive[ɵCONTROL];
}
function inputBinding(publicName, value) {
  if (publicName === 'field') {
    const binding = {
      [BINDING]: FIELD_BINDING_METADATA,
      create: () => {
        controlBinding(binding, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)())?.create();
      },
      update: () => {
        inputBindingUpdate(binding.targetIdx, publicName, value());
        controlBinding(binding, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)())?.update();
      }
    };
    return binding;
  }
  const binding = {
    [BINDING]: INPUT_BINDING_METADATA,
    update: () => inputBindingUpdate(binding.targetIdx, publicName, value())
  };
  return binding;
}
function outputBinding(eventName, listener) {
  const binding = {
    [BINDING]: OUTPUT_BINDING_METADATA,
    create: () => {
      const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
      const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
      const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
      const targetDef = tView.directiveRegistry[binding.targetIdx];
      createOutputListener(tNode, lView, listener, targetDef, eventName);
    }
  };
  return binding;
}
function twoWayBinding(publicName, value) {
  const input = inputBinding(publicName, value);
  const output = outputBinding(publicName + 'Change', eventValue => value.set(eventValue));
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotDefined)(input.create, 'Unexpected `create` callback in inputBinding');
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotDefined)(output.update, 'Unexpected `update` callback in outputBinding');
  const binding = {
    [BINDING]: {
      kind: 'twoWay',
      requiredVars: input[BINDING].requiredVars + output[BINDING].requiredVars
    },
    set targetIdx(idx) {
      input.targetIdx = idx;
      output.targetIdx = idx;
    },
    create: output.create,
    update: input.update
  };
  return binding;
}
class ComponentFactoryResolver extends ComponentFactoryResolver$1 {
  ngModule;
  constructor(ngModule) {
    super();
    this.ngModule = ngModule;
  }
  resolveComponentFactory(component) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertComponentType)(component);
    const componentDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(component);
    return new ComponentFactory(componentDef, this.ngModule);
  }
}
function toInputRefArray(map) {
  return Object.keys(map).map(name => {
    const [propName, flags, transform] = map[name];
    const inputData = {
      propName: propName,
      templateName: name,
      isSignal: (flags & InputFlags.SignalBased) !== 0
    };
    if (transform) {
      inputData.transform = transform;
    }
    return inputData;
  });
}
function toOutputRefArray(map) {
  return Object.keys(map).map(name => ({
    propName: map[name],
    templateName: name
  }));
}
function verifyNotAnOrphanComponent(componentDef) {
  if ((typeof ngJitMode === 'undefined' || ngJitMode) && componentDef.debugInfo?.forbidOrphanRendering) {
    if (depsTracker.isOrphanComponent(componentDef.type)) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(981, `Orphan component found! Trying to render the component ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.debugStringifyTypeForError)(componentDef.type)} without first loading the NgModule that declares it. It is recommended to make this component standalone in order to avoid this error. If this is not possible now, import the component's NgModule in the appropriate NgModule, or the standalone component in which you are trying to render this component. If this is a lazy import, load the NgModule lazily as well and use its module injector.`);
    }
  }
}
function createRootViewInjector(componentDef, environmentInjector, injector) {
  let realEnvironmentInjector = environmentInjector instanceof _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EnvironmentInjector ? environmentInjector : environmentInjector?.injector;
  if (realEnvironmentInjector && componentDef.getStandaloneInjector !== null) {
    realEnvironmentInjector = componentDef.getStandaloneInjector(realEnvironmentInjector) || realEnvironmentInjector;
  }
  const rootViewInjector = realEnvironmentInjector ? new ChainedInjector(injector, realEnvironmentInjector) : injector;
  return rootViewInjector;
}
function createRootLViewEnvironment(rootLViewInjector) {
  const rendererFactory = rootLViewInjector.get(RendererFactory2, null);
  if (rendererFactory === null) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(407, ngDevMode && 'Angular was not able to inject a renderer (RendererFactory2). ' + 'Likely this is due to a broken DI hierarchy. ' + 'Make sure that any injector used to create this component has a correct parent.');
  }
  const sanitizer = rootLViewInjector.get(Sanitizer, null);
  const changeDetectionScheduler = rootLViewInjector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ChangeDetectionScheduler, null);
  let ngReflect = false;
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
    ngReflect = rootLViewInjector.get(NG_REFLECT_ATTRS_FLAG, NG_REFLECT_ATTRS_FLAG_DEFAULT);
  }
  return {
    rendererFactory,
    sanitizer,
    changeDetectionScheduler,
    ngReflect
  };
}
function createHostElement(componentDef, renderer) {
  const tagName = inferTagNameFromDefinition(componentDef);
  const namespace = tagName === 'svg' ? _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.SVG_NAMESPACE : tagName === 'math' ? _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.MATH_ML_NAMESPACE : null;
  return createElementNode(renderer, tagName, namespace);
}
function inferTagNameFromDefinition(componentDef) {
  return (componentDef.selectors[0][0] || 'div').toLowerCase();
}
class ComponentFactory extends ComponentFactory$1 {
  componentDef;
  ngModule;
  selector;
  componentType;
  ngContentSelectors;
  isBoundToModule;
  cachedInputs = null;
  cachedOutputs = null;
  get inputs() {
    this.cachedInputs ??= toInputRefArray(this.componentDef.inputs);
    return this.cachedInputs;
  }
  get outputs() {
    this.cachedOutputs ??= toOutputRefArray(this.componentDef.outputs);
    return this.cachedOutputs;
  }
  constructor(componentDef, ngModule) {
    super();
    this.componentDef = componentDef;
    this.ngModule = ngModule;
    this.componentType = componentDef.type;
    this.selector = stringifyCSSSelectorList(componentDef.selectors);
    this.ngContentSelectors = componentDef.ngContentSelectors ?? [];
    this.isBoundToModule = !!ngModule;
  }
  create(injector, projectableNodes, rootSelectorOrNode, environmentInjector, directives, componentBindings) {
    profiler(ProfilerEvent.DynamicComponentStart);
    const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
    try {
      const cmpDef = this.componentDef;
      ngDevMode && verifyNotAnOrphanComponent(cmpDef);
      const rootTView = createRootTView(rootSelectorOrNode, cmpDef, componentBindings, directives);
      const rootViewInjector = createRootViewInjector(cmpDef, environmentInjector || this.ngModule, injector);
      const environment = createRootLViewEnvironment(rootViewInjector);
      const hostRenderer = environment.rendererFactory.createRenderer(null, cmpDef);
      const hostElement = rootSelectorOrNode ? locateHostElement(hostRenderer, rootSelectorOrNode, cmpDef.encapsulation, rootViewInjector) : createHostElement(cmpDef, hostRenderer);
      const hasInputBindings = componentBindings?.some(isInputBinding) || directives?.some(d => typeof d !== 'function' && d.bindings.some(isInputBinding));
      const rootLView = createLView(null, rootTView, null, 512 | getInitialLViewFlagsFromDef(cmpDef), null, null, environment, hostRenderer, rootViewInjector, null, retrieveHydrationInfo(hostElement, rootViewInjector, true));
      rootLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET] = hostElement;
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.enterView)(rootLView);
      let componentView = null;
      try {
        const hostTNode = directiveHostFirstCreatePass(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET, rootLView, 2, '#host', () => rootTView.directiveRegistry, true, 0);
        setupStaticAttributes(hostRenderer, hostElement, hostTNode);
        attachPatchData(hostElement, rootLView);
        createDirectivesInstances(rootTView, rootLView, hostTNode);
        executeContentQueries(rootTView, hostTNode, rootLView);
        directiveHostEndFirstCreatePass(rootTView, hostTNode);
        if (projectableNodes !== undefined) {
          projectNodes(hostTNode, this.ngContentSelectors, projectableNodes);
        }
        componentView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(hostTNode.index, rootLView);
        rootLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT] = componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT];
        renderView(rootTView, rootLView, null);
      } catch (e) {
        if (componentView !== null) {
          unregisterLView(componentView);
        }
        unregisterLView(rootLView);
        throw e;
      } finally {
        profiler(ProfilerEvent.DynamicComponentEnd);
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.leaveView)();
      }
      return new ComponentRef(this.componentType, rootLView, !!hasInputBindings);
    } finally {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
    }
  }
}
function createRootTView(rootSelectorOrNode, componentDef, componentBindings, directives) {
  const tAttributes = rootSelectorOrNode ? ['ng-version', '21.0.5'] : extractAttrsAndClassesFromSelector(componentDef.selectors[0]);
  let creationBindings = null;
  let updateBindings = null;
  let varsToAllocate = 0;
  if (componentBindings) {
    for (const binding of componentBindings) {
      varsToAllocate += binding[BINDING].requiredVars;
      if (binding.create) {
        binding.targetIdx = 0;
        (creationBindings ??= []).push(binding);
      }
      if (binding.update) {
        binding.targetIdx = 0;
        (updateBindings ??= []).push(binding);
      }
    }
  }
  if (directives) {
    for (let i = 0; i < directives.length; i++) {
      const directive = directives[i];
      if (typeof directive !== 'function') {
        for (const binding of directive.bindings) {
          varsToAllocate += binding[BINDING].requiredVars;
          const targetDirectiveIdx = i + 1;
          if (binding.create) {
            binding.targetIdx = targetDirectiveIdx;
            (creationBindings ??= []).push(binding);
          }
          if (binding.update) {
            binding.targetIdx = targetDirectiveIdx;
            (updateBindings ??= []).push(binding);
          }
        }
      }
    }
  }
  const directivesToApply = [componentDef];
  if (directives) {
    for (const directive of directives) {
      const directiveType = typeof directive === 'function' ? directive : directive.type;
      const directiveDef = ngDevMode ? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDefOrThrow)(directiveType) : (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(directiveType);
      if (ngDevMode && !directiveDef.standalone) {
        throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(907, `The ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(directiveType)} directive must be standalone in ` + `order to be applied to a dynamically-created component.`);
      }
      directivesToApply.push(directiveDef);
    }
  }
  const rootTView = createTView(0, null, getRootTViewTemplate(creationBindings, updateBindings), 1, varsToAllocate, directivesToApply, null, null, null, [tAttributes], null);
  return rootTView;
}
function getRootTViewTemplate(creationBindings, updateBindings) {
  if (!creationBindings && !updateBindings) {
    return null;
  }
  return flags => {
    if (flags & 1 && creationBindings) {
      for (const binding of creationBindings) {
        binding.create();
      }
    }
    if (flags & 2 && updateBindings) {
      for (const binding of updateBindings) {
        binding.update();
      }
    }
  };
}
function isInputBinding(binding) {
  const kind = binding[BINDING].kind;
  return kind === 'input' || kind === 'twoWay';
}
class ComponentRef extends ComponentRef$1 {
  _rootLView;
  _hasInputBindings;
  instance;
  hostView;
  changeDetectorRef;
  componentType;
  location;
  previousInputValues = null;
  _tNode;
  constructor(componentType, _rootLView, _hasInputBindings) {
    super();
    this._rootLView = _rootLView;
    this._hasInputBindings = _hasInputBindings;
    this._tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTNode)(_rootLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET);
    this.location = createElementRef(this._tNode, _rootLView);
    this.instance = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(this._tNode.index, _rootLView)[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT];
    this.hostView = this.changeDetectorRef = new ViewRef(_rootLView, undefined);
    this.componentType = componentType;
  }
  setInput(name, value) {
    if (this._hasInputBindings && ngDevMode) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(317, 'Cannot call `setInput` on a component that is using the `inputBinding` or `twoWayBinding` functions.');
    }
    const tNode = this._tNode;
    this.previousInputValues ??= new Map();
    if (this.previousInputValues.has(name) && Object.is(this.previousInputValues.get(name), value)) {
      return;
    }
    const lView = this._rootLView;
    const hasSetInput = setAllInputsForProperty(tNode, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], lView, name, value);
    this.previousInputValues.set(name, value);
    const childComponentLView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(tNode.index, lView);
    markViewDirty(childComponentLView, 1);
    if (ngDevMode && !hasSetInput) {
      const cmpNameForError = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(this.componentType);
      let message = `Can't set value of the '${name}' input on the '${cmpNameForError}' component. `;
      message += `Make sure that the '${name}' property is declared as an input using the input() or model() function or the @Input() decorator.`;
      reportUnknownPropertyError(message);
    }
  }
  get injector() {
    return new NodeInjector(this._tNode, this._rootLView);
  }
  destroy() {
    this.hostView.destroy();
  }
  onDestroy(callback) {
    this.hostView.onDestroy(callback);
  }
}
function projectNodes(tNode, ngContentSelectors, projectableNodes) {
  const projection = tNode.projection = [];
  for (let i = 0; i < ngContentSelectors.length; i++) {
    const nodesforSlot = projectableNodes[i];
    projection.push(nodesforSlot != null && nodesforSlot.length ? Array.from(nodesforSlot) : null);
  }
}
class ViewContainerRef {
  static __NG_ELEMENT_ID__ = injectViewContainerRef;
}
function injectViewContainerRef() {
  const previousTNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  return createContainerRef(previousTNode, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)());
}
const VE_ViewContainerRef = ViewContainerRef;
const R3ViewContainerRef = class ViewContainerRef extends VE_ViewContainerRef {
  _lContainer;
  _hostTNode;
  _hostLView;
  constructor(_lContainer, _hostTNode, _hostLView) {
    super();
    this._lContainer = _lContainer;
    this._hostTNode = _hostTNode;
    this._hostLView = _hostLView;
  }
  get element() {
    return createElementRef(this._hostTNode, this._hostLView);
  }
  get injector() {
    return new NodeInjector(this._hostTNode, this._hostLView);
  }
  get parentInjector() {
    const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostLView);
    if (hasParentInjector(parentLocation)) {
      const parentView = getParentInjectorView(parentLocation, this._hostLView);
      const injectorIndex = getParentInjectorIndex(parentLocation);
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNodeInjector)(parentView, injectorIndex);
      const parentTNode = parentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data[injectorIndex + 8];
      return new NodeInjector(parentTNode, parentView);
    } else {
      return new NodeInjector(null, this._hostLView);
    }
  }
  clear() {
    while (this.length > 0) {
      this.remove(this.length - 1);
    }
  }
  get(index) {
    const viewRefs = getViewRefs(this._lContainer);
    return viewRefs !== null && viewRefs[index] || null;
  }
  get length() {
    return this._lContainer.length - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET;
  }
  createEmbeddedView(templateRef, context, indexOrOptions) {
    let index;
    let injector;
    if (typeof indexOrOptions === 'number') {
      index = indexOrOptions;
    } else if (indexOrOptions != null) {
      index = indexOrOptions.index;
      injector = indexOrOptions.injector;
    }
    const dehydratedView = findMatchingDehydratedView(this._lContainer, templateRef.ssrId);
    const viewRef = templateRef.createEmbeddedViewImpl(context || {}, injector, dehydratedView);
    this.insertImpl(viewRef, index, shouldAddViewToDom(this._hostTNode, dehydratedView));
    return viewRef;
  }
  createComponent(componentFactoryOrType, indexOrOptions, injector, projectableNodes, environmentInjector, directives, bindings) {
    const isComponentFactory = componentFactoryOrType && !isType(componentFactoryOrType);
    let index;
    if (isComponentFactory) {
      if (ngDevMode) {
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(typeof indexOrOptions !== 'object', true, 'It looks like Component factory was provided as the first argument ' + 'and an options object as the second argument. This combination of arguments ' + 'is incompatible. You can either change the first argument to provide Component ' + 'type or change the second argument to be a number (representing an index at ' + "which to insert the new component's host view into this container)");
      }
      index = indexOrOptions;
    } else {
      if (ngDevMode) {
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(componentFactoryOrType), `Provided Component class doesn't contain Component definition. ` + `Please check whether provided class has @Component decorator.`);
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(typeof indexOrOptions !== 'number', true, 'It looks like Component type was provided as the first argument ' + "and a number (representing an index at which to insert the new component's " + 'host view into this container as the second argument. This combination of arguments ' + 'is incompatible. Please use an object as the second argument instead.');
      }
      const options = indexOrOptions || {};
      if (ngDevMode && options.environmentInjector && options.ngModuleRef) {
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)(`Cannot pass both environmentInjector and ngModuleRef options to createComponent().`);
      }
      index = options.index;
      injector = options.injector;
      projectableNodes = options.projectableNodes;
      environmentInjector = options.environmentInjector || options.ngModuleRef;
      directives = options.directives;
      bindings = options.bindings;
    }
    const componentFactory = isComponentFactory ? componentFactoryOrType : new ComponentFactory((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(componentFactoryOrType));
    const contextInjector = injector || this.parentInjector;
    if (!environmentInjector && componentFactory.ngModule == null) {
      const _injector = isComponentFactory ? contextInjector : this.parentInjector;
      const result = _injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EnvironmentInjector, null);
      if (result) {
        environmentInjector = result;
      }
    }
    const componentDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(componentFactory.componentType ?? {});
    const dehydratedView = findMatchingDehydratedView(this._lContainer, componentDef?.id ?? null);
    const rNode = dehydratedView?.firstChild ?? null;
    const componentRef = componentFactory.create(contextInjector, projectableNodes, rNode, environmentInjector, directives, bindings);
    this.insertImpl(componentRef.hostView, index, shouldAddViewToDom(this._hostTNode, dehydratedView));
    return componentRef;
  }
  insert(viewRef, index) {
    return this.insertImpl(viewRef, index, true);
  }
  insertImpl(viewRef, index, addToDOM) {
    const lView = viewRef._lView;
    if (ngDevMode && viewRef.destroyed) {
      throw new Error('Cannot insert a destroyed View in a ViewContainer!');
    }
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.viewAttachedToContainer)(lView)) {
      const prevIdx = this.indexOf(viewRef);
      if (prevIdx !== -1) {
        this.detach(prevIdx);
      } else {
        const prevLContainer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT];
        ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(prevLContainer), true, 'An attached view should have its PARENT point to a container.');
        const prevVCRef = new R3ViewContainerRef(prevLContainer, prevLContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST], prevLContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT]);
        prevVCRef.detach(prevVCRef.indexOf(viewRef));
      }
    }
    const adjustedIdx = this._adjustIndex(index);
    const lContainer = this._lContainer;
    addLViewToLContainer(lContainer, lView, adjustedIdx, addToDOM);
    viewRef.attachToViewContainerRef();
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.addToArray)(getOrCreateViewRefs(lContainer), adjustedIdx, viewRef);
    return viewRef;
  }
  move(viewRef, newIndex) {
    if (ngDevMode && viewRef.destroyed) {
      throw new Error('Cannot move a destroyed View in a ViewContainer!');
    }
    return this.insert(viewRef, newIndex);
  }
  indexOf(viewRef) {
    const viewRefsArr = getViewRefs(this._lContainer);
    return viewRefsArr !== null ? viewRefsArr.indexOf(viewRef) : -1;
  }
  remove(index) {
    const adjustedIdx = this._adjustIndex(index, -1);
    const detachedView = detachView(this._lContainer, adjustedIdx);
    if (detachedView) {
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.removeFromArray)(getOrCreateViewRefs(this._lContainer), adjustedIdx);
      destroyLView(detachedView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], detachedView);
    }
  }
  detach(index) {
    const adjustedIdx = this._adjustIndex(index, -1);
    const view = detachView(this._lContainer, adjustedIdx);
    const wasDetached = view && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.removeFromArray)(getOrCreateViewRefs(this._lContainer), adjustedIdx) != null;
    return wasDetached ? new ViewRef(view) : null;
  }
  _adjustIndex(index, shift = 0) {
    if (index == null) {
      return this.length + shift;
    }
    if (ngDevMode) {
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertGreaterThan)(index, -1, `ViewRef index must be positive, got ${index}`);
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLessThan)(index, this.length + 1 + shift, 'index');
    }
    return index;
  }
};
function getViewRefs(lContainer) {
  return lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.VIEW_REFS];
}
function getOrCreateViewRefs(lContainer) {
  return lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.VIEW_REFS] || (lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.VIEW_REFS] = []);
}
function createContainerRef(hostTNode, hostLView) {
  ngDevMode && assertTNodeType(hostTNode, 12 | 3);
  let lContainer;
  const slotValue = hostLView[hostTNode.index];
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(slotValue)) {
    lContainer = slotValue;
  } else {
    lContainer = createLContainer(slotValue, hostLView, null, hostTNode);
    hostLView[hostTNode.index] = lContainer;
    addToEndOfViewTree(hostLView, lContainer);
  }
  _locateOrCreateAnchorNode(lContainer, hostLView, hostTNode, slotValue);
  return new R3ViewContainerRef(lContainer, hostTNode, hostLView);
}
function insertAnchorNode(hostLView, hostTNode) {
  const renderer = hostLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  const commentNode = renderer.createComment(ngDevMode ? 'container' : '');
  const hostNative = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(hostTNode, hostLView);
  const parentOfHostNative = renderer.parentNode(hostNative);
  nativeInsertBefore(renderer, parentOfHostNative, commentNode, renderer.nextSibling(hostNative), false);
  return commentNode;
}
let _locateOrCreateAnchorNode = createAnchorNode;
let _populateDehydratedViewsInLContainer = () => false;
function populateDehydratedViewsInLContainer(lContainer, tNode, hostLView) {
  return _populateDehydratedViewsInLContainer(lContainer, tNode, hostLView);
}
function createAnchorNode(lContainer, hostLView, hostTNode, slotValue) {
  if (lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NATIVE]) return;
  let commentNode;
  if (hostTNode.type & 8) {
    commentNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(slotValue);
  } else {
    commentNode = insertAnchorNode(hostLView, hostTNode);
  }
  lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NATIVE] = commentNode;
}
function populateDehydratedViewsInLContainerImpl(lContainer, tNode, hostLView) {
  if (lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NATIVE] && lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DEHYDRATED_VIEWS]) {
    return true;
  }
  const hydrationInfo = hostLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION];
  const noOffsetIndex = tNode.index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock(tNode) || isDisconnectedNode$1(hydrationInfo, noOffsetIndex);
  if (isNodeCreationMode) {
    return false;
  }
  const currentRNode = getSegmentHead(hydrationInfo, noOffsetIndex);
  const serializedViews = hydrationInfo.data[CONTAINERS]?.[noOffsetIndex];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(serializedViews, 'Unexpected state: no hydration info available for a given TNode, ' + 'which represents a view container.');
  const [commentNode, dehydratedViews] = locateDehydratedViewsInContainer(currentRNode, serializedViews);
  if (ngDevMode) {
    validateMatchingNode(commentNode, Node.COMMENT_NODE, null, hostLView, tNode, true);
    markRNodeAsClaimedByHydration(commentNode, false);
  }
  lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NATIVE] = commentNode;
  lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DEHYDRATED_VIEWS] = dehydratedViews;
  return true;
}
function locateOrCreateAnchorNode(lContainer, hostLView, hostTNode, slotValue) {
  if (!_populateDehydratedViewsInLContainer(lContainer, hostTNode, hostLView)) {
    createAnchorNode(lContainer, hostLView, hostTNode, slotValue);
  }
}
function enableLocateOrCreateContainerRefImpl() {
  _locateOrCreateAnchorNode = locateOrCreateAnchorNode;
  _populateDehydratedViewsInLContainer = populateDehydratedViewsInLContainerImpl;
}
class LQuery_ {
  queryList;
  matches = null;
  constructor(queryList) {
    this.queryList = queryList;
  }
  clone() {
    return new LQuery_(this.queryList);
  }
  setDirty() {
    this.queryList.setDirty();
  }
}
class LQueries_ {
  queries;
  constructor(queries = []) {
    this.queries = queries;
  }
  createEmbeddedView(tView) {
    const tQueries = tView.queries;
    if (tQueries !== null) {
      const noOfInheritedQueries = tView.contentQueries !== null ? tView.contentQueries[0] : tQueries.length;
      const viewLQueries = [];
      for (let i = 0; i < noOfInheritedQueries; i++) {
        const tQuery = tQueries.getByIndex(i);
        const parentLQuery = this.queries[tQuery.indexInDeclarationView];
        viewLQueries.push(parentLQuery.clone());
      }
      return new LQueries_(viewLQueries);
    }
    return null;
  }
  insertView(tView) {
    this.dirtyQueriesWithMatches(tView);
  }
  detachView(tView) {
    this.dirtyQueriesWithMatches(tView);
  }
  finishViewCreation(tView) {
    this.dirtyQueriesWithMatches(tView);
  }
  dirtyQueriesWithMatches(tView) {
    for (let i = 0; i < this.queries.length; i++) {
      if (getTQuery(tView, i).matches !== null) {
        this.queries[i].setDirty();
      }
    }
  }
}
class TQueryMetadata_ {
  flags;
  read;
  predicate;
  constructor(predicate, flags, read = null) {
    this.flags = flags;
    this.read = read;
    if (typeof predicate === 'string') {
      this.predicate = splitQueryMultiSelectors(predicate);
    } else {
      this.predicate = predicate;
    }
  }
}
class TQueries_ {
  queries;
  constructor(queries = []) {
    this.queries = queries;
  }
  elementStart(tView, tNode) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView, 'Queries should collect results on the first template pass only');
    for (let i = 0; i < this.queries.length; i++) {
      this.queries[i].elementStart(tView, tNode);
    }
  }
  elementEnd(tNode) {
    for (let i = 0; i < this.queries.length; i++) {
      this.queries[i].elementEnd(tNode);
    }
  }
  embeddedTView(tNode) {
    let queriesForTemplateRef = null;
    for (let i = 0; i < this.length; i++) {
      const childQueryIndex = queriesForTemplateRef !== null ? queriesForTemplateRef.length : 0;
      const tqueryClone = this.getByIndex(i).embeddedTView(tNode, childQueryIndex);
      if (tqueryClone) {
        tqueryClone.indexInDeclarationView = i;
        if (queriesForTemplateRef !== null) {
          queriesForTemplateRef.push(tqueryClone);
        } else {
          queriesForTemplateRef = [tqueryClone];
        }
      }
    }
    return queriesForTemplateRef !== null ? new TQueries_(queriesForTemplateRef) : null;
  }
  template(tView, tNode) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView, 'Queries should collect results on the first template pass only');
    for (let i = 0; i < this.queries.length; i++) {
      this.queries[i].template(tView, tNode);
    }
  }
  getByIndex(index) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(this.queries, index);
    return this.queries[index];
  }
  get length() {
    return this.queries.length;
  }
  track(tquery) {
    this.queries.push(tquery);
  }
}
class TQuery_ {
  metadata;
  matches = null;
  indexInDeclarationView = -1;
  crossesNgTemplate = false;
  _declarationNodeIndex;
  _appliesToNextNode = true;
  constructor(metadata, nodeIndex = -1) {
    this.metadata = metadata;
    this._declarationNodeIndex = nodeIndex;
  }
  elementStart(tView, tNode) {
    if (this.isApplyingToNode(tNode)) {
      this.matchTNode(tView, tNode);
    }
  }
  elementEnd(tNode) {
    if (this._declarationNodeIndex === tNode.index) {
      this._appliesToNextNode = false;
    }
  }
  template(tView, tNode) {
    this.elementStart(tView, tNode);
  }
  embeddedTView(tNode, childQueryIndex) {
    if (this.isApplyingToNode(tNode)) {
      this.crossesNgTemplate = true;
      this.addMatch(-tNode.index, childQueryIndex);
      return new TQuery_(this.metadata);
    }
    return null;
  }
  isApplyingToNode(tNode) {
    if (this._appliesToNextNode && (this.metadata.flags & 1) !== 1) {
      const declarationNodeIdx = this._declarationNodeIndex;
      let parent = tNode.parent;
      while (parent !== null && parent.type & 8 && parent.index !== declarationNodeIdx) {
        parent = parent.parent;
      }
      return declarationNodeIdx === (parent !== null ? parent.index : -1);
    }
    return this._appliesToNextNode;
  }
  matchTNode(tView, tNode) {
    const predicate = this.metadata.predicate;
    if (Array.isArray(predicate)) {
      for (let i = 0; i < predicate.length; i++) {
        const name = predicate[i];
        this.matchTNodeWithReadOption(tView, tNode, getIdxOfMatchingSelector(tNode, name));
        this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, name, false, false));
      }
    } else {
      if (predicate === TemplateRef) {
        if (tNode.type & 4) {
          this.matchTNodeWithReadOption(tView, tNode, -1);
        }
      } else {
        this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, predicate, false, false));
      }
    }
  }
  matchTNodeWithReadOption(tView, tNode, nodeMatchIdx) {
    if (nodeMatchIdx !== null) {
      const read = this.metadata.read;
      if (read !== null) {
        if (read === ElementRef || read === ViewContainerRef || read === TemplateRef && tNode.type & 4) {
          this.addMatch(tNode.index, -2);
        } else {
          const directiveOrProviderIdx = locateDirectiveOrProvider(tNode, tView, read, false, false);
          if (directiveOrProviderIdx !== null) {
            this.addMatch(tNode.index, directiveOrProviderIdx);
          }
        }
      } else {
        this.addMatch(tNode.index, nodeMatchIdx);
      }
    }
  }
  addMatch(tNodeIdx, matchIdx) {
    if (this.matches === null) {
      this.matches = [tNodeIdx, matchIdx];
    } else {
      this.matches.push(tNodeIdx, matchIdx);
    }
  }
}
function getIdxOfMatchingSelector(tNode, selector) {
  const localNames = tNode.localNames;
  if (localNames !== null) {
    for (let i = 0; i < localNames.length; i += 2) {
      if (localNames[i] === selector) {
        return localNames[i + 1];
      }
    }
  }
  return null;
}
function createResultByTNodeType(tNode, currentView) {
  if (tNode.type & (3 | 8)) {
    return createElementRef(tNode, currentView);
  } else if (tNode.type & 4) {
    return createTemplateRef(tNode, currentView);
  }
  return null;
}
function createResultForNode(lView, tNode, matchingIdx, read) {
  if (matchingIdx === -1) {
    return createResultByTNodeType(tNode, lView);
  } else if (matchingIdx === -2) {
    return createSpecialToken(lView, tNode, read);
  } else {
    return getNodeInjectable(lView, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], matchingIdx, tNode);
  }
}
function createSpecialToken(lView, tNode, read) {
  if (read === ElementRef) {
    return createElementRef(tNode, lView);
  } else if (read === TemplateRef) {
    return createTemplateRef(tNode, lView);
  } else if (read === ViewContainerRef) {
    ngDevMode && assertTNodeType(tNode, 3 | 12);
    return createContainerRef(tNode, lView);
  } else {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)(`Special token to read should be one of ElementRef, TemplateRef or ViewContainerRef but got ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringify)(read)}.`);
  }
}
function materializeViewResults(tView, lView, tQuery, queryIndex) {
  const lQuery = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.QUERIES].queries[queryIndex];
  if (lQuery.matches === null) {
    const tViewData = tView.data;
    const tQueryMatches = tQuery.matches;
    const result = [];
    for (let i = 0; tQueryMatches !== null && i < tQueryMatches.length; i += 2) {
      const matchedNodeIdx = tQueryMatches[i];
      if (matchedNodeIdx < 0) {
        result.push(null);
      } else {
        ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(tViewData, matchedNodeIdx);
        const tNode = tViewData[matchedNodeIdx];
        result.push(createResultForNode(lView, tNode, tQueryMatches[i + 1], tQuery.metadata.read));
      }
    }
    lQuery.matches = result;
  }
  return lQuery.matches;
}
function collectQueryResults(tView, lView, queryIndex, result) {
  const tQuery = tView.queries.getByIndex(queryIndex);
  const tQueryMatches = tQuery.matches;
  if (tQueryMatches !== null) {
    const lViewResults = materializeViewResults(tView, lView, tQuery, queryIndex);
    for (let i = 0; i < tQueryMatches.length; i += 2) {
      const tNodeIdx = tQueryMatches[i];
      if (tNodeIdx > 0) {
        result.push(lViewResults[i / 2]);
      } else {
        const childQueryIndex = tQueryMatches[i + 1];
        const declarationLContainer = lView[-tNodeIdx];
        ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLContainer)(declarationLContainer);
        for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET; i < declarationLContainer.length; i++) {
          const embeddedLView = declarationLContainer[i];
          if (embeddedLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_LCONTAINER] === embeddedLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT]) {
            collectQueryResults(embeddedLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], embeddedLView, childQueryIndex, result);
          }
        }
        if (declarationLContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.MOVED_VIEWS] !== null) {
          const embeddedLViews = declarationLContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.MOVED_VIEWS];
          for (let i = 0; i < embeddedLViews.length; i++) {
            const embeddedLView = embeddedLViews[i];
            collectQueryResults(embeddedLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], embeddedLView, childQueryIndex, result);
          }
        }
      }
    }
  }
  return result;
}
function loadQueryInternal(lView, queryIndex) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.QUERIES], 'LQueries should be defined when trying to load a query');
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.QUERIES].queries, queryIndex);
  return lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.QUERIES].queries[queryIndex].queryList;
}
function createLQuery(tView, lView, flags) {
  const queryList = new QueryList((flags & 4) === 4);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.storeCleanupWithContext)(tView, lView, queryList, queryList.destroy);
  const lQueries = (lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.QUERIES] ??= new LQueries_()).queries;
  return lQueries.push(new LQuery_(queryList)) - 1;
}
function createViewQuery(predicate, flags, read) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(flags, 'Expecting flags');
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  if (tView.firstCreatePass) {
    createTQuery(tView, new TQueryMetadata_(predicate, flags, read), -1);
    if ((flags & 2) === 2) {
      tView.staticViewQueries = true;
    }
  }
  return createLQuery(tView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), flags);
}
function createContentQuery(directiveIndex, predicate, flags, read) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(flags, 'Expecting flags');
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  if (tView.firstCreatePass) {
    const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
    createTQuery(tView, new TQueryMetadata_(predicate, flags, read), tNode.index);
    saveContentQueryAndDirectiveIndex(tView, directiveIndex);
    if ((flags & 2) === 2) {
      tView.staticContentQueries = true;
    }
  }
  return createLQuery(tView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), flags);
}
function splitQueryMultiSelectors(locator) {
  return locator.split(',').map(s => s.trim());
}
function createTQuery(tView, metadata, nodeIndex) {
  if (tView.queries === null) tView.queries = new TQueries_();
  tView.queries.track(new TQuery_(metadata, nodeIndex));
}
function saveContentQueryAndDirectiveIndex(tView, directiveIndex) {
  const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);
  const lastSavedDirectiveIndex = tViewContentQueries.length ? tViewContentQueries[tViewContentQueries.length - 1] : -1;
  if (directiveIndex !== lastSavedDirectiveIndex) {
    tViewContentQueries.push(tView.queries.length - 1, directiveIndex);
  }
}
function getTQuery(tView, index) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(tView.queries, 'TQueries must be defined to retrieve a TQuery');
  return tView.queries.getByIndex(index);
}
function getQueryResults(lView, queryIndex) {
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const tQuery = getTQuery(tView, queryIndex);
  return tQuery.crossesNgTemplate ? collectQueryResults(tView, lView, queryIndex, []) : materializeViewResults(tView, lView, tQuery, queryIndex);
}
function createQuerySignalFn(firstOnly, required, opts) {
  let node;
  const signalFn = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.createComputed)(() => {
    node._dirtyCounter();
    const value = refreshSignalQuery(node, firstOnly);
    if (required && value === undefined) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-951, ngDevMode && 'Child query result is required but no value is available.');
    }
    return value;
  });
  node = signalFn[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SIGNAL];
  node._dirtyCounter = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.signal)(0);
  node._flatValue = undefined;
  if (ngDevMode) {
    signalFn.toString = () => `[Query Signal]`;
    node.debugName = opts?.debugName;
  }
  return signalFn;
}
function createSingleResultOptionalQuerySignalFn(opts) {
  return createQuerySignalFn(true, false, opts);
}
function createSingleResultRequiredQuerySignalFn(opts) {
  return createQuerySignalFn(true, true, opts);
}
function createMultiResultQuerySignalFn(opts) {
  return createQuerySignalFn(false, false, opts);
}
function bindQueryToSignal(target, queryIndex) {
  const node = target[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SIGNAL];
  node._lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  node._queryIndex = queryIndex;
  node._queryList = loadQueryInternal(node._lView, queryIndex);
  node._queryList.onDirty(() => node._dirtyCounter.update(v => v + 1));
}
function refreshSignalQuery(node, firstOnly) {
  const lView = node._lView;
  const queryIndex = node._queryIndex;
  if (lView === undefined || queryIndex === undefined || lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] & 4) {
    return firstOnly ? undefined : _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY;
  }
  const queryList = loadQueryInternal(lView, queryIndex);
  const results = getQueryResults(lView, queryIndex);
  queryList.reset(results, unwrapElementRef);
  if (firstOnly) {
    return queryList.first;
  } else {
    const resultChanged = queryList._changesDetected;
    if (resultChanged || node._flatValue === undefined) {
      return node._flatValue = queryList.toArray();
    }
    return node._flatValue;
  }
}
let componentResourceResolutionQueue = new Map();
const componentDefPendingResolution = new Set();
function resolveComponentResources(_x) {
  return _resolveComponentResources.apply(this, arguments);
}
function _resolveComponentResources() {
  _resolveComponentResources = (0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (resourceResolver) {
    const currentQueue = componentResourceResolutionQueue;
    componentResourceResolutionQueue = new Map();
    const urlCache = new Map();
    function cachedResourceResolve(url) {
      const promiseCached = urlCache.get(url);
      if (promiseCached) {
        return promiseCached;
      }
      const promise = resourceResolver(url).then(response => unwrapResponse(url, response));
      urlCache.set(url, promise);
      return promise;
    }
    const resolutionPromises = Array.from(currentQueue).map(/*#__PURE__*/function () {
      var _ref = (0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* ([type, component]) {
        if (component.styleUrl && component.styleUrls?.length) {
          throw new Error('@Component cannot define both `styleUrl` and `styleUrls`. ' + 'Use `styleUrl` if the component has one stylesheet, or `styleUrls` if it has multiple');
        }
        const componentTasks = [];
        if (component.templateUrl) {
          componentTasks.push(cachedResourceResolve(component.templateUrl).then(template => {
            component.template = template;
          }));
        }
        const styles = typeof component.styles === 'string' ? [component.styles] : component.styles ?? [];
        component.styles = styles;
        let {
          styleUrl,
          styleUrls
        } = component;
        if (styleUrl) {
          styleUrls = [styleUrl];
          component.styleUrl = undefined;
        }
        if (styleUrls?.length) {
          const allFetched = Promise.all(styleUrls.map(url => cachedResourceResolve(url))).then(fetchedStyles => {
            styles.push(...fetchedStyles);
            component.styleUrls = undefined;
          });
          componentTasks.push(allFetched);
        }
        yield Promise.all(componentTasks);
        componentDefPendingResolution.delete(type);
      });
      return function (_x1) {
        return _ref.apply(this, arguments);
      };
    }());
    yield Promise.all(resolutionPromises);
  });
  return _resolveComponentResources.apply(this, arguments);
}
function maybeQueueResolutionOfComponentResources(type, metadata) {
  if (componentNeedsResolution(metadata)) {
    componentResourceResolutionQueue.set(type, metadata);
    componentDefPendingResolution.add(type);
  }
}
function isComponentDefPendingResolution(type) {
  return componentDefPendingResolution.has(type);
}
function componentNeedsResolution(component) {
  return !!(component.templateUrl && !component.hasOwnProperty('template') || component.styleUrls?.length || component.styleUrl);
}
function clearResolutionOfComponentResourcesQueue() {
  const old = componentResourceResolutionQueue;
  componentResourceResolutionQueue = new Map();
  return old;
}
function restoreComponentResolutionQueue(queue) {
  componentDefPendingResolution.clear();
  for (const type of queue.keys()) {
    componentDefPendingResolution.add(type);
  }
  componentResourceResolutionQueue = queue;
}
function isComponentResourceResolutionQueueEmpty() {
  return componentResourceResolutionQueue.size === 0;
}
function unwrapResponse(_x2, _x3) {
  return _unwrapResponse.apply(this, arguments);
}
function _unwrapResponse() {
  _unwrapResponse = (0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (url, response) {
    if (typeof response === 'string') {
      return response;
    }
    if (response.status !== undefined && response.status !== 200) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(918, ngDevMode && `Could not load resource: ${url}. Response status: ${response.status}`);
    }
    return response.text();
  });
  return _unwrapResponse.apply(this, arguments);
}
const modules = new Map();
let checkForDuplicateNgModules = true;
function assertSameOrNotExisting(id, type, incoming) {
  if (type && type !== incoming && checkForDuplicateNgModules) {
    throw new Error(`Duplicate module registered for ${id} - ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringify)(type)} vs ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringify)(type.name)}`);
  }
}
function registerNgModuleType(ngModuleType, id) {
  const existing = modules.get(id) || null;
  assertSameOrNotExisting(id, existing, ngModuleType);
  modules.set(id, ngModuleType);
}
function getRegisteredNgModuleType(id) {
  return modules.get(id);
}
function setAllowDuplicateNgModuleIdsForTest(allowDuplicates) {
  checkForDuplicateNgModules = !allowDuplicates;
}
let NgModuleRef$1 = class NgModuleRef {};
let NgModuleFactory$1 = class NgModuleFactory {};
function createNgModule(ngModule, parentInjector) {
  return new NgModuleRef(ngModule, parentInjector ?? null, []);
}
const createNgModuleRef = createNgModule;
class NgModuleRef extends NgModuleRef$1 {
  ngModuleType;
  _parent;
  _bootstrapComponents = [];
  _r3Injector;
  instance;
  destroyCbs = [];
  componentFactoryResolver = new ComponentFactoryResolver(this);
  constructor(ngModuleType, _parent, additionalProviders, runInjectorInitializers = true) {
    super();
    this.ngModuleType = ngModuleType;
    this._parent = _parent;
    const ngModuleDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNgModuleDef)(ngModuleType);
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(ngModuleDef, `NgModule '${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringify)(ngModuleType)}' is not a subtype of 'NgModuleType'.`);
    this._bootstrapComponents = maybeUnwrapFn(ngModuleDef.bootstrap);
    this._r3Injector = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.createInjectorWithoutInjectorInstances)(ngModuleType, _parent, [{
      provide: NgModuleRef$1,
      useValue: this
    }, {
      provide: ComponentFactoryResolver$1,
      useValue: this.componentFactoryResolver
    }, ...additionalProviders], (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringify)(ngModuleType), new Set(['environment']));
    if (runInjectorInitializers) {
      this.resolveInjectorInitializers();
    }
  }
  resolveInjectorInitializers() {
    this._r3Injector.resolveInjectorInitializers();
    this.instance = this._r3Injector.get(this.ngModuleType);
  }
  get injector() {
    return this._r3Injector;
  }
  destroy() {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(this.destroyCbs, 'NgModule already destroyed');
    const injector = this._r3Injector;
    !injector.destroyed && injector.destroy();
    this.destroyCbs.forEach(fn => fn());
    this.destroyCbs = null;
  }
  onDestroy(callback) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(this.destroyCbs, 'NgModule already destroyed');
    this.destroyCbs.push(callback);
  }
}
class NgModuleFactory extends NgModuleFactory$1 {
  moduleType;
  constructor(moduleType) {
    super();
    this.moduleType = moduleType;
  }
  create(parentInjector) {
    return new NgModuleRef(this.moduleType, parentInjector, []);
  }
}
function createNgModuleRefWithProviders(moduleType, parentInjector, additionalProviders) {
  return new NgModuleRef(moduleType, parentInjector, additionalProviders, false);
}
class EnvironmentNgModuleRefAdapter extends NgModuleRef$1 {
  injector;
  componentFactoryResolver = new ComponentFactoryResolver(this);
  instance = null;
  constructor(config) {
    super();
    const injector = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.R3Injector([...config.providers, {
      provide: NgModuleRef$1,
      useValue: this
    }, {
      provide: ComponentFactoryResolver$1,
      useValue: this.componentFactoryResolver
    }], config.parent || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNullInjector)(), config.debugName, new Set(['environment']));
    this.injector = injector;
    if (config.runEnvironmentInitializers) {
      injector.resolveInjectorInitializers();
    }
  }
  destroy() {
    this.injector.destroy();
  }
  onDestroy(callback) {
    this.injector.onDestroy(callback);
  }
}
function createEnvironmentInjector(providers, parent, debugName = null) {
  const adapter = new EnvironmentNgModuleRefAdapter({
    providers,
    parent,
    debugName,
    runEnvironmentInitializers: true
  });
  return adapter.injector;
}
class StandaloneService {
  _injector;
  cachedInjectors = new Map();
  constructor(_injector) {
    this._injector = _injector;
  }
  getOrCreateStandaloneInjector(componentDef) {
    if (!componentDef.standalone) {
      return null;
    }
    if (!this.cachedInjectors.has(componentDef)) {
      const providers = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.internalImportProvidersFrom)(false, componentDef.type);
      const standaloneInjector = providers.length > 0 ? createEnvironmentInjector([providers], this._injector, `Standalone[${componentDef.type.name}]`) : null;
      this.cachedInjectors.set(componentDef, standaloneInjector);
    }
    return this.cachedInjectors.get(componentDef);
  }
  ngOnDestroy() {
    try {
      for (const injector of this.cachedInjectors.values()) {
        if (injector !== null) {
          injector.destroy();
        }
      }
    } finally {
      this.cachedInjectors.clear();
    }
  }
  static ɵprov = /* @__PURE__ */
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
    token: StandaloneService,
    providedIn: 'environment',
    factory: () => new StandaloneService((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EnvironmentInjector))
  });
}
function ɵɵdefineComponent(componentDefinition) {
  return noSideEffects(() => {
    (typeof ngDevMode === 'undefined' || ngDevMode) && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.initNgDevMode)();
    const baseDef = getNgDirectiveDef(componentDefinition);
    const def = {
      ...baseDef,
      decls: componentDefinition.decls,
      vars: componentDefinition.vars,
      template: componentDefinition.template,
      consts: componentDefinition.consts || null,
      ngContentSelectors: componentDefinition.ngContentSelectors,
      onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,
      directiveDefs: null,
      pipeDefs: null,
      dependencies: baseDef.standalone && componentDefinition.dependencies || null,
      getStandaloneInjector: baseDef.standalone ? parentInjector => {
        return parentInjector.get(StandaloneService).getOrCreateStandaloneInjector(def);
      } : null,
      getExternalStyles: null,
      signals: componentDefinition.signals ?? false,
      data: componentDefinition.data || {},
      encapsulation: componentDefinition.encapsulation || ViewEncapsulation.Emulated,
      styles: componentDefinition.styles || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY,
      _: null,
      schemas: componentDefinition.schemas || null,
      tView: null,
      id: ''
    };
    if (baseDef.standalone) {
      performanceMarkFeature('NgStandalone');
    }
    initFeatures(def);
    const dependencies = componentDefinition.dependencies;
    def.directiveDefs = extractDefListOrFactory(dependencies, extractDirectiveDef);
    def.pipeDefs = extractDefListOrFactory(dependencies, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getPipeDef);
    def.id = getComponentId(def);
    return def;
  });
}
function extractDirectiveDef(type) {
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type) || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(type);
}
function ɵɵdefineNgModule(def) {
  return noSideEffects(() => {
    const res = {
      type: def.type,
      bootstrap: def.bootstrap || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY,
      declarations: def.declarations || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY,
      imports: def.imports || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY,
      exports: def.exports || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY,
      transitiveCompileScopes: null,
      schemas: def.schemas || null,
      id: def.id || null
    };
    return res;
  });
}
function parseAndConvertInputsForDefinition(obj, declaredInputs) {
  if (obj == null) return _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
  const newLookup = {};
  for (const minifiedKey in obj) {
    if (obj.hasOwnProperty(minifiedKey)) {
      const value = obj[minifiedKey];
      let publicName;
      let declaredName;
      let inputFlags;
      let transform;
      if (Array.isArray(value)) {
        inputFlags = value[0];
        publicName = value[1];
        declaredName = value[2] ?? publicName;
        transform = value[3] || null;
      } else {
        publicName = value;
        declaredName = value;
        inputFlags = InputFlags.None;
        transform = null;
      }
      newLookup[publicName] = [minifiedKey, inputFlags, transform];
      declaredInputs[publicName] = declaredName;
    }
  }
  return newLookup;
}
function parseAndConvertOutputsForDefinition(obj) {
  if (obj == null) return _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
  const newLookup = {};
  for (const minifiedKey in obj) {
    if (obj.hasOwnProperty(minifiedKey)) {
      newLookup[obj[minifiedKey]] = minifiedKey;
    }
  }
  return newLookup;
}
function ɵɵdefineDirective(directiveDefinition) {
  return noSideEffects(() => {
    const def = getNgDirectiveDef(directiveDefinition);
    initFeatures(def);
    return def;
  });
}
function ɵɵdefinePipe(pipeDef) {
  return {
    type: pipeDef.type,
    name: pipeDef.name,
    factory: null,
    pure: pipeDef.pure !== false,
    standalone: pipeDef.standalone ?? true,
    onDestroy: pipeDef.type.prototype.ngOnDestroy || null
  };
}
function getNgDirectiveDef(directiveDefinition) {
  const declaredInputs = {};
  return {
    type: directiveDefinition.type,
    providersResolver: null,
    viewProvidersResolver: null,
    factory: null,
    hostBindings: directiveDefinition.hostBindings || null,
    hostVars: directiveDefinition.hostVars || 0,
    hostAttrs: directiveDefinition.hostAttrs || null,
    contentQueries: directiveDefinition.contentQueries || null,
    declaredInputs: declaredInputs,
    inputConfig: directiveDefinition.inputs || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    exportAs: directiveDefinition.exportAs || null,
    standalone: directiveDefinition.standalone ?? true,
    signals: directiveDefinition.signals === true,
    selectors: directiveDefinition.selectors || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY,
    viewQuery: directiveDefinition.viewQuery || null,
    features: directiveDefinition.features || null,
    setInput: null,
    resolveHostDirectives: null,
    hostDirectives: null,
    inputs: parseAndConvertInputsForDefinition(directiveDefinition.inputs, declaredInputs),
    outputs: parseAndConvertOutputsForDefinition(directiveDefinition.outputs),
    debugInfo: null
  };
}
function initFeatures(definition) {
  definition.features?.forEach(fn => fn(definition));
}
function extractDefListOrFactory(dependencies, defExtractor) {
  if (!dependencies) {
    return null;
  }
  return () => {
    const resolvedDependencies = typeof dependencies === 'function' ? dependencies() : dependencies;
    const result = [];
    for (const dep of resolvedDependencies) {
      const definition = defExtractor(dep);
      if (definition !== null) {
        result.push(definition);
      }
    }
    return result;
  };
}
const GENERATED_COMP_IDS = new Map();
function getComponentId(componentDef) {
  let hash = 0;
  const componentDefConsts = typeof componentDef.consts === 'function' ? '' : componentDef.consts;
  const hashSelectors = [componentDef.selectors, componentDef.ngContentSelectors, componentDef.hostVars, componentDef.hostAttrs, componentDefConsts, componentDef.vars, componentDef.decls, componentDef.encapsulation, componentDef.standalone, componentDef.signals, componentDef.exportAs, JSON.stringify(componentDef.inputs), JSON.stringify(componentDef.outputs), Object.getOwnPropertyNames(componentDef.type.prototype), !!componentDef.contentQueries, !!componentDef.viewQuery];
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
    for (const item of hashSelectors) {
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotEqual)(typeof item, 'function', 'Internal error: attempting to use a function in component id computation logic.');
    }
  }
  for (const char of hashSelectors.join('|')) {
    hash = Math.imul(31, hash) + char.charCodeAt(0) << 0;
  }
  hash += 2147483647 + 1;
  const compId = 'c' + hash;
  if ((typeof ngDevMode === 'undefined' || ngDevMode) && (typeof ngServerMode === 'undefined' || !ngServerMode)) {
    if (GENERATED_COMP_IDS.has(compId)) {
      const previousCompDefType = GENERATED_COMP_IDS.get(compId);
      if (previousCompDefType !== componentDef.type) {
        console.warn((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(-912, `Component ID generation collision detected. Components '${previousCompDefType.name}' and '${componentDef.type.name}' with selector '${stringifyCSSSelectorList(componentDef.selectors)}' generated the same component ID. To fix this, you can change the selector of one of those components or add an extra host attribute to force a different ID.`));
      }
    } else {
      GENERATED_COMP_IDS.set(compId, componentDef.type);
    }
  }
  return compId;
}
function ɵɵHostDirectivesFeature(rawHostDirectives) {
  const feature = definition => {
    const isEager = Array.isArray(rawHostDirectives);
    if (definition.hostDirectives === null) {
      definition.resolveHostDirectives = resolveHostDirectives;
      definition.hostDirectives = isEager ? rawHostDirectives.map(createHostDirectiveDef) : [rawHostDirectives];
    } else if (isEager) {
      definition.hostDirectives.unshift(...rawHostDirectives.map(createHostDirectiveDef));
    } else {
      definition.hostDirectives.unshift(rawHostDirectives);
    }
  };
  feature.ngInherit = true;
  return feature;
}
function resolveHostDirectives(matches) {
  const allDirectiveDefs = [];
  let hasComponent = false;
  let hostDirectiveDefs = null;
  let hostDirectiveRanges = null;
  for (let i = 0; i < matches.length; i++) {
    const def = matches[i];
    if (def.hostDirectives !== null) {
      const start = allDirectiveDefs.length;
      hostDirectiveDefs ??= new Map();
      hostDirectiveRanges ??= new Map();
      findHostDirectiveDefs(def, allDirectiveDefs, hostDirectiveDefs);
      hostDirectiveRanges.set(def, [start, allDirectiveDefs.length - 1]);
    }
    if (i === 0 && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentDef)(def)) {
      hasComponent = true;
      allDirectiveDefs.push(def);
    }
  }
  for (let i = hasComponent ? 1 : 0; i < matches.length; i++) {
    allDirectiveDefs.push(matches[i]);
  }
  return [allDirectiveDefs, hostDirectiveDefs, hostDirectiveRanges];
}
function findHostDirectiveDefs(currentDef, matchedDefs, hostDirectiveDefs) {
  if (currentDef.hostDirectives !== null) {
    for (const configOrFn of currentDef.hostDirectives) {
      if (typeof configOrFn === 'function') {
        const resolved = configOrFn();
        for (const config of resolved) {
          trackHostDirectiveDef(createHostDirectiveDef(config), matchedDefs, hostDirectiveDefs);
        }
      } else {
        trackHostDirectiveDef(configOrFn, matchedDefs, hostDirectiveDefs);
      }
    }
  }
}
function trackHostDirectiveDef(def, matchedDefs, hostDirectiveDefs) {
  const hostDirectiveDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(def.directive);
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
    validateHostDirective(def, hostDirectiveDef);
  }
  patchDeclaredInputs(hostDirectiveDef.declaredInputs, def.inputs);
  findHostDirectiveDefs(hostDirectiveDef, matchedDefs, hostDirectiveDefs);
  hostDirectiveDefs.set(hostDirectiveDef, def);
  matchedDefs.push(hostDirectiveDef);
}
function createHostDirectiveDef(config) {
  return typeof config === 'function' ? {
    directive: (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(config),
    inputs: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    outputs: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ
  } : {
    directive: (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(config.directive),
    inputs: bindingArrayToMap(config.inputs),
    outputs: bindingArrayToMap(config.outputs)
  };
}
function bindingArrayToMap(bindings) {
  if (bindings === undefined || bindings.length === 0) {
    return _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
  }
  const result = {};
  for (let i = 0; i < bindings.length; i += 2) {
    result[bindings[i]] = bindings[i + 1];
  }
  return result;
}
function patchDeclaredInputs(declaredInputs, exposedInputs) {
  for (const publicName in exposedInputs) {
    if (exposedInputs.hasOwnProperty(publicName)) {
      const remappedPublicName = exposedInputs[publicName];
      const privateName = declaredInputs[publicName];
      if ((typeof ngDevMode === 'undefined' || ngDevMode) && declaredInputs.hasOwnProperty(remappedPublicName)) {
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(declaredInputs[remappedPublicName], declaredInputs[publicName], `Conflicting host directive input alias ${publicName}.`);
      }
      declaredInputs[remappedPublicName] = privateName;
    }
  }
}
function validateHostDirective(hostDirectiveConfig, directiveDef) {
  const type = hostDirectiveConfig.directive;
  if (directiveDef === null) {
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type) !== null) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(310, `Host directive ${type.name} cannot be a component.`);
    }
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(307, `Could not resolve metadata for host directive ${type.name}. ` + `Make sure that the ${type.name} class is annotated with an @Directive decorator.`);
  }
  if (!directiveDef.standalone) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(308, `Host directive ${directiveDef.type.name} must be standalone.`);
  }
  validateMappings('input', directiveDef, hostDirectiveConfig.inputs);
  validateMappings('output', directiveDef, hostDirectiveConfig.outputs);
}
function validateMappings(bindingType, def, hostDirectiveBindings) {
  const className = def.type.name;
  const bindings = bindingType === 'input' ? def.inputs : def.outputs;
  for (const publicName in hostDirectiveBindings) {
    if (hostDirectiveBindings.hasOwnProperty(publicName)) {
      if (!bindings.hasOwnProperty(publicName)) {
        throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(311, `Directive ${className} does not have an ${bindingType} with a public name of ${publicName}.`);
      }
      const remappedPublicName = hostDirectiveBindings[publicName];
      if (bindings.hasOwnProperty(remappedPublicName) && remappedPublicName !== publicName) {
        throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(312, `Cannot alias ${bindingType} ${publicName} of host directive ${className} to ${remappedPublicName}, because it already has a different ${bindingType} with the same public name.`);
      }
    }
  }
}
function getSuperType(type) {
  return Object.getPrototypeOf(type.prototype).constructor;
}
function ɵɵInheritDefinitionFeature(definition) {
  let superType = getSuperType(definition.type);
  let shouldInheritFields = true;
  const inheritanceChain = [definition];
  while (superType) {
    let superDef = undefined;
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentDef)(definition)) {
      superDef = superType.ɵcmp || superType.ɵdir;
    } else {
      if (superType.ɵcmp) {
        throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(903, ngDevMode && `Directives cannot inherit Components. Directive ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(definition.type)} is attempting to extend component ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(superType)}`);
      }
      superDef = superType.ɵdir;
    }
    if (superDef) {
      if (shouldInheritFields) {
        inheritanceChain.push(superDef);
        const writeableDef = definition;
        writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);
        writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);
        writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);
        const superHostBindings = superDef.hostBindings;
        superHostBindings && inheritHostBindings(definition, superHostBindings);
        const superViewQuery = superDef.viewQuery;
        const superContentQueries = superDef.contentQueries;
        superViewQuery && inheritViewQuery(definition, superViewQuery);
        superContentQueries && inheritContentQueries(definition, superContentQueries);
        mergeInputsWithTransforms(definition, superDef);
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.fillProperties)(definition.outputs, superDef.outputs);
        if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentDef)(superDef) && superDef.data.animation) {
          const defData = definition.data;
          defData.animation = (defData.animation || []).concat(superDef.data.animation);
        }
      }
      const features = superDef.features;
      if (features) {
        for (let i = 0; i < features.length; i++) {
          const feature = features[i];
          if (feature && feature.ngInherit) {
            feature(definition);
          }
          if (feature === ɵɵInheritDefinitionFeature) {
            shouldInheritFields = false;
          }
        }
      }
    }
    superType = Object.getPrototypeOf(superType);
  }
  mergeHostAttrsAcrossInheritance(inheritanceChain);
}
function mergeInputsWithTransforms(target, source) {
  for (const key in source.inputs) {
    if (!source.inputs.hasOwnProperty(key)) {
      continue;
    }
    if (target.inputs.hasOwnProperty(key)) {
      continue;
    }
    const value = source.inputs[key];
    if (value !== undefined) {
      target.inputs[key] = value;
      target.declaredInputs[key] = source.declaredInputs[key];
    }
  }
}
function mergeHostAttrsAcrossInheritance(inheritanceChain) {
  let hostVars = 0;
  let hostAttrs = null;
  for (let i = inheritanceChain.length - 1; i >= 0; i--) {
    const def = inheritanceChain[i];
    def.hostVars = hostVars += def.hostVars;
    def.hostAttrs = mergeHostAttrs(def.hostAttrs, hostAttrs = mergeHostAttrs(hostAttrs, def.hostAttrs));
  }
}
function maybeUnwrapEmpty(value) {
  if (value === _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
    return {};
  } else if (value === _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY) {
    return [];
  } else {
    return value;
  }
}
function inheritViewQuery(definition, superViewQuery) {
  const prevViewQuery = definition.viewQuery;
  if (prevViewQuery) {
    definition.viewQuery = (rf, ctx) => {
      superViewQuery(rf, ctx);
      prevViewQuery(rf, ctx);
    };
  } else {
    definition.viewQuery = superViewQuery;
  }
}
function inheritContentQueries(definition, superContentQueries) {
  const prevContentQueries = definition.contentQueries;
  if (prevContentQueries) {
    definition.contentQueries = (rf, ctx, directiveIndex) => {
      superContentQueries(rf, ctx, directiveIndex);
      prevContentQueries(rf, ctx, directiveIndex);
    };
  } else {
    definition.contentQueries = superContentQueries;
  }
}
function inheritHostBindings(definition, superHostBindings) {
  const prevHostBindings = definition.hostBindings;
  if (prevHostBindings) {
    definition.hostBindings = (rf, ctx) => {
      superHostBindings(rf, ctx);
      prevHostBindings(rf, ctx);
    };
  } else {
    definition.hostBindings = superHostBindings;
  }
}
function templateCreate(tNode, declarationLView, declarationTView, index, templateFn, decls, vars, flags) {
  if (declarationTView.firstCreatePass) {
    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);
    const embeddedTView = tNode.tView = createTView(2, tNode, templateFn, decls, vars, declarationTView.directiveRegistry, declarationTView.pipeRegistry, null, declarationTView.schemas, declarationTView.consts, null);
    if (declarationTView.queries !== null) {
      declarationTView.queries.template(declarationTView, tNode);
      embeddedTView.queries = declarationTView.queries.embeddedTView(tNode);
    }
  }
  if (flags) {
    tNode.flags |= flags;
  }
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentTNode)(tNode, false);
  const comment = _locateOrCreateContainerAnchor(declarationTView, declarationLView, tNode, index);
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.wasLastNodeCreated)()) {
    appendChild(declarationTView, declarationLView, comment, tNode);
  }
  attachPatchData(comment, declarationLView);
  const lContainer = createLContainer(comment, declarationLView, comment, tNode);
  declarationLView[index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET] = lContainer;
  addToEndOfViewTree(declarationLView, lContainer);
  populateDehydratedViewsInLContainer(lContainer, tNode, declarationLView);
}
function declareDirectiveHostTemplate(declarationLView, declarationTView, index, templateFn, decls, vars, tagName, attrs, flags, localRefsIndex, localRefExtractor) {
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  let tNode;
  if (declarationTView.firstCreatePass) {
    tNode = getOrCreateTNode(declarationTView, adjustedIndex, 4, tagName || null, attrs || null);
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingsEnabled)()) {
      resolveDirectives(declarationTView, declarationLView, tNode, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(declarationTView.consts, localRefsIndex), findDirectiveDefMatches);
    }
    registerPostOrderHooks(declarationTView, tNode);
  } else {
    tNode = declarationTView.data[adjustedIndex];
  }
  templateCreate(tNode, declarationLView, declarationTView, index, templateFn, decls, vars, flags);
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isDirectiveHost)(tNode)) {
    createDirectivesInstances(declarationTView, declarationLView, tNode);
  }
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(declarationLView, tNode, localRefExtractor);
  }
  return tNode;
}
function declareNoDirectiveHostTemplate(declarationLView, declarationTView, index, templateFn, decls, vars, tagName, attrs, flags, localRefsIndex, localRefExtractor) {
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  let tNode;
  if (declarationTView.firstCreatePass) {
    tNode = getOrCreateTNode(declarationTView, adjustedIndex, 4, tagName || null, attrs || null);
    if (localRefsIndex != null) {
      const refs = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(declarationTView.consts, localRefsIndex);
      tNode.localNames = [];
      for (let i = 0; i < refs.length; i += 2) {
        tNode.localNames.push(refs[i], -1);
      }
    }
  } else {
    tNode = declarationTView.data[adjustedIndex];
  }
  templateCreate(tNode, declarationLView, declarationTView, index, templateFn, decls, vars, flags);
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(declarationLView, tNode, localRefExtractor);
  }
  return tNode;
}
function ɵɵtemplate(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const attrs = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tView.consts, attrsIndex);
  declareDirectiveHostTemplate(lView, tView, index, templateFn, decls, vars, tagName, attrs, undefined, localRefsIndex, localRefExtractor);
  return ɵɵtemplate;
}
function ɵɵdomTemplate(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const attrs = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tView.consts, attrsIndex);
  declareNoDirectiveHostTemplate(lView, tView, index, templateFn, decls, vars, tagName, attrs, undefined, localRefsIndex, localRefExtractor);
  return ɵɵdomTemplate;
}
let _locateOrCreateContainerAnchor = createContainerAnchorImpl;
function createContainerAnchorImpl(tView, lView, tNode, index) {
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.lastNodeWasCreated)(true);
  return lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER].createComment(ngDevMode ? 'container' : '');
}
function locateOrCreateContainerAnchorImpl(tView, lView, tNode, index) {
  const isNodeCreationMode = !canHydrateNode(lView, tNode);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.lastNodeWasCreated)(isNodeCreationMode);
  const ssrId = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION]?.data[TEMPLATES]?.[index] ?? null;
  if (ssrId !== null && tNode.tView !== null) {
    if (tNode.tView.ssrId === null) {
      tNode.tView.ssrId = ssrId;
    } else {
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(tNode.tView.ssrId, ssrId, 'Unexpected value of the `ssrId` for this TView');
    }
  }
  if (isNodeCreationMode) {
    return createContainerAnchorImpl(tView, lView);
  }
  const hydrationInfo = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION];
  const currentRNode = locateNextRNode(hydrationInfo, tView, lView, tNode);
  ngDevMode && validateNodeExists(currentRNode, lView, tNode);
  setSegmentHead(hydrationInfo, index, currentRNode);
  const viewContainerSize = calcSerializedContainerSize(hydrationInfo, index);
  const comment = siblingAfter(viewContainerSize, currentRNode);
  if (ngDevMode) {
    validateMatchingNode(comment, Node.COMMENT_NODE, null, lView, tNode);
    markRNodeAsClaimedByHydration(comment);
  }
  return comment;
}
function enableLocateOrCreateContainerAnchorImpl() {
  _locateOrCreateContainerAnchor = locateOrCreateContainerAnchorImpl;
}
var DeferDependenciesLoadingState;
(function (DeferDependenciesLoadingState) {
  DeferDependenciesLoadingState[DeferDependenciesLoadingState["NOT_STARTED"] = 0] = "NOT_STARTED";
  DeferDependenciesLoadingState[DeferDependenciesLoadingState["IN_PROGRESS"] = 1] = "IN_PROGRESS";
  DeferDependenciesLoadingState[DeferDependenciesLoadingState["COMPLETE"] = 2] = "COMPLETE";
  DeferDependenciesLoadingState[DeferDependenciesLoadingState["FAILED"] = 3] = "FAILED";
})(DeferDependenciesLoadingState || (DeferDependenciesLoadingState = {}));
const MINIMUM_SLOT = 0;
const LOADING_AFTER_SLOT = 1;
var DeferBlockState;
(function (DeferBlockState) {
  DeferBlockState[DeferBlockState["Placeholder"] = 0] = "Placeholder";
  DeferBlockState[DeferBlockState["Loading"] = 1] = "Loading";
  DeferBlockState[DeferBlockState["Complete"] = 2] = "Complete";
  DeferBlockState[DeferBlockState["Error"] = 3] = "Error";
})(DeferBlockState || (DeferBlockState = {}));
var DeferBlockInternalState;
(function (DeferBlockInternalState) {
  DeferBlockInternalState[DeferBlockInternalState["Initial"] = -1] = "Initial";
})(DeferBlockInternalState || (DeferBlockInternalState = {}));
const NEXT_DEFER_BLOCK_STATE = 0;
const DEFER_BLOCK_STATE = 1;
const STATE_IS_FROZEN_UNTIL = 2;
const LOADING_AFTER_CLEANUP_FN = 3;
const TRIGGER_CLEANUP_FNS = 4;
const PREFETCH_TRIGGER_CLEANUP_FNS = 5;
const SSR_UNIQUE_ID = 6;
const SSR_BLOCK_STATE = 7;
const ON_COMPLETE_FNS = 8;
const HYDRATE_TRIGGER_CLEANUP_FNS = 9;
var DeferBlockBehavior;
(function (DeferBlockBehavior) {
  DeferBlockBehavior[DeferBlockBehavior["Manual"] = 0] = "Manual";
  DeferBlockBehavior[DeferBlockBehavior["Playthrough"] = 1] = "Playthrough";
})(DeferBlockBehavior || (DeferBlockBehavior = {}));
function storeTriggerCleanupFn(type, lDetails, cleanupFn) {
  const key = getCleanupFnKeyByType(type);
  if (lDetails[key] === null) {
    lDetails[key] = [];
  }
  lDetails[key].push(cleanupFn);
}
function invokeTriggerCleanupFns(type, lDetails) {
  const key = getCleanupFnKeyByType(type);
  const cleanupFns = lDetails[key];
  if (cleanupFns !== null) {
    for (const cleanupFn of cleanupFns) {
      cleanupFn();
    }
    lDetails[key] = null;
  }
}
function invokeAllTriggerCleanupFns(lDetails) {
  invokeTriggerCleanupFns(1, lDetails);
  invokeTriggerCleanupFns(0, lDetails);
  invokeTriggerCleanupFns(2, lDetails);
}
function getCleanupFnKeyByType(type) {
  let key = TRIGGER_CLEANUP_FNS;
  if (type === 1) {
    key = PREFETCH_TRIGGER_CLEANUP_FNS;
  } else if (type === 2) {
    key = HYDRATE_TRIGGER_CLEANUP_FNS;
  }
  return key;
}
function getDeferBlockDataIndex(deferBlockIndex) {
  return deferBlockIndex + 1;
}
function getLDeferBlockDetails(lView, tNode) {
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const slotIndex = getDeferBlockDataIndex(tNode.index);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInDeclRange)(tView, slotIndex);
  return lView[slotIndex];
}
function setLDeferBlockDetails(lView, deferBlockIndex, lDetails) {
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const slotIndex = getDeferBlockDataIndex(deferBlockIndex);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInDeclRange)(tView, slotIndex);
  lView[slotIndex] = lDetails;
}
function getTDeferBlockDetails(tView, tNode) {
  const slotIndex = getDeferBlockDataIndex(tNode.index);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInDeclRange)(tView, slotIndex);
  return tView.data[slotIndex];
}
function setTDeferBlockDetails(tView, deferBlockIndex, deferBlockConfig) {
  const slotIndex = getDeferBlockDataIndex(deferBlockIndex);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInDeclRange)(tView, slotIndex);
  tView.data[slotIndex] = deferBlockConfig;
}
function getTemplateIndexForState(newState, hostLView, tNode) {
  const tView = hostLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  switch (newState) {
    case DeferBlockState.Complete:
      return tDetails.primaryTmplIndex;
    case DeferBlockState.Loading:
      return tDetails.loadingTmplIndex;
    case DeferBlockState.Error:
      return tDetails.errorTmplIndex;
    case DeferBlockState.Placeholder:
      return tDetails.placeholderTmplIndex;
    default:
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)(`Unexpected defer block state: ${newState}`);
      return null;
  }
}
function getMinimumDurationForState(tDetails, currentState) {
  if (currentState === DeferBlockState.Placeholder) {
    return tDetails.placeholderBlockConfig?.[MINIMUM_SLOT] ?? null;
  } else if (currentState === DeferBlockState.Loading) {
    return tDetails.loadingBlockConfig?.[MINIMUM_SLOT] ?? null;
  }
  return null;
}
function getLoadingBlockAfter(tDetails) {
  return tDetails.loadingBlockConfig?.[LOADING_AFTER_SLOT] ?? null;
}
function addDepsToRegistry(currentDeps, newDeps) {
  if (!currentDeps || currentDeps.length === 0) {
    return newDeps;
  }
  const currentDepSet = new Set(currentDeps);
  for (const dep of newDeps) {
    currentDepSet.add(dep);
  }
  return currentDeps.length === currentDepSet.size ? currentDeps : Array.from(currentDepSet);
}
function getPrimaryBlockTNode(tView, tDetails) {
  const adjustedIndex = tDetails.primaryTmplIndex + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTNode)(tView, adjustedIndex);
}
function assertDeferredDependenciesLoaded(tDetails) {
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(tDetails.loadingState, DeferDependenciesLoadingState.COMPLETE, 'Expecting all deferred dependencies to be loaded.');
}
function isTDeferBlockDetails(value) {
  return value !== null && typeof value === 'object' && typeof value.primaryTmplIndex === 'number';
}
function isDeferBlock(tView, tNode) {
  let tDetails = null;
  const slotIndex = getDeferBlockDataIndex(tNode.index);
  if (_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET < slotIndex && slotIndex < tView.bindingStartIndex) {
    tDetails = getTDeferBlockDetails(tView, tNode);
  }
  return !!tDetails && isTDeferBlockDetails(tDetails);
}
function trackTriggerForDebugging(tView, tNode, textRepresentation) {
  const tDetails = getTDeferBlockDetails(tView, tNode);
  tDetails.debug ??= {};
  tDetails.debug.triggers ??= new Set();
  tDetails.debug.triggers.add(textRepresentation);
}
function onViewportWrapper(trigger, callback, injector, wrapperOptions) {
  const ngZone = injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone);
  return onViewport(trigger, () => ngZone.run(callback), options => ngZone.runOutsideAngular(() => createIntersectionObserver(options)), wrapperOptions);
}
function getTriggerLView(deferredHostLView, deferredTNode, walkUpTimes) {
  if (walkUpTimes == null) {
    return deferredHostLView;
  }
  if (walkUpTimes >= 0) {
    return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.walkUpViews)(walkUpTimes, deferredHostLView);
  }
  const deferredContainer = deferredHostLView[deferredTNode.index];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLContainer)(deferredContainer);
  const triggerLView = deferredContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET] ?? null;
  if (ngDevMode && triggerLView !== null) {
    const lDetails = getLDeferBlockDetails(deferredHostLView, deferredTNode);
    const renderedState = lDetails[DEFER_BLOCK_STATE];
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(renderedState, DeferBlockState.Placeholder, 'Expected a placeholder to be rendered in this defer block.');
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLView)(triggerLView);
  }
  return triggerLView;
}
function getTriggerElement(triggerLView, triggerIndex) {
  const element = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByIndex)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET + triggerIndex, triggerLView);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertElement)(element);
  return element;
}
function registerDomTrigger(initialLView, tNode, triggerIndex, walkUpTimes, registerFn, callback, type, options) {
  const injector = initialLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
  const zone = injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone);
  let poll;
  function pollDomTrigger() {
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isDestroyed)(initialLView)) {
      poll.destroy();
      return;
    }
    const lDetails = getLDeferBlockDetails(initialLView, tNode);
    const renderedState = lDetails[DEFER_BLOCK_STATE];
    if (renderedState !== DeferBlockInternalState.Initial && renderedState !== DeferBlockState.Placeholder) {
      poll.destroy();
      return;
    }
    const triggerLView = getTriggerLView(initialLView, tNode, walkUpTimes);
    if (!triggerLView) {
      return;
    }
    poll.destroy();
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isDestroyed)(triggerLView)) {
      return;
    }
    const element = getTriggerElement(triggerLView, triggerIndex);
    const cleanup = registerFn(element, () => {
      zone.run(() => {
        if (initialLView !== triggerLView) {
          (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.removeLViewOnDestroy)(triggerLView, cleanup);
        }
        callback();
      });
    }, injector, options);
    if (initialLView !== triggerLView) {
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.storeLViewOnDestroy)(triggerLView, cleanup);
    }
    storeTriggerCleanupFn(type, lDetails, cleanup);
  }
  poll = afterEveryRender({
    read: pollDomTrigger
  }, {
    injector
  });
}
function onIdle(callback, injector) {
  const scheduler = injector.get(IdleScheduler);
  const cleanupFn = () => scheduler.remove(callback);
  scheduler.add(callback);
  return cleanupFn;
}
const _requestIdleCallback = () => typeof requestIdleCallback !== 'undefined' ? requestIdleCallback : setTimeout;
const _cancelIdleCallback = () => typeof requestIdleCallback !== 'undefined' ? cancelIdleCallback : clearTimeout;
class IdleScheduler {
  executingCallbacks = false;
  idleId = null;
  current = new Set();
  deferred = new Set();
  ngZone = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone);
  requestIdleCallbackFn = _requestIdleCallback().bind(globalThis);
  cancelIdleCallbackFn = _cancelIdleCallback().bind(globalThis);
  add(callback) {
    const target = this.executingCallbacks ? this.deferred : this.current;
    target.add(callback);
    if (this.idleId === null) {
      this.scheduleIdleCallback();
    }
  }
  remove(callback) {
    const {
      current,
      deferred
    } = this;
    current.delete(callback);
    deferred.delete(callback);
    if (current.size === 0 && deferred.size === 0) {
      this.cancelIdleCallback();
    }
  }
  scheduleIdleCallback() {
    const callback = () => {
      this.cancelIdleCallback();
      this.executingCallbacks = true;
      for (const callback of this.current) {
        callback();
      }
      this.current.clear();
      this.executingCallbacks = false;
      if (this.deferred.size > 0) {
        for (const callback of this.deferred) {
          this.current.add(callback);
        }
        this.deferred.clear();
        this.scheduleIdleCallback();
      }
    };
    this.idleId = this.requestIdleCallbackFn(() => this.ngZone.run(callback));
  }
  cancelIdleCallback() {
    if (this.idleId !== null) {
      this.cancelIdleCallbackFn(this.idleId);
      this.idleId = null;
    }
  }
  ngOnDestroy() {
    this.cancelIdleCallback();
    this.current.clear();
    this.deferred.clear();
  }
  static ɵprov = /* @__PURE__ */
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
    token: IdleScheduler,
    providedIn: 'root',
    factory: () => new IdleScheduler()
  });
}
function onTimer(delay) {
  return (callback, injector) => scheduleTimerTrigger(delay, callback, injector);
}
function scheduleTimerTrigger(delay, callback, injector) {
  const scheduler = injector.get(TimerScheduler);
  const ngZone = injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone);
  const cleanupFn = () => scheduler.remove(callback);
  scheduler.add(delay, callback, ngZone);
  return cleanupFn;
}
class TimerScheduler {
  executingCallbacks = false;
  timeoutId = null;
  invokeTimerAt = null;
  current = [];
  deferred = [];
  add(delay, callback, ngZone) {
    const target = this.executingCallbacks ? this.deferred : this.current;
    this.addToQueue(target, Date.now() + delay, callback);
    this.scheduleTimer(ngZone);
  }
  remove(callback) {
    const {
      current,
      deferred
    } = this;
    const callbackIndex = this.removeFromQueue(current, callback);
    if (callbackIndex === -1) {
      this.removeFromQueue(deferred, callback);
    }
    if (current.length === 0 && deferred.length === 0) {
      this.clearTimeout();
    }
  }
  addToQueue(target, invokeAt, callback) {
    let insertAtIndex = target.length;
    for (let i = 0; i < target.length; i += 2) {
      const invokeQueuedCallbackAt = target[i];
      if (invokeQueuedCallbackAt > invokeAt) {
        insertAtIndex = i;
        break;
      }
    }
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.arrayInsert2)(target, insertAtIndex, invokeAt, callback);
  }
  removeFromQueue(target, callback) {
    let index = -1;
    for (let i = 0; i < target.length; i += 2) {
      const queuedCallback = target[i + 1];
      if (queuedCallback === callback) {
        index = i;
        break;
      }
    }
    if (index > -1) {
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.arraySplice)(target, index, 2);
    }
    return index;
  }
  scheduleTimer(ngZone) {
    const callback = () => {
      this.clearTimeout();
      this.executingCallbacks = true;
      const current = [...this.current];
      const now = Date.now();
      for (let i = 0; i < current.length; i += 2) {
        const invokeAt = current[i];
        const callback = current[i + 1];
        if (invokeAt <= now) {
          callback();
        } else {
          break;
        }
      }
      let lastCallbackIndex = -1;
      for (let i = 0; i < this.current.length; i += 2) {
        const invokeAt = this.current[i];
        if (invokeAt <= now) {
          lastCallbackIndex = i + 1;
        } else {
          break;
        }
      }
      if (lastCallbackIndex >= 0) {
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.arraySplice)(this.current, 0, lastCallbackIndex + 1);
      }
      this.executingCallbacks = false;
      if (this.deferred.length > 0) {
        for (let i = 0; i < this.deferred.length; i += 2) {
          const invokeAt = this.deferred[i];
          const callback = this.deferred[i + 1];
          this.addToQueue(this.current, invokeAt, callback);
        }
        this.deferred.length = 0;
      }
      this.scheduleTimer(ngZone);
    };
    const FRAME_DURATION_MS = 16;
    if (this.current.length > 0) {
      const now = Date.now();
      const invokeAt = this.current[0];
      if (this.timeoutId === null || this.invokeTimerAt && this.invokeTimerAt - invokeAt > FRAME_DURATION_MS) {
        this.clearTimeout();
        const timeout = Math.max(invokeAt - now, FRAME_DURATION_MS);
        this.invokeTimerAt = invokeAt;
        this.timeoutId = ngZone.runOutsideAngular(() => {
          return setTimeout(() => ngZone.run(callback), timeout);
        });
      }
    }
  }
  clearTimeout() {
    if (this.timeoutId !== null) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
  }
  ngOnDestroy() {
    this.clearTimeout();
    this.current.length = 0;
    this.deferred.length = 0;
  }
  static ɵprov = /* @__PURE__ */
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
    token: TimerScheduler,
    providedIn: 'root',
    factory: () => new TimerScheduler()
  });
}
class CachedInjectorService {
  cachedInjectors = new Map();
  getOrCreateInjector(key, parentInjector, providers, debugName) {
    if (!this.cachedInjectors.has(key)) {
      const injector = providers.length > 0 ? createEnvironmentInjector(providers, parentInjector, debugName) : null;
      this.cachedInjectors.set(key, injector);
    }
    return this.cachedInjectors.get(key);
  }
  ngOnDestroy() {
    try {
      for (const injector of this.cachedInjectors.values()) {
        if (injector !== null) {
          injector.destroy();
        }
      }
    } finally {
      this.cachedInjectors.clear();
    }
  }
  static ɵprov = /* @__PURE__ */
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
    token: CachedInjectorService,
    providedIn: 'environment',
    factory: () => new CachedInjectorService()
  });
}
const DEFER_BLOCK_DEPENDENCY_INTERCEPTOR = /* @__PURE__ */new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('DEFER_BLOCK_DEPENDENCY_INTERCEPTOR');
const DEFER_BLOCK_CONFIG = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'DEFER_BLOCK_CONFIG' : '');
function getOrCreateEnvironmentInjector(parentInjector, tDetails, providers) {
  return parentInjector.get(CachedInjectorService).getOrCreateInjector(tDetails, parentInjector, providers, ngDevMode ? 'DeferBlock Injector' : '');
}
function createDeferBlockInjector(parentInjector, tDetails, providers) {
  if (parentInjector instanceof ChainedInjector) {
    const origInjector = parentInjector.injector;
    const parentEnvInjector = parentInjector.parentInjector;
    const envInjector = getOrCreateEnvironmentInjector(parentEnvInjector, tDetails, providers);
    return new ChainedInjector(origInjector, envInjector);
  }
  const parentEnvInjector = parentInjector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EnvironmentInjector);
  if (parentEnvInjector !== parentInjector) {
    const envInjector = getOrCreateEnvironmentInjector(parentEnvInjector, tDetails, providers);
    return new ChainedInjector(parentInjector, envInjector);
  }
  return getOrCreateEnvironmentInjector(parentInjector, tDetails, providers);
}
function renderDeferBlockState(newState, tNode, lContainer, skipTimerScheduling = false) {
  const hostLView = lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT];
  const hostTView = hostLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isDestroyed)(hostLView)) return;
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForLView)(tNode, hostLView);
  const lDetails = getLDeferBlockDetails(hostLView, tNode);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(lDetails, 'Expected a defer block state defined');
  const currentState = lDetails[DEFER_BLOCK_STATE];
  const ssrState = lDetails[SSR_BLOCK_STATE];
  if (ssrState !== null && newState < ssrState) {
    return;
  }
  if (isValidStateChange(currentState, newState) && isValidStateChange(lDetails[NEXT_DEFER_BLOCK_STATE] ?? -1, newState)) {
    const tDetails = getTDeferBlockDetails(hostTView, tNode);
    const needsScheduling = !skipTimerScheduling && (typeof ngServerMode === 'undefined' || !ngServerMode) && (getLoadingBlockAfter(tDetails) !== null || getMinimumDurationForState(tDetails, DeferBlockState.Loading) !== null || getMinimumDurationForState(tDetails, DeferBlockState.Placeholder));
    if (ngDevMode && needsScheduling) {
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(applyDeferBlockStateWithSchedulingImpl, 'Expected scheduling function to be defined');
    }
    const applyStateFn = needsScheduling ? applyDeferBlockStateWithSchedulingImpl : applyDeferBlockState;
    try {
      applyStateFn(newState, lDetails, lContainer, tNode, hostLView);
    } catch (error) {
      handleUncaughtError(hostLView, error);
    }
  }
}
function findMatchingDehydratedViewForDeferBlock(lContainer, lDetails) {
  const dehydratedViewIx = lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DEHYDRATED_VIEWS]?.findIndex(view => view.data[DEFER_BLOCK_STATE$1] === lDetails[DEFER_BLOCK_STATE]) ?? -1;
  const dehydratedView = dehydratedViewIx > -1 ? lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DEHYDRATED_VIEWS][dehydratedViewIx] : null;
  return {
    dehydratedView,
    dehydratedViewIx
  };
}
function applyDeferBlockState(newState, lDetails, lContainer, tNode, hostLView) {
  profiler(ProfilerEvent.DeferBlockStateStart);
  const stateTmplIndex = getTemplateIndexForState(newState, hostLView, tNode);
  if (stateTmplIndex !== null) {
    lDetails[DEFER_BLOCK_STATE] = newState;
    const hostTView = hostLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
    const adjustedIndex = stateTmplIndex + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
    const activeBlockTNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTNode)(hostTView, adjustedIndex);
    const viewIndex = 0;
    removeLViewFromLContainer(lContainer, viewIndex);
    let injector;
    if (newState === DeferBlockState.Complete) {
      const tDetails = getTDeferBlockDetails(hostTView, tNode);
      const providers = tDetails.providers;
      if (providers && providers.length > 0) {
        injector = createDeferBlockInjector(hostLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1], tDetails, providers);
      }
    }
    const {
      dehydratedView,
      dehydratedViewIx
    } = findMatchingDehydratedViewForDeferBlock(lContainer, lDetails);
    const embeddedLView = createAndRenderEmbeddedLView(hostLView, activeBlockTNode, null, {
      injector,
      dehydratedView
    });
    addLViewToLContainer(lContainer, embeddedLView, viewIndex, shouldAddViewToDom(activeBlockTNode, dehydratedView));
    markViewDirty(embeddedLView, 2);
    if (dehydratedViewIx > -1) {
      lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DEHYDRATED_VIEWS]?.splice(dehydratedViewIx, 1);
    }
    if ((newState === DeferBlockState.Complete || newState === DeferBlockState.Error) && Array.isArray(lDetails[ON_COMPLETE_FNS])) {
      for (const callback of lDetails[ON_COMPLETE_FNS]) {
        callback();
      }
      lDetails[ON_COMPLETE_FNS] = null;
    }
  }
  profiler(ProfilerEvent.DeferBlockStateEnd);
}
function applyDeferBlockStateWithScheduling(newState, lDetails, lContainer, tNode, hostLView) {
  const now = Date.now();
  const hostTView = hostLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const tDetails = getTDeferBlockDetails(hostTView, tNode);
  if (lDetails[STATE_IS_FROZEN_UNTIL] === null || lDetails[STATE_IS_FROZEN_UNTIL] <= now) {
    lDetails[STATE_IS_FROZEN_UNTIL] = null;
    const loadingAfter = getLoadingBlockAfter(tDetails);
    const inLoadingAfterPhase = lDetails[LOADING_AFTER_CLEANUP_FN] !== null;
    if (newState === DeferBlockState.Loading && loadingAfter !== null && !inLoadingAfterPhase) {
      lDetails[NEXT_DEFER_BLOCK_STATE] = newState;
      const cleanupFn = scheduleDeferBlockUpdate(loadingAfter, lDetails, tNode, lContainer, hostLView);
      lDetails[LOADING_AFTER_CLEANUP_FN] = cleanupFn;
    } else {
      if (newState > DeferBlockState.Loading && inLoadingAfterPhase) {
        lDetails[LOADING_AFTER_CLEANUP_FN]();
        lDetails[LOADING_AFTER_CLEANUP_FN] = null;
        lDetails[NEXT_DEFER_BLOCK_STATE] = null;
      }
      applyDeferBlockState(newState, lDetails, lContainer, tNode, hostLView);
      const duration = getMinimumDurationForState(tDetails, newState);
      if (duration !== null) {
        lDetails[STATE_IS_FROZEN_UNTIL] = now + duration;
        scheduleDeferBlockUpdate(duration, lDetails, tNode, lContainer, hostLView);
      }
    }
  } else {
    lDetails[NEXT_DEFER_BLOCK_STATE] = newState;
  }
}
function scheduleDeferBlockUpdate(timeout, lDetails, tNode, lContainer, hostLView) {
  const callback = () => {
    const nextState = lDetails[NEXT_DEFER_BLOCK_STATE];
    lDetails[STATE_IS_FROZEN_UNTIL] = null;
    lDetails[NEXT_DEFER_BLOCK_STATE] = null;
    if (nextState !== null) {
      renderDeferBlockState(nextState, tNode, lContainer);
    }
  };
  return scheduleTimerTrigger(timeout, callback, hostLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1]);
}
function isValidStateChange(currentState, newState) {
  return currentState < newState;
}
function renderPlaceholder(lView, tNode) {
  const lContainer = lView[tNode.index];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLContainer)(lContainer);
  renderDeferBlockState(DeferBlockState.Placeholder, tNode, lContainer);
}
function renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(tDetails.loadingPromise, 'Expected loading Promise to exist on this defer block');
  tDetails.loadingPromise.then(() => {
    if (tDetails.loadingState === DeferDependenciesLoadingState.COMPLETE) {
      ngDevMode && assertDeferredDependenciesLoaded(tDetails);
      renderDeferBlockState(DeferBlockState.Complete, tNode, lContainer);
    } else if (tDetails.loadingState === DeferDependenciesLoadingState.FAILED) {
      renderDeferBlockState(DeferBlockState.Error, tNode, lContainer);
    }
  });
}
let applyDeferBlockStateWithSchedulingImpl = null;
function ɵɵdeferEnableTimerScheduling(tView, tDetails, placeholderConfigIndex, loadingConfigIndex) {
  const tViewConsts = tView.consts;
  if (placeholderConfigIndex != null) {
    tDetails.placeholderBlockConfig = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tViewConsts, placeholderConfigIndex);
  }
  if (loadingConfigIndex != null) {
    tDetails.loadingBlockConfig = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tViewConsts, loadingConfigIndex);
  }
  if (applyDeferBlockStateWithSchedulingImpl === null) {
    applyDeferBlockStateWithSchedulingImpl = applyDeferBlockStateWithScheduling;
  }
}
const ASYNC_COMPONENT_METADATA_FN = '__ngAsyncComponentMetadataFn__';
function getAsyncClassMetadataFn(type) {
  const componentClass = type;
  return componentClass[ASYNC_COMPONENT_METADATA_FN] ?? null;
}
function setClassMetadataAsync(type, dependencyLoaderFn, metadataSetterFn) {
  const componentClass = type;
  componentClass[ASYNC_COMPONENT_METADATA_FN] = () => Promise.all(dependencyLoaderFn()).then(dependencies => {
    metadataSetterFn(...dependencies);
    componentClass[ASYNC_COMPONENT_METADATA_FN] = null;
    return dependencies;
  });
  return componentClass[ASYNC_COMPONENT_METADATA_FN];
}
function setClassMetadata(type, decorators, ctorParameters, propDecorators) {
  return noSideEffects(() => {
    const clazz = type;
    if (decorators !== null) {
      if (clazz.hasOwnProperty('decorators') && clazz.decorators !== undefined) {
        clazz.decorators.push(...decorators);
      } else {
        clazz.decorators = decorators;
      }
    }
    if (ctorParameters !== null) {
      clazz.ctorParameters = ctorParameters;
    }
    if (propDecorators !== null) {
      if (clazz.hasOwnProperty('propDecorators') && clazz.propDecorators !== undefined) {
        clazz.propDecorators = {
          ...clazz.propDecorators,
          ...propDecorators
        };
      } else {
        clazz.propDecorators = propDecorators;
      }
    }
  });
}
class Console {
  log(message) {
    console.log(message);
  }
  warn(message) {
    console.warn(message);
  }
  static ɵfac = function Console_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || Console)();
  };
  static ɵprov = /*@__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
    token: Console,
    factory: Console.ɵfac,
    providedIn: 'platform'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Console, [{
    type: Injectable,
    args: [{
      providedIn: 'platform'
    }]
  }], null, null);
})();
class DIDebugData {
  resolverToTokenToDependencies = new WeakMap();
  resolverToProviders = new WeakMap();
  resolverToEffects = new WeakMap();
  standaloneInjectorToComponent = new WeakMap();
  reset() {
    this.resolverToTokenToDependencies = new WeakMap();
    this.resolverToProviders = new WeakMap();
    this.standaloneInjectorToComponent = new WeakMap();
  }
}
let frameworkDIDebugData = new DIDebugData();
function getFrameworkDIDebugData() {
  return frameworkDIDebugData;
}
function setupFrameworkInjectorProfiler() {
  frameworkDIDebugData.reset();
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInjectorProfiler)(injectorProfilerEventHandler);
}
function injectorProfilerEventHandler(injectorProfilerEvent) {
  const {
    context,
    type
  } = injectorProfilerEvent;
  if (type === 0) {
    handleInjectEvent(context, injectorProfilerEvent.service);
  } else if (type === 1) {
    handleInstanceCreatedByInjectorEvent(context, injectorProfilerEvent.instance);
  } else if (type === 2) {
    handleProviderConfiguredEvent(context, injectorProfilerEvent.providerRecord);
  } else if (type === 3) {
    handleEffectCreatedEvent(context, injectorProfilerEvent.effect);
  } else if (type === 4) {
    handleEffectCreatedEvent(context, injectorProfilerEvent.effectPhase);
  }
}
function handleEffectCreatedEvent(context, effect) {
  const diResolver = getDIResolver(context.injector);
  if (diResolver === null) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('An EffectCreated event must be run within an injection context.');
  }
  const {
    resolverToEffects
  } = frameworkDIDebugData;
  const cleanupContainer = effect instanceof _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EffectRefImpl ? effect[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SIGNAL] : effect.sequence;
  let trackedEffects = resolverToEffects.get(diResolver);
  if (!trackedEffects) {
    trackedEffects = [];
    resolverToEffects.set(diResolver, trackedEffects);
  }
  trackedEffects.push(effect);
  cleanupContainer.onDestroyFns ??= [];
  cleanupContainer.onDestroyFns.push(() => {
    const index = trackedEffects.indexOf(effect);
    if (index > -1) {
      trackedEffects.splice(index, 1);
    }
  });
}
function handleInjectEvent(context, data) {
  const diResolver = getDIResolver(context.injector);
  if (diResolver === null) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('An Inject event must be run within an injection context.');
  }
  const diResolverToInstantiatedToken = frameworkDIDebugData.resolverToTokenToDependencies;
  if (!diResolverToInstantiatedToken.has(diResolver)) {
    diResolverToInstantiatedToken.set(diResolver, new WeakMap());
  }
  if (!canBeHeldWeakly(context.token)) {
    return;
  }
  const instantiatedTokenToDependencies = diResolverToInstantiatedToken.get(diResolver);
  if (!instantiatedTokenToDependencies.has(context.token)) {
    instantiatedTokenToDependencies.set(context.token, []);
  }
  const {
    token,
    value,
    flags
  } = data;
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(context.token, 'Injector profiler context token is undefined.');
  const dependencies = instantiatedTokenToDependencies.get(context.token);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(dependencies, 'Could not resolve dependencies for token.');
  if (context.injector instanceof NodeInjector) {
    dependencies.push({
      token,
      value,
      flags,
      injectedIn: getNodeInjectorContext(context.injector)
    });
  } else {
    dependencies.push({
      token,
      value,
      flags
    });
  }
}
function getNodeInjectorContext(injector) {
  if (!(injector instanceof NodeInjector)) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('getNodeInjectorContext must be called with a NodeInjector');
  }
  const lView = getNodeInjectorLView(injector);
  const tNode = getNodeInjectorTNode(injector);
  if (tNode === null) {
    return;
  }
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForLView)(tNode, lView);
  return {
    lView,
    tNode
  };
}
function handleInstanceCreatedByInjectorEvent(context, data) {
  const {
    value
  } = data;
  if (data.value == null) {
    return;
  }
  if (getDIResolver(context.injector) === null) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('An InjectorCreatedInstance event must be run within an injection context.');
  }
  let standaloneComponent = undefined;
  if (typeof value === 'object') {
    standaloneComponent = value?.constructor;
  }
  if (standaloneComponent == undefined || !isStandaloneComponent(standaloneComponent)) {
    return;
  }
  const environmentInjector = context.injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EnvironmentInjector, null, {
    optional: true
  });
  if (environmentInjector === null) {
    return;
  }
  const {
    standaloneInjectorToComponent
  } = frameworkDIDebugData;
  if (standaloneInjectorToComponent.has(environmentInjector)) {
    return;
  }
  standaloneInjectorToComponent.set(environmentInjector, standaloneComponent);
}
function isStandaloneComponent(value) {
  const def = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(value);
  return !!def?.standalone;
}
function handleProviderConfiguredEvent(context, data) {
  const {
    resolverToProviders
  } = frameworkDIDebugData;
  let diResolver;
  if (context?.injector instanceof NodeInjector) {
    diResolver = getNodeInjectorTNode(context.injector);
  } else {
    diResolver = context.injector;
  }
  if (diResolver === null) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('A ProviderConfigured event must be run within an injection context.');
  }
  if (!resolverToProviders.has(diResolver)) {
    resolverToProviders.set(diResolver, []);
  }
  resolverToProviders.get(diResolver).push(data);
}
function getDIResolver(injector) {
  let diResolver = null;
  if (injector === undefined) {
    return diResolver;
  }
  if (injector instanceof NodeInjector) {
    diResolver = getNodeInjectorLView(injector);
  } else {
    diResolver = injector;
  }
  return diResolver;
}
function canBeHeldWeakly(value) {
  return value !== null && (typeof value === 'object' || typeof value === 'function' || typeof value === 'symbol');
}
function isSignal(value) {
  return typeof value === 'function' && value[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SIGNAL] !== undefined;
}
function isWritableSignal(value) {
  return isSignal(value) && typeof value.set === 'function';
}
function applyChanges(component) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(component, 'component');
  markViewDirty(getComponentViewByInstance(component), 3);
  getRootComponents(component).forEach(rootComponent => detectChanges(rootComponent));
}
function detectChanges(component) {
  const view = getComponentViewByInstance(component);
  view[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] |= 1024;
  detectChangesInternal(view);
}
function getDeferBlocks$1(lView, deferBlocks) {
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(lView[i])) {
      const lContainer = lView[i];
      const isLast = i === tView.bindingStartIndex - 1;
      if (!isLast) {
        const tNode = tView.data[i];
        const tDetails = getTDeferBlockDetails(tView, tNode);
        if (isTDeferBlockDetails(tDetails)) {
          deferBlocks.push({
            lContainer,
            lView,
            tNode,
            tDetails
          });
          continue;
        }
      }
      if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST])) {
        getDeferBlocks$1(lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST], deferBlocks);
      }
      for (let j = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET; j < lContainer.length; j++) {
        getDeferBlocks$1(lContainer[j], deferBlocks);
      }
    } else if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(lView[i])) {
      getDeferBlocks$1(lView[i], deferBlocks);
    }
  }
}
function getDeferBlocks(node) {
  const results = [];
  const lView = getLContext(node)?.lView;
  if (lView) {
    findDeferBlocks(node, lView, results);
  }
  return results;
}
function findDeferBlocks(node, lView, results) {
  const viewInjector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
  const registry = viewInjector.get(DEHYDRATED_BLOCK_REGISTRY, null, {
    optional: true
  });
  const blocks = [];
  getDeferBlocks$1(lView, blocks);
  const transferState = viewInjector.get(TransferState);
  const deferBlockParents = transferState.get(NGH_DEFER_BLOCKS_KEY, {});
  for (const details of blocks) {
    const native = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(details.tNode, details.lView);
    const lDetails = getLDeferBlockDetails(details.lView, details.tNode);
    if (!node.contains(native)) {
      continue;
    }
    const tDetails = details.tDetails;
    const renderedLView = getRendererLView(details);
    const rootNodes = [];
    const hydrationState = inferHydrationState(tDetails, lDetails, registry);
    if (renderedLView !== null) {
      collectNativeNodes(renderedLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], renderedLView, renderedLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].firstChild, rootNodes);
    } else if (hydrationState === 'dehydrated') {
      const deferId = lDetails[SSR_UNIQUE_ID];
      const deferData = deferBlockParents[deferId];
      const numberOfRootNodes = deferData[NUM_ROOT_NODES];
      let collectedNodeCount = 0;
      const deferBlockCommentNode = details.lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NATIVE];
      let currentNode = deferBlockCommentNode.previousSibling;
      while (collectedNodeCount < numberOfRootNodes && currentNode) {
        rootNodes.unshift(currentNode);
        currentNode = currentNode.previousSibling;
        collectedNodeCount++;
      }
    }
    const data = {
      state: stringifyState(lDetails[DEFER_BLOCK_STATE]),
      incrementalHydrationState: hydrationState,
      hasErrorBlock: tDetails.errorTmplIndex !== null,
      loadingBlock: {
        exists: tDetails.loadingTmplIndex !== null,
        minimumTime: tDetails.loadingBlockConfig?.[MINIMUM_SLOT] ?? null,
        afterTime: tDetails.loadingBlockConfig?.[LOADING_AFTER_SLOT] ?? null
      },
      placeholderBlock: {
        exists: tDetails.placeholderTmplIndex !== null,
        minimumTime: tDetails.placeholderBlockConfig?.[MINIMUM_SLOT] ?? null
      },
      triggers: tDetails.debug?.triggers ? Array.from(tDetails.debug.triggers).sort() : [],
      rootNodes
    };
    results.push(data);
    if (renderedLView !== null) {
      findDeferBlocks(node, renderedLView, results);
    }
  }
}
function stringifyState(state) {
  switch (state) {
    case DeferBlockState.Complete:
      return 'complete';
    case DeferBlockState.Loading:
      return 'loading';
    case DeferBlockState.Placeholder:
      return 'placeholder';
    case DeferBlockState.Error:
      return 'error';
    case DeferBlockInternalState.Initial:
      return 'initial';
    default:
      throw new Error(`Unrecognized state ${state}`);
  }
}
function inferHydrationState(tDetails, lDetails, registry) {
  if (registry === null || lDetails[SSR_UNIQUE_ID] === null || tDetails.hydrateTriggers === null || tDetails.hydrateTriggers.has(7)) {
    return 'not-configured';
  }
  return registry.has(lDetails[SSR_UNIQUE_ID]) ? 'dehydrated' : 'hydrated';
}
function getRendererLView(details) {
  if (details.lContainer.length <= _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET) {
    return null;
  }
  const lView = details.lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLView)(lView);
  return lView;
}
function getDependenciesFromInjectable(injector, token) {
  const instance = injector.get(token, null, {
    self: true,
    optional: true
  });
  if (instance === null) {
    throw new Error(`Unable to determine instance of ${token} in given injector`);
  }
  const unformattedDependencies = getDependenciesForTokenInInjector(token, injector);
  const resolutionPath = getInjectorResolutionPath(injector);
  const dependencies = unformattedDependencies.map(dep => {
    const formattedDependency = {
      value: dep.value
    };
    const flags = dep.flags;
    formattedDependency.flags = {
      optional: (8 & flags) === 8,
      host: (1 & flags) === 1,
      self: (2 & flags) === 2,
      skipSelf: (4 & flags) === 4
    };
    for (let i = 0; i < resolutionPath.length; i++) {
      const injectorToCheck = resolutionPath[i];
      if (i === 0 && formattedDependency.flags.skipSelf) {
        continue;
      }
      if (formattedDependency.flags.host && injectorToCheck instanceof _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EnvironmentInjector) {
        break;
      }
      const instance = injectorToCheck.get(dep.token, null, {
        self: true,
        optional: true
      });
      if (instance !== null) {
        if (formattedDependency.flags.host) {
          const firstInjector = resolutionPath[0];
          const lookupFromFirstInjector = firstInjector.get(dep.token, null, {
            ...formattedDependency.flags,
            optional: true
          });
          if (lookupFromFirstInjector !== null) {
            formattedDependency.providedIn = injectorToCheck;
          }
          break;
        }
        formattedDependency.providedIn = injectorToCheck;
        break;
      }
      if (i === 0 && formattedDependency.flags.self) {
        break;
      }
    }
    if (dep.token) formattedDependency.token = dep.token;
    return formattedDependency;
  });
  return {
    instance,
    dependencies
  };
}
function getDependenciesForTokenInInjector(token, injector) {
  const {
    resolverToTokenToDependencies
  } = getFrameworkDIDebugData();
  if (!(injector instanceof NodeInjector)) {
    return resolverToTokenToDependencies.get(injector)?.get?.(token) ?? [];
  }
  const lView = getNodeInjectorLView(injector);
  const tokenDependencyMap = resolverToTokenToDependencies.get(lView);
  const dependencies = tokenDependencyMap?.get(token) ?? [];
  return dependencies.filter(dependency => {
    const dependencyNode = dependency.injectedIn?.tNode;
    if (dependencyNode === undefined) {
      return false;
    }
    const instanceNode = getNodeInjectorTNode(injector);
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNode)(dependencyNode);
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNode)(instanceNode);
    return dependencyNode === instanceNode;
  });
}
function getProviderImportsContainer(injector) {
  const {
    standaloneInjectorToComponent
  } = getFrameworkDIDebugData();
  if (standaloneInjectorToComponent.has(injector)) {
    return standaloneInjectorToComponent.get(injector);
  }
  const defTypeRef = injector.get(NgModuleRef$1, null, {
    self: true,
    optional: true
  });
  if (defTypeRef === null) {
    return null;
  }
  if (defTypeRef.instance === null) {
    return null;
  }
  return defTypeRef.instance.constructor;
}
function getNodeInjectorProviders(injector) {
  const diResolver = getNodeInjectorTNode(injector);
  const {
    resolverToProviders
  } = getFrameworkDIDebugData();
  return resolverToProviders.get(diResolver) ?? [];
}
function getProviderImportPaths(providerImportsContainer) {
  const providerToPath = new Map();
  const visitedContainers = new Set();
  const visitor = walkProviderTreeToDiscoverImportPaths(providerToPath, visitedContainers);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.walkProviderTree)(providerImportsContainer, visitor, [], new Set());
  return providerToPath;
}
function walkProviderTreeToDiscoverImportPaths(providerToPath, visitedContainers) {
  return (provider, container) => {
    if (!providerToPath.has(provider)) {
      providerToPath.set(provider, [container]);
    }
    if (!visitedContainers.has(container)) {
      for (const prov of providerToPath.keys()) {
        const existingImportPath = providerToPath.get(prov);
        let containerDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getInjectorDef)(container);
        if (!containerDef) {
          const ngModule = container.ngModule;
          containerDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getInjectorDef)(ngModule);
        }
        if (!containerDef) {
          return;
        }
        const lastContainerAddedToPath = existingImportPath[0];
        let isNextStepInPath = false;
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.deepForEach)(containerDef.imports, moduleImport => {
          if (isNextStepInPath) {
            return;
          }
          isNextStepInPath = moduleImport.ngModule === lastContainerAddedToPath || moduleImport === lastContainerAddedToPath;
          if (isNextStepInPath) {
            providerToPath.get(prov)?.unshift(container);
          }
        });
      }
    }
    visitedContainers.add(container);
  };
}
function getEnvironmentInjectorProviders(injector) {
  const providerRecordsWithoutImportPaths = getFrameworkDIDebugData().resolverToProviders.get(injector) ?? [];
  if (isPlatformInjector(injector)) {
    return providerRecordsWithoutImportPaths;
  }
  const providerImportsContainer = getProviderImportsContainer(injector);
  if (providerImportsContainer === null) {
    return providerRecordsWithoutImportPaths;
  }
  const providerToPath = getProviderImportPaths(providerImportsContainer);
  const providerRecords = [];
  for (const providerRecord of providerRecordsWithoutImportPaths) {
    const provider = providerRecord.provider;
    const token = provider.provide;
    if (token === _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT_INITIALIZER || token === _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR_DEF_TYPES) {
      continue;
    }
    let importPath = providerToPath.get(provider) ?? [];
    const def = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(providerImportsContainer);
    const isStandaloneComponent = !!def?.standalone;
    if (isStandaloneComponent) {
      importPath = [providerImportsContainer, ...importPath];
    }
    providerRecords.push({
      ...providerRecord,
      importPath
    });
  }
  return providerRecords;
}
function isPlatformInjector(injector) {
  return injector instanceof _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.R3Injector && injector.scopes.has('platform');
}
function getInjectorProviders(injector) {
  if (injector instanceof NodeInjector) {
    return getNodeInjectorProviders(injector);
  } else if (injector instanceof _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EnvironmentInjector) {
    return getEnvironmentInjectorProviders(injector);
  }
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('getInjectorProviders only supports NodeInjector and EnvironmentInjector');
}
function getInjectorMetadata(injector) {
  if (injector instanceof NodeInjector) {
    const lView = getNodeInjectorLView(injector);
    const tNode = getNodeInjectorTNode(injector);
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForLView)(tNode, lView);
    return {
      type: 'element',
      source: (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView)
    };
  }
  if (injector instanceof _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.R3Injector) {
    return {
      type: 'environment',
      source: injector.source ?? null
    };
  }
  if (injector instanceof _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NullInjector) {
    return {
      type: 'null',
      source: null
    };
  }
  return null;
}
function getInjectorResolutionPath(injector) {
  const resolutionPath = [injector];
  getInjectorResolutionPathHelper(injector, resolutionPath);
  return resolutionPath;
}
function getInjectorResolutionPathHelper(injector, resolutionPath) {
  const parent = getInjectorParent(injector);
  if (parent === null) {
    if (injector instanceof NodeInjector) {
      const firstInjector = resolutionPath[0];
      if (firstInjector instanceof NodeInjector) {
        const moduleInjector = getModuleInjectorOfNodeInjector(firstInjector);
        if (moduleInjector === null) {
          (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('NodeInjector must have some connection to the module injector tree');
        }
        resolutionPath.push(moduleInjector);
        getInjectorResolutionPathHelper(moduleInjector, resolutionPath);
      }
      return resolutionPath;
    }
  } else {
    resolutionPath.push(parent);
    getInjectorResolutionPathHelper(parent, resolutionPath);
  }
  return resolutionPath;
}
function getInjectorParent(injector) {
  if (injector instanceof _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.R3Injector) {
    return injector.parent;
  }
  let tNode;
  let lView;
  if (injector instanceof NodeInjector) {
    tNode = getNodeInjectorTNode(injector);
    lView = getNodeInjectorLView(injector);
  } else if (injector instanceof _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NullInjector) {
    return null;
  } else if (injector instanceof ChainedInjector) {
    return injector.parentInjector;
  } else {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('getInjectorParent only support injectors of type R3Injector, NodeInjector, NullInjector');
  }
  const parentLocation = getParentInjectorLocation(tNode, lView);
  if (hasParentInjector(parentLocation)) {
    const parentInjectorIndex = getParentInjectorIndex(parentLocation);
    const parentLView = getParentInjectorView(parentLocation, lView);
    const parentTView = parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
    const parentTNode = parentTView.data[parentInjectorIndex + 8];
    return new NodeInjector(parentTNode, parentLView);
  } else {
    const chainedInjector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
    const injectorParent = chainedInjector.injector?.parent;
    if (injectorParent instanceof NodeInjector) {
      return injectorParent;
    }
  }
  return null;
}
function getModuleInjectorOfNodeInjector(injector) {
  let lView;
  if (injector instanceof NodeInjector) {
    lView = getNodeInjectorLView(injector);
  } else {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('getModuleInjectorOfNodeInjector must be called with a NodeInjector');
  }
  const inj = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
  const moduleInjector = inj instanceof ChainedInjector ? inj.parentInjector : inj.parent;
  if (!moduleInjector) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('NodeInjector must have some connection to the module injector tree');
  }
  return moduleInjector;
}
function isComputedNode(node) {
  return node.kind === 'computed';
}
function isTemplateEffectNode(node) {
  return node.kind === 'template';
}
function isSignalNode(node) {
  return node.kind === 'signal';
}
function getTemplateConsumer(injector) {
  const tNode = getNodeInjectorTNode(injector);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNode)(tNode);
  const lView = getNodeInjectorLView(injector);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLView)(lView);
  const templateLView = lView[tNode.index];
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(templateLView)) {
    return templateLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.REACTIVE_TEMPLATE_CONSUMER] ?? null;
  }
  return null;
}
const signalDebugMap = new WeakMap();
let counter$1 = 0;
function getNodesAndEdgesFromSignalMap(signalMap) {
  const nodes = Array.from(signalMap.keys());
  const debugSignalGraphNodes = [];
  const edges = [];
  for (const [consumer, producers] of signalMap.entries()) {
    const consumerIndex = nodes.indexOf(consumer);
    let id = signalDebugMap.get(consumer);
    if (!id) {
      counter$1++;
      id = counter$1.toString();
      signalDebugMap.set(consumer, id);
    }
    if (isComputedNode(consumer)) {
      debugSignalGraphNodes.push({
        label: consumer.debugName,
        value: consumer.value,
        kind: consumer.kind,
        epoch: consumer.version,
        debuggableFn: consumer.computation,
        id
      });
    } else if (isSignalNode(consumer)) {
      debugSignalGraphNodes.push({
        label: consumer.debugName,
        value: consumer.value,
        kind: consumer.kind,
        epoch: consumer.version,
        id
      });
    } else if (isTemplateEffectNode(consumer)) {
      debugSignalGraphNodes.push({
        label: consumer.debugName ?? consumer.lView?.[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST]?.tagName?.toLowerCase?.(),
        kind: consumer.kind,
        epoch: consumer.version,
        debuggableFn: consumer.lView?.[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT]?.constructor,
        id
      });
    } else {
      debugSignalGraphNodes.push({
        label: consumer.debugName,
        kind: consumer.kind,
        epoch: consumer.version,
        id
      });
    }
    for (const producer of producers) {
      edges.push({
        consumer: consumerIndex,
        producer: nodes.indexOf(producer)
      });
    }
  }
  return {
    nodes: debugSignalGraphNodes,
    edges
  };
}
function extractEffectsFromInjector(injector) {
  let diResolver = injector;
  if (injector instanceof NodeInjector) {
    const lView = getNodeInjectorLView(injector);
    diResolver = lView;
  }
  const resolverToEffects = getFrameworkDIDebugData().resolverToEffects;
  const effects = resolverToEffects.get(diResolver) ?? [];
  return effects.map(effect => {
    if (effect instanceof _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EffectRefImpl) {
      return effect[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SIGNAL];
    } else {
      return effect.signal[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SIGNAL];
    }
  });
}
function extractSignalNodesAndEdgesFromRoots(nodes, signalDependenciesMap = new Map()) {
  for (const node of nodes) {
    if (signalDependenciesMap.has(node)) {
      continue;
    }
    const producerNodes = [];
    for (let link = node.producers; link !== undefined; link = link.nextProducer) {
      const producer = link.producer;
      producerNodes.push(producer);
    }
    signalDependenciesMap.set(node, producerNodes);
    extractSignalNodesAndEdgesFromRoots(producerNodes, signalDependenciesMap);
  }
  return signalDependenciesMap;
}
function getSignalGraph(injector) {
  let templateConsumer = null;
  if (!(injector instanceof NodeInjector) && !(injector instanceof _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.R3Injector)) {
    return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('getSignalGraph must be called with a NodeInjector or R3Injector');
  }
  if (injector instanceof NodeInjector) {
    templateConsumer = getTemplateConsumer(injector);
  }
  const nonTemplateEffectNodes = extractEffectsFromInjector(injector);
  const signalNodes = templateConsumer ? [templateConsumer, ...nonTemplateEffectNodes] : nonTemplateEffectNodes;
  const signalDependenciesMap = extractSignalNodesAndEdgesFromRoots(signalNodes);
  return getNodesAndEdgesFromSignalMap(signalDependenciesMap);
}
let changeDetectionRuns = 0;
let changeDetectionSyncRuns = 0;
let counter = 0;
const eventsStack = [];
function measureStart(startEvent) {
  eventsStack.push([startEvent, counter]);
  console.timeStamp('Event_' + startEvent + '_' + counter++);
}
function measureEnd(startEvent, entryName, color) {
  let top;
  do {
    top = eventsStack.pop();
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(top, 'Profiling error: could not find start event entry ' + startEvent);
  } while (top[0] !== startEvent);
  console.timeStamp(entryName, 'Event_' + top[0] + '_' + top[1], undefined, '\u{1F170}\uFE0F Angular', undefined, color);
}
const chromeDevToolsInjectorProfiler = event => {
  const eventType = event.type;
  if (eventType === 5) {
    measureStart(100);
  } else if (eventType === 1) {
    const token = event.context.token;
    measureEnd(100, getProviderTokenMeasureName(token), 'tertiary-dark');
  }
};
const devToolsProfiler = (event, instance, eventFn) => {
  switch (event) {
    case ProfilerEvent.BootstrapApplicationStart:
    case ProfilerEvent.BootstrapComponentStart:
    case ProfilerEvent.ChangeDetectionStart:
    case ProfilerEvent.ChangeDetectionSyncStart:
    case ProfilerEvent.AfterRenderHooksStart:
    case ProfilerEvent.ComponentStart:
    case ProfilerEvent.DeferBlockStateStart:
    case ProfilerEvent.DynamicComponentStart:
    case ProfilerEvent.TemplateCreateStart:
    case ProfilerEvent.LifecycleHookStart:
    case ProfilerEvent.TemplateUpdateStart:
    case ProfilerEvent.HostBindingsUpdateStart:
    case ProfilerEvent.OutputStart:
      {
        measureStart(event);
        break;
      }
    case ProfilerEvent.BootstrapApplicationEnd:
      {
        measureEnd(ProfilerEvent.BootstrapApplicationStart, 'Bootstrap application', 'primary-dark');
        break;
      }
    case ProfilerEvent.BootstrapComponentEnd:
      {
        measureEnd(ProfilerEvent.BootstrapComponentStart, 'Bootstrap component', 'primary-dark');
        break;
      }
    case ProfilerEvent.ChangeDetectionEnd:
      {
        changeDetectionSyncRuns = 0;
        measureEnd(ProfilerEvent.ChangeDetectionStart, 'Change detection ' + changeDetectionRuns++, 'primary-dark');
        break;
      }
    case ProfilerEvent.ChangeDetectionSyncEnd:
      {
        measureEnd(ProfilerEvent.ChangeDetectionSyncStart, 'Synchronization ' + changeDetectionSyncRuns++, 'primary');
        break;
      }
    case ProfilerEvent.AfterRenderHooksEnd:
      {
        measureEnd(ProfilerEvent.AfterRenderHooksStart, 'After render hooks', 'primary');
        break;
      }
    case ProfilerEvent.ComponentEnd:
      {
        const typeName = getComponentMeasureName(instance);
        measureEnd(ProfilerEvent.ComponentStart, typeName, 'primary-light');
        break;
      }
    case ProfilerEvent.DeferBlockStateEnd:
      {
        measureEnd(ProfilerEvent.DeferBlockStateStart, 'Defer block', 'primary-dark');
        break;
      }
    case ProfilerEvent.DynamicComponentEnd:
      {
        measureEnd(ProfilerEvent.DynamicComponentStart, 'Dynamic component creation', 'primary-dark');
        break;
      }
    case ProfilerEvent.TemplateUpdateEnd:
      {
        measureEnd(ProfilerEvent.TemplateUpdateStart, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(eventFn) + ' (update)', 'secondary-dark');
        break;
      }
    case ProfilerEvent.TemplateCreateEnd:
      {
        measureEnd(ProfilerEvent.TemplateCreateStart, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(eventFn) + ' (create)', 'secondary');
        break;
      }
    case ProfilerEvent.HostBindingsUpdateEnd:
      {
        measureEnd(ProfilerEvent.HostBindingsUpdateStart, 'HostBindings', 'secondary-dark');
        break;
      }
    case ProfilerEvent.LifecycleHookEnd:
      {
        const typeName = getComponentMeasureName(instance);
        measureEnd(ProfilerEvent.LifecycleHookStart, `${typeName}:${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(eventFn)}`, 'tertiary');
        break;
      }
    case ProfilerEvent.OutputEnd:
      {
        measureEnd(ProfilerEvent.OutputStart, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(eventFn), 'tertiary-light');
        break;
      }
    default:
      {
        throw new Error('Unexpected profiling event type: ' + event);
      }
  }
};
function getComponentMeasureName(instance) {
  return instance.constructor.name;
}
function getProviderTokenMeasureName(token) {
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isTypeProvider)(token)) {
    return token.name;
  } else if (token.provide != null) {
    return getProviderTokenMeasureName(token.provide);
  }
  return token.toString();
}
function enableProfiling() {
  performanceMarkFeature('Chrome DevTools profiling');
  if (typeof ngDevMode !== 'undefined' && ngDevMode) {
    const removeInjectorProfiler = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInjectorProfiler)(chromeDevToolsInjectorProfiler);
    const removeProfiler = setProfiler(devToolsProfiler);
    return () => {
      removeInjectorProfiler();
      removeProfiler();
    };
  }
  return () => {};
}
function getTransferState(injector) {
  const doc = injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT);
  const appId = injector.get(APP_ID);
  const transferState = retrieveTransferredState(doc, appId);
  const filteredEntries = {};
  for (const [key, value] of Object.entries(transferState)) {
    if (!isInternalHydrationTransferStateKey(key)) {
      filteredEntries[key] = value;
    }
  }
  return filteredEntries;
}
const GLOBAL_PUBLISH_EXPANDO_KEY = 'ng';
const globalUtilsFunctions = {
  'ɵgetDependenciesFromInjectable': getDependenciesFromInjectable,
  'ɵgetInjectorProviders': getInjectorProviders,
  'ɵgetInjectorResolutionPath': getInjectorResolutionPath,
  'ɵgetInjectorMetadata': getInjectorMetadata,
  'ɵsetProfiler': setProfiler,
  'ɵgetSignalGraph': getSignalGraph,
  'ɵgetDeferBlocks': getDeferBlocks,
  'ɵgetTransferState': getTransferState,
  'getDirectiveMetadata': getDirectiveMetadata$1,
  'getComponent': getComponent,
  'getContext': getContext,
  'getListeners': getListeners,
  'getOwningComponent': getOwningComponent,
  'getHostElement': getHostElement,
  'getInjector': getInjector,
  'getRootComponents': getRootComponents,
  'getDirectives': getDirectives,
  'applyChanges': applyChanges,
  'isSignal': isSignal,
  'enableProfiling': enableProfiling
};
let _published = false;
function publishDefaultGlobalUtils$1() {
  if (!_published) {
    _published = true;
    if (typeof window !== 'undefined') {
      setupFrameworkInjectorProfiler();
    }
    for (const [methodName, method] of Object.entries(globalUtilsFunctions)) {
      publishGlobalUtil(methodName, method);
    }
  }
}
function publishGlobalUtil(name, fn) {
  publishUtil(name, fn);
}
function publishExternalGlobalUtil(name, fn) {
  publishUtil(name, fn);
}
function publishUtil(name, fn) {
  if (typeof COMPILED === 'undefined' || !COMPILED) {
    const w = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__._global;
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(fn, 'function not defined');
    w[GLOBAL_PUBLISH_EXPANDO_KEY] ??= {};
    w[GLOBAL_PUBLISH_EXPANDO_KEY][name] = fn;
  }
}
const TESTABILITY = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('');
const TESTABILITY_GETTER = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('');
class Testability {
  _ngZone;
  registry;
  _isZoneStable = true;
  _callbacks = [];
  _taskTrackingZone = null;
  _destroyRef;
  constructor(_ngZone, registry, testabilityGetter) {
    this._ngZone = _ngZone;
    this.registry = registry;
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isInInjectionContext)()) {
      this._destroyRef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DestroyRef, {
        optional: true
      }) ?? undefined;
    }
    if (!_testabilityGetter) {
      setTestabilityGetter(testabilityGetter);
      testabilityGetter.addToWindow(registry);
    }
    this._watchAngularEvents();
    _ngZone.run(() => {
      this._taskTrackingZone = typeof Zone == 'undefined' ? null : Zone.current.get('TaskTrackingZone');
    });
  }
  _watchAngularEvents() {
    const onUnstableSubscription = this._ngZone.onUnstable.subscribe({
      next: () => {
        this._isZoneStable = false;
      }
    });
    const onStableSubscription = this._ngZone.runOutsideAngular(() => this._ngZone.onStable.subscribe({
      next: () => {
        _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone.assertNotInAngularZone();
        queueMicrotask(() => {
          this._isZoneStable = true;
          this._runCallbacksIfReady();
        });
      }
    }));
    this._destroyRef?.onDestroy(() => {
      onUnstableSubscription.unsubscribe();
      onStableSubscription.unsubscribe();
    });
  }
  isStable() {
    return this._isZoneStable && !this._ngZone.hasPendingMacrotasks;
  }
  _runCallbacksIfReady() {
    if (this.isStable()) {
      queueMicrotask(() => {
        while (this._callbacks.length !== 0) {
          let cb = this._callbacks.pop();
          clearTimeout(cb.timeoutId);
          cb.doneCb();
        }
      });
    } else {
      let pending = this.getPendingTasks();
      this._callbacks = this._callbacks.filter(cb => {
        if (cb.updateCb && cb.updateCb(pending)) {
          clearTimeout(cb.timeoutId);
          return false;
        }
        return true;
      });
    }
  }
  getPendingTasks() {
    if (!this._taskTrackingZone) {
      return [];
    }
    return this._taskTrackingZone.macroTasks.map(t => {
      return {
        source: t.source,
        creationLocation: t.creationLocation,
        data: t.data
      };
    });
  }
  addCallback(cb, timeout, updateCb) {
    let timeoutId = -1;
    if (timeout && timeout > 0) {
      timeoutId = setTimeout(() => {
        this._callbacks = this._callbacks.filter(cb => cb.timeoutId !== timeoutId);
        cb();
      }, timeout);
    }
    this._callbacks.push({
      doneCb: cb,
      timeoutId: timeoutId,
      updateCb: updateCb
    });
  }
  whenStable(doneCb, timeout, updateCb) {
    if (updateCb && !this._taskTrackingZone) {
      throw new Error('Task tracking zone is required when passing an update callback to ' + 'whenStable(). Is "zone.js/plugins/task-tracking" loaded?');
    }
    this.addCallback(doneCb, timeout, updateCb);
    this._runCallbacksIfReady();
  }
  registerApplication(token) {
    this.registry.registerApplication(token, this);
  }
  unregisterApplication(token) {
    this.registry.unregisterApplication(token);
  }
  findProviders(using, provider, exactMatch) {
    return [];
  }
  static ɵfac = function Testability_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || Testability)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(TestabilityRegistry), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(TESTABILITY_GETTER));
  };
  static ɵprov = /*@__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
    token: Testability,
    factory: Testability.ɵfac
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Testability, [{
    type: Injectable
  }], () => [{
    type: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone
  }, {
    type: TestabilityRegistry
  }, {
    type: undefined,
    decorators: [{
      type: Inject,
      args: [TESTABILITY_GETTER]
    }]
  }], null);
})();
class TestabilityRegistry {
  _applications = new Map();
  registerApplication(token, testability) {
    this._applications.set(token, testability);
  }
  unregisterApplication(token) {
    this._applications.delete(token);
  }
  unregisterAllApplications() {
    this._applications.clear();
  }
  getTestability(elem) {
    return this._applications.get(elem) || null;
  }
  getAllTestabilities() {
    return Array.from(this._applications.values());
  }
  getAllRootElements() {
    return Array.from(this._applications.keys());
  }
  findTestabilityInTree(elem, findInAncestors = true) {
    return _testabilityGetter?.findTestabilityInTree(this, elem, findInAncestors) ?? null;
  }
  static ɵfac = function TestabilityRegistry_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || TestabilityRegistry)();
  };
  static ɵprov = /*@__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
    token: TestabilityRegistry,
    factory: TestabilityRegistry.ɵfac,
    providedIn: 'platform'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TestabilityRegistry, [{
    type: Injectable,
    args: [{
      providedIn: 'platform'
    }]
  }], null, null);
})();
function setTestabilityGetter(getter) {
  _testabilityGetter = getter;
}
let _testabilityGetter;
function isPromise(obj) {
  return !!obj && typeof obj.then === 'function';
}
function isSubscribable(obj) {
  return !!obj && typeof obj.subscribe === 'function';
}
const APP_INITIALIZER = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(ngDevMode ? 'Application Initializer' : '');
function provideAppInitializer(initializerFn) {
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.makeEnvironmentProviders)([{
    provide: APP_INITIALIZER,
    multi: true,
    useValue: initializerFn
  }]);
}
class ApplicationInitStatus {
  resolve;
  reject;
  initialized = false;
  done = false;
  donePromise = new Promise((res, rej) => {
    this.resolve = res;
    this.reject = rej;
  });
  appInits = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(APP_INITIALIZER, {
    optional: true
  }) ?? [];
  injector = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.Injector);
  constructor() {
    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !Array.isArray(this.appInits)) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-209, 'Unexpected type of the `APP_INITIALIZER` token value ' + `(expected an array, but got ${typeof this.appInits}). ` + 'Please check that the `APP_INITIALIZER` token is configured as a ' + '`multi: true` provider.');
    }
  }
  runInitializers() {
    if (this.initialized) {
      return;
    }
    const asyncInitPromises = [];
    for (const appInits of this.appInits) {
      const initResult = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.runInInjectionContext)(this.injector, appInits);
      if (isPromise(initResult)) {
        asyncInitPromises.push(initResult);
      } else if (isSubscribable(initResult)) {
        const observableAsPromise = new Promise((resolve, reject) => {
          initResult.subscribe({
            complete: resolve,
            error: reject
          });
        });
        asyncInitPromises.push(observableAsPromise);
      }
    }
    const complete = () => {
      this.done = true;
      this.resolve();
    };
    Promise.all(asyncInitPromises).then(() => {
      complete();
    }).catch(e => {
      this.reject(e);
    });
    if (asyncInitPromises.length === 0) {
      complete();
    }
    this.initialized = true;
  }
  static ɵfac = function ApplicationInitStatus_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || ApplicationInitStatus)();
  };
  static ɵprov = /*@__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
    token: ApplicationInitStatus,
    factory: ApplicationInitStatus.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationInitStatus, [{
    type: Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], () => [], null);
})();
const APP_BOOTSTRAP_LISTENER = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(ngDevMode ? 'appBootstrapListener' : '');
function publishDefaultGlobalUtils() {
  ngDevMode && publishDefaultGlobalUtils$1();
}
function publishSignalConfiguration() {
  (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setThrowInvalidWriteToSignalError)(() => {
    let errorMessage = '';
    if (ngDevMode) {
      const activeConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getActiveConsumer)();
      errorMessage = activeConsumer && isReactiveLViewConsumer(activeConsumer) ? 'Writing to signals is not allowed while Angular renders the template (eg. interpolations)' : 'Writing to signals is not allowed in a `computed`';
    }
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(600, errorMessage);
  });
}
function isBoundToModule(cf) {
  return cf.isBoundToModule;
}
const MAXIMUM_REFRESH_RERUNS = 10;
function optionsReducer(dst, objs) {
  if (Array.isArray(objs)) {
    return objs.reduce(optionsReducer, dst);
  }
  return {
    ...dst,
    ...objs
  };
}
class ApplicationRef {
  _runningTick = false;
  _destroyed = false;
  _destroyListeners = [];
  _views = [];
  internalErrorHandler = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INTERNAL_APPLICATION_ERROR_HANDLER);
  afterRenderManager = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(AfterRenderManager);
  zonelessEnabled = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ZONELESS_ENABLED);
  rootEffectScheduler = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EffectScheduler);
  dirtyFlags = 0;
  tracingSnapshot = null;
  allTestViews = new Set();
  autoDetectTestViews = new Set();
  includeAllTestViews = false;
  afterTick = new rxjs__WEBPACK_IMPORTED_MODULE_3__.Subject();
  get allViews() {
    return [...(this.includeAllTestViews ? this.allTestViews : this.autoDetectTestViews).keys(), ...this._views];
  }
  get destroyed() {
    return this._destroyed;
  }
  componentTypes = [];
  components = [];
  internalPendingTask = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PendingTasksInternal);
  get isStable() {
    return this.internalPendingTask.hasPendingTasksObservable.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.map)(pending => !pending));
  }
  constructor() {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(TracingService, {
      optional: true
    });
  }
  whenStable() {
    let subscription;
    return new Promise(resolve => {
      subscription = this.isStable.subscribe({
        next: stable => {
          if (stable) {
            resolve();
          }
        }
      });
    }).finally(() => {
      subscription.unsubscribe();
    });
  }
  _injector = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EnvironmentInjector);
  _rendererFactory = null;
  get injector() {
    return this._injector;
  }
  bootstrap(componentOrFactory, rootSelectorOrNode) {
    return this.bootstrapImpl(componentOrFactory, rootSelectorOrNode);
  }
  bootstrapImpl(componentOrFactory, rootSelectorOrNode, injector = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.Injector.NULL) {
    const ngZone = this._injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone);
    return ngZone.run(() => {
      profiler(ProfilerEvent.BootstrapComponentStart);
      (typeof ngDevMode === 'undefined' || ngDevMode) && warnIfDestroyed(this._destroyed);
      const isComponentFactory = componentOrFactory instanceof ComponentFactory$1;
      const initStatus = this._injector.get(ApplicationInitStatus);
      if (!initStatus.done) {
        let errorMessage = '';
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
          const standalone = !isComponentFactory && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isStandalone)(componentOrFactory);
          errorMessage = 'Cannot bootstrap as there are still asynchronous initializers running.' + (standalone ? '' : ' Bootstrap components in the `ngDoBootstrap` method of the root module.');
        }
        throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(405, errorMessage);
      }
      let componentFactory;
      if (isComponentFactory) {
        componentFactory = componentOrFactory;
      } else {
        const resolver = this._injector.get(ComponentFactoryResolver$1);
        componentFactory = resolver.resolveComponentFactory(componentOrFactory);
      }
      this.componentTypes.push(componentFactory.componentType);
      const ngModule = isBoundToModule(componentFactory) ? undefined : this._injector.get(NgModuleRef$1);
      const selectorOrNode = rootSelectorOrNode || componentFactory.selector;
      const compRef = componentFactory.create(injector, [], selectorOrNode, ngModule);
      const nativeElement = compRef.location.nativeElement;
      const testability = compRef.injector.get(TESTABILITY, null);
      testability?.registerApplication(nativeElement);
      compRef.onDestroy(() => {
        this.detachView(compRef.hostView);
        remove(this.components, compRef);
        testability?.unregisterApplication(nativeElement);
      });
      this._loadComponent(compRef);
      if (typeof ngDevMode === 'undefined' || ngDevMode) {
        const _console = this._injector.get(Console);
        _console.log(`Angular is running in development mode.`);
      }
      profiler(ProfilerEvent.BootstrapComponentEnd, compRef);
      return compRef;
    });
  }
  tick() {
    if (!this.zonelessEnabled) {
      this.dirtyFlags |= 1;
    }
    this._tick();
  }
  _tick() {
    profiler(ProfilerEvent.ChangeDetectionStart);
    if (this.tracingSnapshot !== null) {
      this.tracingSnapshot.run(TracingAction.CHANGE_DETECTION, this.tickImpl);
    } else {
      this.tickImpl();
    }
  }
  tickImpl = () => {
    (typeof ngDevMode === 'undefined' || ngDevMode) && warnIfDestroyed(this._destroyed);
    if (this._runningTick) {
      profiler(ProfilerEvent.ChangeDetectionEnd);
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(101, ngDevMode && 'ApplicationRef.tick is called recursively');
    }
    const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
    try {
      this._runningTick = true;
      this.synchronize();
      if (typeof ngDevMode === 'undefined' || ngDevMode) {
        for (let view of this.allViews) {
          view.checkNoChanges();
        }
      }
    } finally {
      this._runningTick = false;
      this.tracingSnapshot?.dispose();
      this.tracingSnapshot = null;
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
      this.afterTick.next();
      profiler(ProfilerEvent.ChangeDetectionEnd);
    }
  };
  synchronize() {
    if (this._rendererFactory === null && !this._injector.destroyed) {
      this._rendererFactory = this._injector.get(RendererFactory2, null, {
        optional: true
      });
    }
    let runs = 0;
    while (this.dirtyFlags !== 0 && runs++ < MAXIMUM_REFRESH_RERUNS) {
      profiler(ProfilerEvent.ChangeDetectionSyncStart);
      try {
        this.synchronizeOnce();
      } finally {
        profiler(ProfilerEvent.ChangeDetectionSyncEnd);
      }
    }
    if ((typeof ngDevMode === 'undefined' || ngDevMode) && runs >= MAXIMUM_REFRESH_RERUNS) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(103, ngDevMode && 'Infinite change detection while refreshing application views. ' + 'Ensure views are not calling `markForCheck` on every template execution or ' + 'that afterRender hooks always mark views for check.');
    }
  }
  synchronizeOnce() {
    if (this.dirtyFlags & 16) {
      this.dirtyFlags &= ~16;
      this.rootEffectScheduler.flush();
    }
    let ranDetectChanges = false;
    if (this.dirtyFlags & 7) {
      const useGlobalCheck = Boolean(this.dirtyFlags & 1);
      this.dirtyFlags &= ~7;
      this.dirtyFlags |= 8;
      for (let {
        _lView
      } of this.allViews) {
        if (!useGlobalCheck && !(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.requiresRefreshOrTraversal)(_lView)) {
          continue;
        }
        const mode = useGlobalCheck && !this.zonelessEnabled ? 0 : 1;
        detectChangesInternal(_lView, mode);
        ranDetectChanges = true;
      }
      this.dirtyFlags &= ~4;
      this.syncDirtyFlagsWithViews();
      if (this.dirtyFlags & (7 | 16)) {
        return;
      }
    }
    if (!ranDetectChanges) {
      this._rendererFactory?.begin?.();
      this._rendererFactory?.end?.();
    }
    if (this.dirtyFlags & 8) {
      this.dirtyFlags &= ~8;
      this.afterRenderManager.execute();
    }
    this.syncDirtyFlagsWithViews();
  }
  syncDirtyFlagsWithViews() {
    if (this.allViews.some(({
      _lView
    }) => (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.requiresRefreshOrTraversal)(_lView))) {
      this.dirtyFlags |= 2;
      return;
    } else {
      this.dirtyFlags &= ~7;
    }
  }
  attachView(viewRef) {
    (typeof ngDevMode === 'undefined' || ngDevMode) && warnIfDestroyed(this._destroyed);
    const view = viewRef;
    this._views.push(view);
    view.attachToAppRef(this);
  }
  detachView(viewRef) {
    (typeof ngDevMode === 'undefined' || ngDevMode) && warnIfDestroyed(this._destroyed);
    const view = viewRef;
    remove(this._views, view);
    view.detachFromAppRef();
  }
  _loadComponent(componentRef) {
    this.attachView(componentRef.hostView);
    try {
      this.tick();
    } catch (e) {
      this.internalErrorHandler(e);
    }
    this.components.push(componentRef);
    const listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, []);
    if (ngDevMode && !Array.isArray(listeners)) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-209, 'Unexpected type of the `APP_BOOTSTRAP_LISTENER` token value ' + `(expected an array, but got ${typeof listeners}). ` + 'Please check that the `APP_BOOTSTRAP_LISTENER` token is configured as a ' + '`multi: true` provider.');
    }
    listeners.forEach(listener => listener(componentRef));
  }
  ngOnDestroy() {
    if (this._destroyed) return;
    try {
      this._destroyListeners.forEach(listener => listener());
      this._views.slice().forEach(view => view.destroy());
    } finally {
      this._destroyed = true;
      this._views = [];
      this._destroyListeners = [];
    }
  }
  onDestroy(callback) {
    (typeof ngDevMode === 'undefined' || ngDevMode) && warnIfDestroyed(this._destroyed);
    this._destroyListeners.push(callback);
    return () => remove(this._destroyListeners, callback);
  }
  destroy() {
    if (this._destroyed) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(406, ngDevMode && 'This instance of the `ApplicationRef` has already been destroyed.');
    }
    const injector = this._injector;
    if (injector.destroy && !injector.destroyed) {
      injector.destroy();
    }
  }
  get viewCount() {
    return this._views.length;
  }
  static ɵfac = function ApplicationRef_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || ApplicationRef)();
  };
  static ɵprov = /*@__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
    token: ApplicationRef,
    factory: ApplicationRef.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationRef, [{
    type: Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], () => [], null);
})();
function warnIfDestroyed(destroyed) {
  if (destroyed) {
    console.warn((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(406, 'This instance of the `ApplicationRef` has already been destroyed.'));
  }
}
function remove(list, el) {
  const index = list.indexOf(el);
  if (index > -1) {
    list.splice(index, 1);
  }
}
function promiseWithResolvers() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return {
    promise,
    resolve,
    reject
  };
}
function scheduleDelayedTrigger(scheduleFn) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  renderPlaceholder(lView, tNode);
  if (!shouldTriggerDeferBlock(0, lView)) return;
  const injector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const cleanupFn = scheduleFn(() => triggerDeferBlock(0, lView, tNode), injector);
  storeTriggerCleanupFn(0, lDetails, cleanupFn);
}
function scheduleDelayedPrefetching(scheduleFn) {
  if (typeof ngServerMode !== 'undefined' && ngServerMode) return;
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const injector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    const lDetails = getLDeferBlockDetails(lView, tNode);
    const prefetch = () => triggerPrefetching(tDetails, lView, tNode);
    const cleanupFn = scheduleFn(prefetch, injector);
    storeTriggerCleanupFn(1, lDetails, cleanupFn);
  }
}
function scheduleDelayedHydrating(scheduleFn, lView, tNode) {
  if (typeof ngServerMode !== 'undefined' && ngServerMode) return;
  const injector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const ssrUniqueId = lDetails[SSR_UNIQUE_ID];
  ngDevMode && assertSsrIdDefined(ssrUniqueId);
  const cleanupFn = scheduleFn(() => triggerHydrationFromBlockName(injector, ssrUniqueId), injector);
  storeTriggerCleanupFn(2, lDetails, cleanupFn);
}
function triggerPrefetching(tDetails, lView, tNode) {
  triggerResourceLoading(tDetails, lView, tNode);
}
function triggerResourceLoading(tDetails, lView, tNode) {
  const injector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  if (tDetails.loadingState !== DeferDependenciesLoadingState.NOT_STARTED) {
    return tDetails.loadingPromise ?? Promise.resolve();
  }
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const primaryBlockTNode = getPrimaryBlockTNode(tView, tDetails);
  tDetails.loadingState = DeferDependenciesLoadingState.IN_PROGRESS;
  invokeTriggerCleanupFns(1, lDetails);
  let dependenciesFn = tDetails.dependencyResolverFn;
  if (ngDevMode) {
    const deferDependencyInterceptor = injector.get(DEFER_BLOCK_DEPENDENCY_INTERCEPTOR, null, {
      optional: true
    });
    if (deferDependencyInterceptor) {
      dependenciesFn = deferDependencyInterceptor.intercept(dependenciesFn);
    }
  }
  const removeTask = injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PendingTasks).add();
  if (!dependenciesFn) {
    tDetails.loadingPromise = Promise.resolve().then(() => {
      tDetails.loadingPromise = null;
      tDetails.loadingState = DeferDependenciesLoadingState.COMPLETE;
      removeTask();
    });
    return tDetails.loadingPromise;
  }
  tDetails.loadingPromise = Promise.allSettled(dependenciesFn()).then(results => {
    let failed = false;
    const directiveDefs = [];
    const pipeDefs = [];
    for (const result of results) {
      if (result.status === 'fulfilled') {
        const dependency = result.value;
        const directiveDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(dependency) || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(dependency);
        if (directiveDef) {
          directiveDefs.push(directiveDef);
        } else {
          const pipeDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getPipeDef)(dependency);
          if (pipeDef) {
            pipeDefs.push(pipeDef);
          }
        }
      } else {
        failed = true;
        break;
      }
    }
    if (failed) {
      tDetails.loadingState = DeferDependenciesLoadingState.FAILED;
      if (tDetails.errorTmplIndex === null) {
        const templateLocation = ngDevMode ? getTemplateLocationDetails(lView) : '';
        const error = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-750, ngDevMode && 'Loading dependencies for `@defer` block failed, ' + `but no \`@error\` block was configured${templateLocation}. ` + 'Consider using the `@error` block to render an error state.');
        handleUncaughtError(lView, error);
      }
    } else {
      tDetails.loadingState = DeferDependenciesLoadingState.COMPLETE;
      const primaryBlockTView = primaryBlockTNode.tView;
      if (directiveDefs.length > 0) {
        primaryBlockTView.directiveRegistry = addDepsToRegistry(primaryBlockTView.directiveRegistry, directiveDefs);
        const directiveTypes = directiveDefs.map(def => def.type);
        const providers = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.internalImportProvidersFrom)(false, ...directiveTypes);
        tDetails.providers = providers;
      }
      if (pipeDefs.length > 0) {
        primaryBlockTView.pipeRegistry = addDepsToRegistry(primaryBlockTView.pipeRegistry, pipeDefs);
      }
    }
  });
  return tDetails.loadingPromise.finally(() => {
    tDetails.loadingPromise = null;
    removeTask();
  });
}
function shouldTriggerDeferBlock(triggerType, lView) {
  if (triggerType === 0 && typeof ngServerMode !== 'undefined' && ngServerMode) {
    return false;
  }
  const injector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
  const config = injector.get(DEFER_BLOCK_CONFIG, null, {
    optional: true
  });
  if (config?.behavior === DeferBlockBehavior.Manual) {
    return false;
  }
  return true;
}
function triggerDeferBlock(triggerType, lView, tNode) {
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const lContainer = lView[tNode.index];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLContainer)(lContainer);
  if (!shouldTriggerDeferBlock(triggerType, lView)) return;
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const tDetails = getTDeferBlockDetails(tView, tNode);
  invokeAllTriggerCleanupFns(lDetails);
  switch (tDetails.loadingState) {
    case DeferDependenciesLoadingState.NOT_STARTED:
      renderDeferBlockState(DeferBlockState.Loading, tNode, lContainer);
      triggerResourceLoading(tDetails, lView, tNode);
      if (tDetails.loadingState === DeferDependenciesLoadingState.IN_PROGRESS) {
        renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer);
      }
      break;
    case DeferDependenciesLoadingState.IN_PROGRESS:
      renderDeferBlockState(DeferBlockState.Loading, tNode, lContainer);
      renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer);
      break;
    case DeferDependenciesLoadingState.COMPLETE:
      ngDevMode && assertDeferredDependenciesLoaded(tDetails);
      renderDeferBlockState(DeferBlockState.Complete, tNode, lContainer);
      break;
    case DeferDependenciesLoadingState.FAILED:
      renderDeferBlockState(DeferBlockState.Error, tNode, lContainer);
      break;
    default:
      if (ngDevMode) {
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('Unknown defer block state');
      }
  }
}
function triggerHydrationFromBlockName(_x4, _x5, _x6) {
  return _triggerHydrationFromBlockName.apply(this, arguments);
}
function _triggerHydrationFromBlockName() {
  _triggerHydrationFromBlockName = (0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (injector, blockName, replayQueuedEventsFn) {
    const dehydratedBlockRegistry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
    const blocksBeingHydrated = dehydratedBlockRegistry.hydrating;
    if (blocksBeingHydrated.has(blockName)) {
      return;
    }
    const {
      parentBlockPromise,
      hydrationQueue
    } = getParentBlockHydrationQueue(blockName, injector);
    if (hydrationQueue.length === 0) return;
    if (parentBlockPromise !== null) {
      hydrationQueue.shift();
    }
    populateHydratingStateForQueue(dehydratedBlockRegistry, hydrationQueue);
    if (parentBlockPromise !== null) {
      yield parentBlockPromise;
    }
    const topmostParentBlock = hydrationQueue[0];
    if (dehydratedBlockRegistry.has(topmostParentBlock)) {
      yield triggerHydrationForBlockQueue(injector, hydrationQueue, replayQueuedEventsFn);
    } else {
      dehydratedBlockRegistry.awaitParentBlock(topmostParentBlock, /*#__PURE__*/(0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
        return yield triggerHydrationForBlockQueue(injector, hydrationQueue, replayQueuedEventsFn);
      }));
    }
  });
  return _triggerHydrationFromBlockName.apply(this, arguments);
}
function triggerHydrationForBlockQueue(_x7, _x8, _x9) {
  return _triggerHydrationForBlockQueue.apply(this, arguments);
}
function _triggerHydrationForBlockQueue() {
  _triggerHydrationForBlockQueue = (0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (injector, hydrationQueue, replayQueuedEventsFn) {
    const dehydratedBlockRegistry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
    const blocksBeingHydrated = dehydratedBlockRegistry.hydrating;
    const pendingTasks = injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PendingTasksInternal);
    const taskId = pendingTasks.add();
    for (let blockQueueIdx = 0; blockQueueIdx < hydrationQueue.length; blockQueueIdx++) {
      const dehydratedBlockId = hydrationQueue[blockQueueIdx];
      const dehydratedDeferBlock = dehydratedBlockRegistry.get(dehydratedBlockId);
      if (dehydratedDeferBlock != null) {
        yield triggerResourceLoadingForHydration(dehydratedDeferBlock);
        yield nextRender(injector);
        if (deferBlockHasErrored(dehydratedDeferBlock)) {
          removeDehydratedViewList(dehydratedDeferBlock);
          cleanupRemainingHydrationQueue(hydrationQueue.slice(blockQueueIdx), dehydratedBlockRegistry);
          break;
        }
        blocksBeingHydrated.get(dehydratedBlockId).resolve();
      } else {
        cleanupParentContainer(blockQueueIdx, hydrationQueue, dehydratedBlockRegistry);
        cleanupRemainingHydrationQueue(hydrationQueue.slice(blockQueueIdx), dehydratedBlockRegistry);
        break;
      }
    }
    const lastBlockName = hydrationQueue[hydrationQueue.length - 1];
    yield blocksBeingHydrated.get(lastBlockName)?.promise;
    pendingTasks.remove(taskId);
    if (replayQueuedEventsFn) {
      replayQueuedEventsFn(hydrationQueue);
    }
    cleanupHydratedDeferBlocks(dehydratedBlockRegistry.get(lastBlockName), hydrationQueue, dehydratedBlockRegistry, injector.get(ApplicationRef));
  });
  return _triggerHydrationForBlockQueue.apply(this, arguments);
}
function deferBlockHasErrored(deferBlock) {
  return getLDeferBlockDetails(deferBlock.lView, deferBlock.tNode)[DEFER_BLOCK_STATE] === DeferBlockState.Error;
}
function cleanupParentContainer(currentBlockIdx, hydrationQueue, dehydratedBlockRegistry) {
  const parentDeferBlockIdx = currentBlockIdx - 1;
  const parentDeferBlock = parentDeferBlockIdx > -1 ? dehydratedBlockRegistry.get(hydrationQueue[parentDeferBlockIdx]) : null;
  if (parentDeferBlock) {
    cleanupLContainer(parentDeferBlock.lContainer);
  }
}
function cleanupRemainingHydrationQueue(hydrationQueue, dehydratedBlockRegistry) {
  const blocksBeingHydrated = dehydratedBlockRegistry.hydrating;
  for (const dehydratedBlockId in hydrationQueue) {
    blocksBeingHydrated.get(dehydratedBlockId)?.reject();
  }
  dehydratedBlockRegistry.cleanup(hydrationQueue);
}
function populateHydratingStateForQueue(registry, queue) {
  for (let blockId of queue) {
    registry.hydrating.set(blockId, promiseWithResolvers());
  }
}
function nextRender(injector) {
  return new Promise(resolveFn => afterNextRender(resolveFn, {
    injector
  }));
}
function triggerResourceLoadingForHydration(_x0) {
  return _triggerResourceLoadingForHydration.apply(this, arguments);
}
function _triggerResourceLoadingForHydration() {
  _triggerResourceLoadingForHydration = (0,C_Users_liuko_projects_git_RiverScript_Angular_Edition_ChatAng_node_modules_pnpm_babel_runtime_7_28_4_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (dehydratedBlock) {
    const {
      tNode,
      lView
    } = dehydratedBlock;
    const lDetails = getLDeferBlockDetails(lView, tNode);
    return new Promise(resolve => {
      onDeferBlockCompletion(lDetails, resolve);
      triggerDeferBlock(2, lView, tNode);
    });
  });
  return _triggerResourceLoadingForHydration.apply(this, arguments);
}
function onDeferBlockCompletion(lDetails, callback) {
  if (!Array.isArray(lDetails[ON_COMPLETE_FNS])) {
    lDetails[ON_COMPLETE_FNS] = [];
  }
  lDetails[ON_COMPLETE_FNS].push(callback);
}
function shouldAttachTrigger(triggerType, lView, tNode) {
  if (triggerType === 0) {
    return shouldAttachRegularTrigger(lView, tNode);
  } else if (triggerType === 2) {
    return !shouldAttachRegularTrigger(lView, tNode);
  }
  return !(typeof ngServerMode !== 'undefined' && ngServerMode);
}
function hasHydrateTriggers(flags) {
  return flags != null && (flags & 1) === 1;
}
function shouldAttachRegularTrigger(lView, tNode) {
  const injector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
  const tDetails = getTDeferBlockDetails(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode);
  const incrementalHydrationEnabled = isIncrementalHydrationEnabled(injector);
  const _hasHydrateTriggers = hasHydrateTriggers(tDetails.flags);
  if (typeof ngServerMode !== 'undefined' && ngServerMode) {
    return !incrementalHydrationEnabled || !_hasHydrateTriggers;
  }
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const wasServerSideRendered = lDetails[SSR_UNIQUE_ID] !== null;
  if (_hasHydrateTriggers && wasServerSideRendered && incrementalHydrationEnabled) {
    return false;
  }
  return true;
}
function getHydrateTriggers(tView, tNode) {
  const tDetails = getTDeferBlockDetails(tView, tNode);
  return tDetails.hydrateTriggers ??= new Map();
}
function processAndInitTriggers(injector, blockData, nodes) {
  const idleElements = [];
  const timerElements = [];
  const viewportElements = [];
  const immediateElements = [];
  for (let [blockId, blockSummary] of blockData) {
    const commentNode = nodes.get(blockId);
    if (commentNode !== undefined) {
      const numRootNodes = blockSummary.data[NUM_ROOT_NODES];
      let currentNode = commentNode;
      for (let i = 0; i < numRootNodes; i++) {
        currentNode = currentNode.previousSibling;
        if (currentNode.nodeType !== Node.ELEMENT_NODE) {
          continue;
        }
        const elementTrigger = {
          el: currentNode,
          blockName: blockId
        };
        if (blockSummary.hydrate.idle) {
          idleElements.push(elementTrigger);
        }
        if (blockSummary.hydrate.immediate) {
          immediateElements.push(elementTrigger);
        }
        if (blockSummary.hydrate.timer !== null) {
          elementTrigger.delay = blockSummary.hydrate.timer;
          timerElements.push(elementTrigger);
        }
        if (blockSummary.hydrate.viewport) {
          if (typeof blockSummary.hydrate.viewport !== 'boolean') {
            elementTrigger.intersectionObserverOptions = blockSummary.hydrate.viewport;
          }
          viewportElements.push(elementTrigger);
        }
      }
    }
  }
  setIdleTriggers(injector, idleElements);
  setImmediateTriggers(injector, immediateElements);
  setViewportTriggers(injector, viewportElements);
  setTimerTriggers(injector, timerElements);
}
function setIdleTriggers(injector, elementTriggers) {
  for (const elementTrigger of elementTriggers) {
    const registry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
    const onInvoke = () => triggerHydrationFromBlockName(injector, elementTrigger.blockName);
    const cleanupFn = onIdle(onInvoke, injector);
    registry.addCleanupFn(elementTrigger.blockName, cleanupFn);
  }
}
function setViewportTriggers(injector, elementTriggers) {
  if (elementTriggers.length > 0) {
    const registry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
    for (let elementTrigger of elementTriggers) {
      const cleanupFn = onViewportWrapper(elementTrigger.el, () => triggerHydrationFromBlockName(injector, elementTrigger.blockName), injector, elementTrigger.intersectionObserverOptions);
      registry.addCleanupFn(elementTrigger.blockName, cleanupFn);
    }
  }
}
function setTimerTriggers(injector, elementTriggers) {
  for (const elementTrigger of elementTriggers) {
    const registry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
    const onInvoke = () => triggerHydrationFromBlockName(injector, elementTrigger.blockName);
    const timerFn = onTimer(elementTrigger.delay);
    const cleanupFn = timerFn(onInvoke, injector);
    registry.addCleanupFn(elementTrigger.blockName, cleanupFn);
  }
}
function setImmediateTriggers(injector, elementTriggers) {
  for (const elementTrigger of elementTriggers) {
    triggerHydrationFromBlockName(injector, elementTrigger.blockName);
  }
}
let _hmrWarningProduced = false;
function logHmrWarning(injector) {
  if (!_hmrWarningProduced) {
    _hmrWarningProduced = true;
    const console = injector.get(Console);
    console.log((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(-751, 'Angular has detected that this application contains `@defer` blocks ' + 'and the hot module replacement (HMR) mode is enabled. All `@defer` ' + 'block dependencies will be loaded eagerly.'));
  }
}
function ɵɵdefer(index, primaryTmplIndex, dependencyResolverFn, loadingTmplIndex, placeholderTmplIndex, errorTmplIndex, loadingConfigIndex, placeholderConfigIndex, enableTimerScheduling, flags) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const tNode = declareNoDirectiveHostTemplate(lView, tView, index, null, 0, 0);
  const injector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
  const incrementalHydrationEnabled = isIncrementalHydrationEnabled(injector);
  if (tView.firstCreatePass) {
    performanceMarkFeature('NgDefer');
    if (ngDevMode) {
      if (typeof ngHmrMode !== 'undefined' && ngHmrMode) {
        logHmrWarning(injector);
      }
      if (hasHydrateTriggers(flags) && !incrementalHydrationEnabled) {
        warnIncrementalHydrationNotConfigured();
      }
    }
    const tDetails = {
      primaryTmplIndex,
      loadingTmplIndex: loadingTmplIndex ?? null,
      placeholderTmplIndex: placeholderTmplIndex ?? null,
      errorTmplIndex: errorTmplIndex ?? null,
      placeholderBlockConfig: null,
      loadingBlockConfig: null,
      dependencyResolverFn: dependencyResolverFn ?? null,
      loadingState: DeferDependenciesLoadingState.NOT_STARTED,
      loadingPromise: null,
      providers: null,
      hydrateTriggers: null,
      debug: null,
      flags: flags ?? 0
    };
    enableTimerScheduling?.(tView, tDetails, placeholderConfigIndex, loadingConfigIndex);
    setTDeferBlockDetails(tView, adjustedIndex, tDetails);
  }
  const lContainer = lView[adjustedIndex];
  populateDehydratedViewsInLContainer(lContainer, tNode, lView);
  let ssrBlockState = null;
  let ssrUniqueId = null;
  if (lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DEHYDRATED_VIEWS]?.length > 0) {
    const info = lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DEHYDRATED_VIEWS][0].data;
    ssrUniqueId = info[DEFER_BLOCK_ID] ?? null;
    ssrBlockState = info[DEFER_BLOCK_STATE$1];
  }
  const lDetails = [null, DeferBlockInternalState.Initial, null, null, null, null, ssrUniqueId, ssrBlockState, null, null];
  setLDeferBlockDetails(lView, adjustedIndex, lDetails);
  let registry = null;
  if (ssrUniqueId !== null && incrementalHydrationEnabled) {
    registry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
    registry.add(ssrUniqueId, {
      lView,
      tNode,
      lContainer
    });
  }
  const onLViewDestroy = () => {
    invokeAllTriggerCleanupFns(lDetails);
    if (ssrUniqueId !== null) {
      registry?.cleanup([ssrUniqueId]);
    }
  };
  storeTriggerCleanupFn(0, lDetails, () => (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.removeLViewOnDestroy)(lView, onLViewDestroy));
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.storeLViewOnDestroy)(lView, onLViewDestroy);
}
function ɵɵdeferWhen(rawValue) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, 'when <expression>');
  }
  if (!shouldAttachTrigger(0, lView, tNode)) return;
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, rawValue)) {
    const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
    try {
      const value = Boolean(rawValue);
      const lDetails = getLDeferBlockDetails(lView, tNode);
      const renderedState = lDetails[DEFER_BLOCK_STATE];
      if (value === false && renderedState === DeferBlockInternalState.Initial) {
        renderPlaceholder(lView, tNode);
      } else if (value === true && (renderedState === DeferBlockInternalState.Initial || renderedState === DeferBlockState.Placeholder)) {
        triggerDeferBlock(0, lView, tNode);
      }
    } finally {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
    }
  }
}
function ɵɵdeferPrefetchWhen(rawValue) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, 'prefetch when <expression>');
  }
  if (!shouldAttachTrigger(1, lView, tNode)) return;
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, rawValue)) {
    const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
    try {
      const value = Boolean(rawValue);
      const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
      const tDetails = getTDeferBlockDetails(tView, tNode);
      if (value === true && tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
        triggerPrefetching(tDetails, lView, tNode);
      }
    } finally {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
    }
  }
}
function ɵɵdeferHydrateWhen(rawValue) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, 'hydrate when <expression>');
  }
  if (!shouldAttachTrigger(2, lView, tNode)) return;
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const hydrateTriggers = getHydrateTriggers(tView, tNode);
  hydrateTriggers.set(6, null);
  if (bindingUpdated(lView, bindingIndex, rawValue)) {
    if (typeof ngServerMode !== 'undefined' && ngServerMode) {
      triggerDeferBlock(2, lView, tNode);
    } else {
      const injector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
      const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
      try {
        const value = Boolean(rawValue);
        if (value === true) {
          const lDetails = getLDeferBlockDetails(lView, tNode);
          const ssrUniqueId = lDetails[SSR_UNIQUE_ID];
          ngDevMode && assertSsrIdDefined(ssrUniqueId);
          triggerHydrationFromBlockName(injector, ssrUniqueId);
        }
      } finally {
        (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
      }
    }
  }
}
function ɵɵdeferHydrateNever() {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, 'hydrate never');
  }
  if (!shouldAttachTrigger(2, lView, tNode)) return;
  const hydrateTriggers = getHydrateTriggers((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)(), tNode);
  hydrateTriggers.set(7, null);
  if (typeof ngServerMode !== 'undefined' && ngServerMode) {
    triggerDeferBlock(2, lView, tNode);
  }
}
function ɵɵdeferOnIdle() {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, 'on idle');
  }
  if (!shouldAttachTrigger(0, lView, tNode)) return;
  scheduleDelayedTrigger(onIdle);
}
function ɵɵdeferPrefetchOnIdle() {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, 'prefetch on idle');
  }
  if (!shouldAttachTrigger(1, lView, tNode)) return;
  scheduleDelayedPrefetching(onIdle);
}
function ɵɵdeferHydrateOnIdle() {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, 'hydrate on idle');
  }
  if (!shouldAttachTrigger(2, lView, tNode)) return;
  const hydrateTriggers = getHydrateTriggers((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)(), tNode);
  hydrateTriggers.set(0, null);
  if (typeof ngServerMode !== 'undefined' && ngServerMode) {
    triggerDeferBlock(2, lView, tNode);
  } else {
    scheduleDelayedHydrating(onIdle, lView, tNode);
  }
}
function ɵɵdeferOnImmediate() {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, 'on immediate');
  }
  if (!shouldAttachTrigger(0, lView, tNode)) return;
  const tDetails = getTDeferBlockDetails(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode);
  if (tDetails.loadingTmplIndex === null) {
    renderPlaceholder(lView, tNode);
  }
  triggerDeferBlock(0, lView, tNode);
}
function ɵɵdeferPrefetchOnImmediate() {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, 'prefetch on immediate');
  }
  if (!shouldAttachTrigger(1, lView, tNode)) return;
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    triggerResourceLoading(tDetails, lView, tNode);
  }
}
function ɵɵdeferHydrateOnImmediate() {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, 'hydrate on immediate');
  }
  if (!shouldAttachTrigger(2, lView, tNode)) return;
  const hydrateTriggers = getHydrateTriggers((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)(), tNode);
  hydrateTriggers.set(1, null);
  if (typeof ngServerMode !== 'undefined' && ngServerMode) {
    triggerDeferBlock(2, lView, tNode);
  } else {
    const injector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
    const lDetails = getLDeferBlockDetails(lView, tNode);
    const ssrUniqueId = lDetails[SSR_UNIQUE_ID];
    ngDevMode && assertSsrIdDefined(ssrUniqueId);
    triggerHydrationFromBlockName(injector, ssrUniqueId);
  }
}
function ɵɵdeferOnTimer(delay) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, `on timer(${delay}ms)`);
  }
  if (!shouldAttachTrigger(0, lView, tNode)) return;
  scheduleDelayedTrigger(onTimer(delay));
}
function ɵɵdeferPrefetchOnTimer(delay) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, `prefetch on timer(${delay}ms)`);
  }
  if (!shouldAttachTrigger(1, lView, tNode)) return;
  scheduleDelayedPrefetching(onTimer(delay));
}
function ɵɵdeferHydrateOnTimer(delay) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, `hydrate on timer(${delay}ms)`);
  }
  if (!shouldAttachTrigger(2, lView, tNode)) return;
  const hydrateTriggers = getHydrateTriggers((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)(), tNode);
  hydrateTriggers.set(5, {
    type: 5,
    delay
  });
  if (typeof ngServerMode !== 'undefined' && ngServerMode) {
    triggerDeferBlock(2, lView, tNode);
  } else {
    scheduleDelayedHydrating(onTimer(delay), lView, tNode);
  }
}
function ɵɵdeferOnHover(triggerIndex, walkUpTimes) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, `on hover${walkUpTimes === -1 ? '' : '(<target>)'}`);
  }
  if (!shouldAttachTrigger(0, lView, tNode)) return;
  renderPlaceholder(lView, tNode);
  if (!(typeof ngServerMode !== 'undefined' && ngServerMode)) {
    registerDomTrigger(lView, tNode, triggerIndex, walkUpTimes, onHover, () => triggerDeferBlock(0, lView, tNode), 0);
  }
}
function ɵɵdeferPrefetchOnHover(triggerIndex, walkUpTimes) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, `prefetch on hover${walkUpTimes === -1 ? '' : '(<target>)'}`);
  }
  if (!shouldAttachTrigger(1, lView, tNode)) return;
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    registerDomTrigger(lView, tNode, triggerIndex, walkUpTimes, onHover, () => triggerPrefetching(tDetails, lView, tNode), 1);
  }
}
function ɵɵdeferHydrateOnHover() {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, 'hydrate on hover');
  }
  if (!shouldAttachTrigger(2, lView, tNode)) return;
  const hydrateTriggers = getHydrateTriggers((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)(), tNode);
  hydrateTriggers.set(4, null);
  if (typeof ngServerMode !== 'undefined' && ngServerMode) {
    triggerDeferBlock(2, lView, tNode);
  }
}
function ɵɵdeferOnInteraction(triggerIndex, walkUpTimes) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, `on interaction${walkUpTimes === -1 ? '' : '(<target>)'}`);
  }
  if (!shouldAttachTrigger(0, lView, tNode)) return;
  renderPlaceholder(lView, tNode);
  if (!(typeof ngServerMode !== 'undefined' && ngServerMode)) {
    registerDomTrigger(lView, tNode, triggerIndex, walkUpTimes, onInteraction, () => triggerDeferBlock(0, lView, tNode), 0);
  }
}
function ɵɵdeferPrefetchOnInteraction(triggerIndex, walkUpTimes) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, `prefetch on interaction${walkUpTimes === -1 ? '' : '(<target>)'}`);
  }
  if (!shouldAttachTrigger(1, lView, tNode)) return;
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    registerDomTrigger(lView, tNode, triggerIndex, walkUpTimes, onInteraction, () => triggerPrefetching(tDetails, lView, tNode), 1);
  }
}
function ɵɵdeferHydrateOnInteraction() {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, 'hydrate on interaction');
  }
  if (!shouldAttachTrigger(2, lView, tNode)) return;
  const hydrateTriggers = getHydrateTriggers((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)(), tNode);
  hydrateTriggers.set(3, null);
  if (typeof ngServerMode !== 'undefined' && ngServerMode) {
    triggerDeferBlock(2, lView, tNode);
  }
}
function ɵɵdeferOnViewport(triggerIndex, walkUpTimes, options) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    const args = [];
    if (walkUpTimes !== undefined && walkUpTimes !== -1) {
      args.push('<target>');
    }
    if (options) {
      args.push(JSON.stringify(options));
    }
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, `on viewport${args.length === 0 ? '' : `(${args.join(', ')})`}`);
  }
  if (!shouldAttachTrigger(0, lView, tNode)) return;
  renderPlaceholder(lView, tNode);
  if (!(typeof ngServerMode !== 'undefined' && ngServerMode)) {
    registerDomTrigger(lView, tNode, triggerIndex, walkUpTimes, onViewportWrapper, () => triggerDeferBlock(0, lView, tNode), 0, options);
  }
}
function ɵɵdeferPrefetchOnViewport(triggerIndex, walkUpTimes, options) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    const args = [];
    if (walkUpTimes !== undefined && walkUpTimes !== -1) {
      args.push('<target>');
    }
    if (options) {
      args.push(JSON.stringify(options));
    }
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, `prefetch on viewport${args.length === 0 ? '' : `(${args.join(', ')})`}`);
  }
  if (!shouldAttachTrigger(1, lView, tNode)) return;
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    registerDomTrigger(lView, tNode, triggerIndex, walkUpTimes, onViewportWrapper, () => triggerPrefetching(tDetails, lView, tNode), 1, options);
  }
}
function ɵɵdeferHydrateOnViewport(options) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, `hydrate on viewport${options ? `(${JSON.stringify(options)})` : ''}`);
  }
  if (!shouldAttachTrigger(2, lView, tNode)) return;
  const hydrateTriggers = getHydrateTriggers((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)(), tNode);
  hydrateTriggers.set(2, options ? {
    type: 2,
    intersectionObserverOptions: options
  } : null);
  if (typeof ngServerMode !== 'undefined' && ngServerMode) {
    triggerDeferBlock(2, lView, tNode);
  }
}
function ɵɵariaProperty(name, value) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
    const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)();
    const hasSetInput = setAllInputsForProperty(tNode, tView, lView, name, value);
    if (hasSetInput) {
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentHost)(tNode) && markDirtyIfOnPush(lView, tNode.index);
      ngDevMode && setNgReflectProperties(lView, tView, tNode, name, value);
    } else {
      ngDevMode && assertTNodeType(tNode, 2);
      const element = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
      setElementAttribute(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], element, null, tNode.value, name, value, null);
    }
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, name, bindingIndex);
  }
  return ɵɵariaProperty;
}
function ɵɵattribute(name, value, sanitizer, namespace) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
    const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)();
    elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, 'attr.' + name, bindingIndex);
  }
  return ɵɵattribute;
}
const ANIMATIONS_DISABLED = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'AnimationsDisabled' : '', {
  factory: () => false
});
const MAX_ANIMATION_TIMEOUT = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'MaxAnimationTimeout' : '', {
  factory: () => MAX_ANIMATION_TIMEOUT_DEFAULT
});
const MAX_ANIMATION_TIMEOUT_DEFAULT = 4000;
const DEFAULT_ANIMATIONS_DISABLED = false;
const areAnimationSupported = (typeof ngServerMode === 'undefined' || !ngServerMode) && typeof document !== 'undefined' && typeof document?.documentElement?.getAnimations === 'function';
function areAnimationsDisabled(lView) {
  const injector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
  return injector.get(ANIMATIONS_DISABLED, DEFAULT_ANIMATIONS_DISABLED);
}
function assertAnimationTypes(value, instruction) {
  if (value == null || typeof value !== 'string' && typeof value !== 'function') {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(650, `'${instruction}' value must be a string of CSS classes or an animation function, got ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringify)(value)}`);
  }
}
function assertElementNodes(nativeElement, instruction) {
  if (nativeElement.nodeType !== Node.ELEMENT_NODE) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(650, `'${instruction}' can only be used on an element node, got ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringify)(nativeElement.nodeType)}`);
  }
}
function trackEnterClasses(el, classList, cleanupFns) {
  const elementData = enterClassMap.get(el);
  if (elementData) {
    for (const klass of classList) {
      elementData.classList.push(klass);
    }
    for (const fn of cleanupFns) {
      elementData.cleanupFns.push(fn);
    }
  } else {
    enterClassMap.set(el, {
      classList,
      cleanupFns
    });
  }
}
function cleanupEnterClassData(element) {
  const elementData = enterClassMap.get(element);
  if (elementData) {
    for (const fn of elementData.cleanupFns) {
      fn();
    }
    enterClassMap.delete(element);
  }
  longestAnimations.delete(element);
}
const noOpAnimationComplete = () => {};
const enterClassMap = new WeakMap();
const longestAnimations = new WeakMap();
const leavingNodes = new WeakMap();
function clearLeavingNodes(tNode, el) {
  const nodes = leavingNodes.get(tNode);
  if (nodes && nodes.length > 0) {
    const ix = nodes.findIndex(node => node === el);
    if (ix > -1) nodes.splice(ix, 1);
  }
  if (nodes?.length === 0) {
    leavingNodes.delete(tNode);
  }
}
function cancelLeavingNodes(tNode, lView) {
  const leavingEl = leavingNodes.get(tNode)?.shift();
  const lContainer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_LCONTAINER];
  if (lContainer) {
    const beforeNode = getBeforeNodeForView(tNode.index, lContainer);
    const previousNode = beforeNode?.previousSibling;
    if (leavingEl && previousNode && leavingEl === previousNode) {
      leavingEl.dispatchEvent(new CustomEvent('animationend', {
        detail: {
          cancel: true
        }
      }));
    }
  }
}
function trackLeavingNodes(tNode, el) {
  if (leavingNodes.has(tNode)) {
    leavingNodes.get(tNode)?.push(el);
  } else {
    leavingNodes.set(tNode, [el]);
  }
}
function getLViewEnterAnimations(lView) {
  const animationData = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ANIMATIONS] ??= {};
  return animationData.enter ??= new Map();
}
function getLViewLeaveAnimations(lView) {
  const animationData = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ANIMATIONS] ??= {};
  return animationData.leave ??= new Map();
}
function getClassListFromValue(value) {
  const classes = typeof value === 'function' ? value() : value;
  let classList = Array.isArray(classes) ? classes : null;
  if (typeof classes === 'string') {
    classList = classes.trim().split(/\s+/).filter(k => k);
  }
  return classList;
}
function cancelAnimationsIfRunning(element, renderer) {
  if (!areAnimationSupported) return;
  const elementData = enterClassMap.get(element);
  if (elementData && elementData.classList.length > 0 && elementHasClassList(element, elementData.classList)) {
    for (const klass of elementData.classList) {
      renderer.removeClass(element, klass);
    }
  }
  cleanupEnterClassData(element);
}
function elementHasClassList(element, classList) {
  for (const className of classList) {
    if (element.classList.contains(className)) return true;
  }
  return false;
}
function isLongestAnimation(event, nativeElement) {
  const longestAnimation = longestAnimations.get(nativeElement);
  if (longestAnimation === undefined) return true;
  return nativeElement === event.target && (longestAnimation.animationName !== undefined && event.animationName === longestAnimation.animationName || longestAnimation.propertyName !== undefined && event.propertyName === longestAnimation.propertyName);
}
function addAnimationToLView(animations, tNode, fn) {
  const nodeAnimations = animations.get(tNode.index) ?? {
    animateFns: []
  };
  nodeAnimations.animateFns.push(fn);
  animations.set(tNode.index, nodeAnimations);
}
function cleanupAfterLeaveAnimations(resolvers, cleanupFns) {
  if (resolvers) {
    for (const fn of resolvers) {
      fn();
    }
  }
  for (const fn of cleanupFns) {
    fn();
  }
}
function clearLViewNodeAnimationResolvers(lView, tNode) {
  const nodeAnimations = getLViewLeaveAnimations(lView).get(tNode.index);
  if (nodeAnimations) nodeAnimations.resolvers = undefined;
}
function leaveAnimationFunctionCleanup(lView, tNode, nativeElement, resolvers, cleanupFns) {
  clearLeavingNodes(tNode, nativeElement);
  cleanupAfterLeaveAnimations(resolvers, cleanupFns);
  clearLViewNodeAnimationResolvers(lView, tNode);
}
function ɵɵanimateEnter(value) {
  performanceMarkFeature('NgAnimateEnter');
  if (typeof ngServerMode !== 'undefined' && ngServerMode || !areAnimationSupported) {
    return ɵɵanimateEnter;
  }
  ngDevMode && assertAnimationTypes(value, 'animate.enter');
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  if (areAnimationsDisabled(lView)) {
    return ɵɵanimateEnter;
  }
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  cancelLeavingNodes(tNode, lView);
  addAnimationToLView(getLViewEnterAnimations(lView), tNode, () => runEnterAnimation(lView, tNode, value));
  initializeAnimationQueueScheduler(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1]);
  queueEnterAnimations(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1], getLViewEnterAnimations(lView));
  return ɵɵanimateEnter;
}
function runEnterAnimation(lView, tNode, value) {
  const nativeElement = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
  ngDevMode && assertElementNodes(nativeElement, 'animate.enter');
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  const ngZone = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1].get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone);
  const activeClasses = getClassListFromValue(value);
  const cleanupFns = [];
  const handleEnterAnimationStart = event => {
    if (event.target !== nativeElement) return;
    const eventName = event instanceof AnimationEvent ? 'animationend' : 'transitionend';
    ngZone.runOutsideAngular(() => {
      renderer.listen(nativeElement, eventName, handleEnterAnimationEnd);
    });
  };
  const handleEnterAnimationEnd = event => {
    if (event.target !== nativeElement) return;
    enterAnimationEnd(event, nativeElement, renderer);
  };
  if (activeClasses && activeClasses.length > 0) {
    ngZone.runOutsideAngular(() => {
      cleanupFns.push(renderer.listen(nativeElement, 'animationstart', handleEnterAnimationStart));
      cleanupFns.push(renderer.listen(nativeElement, 'transitionstart', handleEnterAnimationStart));
    });
    trackEnterClasses(nativeElement, activeClasses, cleanupFns);
    for (const klass of activeClasses) {
      renderer.addClass(nativeElement, klass);
    }
    ngZone.runOutsideAngular(() => {
      requestAnimationFrame(() => {
        determineLongestAnimation(nativeElement, longestAnimations, areAnimationSupported);
        if (!longestAnimations.has(nativeElement)) {
          for (const klass of activeClasses) {
            renderer.removeClass(nativeElement, klass);
          }
          cleanupEnterClassData(nativeElement);
        }
      });
    });
  }
}
function enterAnimationEnd(event, nativeElement, renderer) {
  const elementData = enterClassMap.get(nativeElement);
  if (event.target !== nativeElement || !elementData) return;
  if (isLongestAnimation(event, nativeElement)) {
    event.stopImmediatePropagation();
    for (const klass of elementData.classList) {
      renderer.removeClass(nativeElement, klass);
    }
    cleanupEnterClassData(nativeElement);
  }
}
function ɵɵanimateEnterListener(value) {
  performanceMarkFeature('NgAnimateEnter');
  if (typeof ngServerMode !== 'undefined' && ngServerMode || !areAnimationSupported) {
    return ɵɵanimateEnterListener;
  }
  ngDevMode && assertAnimationTypes(value, 'animate.enter');
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  if (areAnimationsDisabled(lView)) {
    return ɵɵanimateEnterListener;
  }
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  cancelLeavingNodes(tNode, lView);
  addAnimationToLView(getLViewEnterAnimations(lView), tNode, () => runEnterAnimationFunction(lView, tNode, value));
  initializeAnimationQueueScheduler(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1]);
  queueEnterAnimations(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1], getLViewEnterAnimations(lView));
  return ɵɵanimateEnterListener;
}
function runEnterAnimationFunction(lView, tNode, value) {
  const nativeElement = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
  ngDevMode && assertElementNodes(nativeElement, 'animate.enter');
  value.call(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT], {
    target: nativeElement,
    animationComplete: noOpAnimationComplete
  });
}
function ɵɵanimateLeave(value) {
  performanceMarkFeature('NgAnimateLeave');
  if (typeof ngServerMode !== 'undefined' && ngServerMode || !areAnimationSupported) {
    return ɵɵanimateLeave;
  }
  ngDevMode && assertAnimationTypes(value, 'animate.leave');
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const animationsDisabled = areAnimationsDisabled(lView);
  if (animationsDisabled) {
    return ɵɵanimateLeave;
  }
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  cancelLeavingNodes(tNode, lView);
  addAnimationToLView(getLViewLeaveAnimations(lView), tNode, () => runLeaveAnimations(lView, tNode, value));
  initializeAnimationQueueScheduler(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1]);
  return ɵɵanimateLeave;
}
function runLeaveAnimations(lView, tNode, value) {
  const {
    promise,
    resolve
  } = promiseWithResolvers();
  const nativeElement = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
  ngDevMode && assertElementNodes(nativeElement, 'animate.leave');
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  const ngZone = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1].get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone);
  allLeavingAnimations.add(lView);
  (getLViewLeaveAnimations(lView).get(tNode.index).resolvers ??= []).push(resolve);
  const activeClasses = getClassListFromValue(value);
  if (activeClasses && activeClasses.length > 0) {
    animateLeaveClassRunner(nativeElement, tNode, lView, activeClasses, renderer, ngZone);
  } else {
    resolve();
  }
  return {
    promise,
    resolve
  };
}
function animateLeaveClassRunner(el, tNode, lView, classList, renderer, ngZone) {
  cancelAnimationsIfRunning(el, renderer);
  const cleanupFns = [];
  const resolvers = getLViewLeaveAnimations(lView).get(tNode.index)?.resolvers;
  const handleOutAnimationEnd = event => {
    if (event.target !== el) return;
    if (event instanceof CustomEvent || isLongestAnimation(event, el)) {
      event.stopImmediatePropagation();
      longestAnimations.delete(el);
      clearLeavingNodes(tNode, el);
      if (Array.isArray(tNode.projection)) {
        for (const item of classList) {
          renderer.removeClass(el, item);
        }
      }
      cleanupAfterLeaveAnimations(resolvers, cleanupFns);
      clearLViewNodeAnimationResolvers(lView, tNode);
    }
  };
  ngZone.runOutsideAngular(() => {
    cleanupFns.push(renderer.listen(el, 'animationend', handleOutAnimationEnd));
    cleanupFns.push(renderer.listen(el, 'transitionend', handleOutAnimationEnd));
  });
  trackLeavingNodes(tNode, el);
  for (const item of classList) {
    renderer.addClass(el, item);
  }
  ngZone.runOutsideAngular(() => {
    requestAnimationFrame(() => {
      determineLongestAnimation(el, longestAnimations, areAnimationSupported);
      if (!longestAnimations.has(el)) {
        clearLeavingNodes(tNode, el);
        cleanupAfterLeaveAnimations(resolvers, cleanupFns);
        clearLViewNodeAnimationResolvers(lView, tNode);
      }
    });
  });
}
function ɵɵanimateLeaveListener(value) {
  performanceMarkFeature('NgAnimateLeave');
  if (typeof ngServerMode !== 'undefined' && ngServerMode || !areAnimationSupported) {
    return ɵɵanimateLeaveListener;
  }
  ngDevMode && assertAnimationTypes(value, 'animate.leave');
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  cancelLeavingNodes(tNode, lView);
  allLeavingAnimations.add(lView);
  addAnimationToLView(getLViewLeaveAnimations(lView), tNode, () => runLeaveAnimationFunction(lView, tNode, value));
  initializeAnimationQueueScheduler(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1]);
  return ɵɵanimateLeaveListener;
}
function runLeaveAnimationFunction(lView, tNode, value) {
  const {
    promise,
    resolve
  } = promiseWithResolvers();
  const nativeElement = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
  ngDevMode && assertElementNodes(nativeElement, 'animate.leave');
  const cleanupFns = [];
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  const animationsDisabled = areAnimationsDisabled(lView);
  const ngZone = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1].get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone);
  const maxAnimationTimeout = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1].get(MAX_ANIMATION_TIMEOUT);
  (getLViewLeaveAnimations(lView).get(tNode.index).resolvers ??= []).push(resolve);
  const resolvers = getLViewLeaveAnimations(lView).get(tNode.index)?.resolvers;
  if (animationsDisabled) {
    leaveAnimationFunctionCleanup(lView, tNode, nativeElement, resolvers, cleanupFns);
  } else {
    const timeoutId = setTimeout(() => leaveAnimationFunctionCleanup(lView, tNode, nativeElement, resolvers, cleanupFns), maxAnimationTimeout);
    const event = {
      target: nativeElement,
      animationComplete: () => {
        leaveAnimationFunctionCleanup(lView, tNode, nativeElement, resolvers, cleanupFns);
        clearTimeout(timeoutId);
      }
    };
    trackLeavingNodes(tNode, nativeElement);
    ngZone.runOutsideAngular(() => {
      cleanupFns.push(renderer.listen(nativeElement, 'animationend', () => {
        leaveAnimationFunctionCleanup(lView, tNode, nativeElement, resolvers, cleanupFns);
        clearTimeout(timeoutId);
      }, {
        once: true
      }));
    });
    value.call(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT], event);
  }
  return {
    promise,
    resolve
  };
}
function ɵɵcomponentInstance() {
  const instance = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)()[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(instance, 'Expected component instance to be defined');
  return instance;
}
function ɵɵcontrolCreate() {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (tView.firstCreatePass) {
    initializeControlFirstCreatePass(tView, tNode, lView);
  }
  const control = getControlDirective(tNode, lView);
  if (!control) {
    return;
  }
  performanceMarkFeature('NgSignalForms');
  if (tNode.flags & 1024) {
    listenToCustomControl(lView, tNode, control, 'value');
  } else if (tNode.flags & 2048) {
    listenToCustomControl(lView, tNode, control, 'checked');
  } else if (tNode.flags & 4096) {
    listenToInteropControl(control);
  } else {
    listenToNativeControl(lView, tNode, control);
  }
  control.ɵregister();
}
function ɵɵcontrol(value, sanitizer) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)();
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
    setPropertyAndInputs(tNode, lView, 'field', value, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], sanitizer);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, 'field', bindingIndex);
  }
  updateControl(lView, tNode);
}
function ɵcontrolUpdate() {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)();
  updateControl(lView, tNode);
}
function updateControl(lView, tNode) {
  const control = getControlDirective(tNode, lView);
  if (control) {
    updateControlClasses(lView, tNode, control);
    if (tNode.flags & 1024) {
      updateCustomControl(tNode, lView, control, 'value');
    } else if (tNode.flags & 2048) {
      updateCustomControl(tNode, lView, control, 'checked');
    } else if (tNode.flags & 4096) {
      updateInteropControl(lView, control);
    } else {
      updateNativeControl(tNode, lView, control);
    }
  }
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
}
function initializeControlFirstCreatePass(tView, tNode, lView) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView);
  const directiveIndices = tNode.inputs?.['field'];
  if (!directiveIndices) {
    return;
  }
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentHost)(tNode) && directiveIndices.includes(tNode.directiveStart + tNode.componentOffset)) {
    return;
  }
  const controlIndex = directiveIndices.find(index => ɵCONTROL in lView[index]);
  if (controlIndex === undefined) {
    return;
  }
  tNode.fieldIndex = controlIndex;
  const isCustomControl = isCustomControlFirstCreatePass(tView, tNode);
  if (!isCustomControl && lView[controlIndex].ɵinteropControl) {
    tNode.flags |= 4096;
    return;
  }
  const isNativeControl = isNativeControlFirstCreatePass(tView, tNode);
  if (isNativeControl || isCustomControl) {
    return;
  }
  const host = describeElement(tView, tNode);
  throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(318, `${host} is an invalid [field] directive host. The host must be a native form control ` + `(such as <input>', '<select>', or '<textarea>') or a custom form control with a 'value' or ` + `'checked' model.`);
}
function describeElement(tView, tNode) {
  if (ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentHost)(tNode)) {
    const componentIndex = tNode.directiveStart + tNode.componentOffset;
    const componentDef = tView.data[componentIndex];
    return `Component ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.debugStringifyTypeForError)(componentDef.type)}`;
  }
  return `<${tNode.value}>`;
}
function isCustomControlFirstCreatePass(tView, tNode) {
  for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {
    const directiveDef = tView.data[i];
    if (hasModelInput(directiveDef, 'value')) {
      tNode.flags |= 1024;
      tNode.customControlIndex = i;
      return true;
    }
    if (hasModelInput(directiveDef, 'checked')) {
      tNode.flags |= 2048;
      tNode.customControlIndex = i;
      return true;
    }
  }
  return false;
}
function isNativeControlFirstCreatePass(tView, tNode) {
  if (!isNativeControl(tNode)) {
    return false;
  }
  tNode.flags |= 8192;
  if (isNumericInput(tNode)) {
    tNode.flags |= 16384;
  }
  if (isTextControl(tNode)) {
    tNode.flags |= 32768;
  }
  return true;
}
function getControlDirective(tNode, lView) {
  const index = tNode.fieldIndex;
  return index === -1 ? null : lView[index];
}
function hasModelInput(directiveDef, name) {
  return hasSignalInput(directiveDef, name) && hasOutput(directiveDef, name + 'Change');
}
function hasSignalInput(directiveDef, name) {
  const input = directiveDef.inputs[name];
  return input && (input[1] & InputFlags.SignalBased) !== 0;
}
function hasOutput(directiveDef, name) {
  return name in directiveDef.outputs;
}
function listenToCustomControl(lView, tNode, control, modelName) {
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const directiveIndex = tNode.customControlIndex;
  const outputName = modelName + 'Change';
  listenToOutput(tNode, lView, directiveIndex, outputName, outputName, wrapListener(tNode, lView, value => control.state().setControlValue(value)));
  const directiveDef = tView.data[directiveIndex];
  const touchedOutputName = 'touchedChange';
  if (hasOutput(directiveDef, touchedOutputName)) {
    listenToOutput(tNode, lView, directiveIndex, touchedOutputName, touchedOutputName, wrapListener(tNode, lView, () => control.state().markAsTouched()));
  }
}
function listenToInteropControl(control) {
  const interopControl = control.ɵinteropControl;
  interopControl.registerOnChange(value => control.state().setControlValue(value));
  interopControl.registerOnTouched(() => control.state().markAsTouched());
}
function isNativeControl(tNode) {
  if (tNode.type !== 2) {
    return false;
  }
  const tagName = tNode.value;
  return tagName === 'input' || tagName === 'textarea' || tagName === 'select';
}
function listenToNativeControl(lView, tNode, control) {
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  const element = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
  const inputListener = () => {
    const state = control.state();
    state.setControlValue(getNativeControlValue(element, state.value));
  };
  listenToDomEvent(tNode, tView, lView, undefined, renderer, 'input', inputListener, wrapListener(tNode, lView, inputListener));
  const blurListener = () => {
    control.state().markAsTouched();
  };
  listenToDomEvent(tNode, tView, lView, undefined, renderer, 'blur', blurListener, wrapListener(tNode, lView, blurListener));
  if (tNode.type === 2 && tNode.value === 'select' && typeof MutationObserver === 'function') {
    const observer = observeSelectMutations(element, control);
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.storeCleanupWithContext)(tView, lView, observer, observer.disconnect);
  }
}
function observeSelectMutations(select, controlDirective) {
  const observer = new MutationObserver(mutations => {
    if (mutations.some(m => isRelevantSelectMutation(m))) {
      select.value = controlDirective.state().value();
    }
  });
  observer.observe(select, {
    attributes: true,
    attributeFilter: ['value'],
    characterData: true,
    childList: true,
    subtree: true
  });
  return observer;
}
function isRelevantSelectMutation(mutation) {
  if (mutation.type === 'childList' || mutation.type === 'characterData') {
    if (mutation.target instanceof Comment) {
      return false;
    }
    for (const node of mutation.addedNodes) {
      if (!(node instanceof Comment)) {
        return true;
      }
    }
    for (const node of mutation.removedNodes) {
      if (!(node instanceof Comment)) {
        return true;
      }
    }
    return false;
  }
  if (mutation.type === 'attributes' && mutation.target instanceof HTMLOptionElement) {
    return true;
  }
  return false;
}
function updateControlClasses(lView, tNode, control) {
  if (control.classes) {
    const bindings = getControlBindings(lView);
    bindings.classes ??= {};
    control.state();
    const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
    const element = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
    for (const [className, enabled] of control.classes) {
      const isEnabled = enabled();
      if (controlClassBindingUpdated(bindings.classes, className, isEnabled)) {
        if (isEnabled) {
          renderer.addClass(element, className);
        } else {
          renderer.removeClass(element, className);
        }
      }
    }
  }
}
function updateCustomControl(tNode, lView, control, modelName) {
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const directiveIndex = tNode.customControlIndex;
  const directive = lView[directiveIndex];
  const directiveDef = tView.data[directiveIndex];
  const state = control.state();
  const bindings = getControlBindings(lView);
  maybeUpdateInput(directiveDef, directive, bindings, state, CONTROL_VALUE, modelName);
  for (const key of CONTROL_BINDING_KEYS) {
    const inputName = CONTROL_BINDING_NAMES[key];
    maybeUpdateInput(directiveDef, directive, bindings, state, key, inputName);
  }
  if (tNode.flags & 8192) {
    updateNativeControl(tNode, lView, control);
  }
}
function maybeUpdateInput(directiveDef, directive, bindings, state, key, inputName) {
  if (inputName in directiveDef.inputs) {
    const value = state[key]?.();
    if (controlBindingUpdated(bindings, key, value)) {
      writeToDirectiveInput(directiveDef, directive, inputName, value);
    }
  }
}
function updateInteropControl(lView, control) {
  const interopControl = control.ɵinteropControl;
  const bindings = getControlBindings(lView);
  const state = control.state();
  const value = state.value();
  if (controlBindingUpdated(bindings, CONTROL_VALUE, value)) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(() => interopControl.writeValue(value));
  }
  if (interopControl.setDisabledState) {
    const disabled = state.disabled();
    if (controlBindingUpdated(bindings, DISABLED, disabled)) {
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(() => interopControl.setDisabledState(disabled));
    }
  }
}
function updateNativeControl(tNode, lView, control) {
  const element = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  const state = control.state();
  const bindings = getControlBindings(lView);
  const controlValue = state.controlValue();
  if (controlBindingUpdated(bindings, CONTROL_VALUE, controlValue)) {
    setNativeControlValue(element, controlValue);
  }
  const name = state.name();
  if (controlBindingUpdated(bindings, NAME, name)) {
    renderer.setAttribute(element, 'name', name);
  }
  updateBooleanAttribute(renderer, element, bindings, state, DISABLED);
  updateBooleanAttribute(renderer, element, bindings, state, READONLY);
  updateBooleanAttribute(renderer, element, bindings, state, REQUIRED);
  if (tNode.flags & 16384) {
    updateOptionalAttribute(renderer, element, bindings, state, MAX);
    updateOptionalAttribute(renderer, element, bindings, state, MIN);
  }
  if (tNode.flags & 32768) {
    updateOptionalAttribute(renderer, element, bindings, state, MAX_LENGTH);
    updateOptionalAttribute(renderer, element, bindings, state, MIN_LENGTH);
  }
}
function updateBooleanAttribute(renderer, element, bindings, state, key) {
  const value = state[key]();
  if (controlBindingUpdated(bindings, key, value)) {
    const name = CONTROL_BINDING_NAMES[key];
    setBooleanAttribute(renderer, element, name, value);
  }
}
function updateOptionalAttribute(renderer, element, bindings, state, key) {
  const value = state[key]?.();
  if (controlBindingUpdated(bindings, key, value)) {
    const name = CONTROL_BINDING_NAMES[key];
    setOptionalAttribute(renderer, element, name, value);
  }
}
function isDateOrNull(value) {
  return value === null || value instanceof Date;
}
function isNumericInput(tNode) {
  if (!tNode.attrs || tNode.value !== 'input') {
    return false;
  }
  for (let i = 0; i < tNode.attrs.length; i += 2) {
    const name = tNode.attrs[i];
    if (isNameOnlyAttributeMarker(name)) {
      break;
    }
    if (name === 'type') {
      const value = tNode.attrs[i + 1];
      return value === 'date' || value === 'datetime-local' || value === 'month' || value === 'number' || value === 'range' || value === 'time' || value === 'week';
    }
  }
  return false;
}
function isTextControl(tNode) {
  return tNode.value !== 'select';
}
function getNativeControlValue(element, currentValue) {
  switch (element.type) {
    case 'checkbox':
      return element.checked;
    case 'number':
    case 'range':
    case 'datetime-local':
      if (typeof currentValue() === 'number') {
        return element.valueAsNumber;
      }
      break;
    case 'date':
    case 'month':
    case 'time':
    case 'week':
      const value = currentValue();
      if (isDateOrNull(value)) {
        return element.valueAsDate;
      } else if (typeof value === 'number') {
        return element.valueAsNumber;
      }
      break;
  }
  return element.value;
}
function setNativeControlValue(element, value) {
  switch (element.type) {
    case 'checkbox':
      element.checked = value;
      return;
    case 'radio':
      element.checked = value === element.value;
      return;
    case 'number':
    case 'range':
    case 'datetime-local':
      if (typeof value === 'number') {
        setNativeNumberControlValue(element, value);
        return;
      }
      break;
    case 'date':
    case 'month':
    case 'time':
    case 'week':
      if (isDateOrNull(value)) {
        element.valueAsDate = value;
        return;
      } else if (typeof value === 'number') {
        setNativeNumberControlValue(element, value);
        return;
      }
  }
  element.value = value;
}
function setNativeNumberControlValue(element, value) {
  if (isNaN(value)) {
    element.value = '';
  } else {
    element.valueAsNumber = value;
  }
}
const DISABLED = /* @__PURE__ */(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty)({
  disabled: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty
});
const MAX = /* @__PURE__ */(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty)({
  max: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty
});
const MAX_LENGTH = /* @__PURE__ */(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty)({
  maxLength: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty
});
const MIN = /* @__PURE__ */(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty)({
  min: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty
});
const MIN_LENGTH = /* @__PURE__ */(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty)({
  minLength: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty
});
const NAME = /* @__PURE__ */(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty)({
  name: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty
});
const READONLY = /* @__PURE__ */(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty)({
  readonly: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty
});
const REQUIRED = /* @__PURE__ */(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty)({
  required: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty
});
const CONTROL_VALUE = /* @__PURE__ */(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty)({
  controlValue: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty
});
const CONTROL_BINDING_NAMES = {
  disabled: 'disabled',
  disabledReasons: 'disabledReasons',
  dirty: 'dirty',
  errors: 'errors',
  hidden: 'hidden',
  invalid: 'invalid',
  max: 'max',
  maxLength: 'maxLength',
  min: 'min',
  minLength: 'minLength',
  name: 'name',
  pattern: 'pattern',
  pending: 'pending',
  readonly: 'readonly',
  required: 'required',
  touched: 'touched'
};
const CONTROL_BINDING_KEYS = /* @__PURE__ */(() => Object.keys(CONTROL_BINDING_NAMES))();
function getControlBindings(lView) {
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingIndex)();
  let bindings = lView[bindingIndex];
  if (bindings === NO_CHANGE) {
    bindings = lView[bindingIndex] = {};
  }
  return bindings;
}
function controlBindingUpdated(bindings, key, value) {
  const oldValue = bindings[key];
  if (Object.is(oldValue, value)) {
    return false;
  }
  bindings[key] = value;
  return true;
}
function controlClassBindingUpdated(bindings, className, value) {
  const oldValue = bindings[className];
  if (Object.is(oldValue, value)) {
    return false;
  }
  bindings[className] = value;
  return true;
}
function setBooleanAttribute(renderer, element, name, value) {
  if (value) {
    renderer.setAttribute(element, name, '');
  } else {
    renderer.removeAttribute(element, name);
  }
}
function setOptionalAttribute(renderer, element, name, value) {
  if (value !== undefined) {
    renderer.setAttribute(element, name, value.toString());
  } else {
    renderer.removeAttribute(element, name);
  }
}
class LiveCollection {
  destroy(item) {}
  updateValue(index, value) {}
  swap(index1, index2) {
    const startIdx = Math.min(index1, index2);
    const endIdx = Math.max(index1, index2);
    const endItem = this.detach(endIdx);
    if (endIdx - startIdx > 1) {
      const startItem = this.detach(startIdx);
      this.attach(startIdx, endItem);
      this.attach(endIdx, startItem);
    } else {
      this.attach(startIdx, endItem);
    }
  }
  move(prevIndex, newIdx) {
    this.attach(newIdx, this.detach(prevIndex));
  }
}
function valuesMatching(liveIdx, liveValue, newIdx, newValue, trackBy) {
  if (liveIdx === newIdx && Object.is(liveValue, newValue)) {
    return 1;
  } else if (Object.is(trackBy(liveIdx, liveValue), trackBy(newIdx, newValue))) {
    return -1;
  }
  return 0;
}
function recordDuplicateKeys(keyToIdx, key, idx) {
  const idxSoFar = keyToIdx.get(key);
  if (idxSoFar !== undefined) {
    idxSoFar.add(idx);
  } else {
    keyToIdx.set(key, new Set([idx]));
  }
}
function reconcile(liveCollection, newCollection, trackByFn, reactiveConsumer) {
  let detachedItems = undefined;
  let liveKeysInTheFuture = undefined;
  let liveStartIdx = 0;
  let liveEndIdx = liveCollection.length - 1;
  const duplicateKeys = ngDevMode ? new Map() : undefined;
  if (Array.isArray(newCollection)) {
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(reactiveConsumer);
    let newEndIdx = newCollection.length - 1;
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
    while (liveStartIdx <= liveEndIdx && liveStartIdx <= newEndIdx) {
      const liveStartValue = liveCollection.at(liveStartIdx);
      const newStartValue = newCollection[liveStartIdx];
      if (ngDevMode) {
        recordDuplicateKeys(duplicateKeys, trackByFn(liveStartIdx, newStartValue), liveStartIdx);
      }
      const isStartMatching = valuesMatching(liveStartIdx, liveStartValue, liveStartIdx, newStartValue, trackByFn);
      if (isStartMatching !== 0) {
        if (isStartMatching < 0) {
          liveCollection.updateValue(liveStartIdx, newStartValue);
        }
        liveStartIdx++;
        continue;
      }
      const liveEndValue = liveCollection.at(liveEndIdx);
      const newEndValue = newCollection[newEndIdx];
      if (ngDevMode) {
        recordDuplicateKeys(duplicateKeys, trackByFn(newEndIdx, newEndValue), newEndIdx);
      }
      const isEndMatching = valuesMatching(liveEndIdx, liveEndValue, newEndIdx, newEndValue, trackByFn);
      if (isEndMatching !== 0) {
        if (isEndMatching < 0) {
          liveCollection.updateValue(liveEndIdx, newEndValue);
        }
        liveEndIdx--;
        newEndIdx--;
        continue;
      }
      const liveStartKey = trackByFn(liveStartIdx, liveStartValue);
      const liveEndKey = trackByFn(liveEndIdx, liveEndValue);
      const newStartKey = trackByFn(liveStartIdx, newStartValue);
      if (Object.is(newStartKey, liveEndKey)) {
        const newEndKey = trackByFn(newEndIdx, newEndValue);
        if (Object.is(newEndKey, liveStartKey)) {
          liveCollection.swap(liveStartIdx, liveEndIdx);
          liveCollection.updateValue(liveEndIdx, newEndValue);
          newEndIdx--;
          liveEndIdx--;
        } else {
          liveCollection.move(liveEndIdx, liveStartIdx);
        }
        liveCollection.updateValue(liveStartIdx, newStartValue);
        liveStartIdx++;
        continue;
      }
      detachedItems ??= new UniqueValueMultiKeyMap();
      liveKeysInTheFuture ??= initLiveItemsInTheFuture(liveCollection, liveStartIdx, liveEndIdx, trackByFn);
      if (attachPreviouslyDetached(liveCollection, detachedItems, liveStartIdx, newStartKey)) {
        liveCollection.updateValue(liveStartIdx, newStartValue);
        liveStartIdx++;
        liveEndIdx++;
      } else if (!liveKeysInTheFuture.has(newStartKey)) {
        const newItem = liveCollection.create(liveStartIdx, newCollection[liveStartIdx]);
        liveCollection.attach(liveStartIdx, newItem);
        liveStartIdx++;
        liveEndIdx++;
      } else {
        detachedItems.set(liveStartKey, liveCollection.detach(liveStartIdx));
        liveEndIdx--;
      }
    }
    while (liveStartIdx <= newEndIdx) {
      createOrAttach(liveCollection, detachedItems, trackByFn, liveStartIdx, newCollection[liveStartIdx]);
      liveStartIdx++;
    }
  } else if (newCollection != null) {
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(reactiveConsumer);
    const newCollectionIterator = newCollection[Symbol.iterator]();
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
    let newIterationResult = newCollectionIterator.next();
    while (!newIterationResult.done && liveStartIdx <= liveEndIdx) {
      const liveValue = liveCollection.at(liveStartIdx);
      const newValue = newIterationResult.value;
      if (ngDevMode) {
        recordDuplicateKeys(duplicateKeys, trackByFn(liveStartIdx, newValue), liveStartIdx);
      }
      const isStartMatching = valuesMatching(liveStartIdx, liveValue, liveStartIdx, newValue, trackByFn);
      if (isStartMatching !== 0) {
        if (isStartMatching < 0) {
          liveCollection.updateValue(liveStartIdx, newValue);
        }
        liveStartIdx++;
        newIterationResult = newCollectionIterator.next();
      } else {
        detachedItems ??= new UniqueValueMultiKeyMap();
        liveKeysInTheFuture ??= initLiveItemsInTheFuture(liveCollection, liveStartIdx, liveEndIdx, trackByFn);
        const newKey = trackByFn(liveStartIdx, newValue);
        if (attachPreviouslyDetached(liveCollection, detachedItems, liveStartIdx, newKey)) {
          liveCollection.updateValue(liveStartIdx, newValue);
          liveStartIdx++;
          liveEndIdx++;
          newIterationResult = newCollectionIterator.next();
        } else if (!liveKeysInTheFuture.has(newKey)) {
          liveCollection.attach(liveStartIdx, liveCollection.create(liveStartIdx, newValue));
          liveStartIdx++;
          liveEndIdx++;
          newIterationResult = newCollectionIterator.next();
        } else {
          const liveKey = trackByFn(liveStartIdx, liveValue);
          detachedItems.set(liveKey, liveCollection.detach(liveStartIdx));
          liveEndIdx--;
        }
      }
    }
    while (!newIterationResult.done) {
      createOrAttach(liveCollection, detachedItems, trackByFn, liveCollection.length, newIterationResult.value);
      newIterationResult = newCollectionIterator.next();
    }
  }
  while (liveStartIdx <= liveEndIdx) {
    liveCollection.destroy(liveCollection.detach(liveEndIdx--));
  }
  detachedItems?.forEach(item => {
    liveCollection.destroy(item);
  });
  if (ngDevMode) {
    let duplicatedKeysMsg = [];
    for (const [key, idxSet] of duplicateKeys) {
      if (idxSet.size > 1) {
        const idx = [...idxSet].sort((a, b) => a - b);
        for (let i = 1; i < idx.length; i++) {
          duplicatedKeysMsg.push(`key "${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(key)}" at index "${idx[i - 1]}" and "${idx[i]}"`);
        }
      }
    }
    if (duplicatedKeysMsg.length > 0) {
      const message = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(-955, 'The provided track expression resulted in duplicated keys for a given collection. ' + 'Adjust the tracking expression such that it uniquely identifies all the items in the collection. ' + 'Duplicated keys were: \n' + duplicatedKeysMsg.join(', \n') + '.');
      console.warn(message);
    }
  }
}
function attachPreviouslyDetached(prevCollection, detachedItems, index, key) {
  if (detachedItems !== undefined && detachedItems.has(key)) {
    prevCollection.attach(index, detachedItems.get(key));
    detachedItems.delete(key);
    return true;
  }
  return false;
}
function createOrAttach(liveCollection, detachedItems, trackByFn, index, value) {
  if (!attachPreviouslyDetached(liveCollection, detachedItems, index, trackByFn(index, value))) {
    const newItem = liveCollection.create(index, value);
    liveCollection.attach(index, newItem);
  } else {
    liveCollection.updateValue(index, value);
  }
}
function initLiveItemsInTheFuture(liveCollection, start, end, trackByFn) {
  const keys = new Set();
  for (let i = start; i <= end; i++) {
    keys.add(trackByFn(i, liveCollection.at(i)));
  }
  return keys;
}
class UniqueValueMultiKeyMap {
  kvMap = new Map();
  _vMap = undefined;
  has(key) {
    return this.kvMap.has(key);
  }
  delete(key) {
    if (!this.has(key)) return false;
    const value = this.kvMap.get(key);
    if (this._vMap !== undefined && this._vMap.has(value)) {
      this.kvMap.set(key, this._vMap.get(value));
      this._vMap.delete(value);
    } else {
      this.kvMap.delete(key);
    }
    return true;
  }
  get(key) {
    return this.kvMap.get(key);
  }
  set(key, value) {
    if (this.kvMap.has(key)) {
      let prevValue = this.kvMap.get(key);
      if (ngDevMode && prevValue === value) {
        throw new Error(`Detected a duplicated value ${value} for the key ${key}`);
      }
      if (this._vMap === undefined) {
        this._vMap = new Map();
      }
      const vMap = this._vMap;
      while (vMap.has(prevValue)) {
        prevValue = vMap.get(prevValue);
      }
      vMap.set(prevValue, value);
    } else {
      this.kvMap.set(key, value);
    }
  }
  forEach(cb) {
    for (let [key, value] of this.kvMap) {
      cb(value, key);
      if (this._vMap !== undefined) {
        const vMap = this._vMap;
        while (vMap.has(value)) {
          value = vMap.get(value);
          cb(value, key);
        }
      }
    }
  }
}
function ɵɵconditionalCreate(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
  performanceMarkFeature('NgControlFlow');
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const attrs = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tView.consts, attrsIndex);
  declareNoDirectiveHostTemplate(lView, tView, index, templateFn, decls, vars, tagName, attrs, 256, localRefsIndex, localRefExtractor);
  return ɵɵconditionalBranchCreate;
}
function ɵɵconditionalBranchCreate(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
  performanceMarkFeature('NgControlFlow');
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const attrs = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tView.consts, attrsIndex);
  declareNoDirectiveHostTemplate(lView, tView, index, templateFn, decls, vars, tagName, attrs, 512, localRefsIndex, localRefExtractor);
  return ɵɵconditionalBranchCreate;
}
function ɵɵconditional(matchingTemplateIndex, contextValue) {
  performanceMarkFeature('NgControlFlow');
  const hostLView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
  const prevMatchingTemplateIndex = hostLView[bindingIndex] !== NO_CHANGE ? hostLView[bindingIndex] : -1;
  const prevContainer = prevMatchingTemplateIndex !== -1 ? getLContainer(hostLView, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET + prevMatchingTemplateIndex) : undefined;
  const viewInContainerIdx = 0;
  if (bindingUpdated(hostLView, bindingIndex, matchingTemplateIndex)) {
    const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
    try {
      if (prevContainer !== undefined) {
        removeLViewFromLContainer(prevContainer, viewInContainerIdx);
      }
      if (matchingTemplateIndex !== -1) {
        const nextLContainerIndex = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET + matchingTemplateIndex;
        const nextContainer = getLContainer(hostLView, nextLContainerIndex);
        const templateTNode = getExistingTNode(hostLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], nextLContainerIndex);
        const dehydratedView = findAndReconcileMatchingDehydratedViews(nextContainer, templateTNode, hostLView);
        const embeddedLView = createAndRenderEmbeddedLView(hostLView, templateTNode, contextValue, {
          dehydratedView
        });
        addLViewToLContainer(nextContainer, embeddedLView, viewInContainerIdx, shouldAddViewToDom(templateTNode, dehydratedView));
      }
    } finally {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
    }
  } else if (prevContainer !== undefined) {
    const lView = getLViewFromLContainer(prevContainer, viewInContainerIdx);
    if (lView !== undefined) {
      lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT] = contextValue;
    }
  }
}
class RepeaterContext {
  lContainer;
  $implicit;
  $index;
  constructor(lContainer, $implicit, $index) {
    this.lContainer = lContainer;
    this.$implicit = $implicit;
    this.$index = $index;
  }
  get $count() {
    return this.lContainer.length - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET;
  }
}
function ɵɵrepeaterTrackByIndex(index) {
  return index;
}
function ɵɵrepeaterTrackByIdentity(_, value) {
  return value;
}
class RepeaterMetadata {
  hasEmptyBlock;
  trackByFn;
  liveCollection;
  constructor(hasEmptyBlock, trackByFn, liveCollection) {
    this.hasEmptyBlock = hasEmptyBlock;
    this.trackByFn = trackByFn;
    this.liveCollection = liveCollection;
  }
}
function ɵɵrepeaterCreate(index, templateFn, decls, vars, tagName, attrsIndex, trackByFn, trackByUsesComponentInstance, emptyTemplateFn, emptyDecls, emptyVars, emptyTagName, emptyAttrsIndex) {
  performanceMarkFeature('NgControlFlow');
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFunction)(trackByFn, `A track expression must be a function, was ${typeof trackByFn} instead.`);
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const hasEmptyBlock = emptyTemplateFn !== undefined;
  const hostLView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const boundTrackBy = trackByUsesComponentInstance ? trackByFn.bind(hostLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT]) : trackByFn;
  const metadata = new RepeaterMetadata(hasEmptyBlock, boundTrackBy);
  hostLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET + index] = metadata;
  declareNoDirectiveHostTemplate(lView, tView, index + 1, templateFn, decls, vars, tagName, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tView.consts, attrsIndex), 256);
  if (hasEmptyBlock) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(emptyDecls, 'Missing number of declarations for the empty repeater block.');
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(emptyVars, 'Missing number of bindings for the empty repeater block.');
    declareNoDirectiveHostTemplate(lView, tView, index + 2, emptyTemplateFn, emptyDecls, emptyVars, emptyTagName, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tView.consts, emptyAttrsIndex), 512);
  }
}
function isViewExpensiveToRecreate(lView) {
  return lView.length - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET > 2;
}
class OperationsCounter {
  created = 0;
  destroyed = 0;
  reset() {
    this.created = 0;
    this.destroyed = 0;
  }
  recordCreate() {
    this.created++;
  }
  recordDestroy() {
    this.destroyed++;
  }
  wasReCreated(collectionLen) {
    return collectionLen > 0 && this.created === this.destroyed && this.created === collectionLen;
  }
}
class LiveCollectionLContainerImpl extends LiveCollection {
  lContainer;
  hostLView;
  templateTNode;
  operationsCounter = ngDevMode ? new OperationsCounter() : undefined;
  needsIndexUpdate = false;
  constructor(lContainer, hostLView, templateTNode) {
    super();
    this.lContainer = lContainer;
    this.hostLView = hostLView;
    this.templateTNode = templateTNode;
  }
  get length() {
    return this.lContainer.length - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET;
  }
  at(index) {
    return this.getLView(index)[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT].$implicit;
  }
  attach(index, lView) {
    const dehydratedView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION];
    this.needsIndexUpdate ||= index !== this.length;
    addLViewToLContainer(this.lContainer, lView, index, shouldAddViewToDom(this.templateTNode, dehydratedView));
    clearDetachAnimationList(this.lContainer, index);
  }
  detach(index) {
    this.needsIndexUpdate ||= index !== this.length - 1;
    maybeInitDetachAnimationList(this.lContainer, index);
    return detachExistingView(this.lContainer, index);
  }
  create(index, value) {
    const dehydratedView = findMatchingDehydratedView(this.lContainer, this.templateTNode.tView.ssrId);
    const embeddedLView = createAndRenderEmbeddedLView(this.hostLView, this.templateTNode, new RepeaterContext(this.lContainer, value, index), {
      dehydratedView
    });
    ngDevMode && this.operationsCounter?.recordCreate();
    return embeddedLView;
  }
  destroy(lView) {
    destroyLView(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], lView);
    ngDevMode && this.operationsCounter?.recordDestroy();
  }
  updateValue(index, value) {
    this.getLView(index)[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT].$implicit = value;
  }
  reset() {
    this.needsIndexUpdate = false;
    ngDevMode && this.operationsCounter?.reset();
  }
  updateIndexes() {
    if (this.needsIndexUpdate) {
      for (let i = 0; i < this.length; i++) {
        this.getLView(i)[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT].$index = i;
      }
    }
  }
  getLView(index) {
    return getExistingLViewFromLContainer(this.lContainer, index);
  }
}
function ɵɵrepeater(collection) {
  const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
  const metadataSlotIdx = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)();
  try {
    const hostLView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
    const hostTView = hostLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
    const metadata = hostLView[metadataSlotIdx];
    const containerIndex = metadataSlotIdx + 1;
    const lContainer = getLContainer(hostLView, containerIndex);
    if (metadata.liveCollection === undefined) {
      const itemTemplateTNode = getExistingTNode(hostTView, containerIndex);
      metadata.liveCollection = new LiveCollectionLContainerImpl(lContainer, hostLView, itemTemplateTNode);
    } else {
      metadata.liveCollection.reset();
    }
    const liveCollection = metadata.liveCollection;
    reconcile(liveCollection, collection, metadata.trackByFn, prevConsumer);
    if (ngDevMode && metadata.trackByFn === ɵɵrepeaterTrackByIdentity && liveCollection.operationsCounter?.wasReCreated(liveCollection.length) && isViewExpensiveToRecreate(getExistingLViewFromLContainer(lContainer, 0))) {
      const message = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(-956, `The configured tracking expression (track by identity) caused re-creation of the entire collection of size ${liveCollection.length}. ` + 'This is an expensive operation requiring destruction and subsequent creation of DOM nodes, directives, components etc. ' + 'Please review the "track expression" and make sure that it uniquely identifies items in a collection.');
      console.warn(message);
    }
    liveCollection.updateIndexes();
    if (metadata.hasEmptyBlock) {
      const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
      const isCollectionEmpty = liveCollection.length === 0;
      if (bindingUpdated(hostLView, bindingIndex, isCollectionEmpty)) {
        const emptyTemplateIndex = metadataSlotIdx + 2;
        const lContainerForEmpty = getLContainer(hostLView, emptyTemplateIndex);
        if (isCollectionEmpty) {
          const emptyTemplateTNode = getExistingTNode(hostTView, emptyTemplateIndex);
          const dehydratedView = findAndReconcileMatchingDehydratedViews(lContainerForEmpty, emptyTemplateTNode, hostLView);
          const embeddedLView = createAndRenderEmbeddedLView(hostLView, emptyTemplateTNode, undefined, {
            dehydratedView
          });
          addLViewToLContainer(lContainerForEmpty, embeddedLView, 0, shouldAddViewToDom(emptyTemplateTNode, dehydratedView));
        } else {
          if (hostTView.firstUpdatePass) {
            removeDehydratedViews(lContainerForEmpty);
          }
          removeLViewFromLContainer(lContainerForEmpty, 0);
        }
      }
    }
  } finally {
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
  }
}
function getLContainer(lView, index) {
  const lContainer = lView[index];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLContainer)(lContainer);
  return lContainer;
}
function clearDetachAnimationList(lContainer, index) {
  if (lContainer.length <= _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET) return;
  const indexInContainer = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET + index;
  const viewToDetach = lContainer[indexInContainer];
  const animations = viewToDetach ? viewToDetach[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ANIMATIONS] : undefined;
  if (viewToDetach && animations && animations.detachedLeaveAnimationFns && animations.detachedLeaveAnimationFns.length > 0) {
    const injector = viewToDetach[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
    removeFromAnimationQueue(injector, animations);
    allLeavingAnimations.delete(viewToDetach);
    animations.detachedLeaveAnimationFns = undefined;
  }
}
function maybeInitDetachAnimationList(lContainer, index) {
  if (lContainer.length <= _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET) return;
  const indexInContainer = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET + index;
  const viewToDetach = lContainer[indexInContainer];
  const animations = viewToDetach ? viewToDetach[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ANIMATIONS] : undefined;
  if (animations && animations.leave && animations.leave.size > 0) {
    animations.detachedLeaveAnimationFns = [];
  }
}
function detachExistingView(lContainer, index) {
  const existingLView = detachView(lContainer, index);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLView)(existingLView);
  return existingLView;
}
function getExistingLViewFromLContainer(lContainer, index) {
  const existingLView = getLViewFromLContainer(lContainer, index);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLView)(existingLView);
  return existingLView;
}
function getExistingTNode(tView, index) {
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTNode)(tView, index);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNode)(tNode);
  return tNode;
}
function ɵɵproperty(propName, value, sanitizer) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
    const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)();
    setPropertyAndInputs(tNode, lView, propName, value, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], sanitizer);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return ɵɵproperty;
}
function setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased) {
  setAllInputsForProperty(tNode, tView, lView, isClassBased ? 'class' : 'style', value);
}
function ɵɵelementStart(index, name, attrsIndex, localRefsIndex) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeCreationIndex)(lView, index);
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const tNode = tView.firstCreatePass ? directiveHostFirstCreatePass(adjustedIndex, lView, 2, name, findDirectiveDefMatches, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingsEnabled)(), attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  elementLikeStartShared(tNode, lView, index, name, _locateOrCreateElementNode);
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isDirectiveHost)(tNode)) {
    const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
    createDirectivesInstances(tView, lView, tNode);
    executeContentQueries(tView, tNode, lView);
  }
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  if (ngDevMode && lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].firstCreatePass) {
    validateElementIsKnown(lView, tNode);
  }
  return ɵɵelementStart;
}
function ɵɵelementEnd() {
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const initialTNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(initialTNode, 'No parent node to close.');
  const currentTNode = elementLikeEndShared(initialTNode);
  ngDevMode && assertTNodeType(currentTNode, 3);
  if (tView.firstCreatePass) {
    directiveHostEndFirstCreatePass(tView, currentTNode);
  }
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isSkipHydrationRootTNode)(currentTNode)) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.leaveSkipHydrationBlock)();
  }
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.decreaseElementDepthCount)();
  if (currentTNode.classesWithoutHost != null && hasClassInput(currentTNode)) {
    setDirectiveInputsWhichShadowsStyling(tView, currentTNode, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), currentTNode.classesWithoutHost, true);
  }
  if (currentTNode.stylesWithoutHost != null && hasStyleInput(currentTNode)) {
    setDirectiveInputsWhichShadowsStyling(tView, currentTNode, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), currentTNode.stylesWithoutHost, false);
  }
  return ɵɵelementEnd;
}
function ɵɵelement(index, name, attrsIndex, localRefsIndex) {
  ɵɵelementStart(index, name, attrsIndex, localRefsIndex);
  ɵɵelementEnd();
  return ɵɵelement;
}
function ɵɵdomElementStart(index, name, attrsIndex, localRefsIndex) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeCreationIndex)(lView, index);
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const tNode = tView.firstCreatePass ? domOnlyFirstCreatePass(adjustedIndex, tView, 2, name, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  elementLikeStartShared(tNode, lView, index, name, _locateOrCreateElementNode);
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  if (ngDevMode && lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].firstCreatePass) {
    validateElementIsKnown(lView, tNode);
  }
  return ɵɵdomElementStart;
}
function ɵɵdomElementEnd() {
  const initialTNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(initialTNode, 'No parent node to close.');
  const currentTNode = elementLikeEndShared(initialTNode);
  ngDevMode && assertTNodeType(currentTNode, 3);
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isSkipHydrationRootTNode)(currentTNode)) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.leaveSkipHydrationBlock)();
  }
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.decreaseElementDepthCount)();
  return ɵɵdomElementEnd;
}
function ɵɵdomElement(index, name, attrsIndex, localRefsIndex) {
  ɵɵdomElementStart(index, name, attrsIndex, localRefsIndex);
  ɵɵdomElementEnd();
  return ɵɵdomElement;
}
let _locateOrCreateElementNode = (tView, lView, tNode, name, index) => {
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.lastNodeWasCreated)(true);
  return createElementNode(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], name, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNamespace)());
};
function locateOrCreateElementNodeImpl(tView, lView, tNode, name, index) {
  const isNodeCreationMode = !canHydrateNode(lView, tNode);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.lastNodeWasCreated)(isNodeCreationMode);
  if (isNodeCreationMode) {
    return createElementNode(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], name, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNamespace)());
  }
  const hydrationInfo = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION];
  const native = locateNextRNode(hydrationInfo, tView, lView, tNode);
  ngDevMode && validateMatchingNode(native, Node.ELEMENT_NODE, name, lView, tNode);
  ngDevMode && markRNodeAsClaimedByHydration(native);
  if (getSerializedContainerViews(hydrationInfo, index)) {
    ngDevMode && validateNodeExists(native.nextSibling, lView, tNode);
    setSegmentHead(hydrationInfo, index, native.nextSibling);
  }
  if (hydrationInfo && (hasSkipHydrationAttrOnTNode(tNode) || hasSkipHydrationAttrOnRElement(native))) {
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentHost)(tNode)) {
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.enterSkipHydrationBlock)(tNode);
      clearElementContents(native);
      ngDevMode && markRNodeAsSkippedByHydration(native);
    } else if (ngDevMode) {
      throw invalidSkipHydrationHost(native);
    }
  }
  return native;
}
function enableLocateOrCreateElementNodeImpl() {
  _locateOrCreateElementNode = locateOrCreateElementNodeImpl;
}
function ɵɵelementContainerStart(index, attrsIndex, localRefsIndex) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeCreationIndex)(lView, index);
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const tNode = tView.firstCreatePass ? directiveHostFirstCreatePass(adjustedIndex, lView, 8, 'ng-container', findDirectiveDefMatches, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingsEnabled)(), attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  elementLikeStartShared(tNode, lView, index, 'ng-container', _locateOrCreateElementContainerNode);
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isDirectiveHost)(tNode)) {
    const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
    createDirectivesInstances(tView, lView, tNode);
    executeContentQueries(tView, tNode, lView);
  }
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  return ɵɵelementContainerStart;
}
function ɵɵelementContainerEnd() {
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const initialTNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(initialTNode, 'No parent node to close.');
  const currentTNode = elementLikeEndShared(initialTNode);
  if (tView.firstCreatePass) {
    directiveHostEndFirstCreatePass(tView, currentTNode);
  }
  ngDevMode && assertTNodeType(currentTNode, 8);
  return ɵɵelementContainerEnd;
}
function ɵɵelementContainer(index, attrsIndex, localRefsIndex) {
  ɵɵelementContainerStart(index, attrsIndex, localRefsIndex);
  ɵɵelementContainerEnd();
  return ɵɵelementContainer;
}
function ɵɵdomElementContainerStart(index, attrsIndex, localRefsIndex) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeCreationIndex)(lView, index);
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const tNode = tView.firstCreatePass ? domOnlyFirstCreatePass(adjustedIndex, tView, 8, 'ng-container', attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  elementLikeStartShared(tNode, lView, index, 'ng-container', _locateOrCreateElementContainerNode);
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  return ɵɵdomElementContainerStart;
}
function ɵɵdomElementContainerEnd() {
  const initialTNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(initialTNode, 'No parent node to close.');
  const currentTNode = elementLikeEndShared(initialTNode);
  ngDevMode && assertTNodeType(currentTNode, 8);
  return ɵɵelementContainerEnd;
}
function ɵɵdomElementContainer(index, attrsIndex, localRefsIndex) {
  ɵɵdomElementContainerStart(index, attrsIndex, localRefsIndex);
  ɵɵdomElementContainerEnd();
  return ɵɵdomElementContainer;
}
let _locateOrCreateElementContainerNode = (tView, lView, tNode, commentText, index) => {
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.lastNodeWasCreated)(true);
  return createCommentNode(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], ngDevMode ? commentText : '');
};
function locateOrCreateElementContainerNode(tView, lView, tNode, commentText, index) {
  let comment;
  const isNodeCreationMode = !canHydrateNode(lView, tNode);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.lastNodeWasCreated)(isNodeCreationMode);
  if (isNodeCreationMode) {
    return createCommentNode(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], ngDevMode ? commentText : '');
  }
  const hydrationInfo = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION];
  const currentRNode = locateNextRNode(hydrationInfo, tView, lView, tNode);
  ngDevMode && validateNodeExists(currentRNode, lView, tNode);
  const ngContainerSize = getNgContainerSize(hydrationInfo, index);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(ngContainerSize, 'Unexpected state: hydrating an <ng-container>, ' + 'but no hydration info is available.');
  setSegmentHead(hydrationInfo, index, currentRNode);
  comment = siblingAfter(ngContainerSize, currentRNode);
  if (ngDevMode) {
    validateMatchingNode(comment, Node.COMMENT_NODE, null, lView, tNode);
    markRNodeAsClaimedByHydration(comment);
  }
  return comment;
}
function enableLocateOrCreateElementContainerNodeImpl() {
  _locateOrCreateElementContainerNode = locateOrCreateElementContainerNode;
}
function ɵɵgetCurrentView() {
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
}
function ɵɵdomProperty(propName, value, sanitizer) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
    const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)();
    setDomProperty(tNode, lView, propName, value, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], sanitizer);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return ɵɵdomProperty;
}
function ɵɵsyntheticHostProperty(propName, value, sanitizer) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
    const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)();
    const currentDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentDirectiveDef)(tView.data);
    const renderer = loadComponentRenderer(currentDef, tNode, lView);
    setDomProperty(tNode, lView, propName, value, renderer, sanitizer);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return ɵɵsyntheticHostProperty;
}
const u = undefined;
function plural(val) {
  const i = Math.floor(Math.abs(val)),
    v = val.toString().replace(/^[^.]*\.?/, '').length;
  if (i === 1 && v === 0) return 1;
  return 5;
}
var localeEn = ["en", [["a", "p"], ["AM", "PM"]], [["AM", "PM"]], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], u, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], u, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", u, u, u], [".", ",", ";", "%", "+", "-", "E", "×", "‰", "∞", "NaN", ":"], ["#,##0.###", "#,##0%", "¤#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", plural];
let LOCALE_DATA = {};
function registerLocaleData(data, localeId, extraData) {
  if (typeof localeId !== 'string') {
    extraData = localeId;
    localeId = data[LocaleDataIndex.LocaleId];
  }
  localeId = localeId.toLowerCase().replace(/_/g, '-');
  LOCALE_DATA[localeId] = data;
  if (extraData) {
    LOCALE_DATA[localeId][LocaleDataIndex.ExtraData] = extraData;
  }
}
function findLocaleData(locale) {
  const normalizedLocale = normalizeLocale(locale);
  let match = getLocaleData(normalizedLocale);
  if (match) {
    return match;
  }
  const parentLocale = normalizedLocale.split('-')[0];
  match = getLocaleData(parentLocale);
  if (match) {
    return match;
  }
  if (parentLocale === 'en') {
    return localeEn;
  }
  throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(701, ngDevMode && `Missing locale data for the locale "${locale}".`);
}
function getLocaleCurrencyCode(locale) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.CurrencyCode] || null;
}
function getLocalePluralCase(locale) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.PluralCase];
}
function getLocaleData(normalizedLocale) {
  if (!(normalizedLocale in LOCALE_DATA)) {
    LOCALE_DATA[normalizedLocale] = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__._global.ng && _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__._global.ng.common && _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__._global.ng.common.locales && _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__._global.ng.common.locales[normalizedLocale];
  }
  return LOCALE_DATA[normalizedLocale];
}
function unregisterAllLocaleData() {
  LOCALE_DATA = {};
}
var LocaleDataIndex;
(function (LocaleDataIndex) {
  LocaleDataIndex[LocaleDataIndex["LocaleId"] = 0] = "LocaleId";
  LocaleDataIndex[LocaleDataIndex["DayPeriodsFormat"] = 1] = "DayPeriodsFormat";
  LocaleDataIndex[LocaleDataIndex["DayPeriodsStandalone"] = 2] = "DayPeriodsStandalone";
  LocaleDataIndex[LocaleDataIndex["DaysFormat"] = 3] = "DaysFormat";
  LocaleDataIndex[LocaleDataIndex["DaysStandalone"] = 4] = "DaysStandalone";
  LocaleDataIndex[LocaleDataIndex["MonthsFormat"] = 5] = "MonthsFormat";
  LocaleDataIndex[LocaleDataIndex["MonthsStandalone"] = 6] = "MonthsStandalone";
  LocaleDataIndex[LocaleDataIndex["Eras"] = 7] = "Eras";
  LocaleDataIndex[LocaleDataIndex["FirstDayOfWeek"] = 8] = "FirstDayOfWeek";
  LocaleDataIndex[LocaleDataIndex["WeekendRange"] = 9] = "WeekendRange";
  LocaleDataIndex[LocaleDataIndex["DateFormat"] = 10] = "DateFormat";
  LocaleDataIndex[LocaleDataIndex["TimeFormat"] = 11] = "TimeFormat";
  LocaleDataIndex[LocaleDataIndex["DateTimeFormat"] = 12] = "DateTimeFormat";
  LocaleDataIndex[LocaleDataIndex["NumberSymbols"] = 13] = "NumberSymbols";
  LocaleDataIndex[LocaleDataIndex["NumberFormats"] = 14] = "NumberFormats";
  LocaleDataIndex[LocaleDataIndex["CurrencyCode"] = 15] = "CurrencyCode";
  LocaleDataIndex[LocaleDataIndex["CurrencySymbol"] = 16] = "CurrencySymbol";
  LocaleDataIndex[LocaleDataIndex["CurrencyName"] = 17] = "CurrencyName";
  LocaleDataIndex[LocaleDataIndex["Currencies"] = 18] = "Currencies";
  LocaleDataIndex[LocaleDataIndex["Directionality"] = 19] = "Directionality";
  LocaleDataIndex[LocaleDataIndex["PluralCase"] = 20] = "PluralCase";
  LocaleDataIndex[LocaleDataIndex["ExtraData"] = 21] = "ExtraData";
})(LocaleDataIndex || (LocaleDataIndex = {}));
function normalizeLocale(locale) {
  return locale.toLowerCase().replace(/_/g, '-');
}
const pluralMapping = ['zero', 'one', 'two', 'few', 'many'];
function getPluralCase(value, locale) {
  const plural = getLocalePluralCase(locale)(parseInt(value, 10));
  const result = pluralMapping[plural];
  return result !== undefined ? result : 'other';
}
const DEFAULT_LOCALE_ID = 'en-US';
const USD_CURRENCY_CODE = 'USD';
const ELEMENT_MARKER = {
  marker: 'element'
};
const ICU_MARKER = {
  marker: 'ICU'
};
var I18nCreateOpCode;
(function (I18nCreateOpCode) {
  I18nCreateOpCode[I18nCreateOpCode["SHIFT"] = 2] = "SHIFT";
  I18nCreateOpCode[I18nCreateOpCode["APPEND_EAGERLY"] = 1] = "APPEND_EAGERLY";
  I18nCreateOpCode[I18nCreateOpCode["COMMENT"] = 2] = "COMMENT";
})(I18nCreateOpCode || (I18nCreateOpCode = {}));
let LOCALE_ID$1 = DEFAULT_LOCALE_ID;
function setLocaleId(localeId) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(localeId, `Expected localeId to be defined`);
  if (typeof localeId === 'string') {
    LOCALE_ID$1 = localeId.toLowerCase().replace(/_/g, '-');
  }
}
function getLocaleId() {
  return LOCALE_ID$1;
}
let changeMask = 0b0;
let changeMaskCounter = 0;
function setMaskBit(hasChange) {
  if (hasChange) {
    changeMask = changeMask | 1 << Math.min(changeMaskCounter, 31);
  }
  changeMaskCounter++;
}
function applyI18n(tView, lView, index) {
  if (changeMaskCounter > 0) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(tView, `tView should be defined`);
    const tI18n = tView.data[index];
    const updateOpCodes = Array.isArray(tI18n) ? tI18n : tI18n.update;
    const bindingsStartIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingIndex)() - changeMaskCounter - 1;
    applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);
  }
  changeMask = 0b0;
  changeMaskCounter = 0;
}
function createNodeWithoutHydration(lView, textOrName, nodeType) {
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  switch (nodeType) {
    case Node.COMMENT_NODE:
      return createCommentNode(renderer, textOrName);
    case Node.TEXT_NODE:
      return createTextNode(renderer, textOrName);
    case Node.ELEMENT_NODE:
      return createElementNode(renderer, textOrName, null);
  }
}
let _locateOrCreateNode = (lView, index, textOrName, nodeType) => {
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.lastNodeWasCreated)(true);
  return createNodeWithoutHydration(lView, textOrName, nodeType);
};
function locateOrCreateNodeImpl(lView, index, textOrName, nodeType) {
  const hydrationInfo = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION];
  const noOffsetIndex = index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const isNodeCreationMode = !isI18nHydrationSupportEnabled() || !hydrationInfo || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isInSkipHydrationBlock)() || isDisconnectedNode$1(hydrationInfo, noOffsetIndex);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.lastNodeWasCreated)(isNodeCreationMode);
  if (isNodeCreationMode) {
    return createNodeWithoutHydration(lView, textOrName, nodeType);
  }
  const native = locateI18nRNodeByIndex(hydrationInfo, noOffsetIndex);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(native, 'expected native element');
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(native.nodeType, nodeType, 'expected matching nodeType');
  ngDevMode && nodeType === Node.ELEMENT_NODE && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(native.tagName.toLowerCase(), textOrName.toLowerCase(), 'expecting matching tagName');
  ngDevMode && markRNodeAsClaimedByHydration(native);
  return native;
}
function enableLocateOrCreateI18nNodeImpl() {
  _locateOrCreateNode = locateOrCreateNodeImpl;
}
function applyCreateOpCodes(lView, createOpCodes, parentRNode, insertInFrontOf) {
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  for (let i = 0; i < createOpCodes.length; i++) {
    const opCode = createOpCodes[i++];
    const text = createOpCodes[i];
    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
    const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
    const index = opCode >>> I18nCreateOpCode.SHIFT;
    let rNode = lView[index];
    let lastNodeWasCreated = false;
    if (rNode === null) {
      rNode = lView[index] = _locateOrCreateNode(lView, index, text, isComment ? Node.COMMENT_NODE : Node.TEXT_NODE);
      lastNodeWasCreated = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.wasLastNodeCreated)();
    }
    if (appendNow && parentRNode !== null && lastNodeWasCreated) {
      nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);
    }
  }
}
function applyMutableOpCodes(tView, mutableOpCodes, lView, anchorRNode) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDomNode)(anchorRNode);
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  let rootIdx = null;
  let rootRNode;
  for (let i = 0; i < mutableOpCodes.length; i++) {
    const opCode = mutableOpCodes[i];
    if (typeof opCode == 'string') {
      const textNodeIndex = mutableOpCodes[++i];
      if (lView[textNodeIndex] === null) {
        ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, textNodeIndex);
        lView[textNodeIndex] = _locateOrCreateNode(lView, textNodeIndex, opCode, Node.TEXT_NODE);
      }
    } else if (typeof opCode == 'number') {
      switch (opCode & 1) {
        case 0:
          const parentIdx = getParentFromIcuCreateOpCode(opCode);
          if (rootIdx === null) {
            rootIdx = parentIdx;
            rootRNode = renderer.parentNode(anchorRNode);
          }
          let insertInFrontOf;
          let parentRNode;
          if (parentIdx === rootIdx) {
            insertInFrontOf = anchorRNode;
            parentRNode = rootRNode;
          } else {
            insertInFrontOf = null;
            parentRNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[parentIdx]);
          }
          if (parentRNode !== null) {
            ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDomNode)(parentRNode);
            const refIdx = getRefFromIcuCreateOpCode(opCode);
            ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertGreaterThan)(refIdx, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET, 'Missing ref');
            const child = lView[refIdx];
            ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDomNode)(child);
            nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);
            const tIcu = getTIcu(tView, refIdx);
            if (tIcu !== null && typeof tIcu === 'object') {
              ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTIcu)(tIcu);
              const caseIndex = getCurrentICUCaseIndex(tIcu, lView);
              if (caseIndex !== null) {
                applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);
              }
            }
          }
          break;
        case 1:
          const elementNodeIndex = opCode >>> 1;
          const attrName = mutableOpCodes[++i];
          const attrValue = mutableOpCodes[++i];
          setElementAttribute(renderer, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByIndex)(elementNodeIndex, lView), null, null, attrName, attrValue, null);
          break;
        default:
          if (ngDevMode) {
            throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(700, `Unable to determine the type of mutate operation for "${opCode}"`);
          }
      }
    } else {
      switch (opCode) {
        case ICU_MARKER:
          const commentValue = mutableOpCodes[++i];
          const commentNodeIndex = mutableOpCodes[++i];
          if (lView[commentNodeIndex] === null) {
            ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(typeof commentValue, 'string', `Expected "${commentValue}" to be a comment node value`);
            ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInExpandoRange)(lView, commentNodeIndex);
            const commentRNode = lView[commentNodeIndex] = _locateOrCreateNode(lView, commentNodeIndex, commentValue, Node.COMMENT_NODE);
            attachPatchData(commentRNode, lView);
          }
          break;
        case ELEMENT_MARKER:
          const tagName = mutableOpCodes[++i];
          const elementNodeIndex = mutableOpCodes[++i];
          if (lView[elementNodeIndex] === null) {
            ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(typeof tagName, 'string', `Expected "${tagName}" to be an element node tag name`);
            ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInExpandoRange)(lView, elementNodeIndex);
            const elementRNode = lView[elementNodeIndex] = _locateOrCreateNode(lView, elementNodeIndex, tagName, Node.ELEMENT_NODE);
            attachPatchData(elementRNode, lView);
          }
          break;
        default:
          ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)(`Unable to determine the type of mutate operation for "${opCode}"`);
      }
    }
  }
}
function applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask) {
  for (let i = 0; i < updateOpCodes.length; i++) {
    const checkBit = updateOpCodes[i];
    const skipCodes = updateOpCodes[++i];
    if (checkBit & changeMask) {
      let value = '';
      for (let j = i + 1; j <= i + skipCodes; j++) {
        const opCode = updateOpCodes[j];
        if (typeof opCode == 'string') {
          value += opCode;
        } else if (typeof opCode == 'number') {
          if (opCode < 0) {
            value += (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(lView[bindingsStartIndex - opCode]);
          } else {
            const nodeIndex = opCode >>> 2;
            switch (opCode & 3) {
              case 1:
                const propName = updateOpCodes[++j];
                const sanitizeFn = updateOpCodes[++j];
                const tNodeOrTagName = tView.data[nodeIndex];
                ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(tNodeOrTagName, 'Experting TNode or string');
                if (typeof tNodeOrTagName === 'string') {
                  setElementAttribute(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value, sanitizeFn);
                } else {
                  setPropertyAndInputs(tNodeOrTagName, lView, propName, value, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], sanitizeFn);
                }
                break;
              case 0:
                const rText = lView[nodeIndex];
                rText !== null && updateTextNode(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], rText, value);
                break;
              case 2:
                applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex), lView, value);
                break;
              case 3:
                applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex), bindingsStartIndex, lView);
                break;
            }
          }
        }
      }
    } else {
      const opCode = updateOpCodes[i + 1];
      if (opCode > 0 && (opCode & 3) === 3) {
        const nodeIndex = opCode >>> 2;
        const tIcu = getTIcu(tView, nodeIndex);
        const currentIndex = lView[tIcu.currentCaseLViewIndex];
        if (currentIndex < 0) {
          applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);
        }
      }
    }
    i += skipCodes;
  }
}
function applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, tIcu.currentCaseLViewIndex);
  let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];
  if (activeCaseIndex !== null) {
    let mask = changeMask;
    if (activeCaseIndex < 0) {
      activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;
      mask = -1;
    }
    applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);
  }
}
function applyIcuSwitchCase(tView, tIcu, lView, value) {
  const caseIndex = getCaseIndex(tIcu, value);
  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
  if (activeCaseIndex !== caseIndex) {
    applyIcuSwitchCaseRemove(tView, tIcu, lView);
    lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;
    if (caseIndex !== null) {
      const anchorRNode = lView[tIcu.anchorIdx];
      if (anchorRNode) {
        ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDomNode)(anchorRNode);
        applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);
      }
      claimDehydratedIcuCase(lView, tIcu.anchorIdx, caseIndex);
    }
  }
}
function applyIcuSwitchCaseRemove(tView, tIcu, lView) {
  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
  if (activeCaseIndex !== null) {
    const removeCodes = tIcu.remove[activeCaseIndex];
    for (let i = 0; i < removeCodes.length; i++) {
      const nodeOrIcuIndex = removeCodes[i];
      if (nodeOrIcuIndex > 0) {
        const rNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByIndex)(nodeOrIcuIndex, lView);
        rNode !== null && nativeRemoveNode(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], rNode);
      } else {
        applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex), lView);
      }
    }
  }
}
function getCaseIndex(icuExpression, bindingValue) {
  let index = icuExpression.cases.indexOf(bindingValue);
  if (index === -1) {
    switch (icuExpression.type) {
      case 1:
        {
          const resolvedCase = getPluralCase(bindingValue, getLocaleId());
          index = icuExpression.cases.indexOf(resolvedCase);
          if (index === -1 && resolvedCase !== 'other') {
            index = icuExpression.cases.indexOf('other');
          }
          break;
        }
      case 0:
        {
          index = icuExpression.cases.indexOf('other');
          break;
        }
    }
  }
  return index === -1 ? null : index;
}
function i18nCreateOpCodesToString(opcodes) {
  const createOpCodes = opcodes || (Array.isArray(this) ? this : []);
  let lines = [];
  for (let i = 0; i < createOpCodes.length; i++) {
    const opCode = createOpCodes[i++];
    const text = createOpCodes[i];
    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
    const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
    const index = opCode >>> I18nCreateOpCode.SHIFT;
    lines.push(`lView[${index}] = document.${isComment ? 'createComment' : 'createText'}(${JSON.stringify(text)});`);
    if (appendNow) {
      lines.push(`parent.appendChild(lView[${index}]);`);
    }
  }
  return lines;
}
function i18nUpdateOpCodesToString(opcodes) {
  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
  let lines = [];
  function consumeOpCode(value) {
    const ref = value >>> 2;
    const opCode = value & 3;
    switch (opCode) {
      case 0:
        return `(lView[${ref}] as Text).textContent = $$$`;
      case 1:
        const attrName = parser.consumeString();
        const sanitizationFn = parser.consumeFunction();
        const value = sanitizationFn ? `(${sanitizationFn})($$$)` : '$$$';
        return `(lView[${ref}] as Element).setAttribute('${attrName}', ${value})`;
      case 2:
        return `icuSwitchCase(${ref}, $$$)`;
      case 3:
        return `icuUpdateCase(${ref})`;
    }
    throw new Error('unexpected OpCode');
  }
  while (parser.hasMore()) {
    let mask = parser.consumeNumber();
    let size = parser.consumeNumber();
    const end = parser.i + size;
    const statements = [];
    let statement = '';
    while (parser.i < end) {
      let value = parser.consumeNumberOrString();
      if (typeof value === 'string') {
        statement += value;
      } else if (value < 0) {
        statement += '${lView[i' + value + ']}';
      } else {
        const opCodeText = consumeOpCode(value);
        statements.push(opCodeText.replace('$$$', '`' + statement + '`') + ';');
        statement = '';
      }
    }
    lines.push(`if (mask & 0b${mask.toString(2)}) { ${statements.join(' ')} }`);
  }
  return lines;
}
function icuCreateOpCodesToString(opcodes) {
  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
  let lines = [];
  function consumeOpCode(opCode) {
    const parent = getParentFromIcuCreateOpCode(opCode);
    const ref = getRefFromIcuCreateOpCode(opCode);
    switch (getInstructionFromIcuCreateOpCode(opCode)) {
      case 0:
        return `(lView[${parent}] as Element).appendChild(lView[${lastRef}])`;
      case 1:
        return `(lView[${ref}] as Element).setAttribute("${parser.consumeString()}", "${parser.consumeString()}")`;
    }
    throw new Error('Unexpected OpCode: ' + getInstructionFromIcuCreateOpCode(opCode));
  }
  let lastRef = -1;
  while (parser.hasMore()) {
    let value = parser.consumeNumberStringOrMarker();
    if (value === ICU_MARKER) {
      const text = parser.consumeString();
      lastRef = parser.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createComment("${text}")`);
    } else if (value === ELEMENT_MARKER) {
      const text = parser.consumeString();
      lastRef = parser.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createElement("${text}")`);
    } else if (typeof value === 'string') {
      lastRef = parser.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createTextNode("${value}")`);
    } else if (typeof value === 'number') {
      const line = consumeOpCode(value);
      line && lines.push(line);
    } else {
      throw new Error('Unexpected value');
    }
  }
  return lines;
}
function i18nRemoveOpCodesToString(opcodes) {
  const removeCodes = opcodes || (Array.isArray(this) ? this : []);
  let lines = [];
  for (let i = 0; i < removeCodes.length; i++) {
    const nodeOrIcuIndex = removeCodes[i];
    if (nodeOrIcuIndex > 0) {
      lines.push(`remove(lView[${nodeOrIcuIndex}])`);
    } else {
      lines.push(`removeNestedICU(${~nodeOrIcuIndex})`);
    }
  }
  return lines;
}
class OpCodeParser {
  i = 0;
  codes;
  constructor(codes) {
    this.codes = codes;
  }
  hasMore() {
    return this.i < this.codes.length;
  }
  consumeNumber() {
    let value = this.codes[this.i++];
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(value, 'expecting number in OpCode');
    return value;
  }
  consumeString() {
    let value = this.codes[this.i++];
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertString)(value, 'expecting string in OpCode');
    return value;
  }
  consumeFunction() {
    let value = this.codes[this.i++];
    if (value === null || typeof value === 'function') {
      return value;
    }
    throw new Error('expecting function in OpCode');
  }
  consumeNumberOrString() {
    let value = this.codes[this.i++];
    if (typeof value === 'string') {
      return value;
    }
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(value, 'expecting number or string in OpCode');
    return value;
  }
  consumeNumberStringOrMarker() {
    let value = this.codes[this.i++];
    if (typeof value === 'string' || typeof value === 'number' || value == ICU_MARKER || value == ELEMENT_MARKER) {
      return value;
    }
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(value, 'expecting number, string, ICU_MARKER or ELEMENT_MARKER in OpCode');
    return value;
  }
}
const BINDING_REGEXP = /�(\d+):?\d*�/gi;
const ICU_REGEXP = /({\s*�\d+:?\d*�\s*,\s*\S{6}\s*,[\s\S]*})/gi;
const NESTED_ICU = /�(\d+)�/;
const ICU_BLOCK_REGEXP = /^\s*(�\d+:?\d*�)\s*,\s*(select|plural)\s*,/;
const MARKER = `�`;
const SUBTEMPLATE_REGEXP = /�\/?\*(\d+:\d+)�/gi;
const PH_REGEXP = /�(\/?[#*]\d+):?\d*�/gi;
const NGSP_UNICODE_REGEXP = /\uE500/g;
function replaceNgsp(value) {
  return value.replace(NGSP_UNICODE_REGEXP, ' ');
}
function attachDebugGetter(obj, debugGetter) {
  if (ngDevMode) {
    Object.defineProperty(obj, 'debug', {
      get: debugGetter,
      enumerable: false
    });
  } else {
    throw new Error('This method should be guarded with `ngDevMode` so that it can be tree shaken in production!');
  }
}
function i18nStartFirstCreatePass(tView, parentTNodeIndex, lView, index, message, subTemplateIndex) {
  const rootTNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentParentTNode)();
  const createOpCodes = [];
  const updateOpCodes = [];
  const existingTNodeStack = [[]];
  const astStack = [[]];
  if (ngDevMode) {
    attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  message = getTranslationForTemplate(message, subTemplateIndex);
  const msgParts = replaceNgsp(message).split(PH_REGEXP);
  for (let i = 0; i < msgParts.length; i++) {
    let value = msgParts[i];
    if ((i & 1) === 0) {
      const parts = i18nParseTextIntoPartsAndICU(value);
      for (let j = 0; j < parts.length; j++) {
        let part = parts[j];
        if ((j & 1) === 0) {
          const text = part;
          ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertString)(text, 'Parsed ICU part should be string');
          if (text !== '') {
            i18nStartFirstCreatePassProcessTextNode(astStack[0], tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView, text);
          }
        } else {
          const icuExpression = part;
          if (typeof icuExpression !== 'object') {
            throw new Error(`Unable to parse ICU expression in "${message}" message.`);
          }
          const icuContainerTNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodeStack[0], lView, createOpCodes, ngDevMode ? `ICU ${index}:${icuExpression.mainBinding}` : '', true);
          const icuNodeIndex = icuContainerTNode.index;
          ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertGreaterThanOrEqual)(icuNodeIndex, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET, 'Index must be in absolute LView offset');
          icuStart(astStack[0], tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);
        }
      }
    } else {
      const isClosing = value.charCodeAt(0) === 47;
      const type = value.charCodeAt(isClosing ? 1 : 0);
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertOneOf)(type, 42, 35);
      const index = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET + Number.parseInt(value.substring(isClosing ? 2 : 1));
      if (isClosing) {
        existingTNodeStack.shift();
        astStack.shift();
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentTNode)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentParentTNode)(), false);
      } else {
        const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index);
        existingTNodeStack.unshift([]);
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentTNode)(tNode, true);
        const placeholderNode = {
          kind: 2,
          index,
          children: [],
          type: type === 35 ? 0 : 1
        };
        astStack[0].push(placeholderNode);
        astStack.unshift(placeholderNode.children);
      }
    }
  }
  tView.data[index] = {
    create: createOpCodes,
    update: updateOpCodes,
    ast: astStack[0],
    parentTNodeIndex
  };
}
function createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, text, isICU) {
  const i18nNodeIdx = allocExpando(tView, lView, 1, null);
  let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;
  let parentTNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentParentTNode)();
  if (rootTNode === parentTNode) {
    parentTNode = null;
  }
  if (parentTNode === null) {
    opCode |= I18nCreateOpCode.APPEND_EAGERLY;
  }
  if (isICU) {
    opCode |= I18nCreateOpCode.COMMENT;
    ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);
  }
  createOpCodes.push(opCode, text === null ? '' : text);
  const tNode = createTNodeAtIndex(tView, i18nNodeIdx, isICU ? 32 : 1, text === null ? ngDevMode ? '{{?}}' : '' : text, null);
  addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);
  const tNodeIdx = tNode.index;
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentTNode)(tNode, false);
  if (parentTNode !== null && rootTNode !== parentTNode) {
    setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);
  }
  return tNode;
}
function i18nStartFirstCreatePassProcessTextNode(ast, tView, rootTNode, existingTNodes, createOpCodes, updateOpCodes, lView, text) {
  const hasBinding = text.match(BINDING_REGEXP);
  const tNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? null : text, false);
  const index = tNode.index;
  if (hasBinding) {
    generateBindingUpdateOpCodes(updateOpCodes, text, index, null, 0, null);
  }
  ast.push({
    kind: 0,
    index
  });
}
function i18nAttributesFirstPass(tView, index, values) {
  const previousElement = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  const previousElementIndex = previousElement.index;
  const updateOpCodes = [];
  if (ngDevMode) {
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  if (tView.firstCreatePass && tView.data[index] === null) {
    for (let i = 0; i < values.length; i += 2) {
      const attrName = values[i];
      const message = values[i + 1];
      if (message !== '') {
        if (ICU_REGEXP.test(message)) {
          throw new Error(`ICU expressions are not supported in attributes. Message: "${message}".`);
        }
        generateBindingUpdateOpCodes(updateOpCodes, message, previousElementIndex, attrName, countBindings(updateOpCodes), null);
      }
    }
    tView.data[index] = updateOpCodes;
  }
}
function generateBindingUpdateOpCodes(updateOpCodes, str, destinationNode, attrName, bindingStart, sanitizeFn) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertGreaterThanOrEqual)(destinationNode, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET, 'Index must be in absolute LView offset');
  const maskIndex = updateOpCodes.length;
  const sizeIndex = maskIndex + 1;
  updateOpCodes.push(null, null);
  const startIndex = maskIndex + 2;
  if (ngDevMode) {
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  const textParts = str.split(BINDING_REGEXP);
  let mask = 0;
  for (let j = 0; j < textParts.length; j++) {
    const textValue = textParts[j];
    if (j & 1) {
      const bindingIndex = bindingStart + parseInt(textValue, 10);
      updateOpCodes.push(-1 - bindingIndex);
      mask = mask | toMaskBit(bindingIndex);
    } else if (textValue !== '') {
      updateOpCodes.push(textValue);
    }
  }
  updateOpCodes.push(destinationNode << 2 | (attrName ? 1 : 0));
  if (attrName) {
    updateOpCodes.push(attrName, sanitizeFn);
  }
  updateOpCodes[maskIndex] = mask;
  updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;
  return mask;
}
function countBindings(opCodes) {
  let count = 0;
  for (let i = 0; i < opCodes.length; i++) {
    const opCode = opCodes[i];
    if (typeof opCode === 'number' && opCode < 0) {
      count++;
    }
  }
  return count;
}
function toMaskBit(bindingIndex) {
  return 1 << Math.min(bindingIndex, 31);
}
function removeInnerTemplateTranslation(message) {
  let match;
  let res = '';
  let index = 0;
  let inTemplate = false;
  let tagMatched;
  while ((match = SUBTEMPLATE_REGEXP.exec(message)) !== null) {
    if (!inTemplate) {
      res += message.substring(index, match.index + match[0].length);
      tagMatched = match[1];
      inTemplate = true;
    } else {
      if (match[0] === `${MARKER}/*${tagMatched}${MARKER}`) {
        index = match.index;
        inTemplate = false;
      }
    }
  }
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(inTemplate, false, `Tag mismatch: unable to find the end of the sub-template in the translation "${message}"`);
  res += message.slice(index);
  return res;
}
function getTranslationForTemplate(message, subTemplateIndex) {
  if (isRootTemplateMessage(subTemplateIndex)) {
    return removeInnerTemplateTranslation(message);
  } else {
    const start = message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;
    const end = message.search(new RegExp(`${MARKER}\\/\\*\\d+:${subTemplateIndex}${MARKER}`));
    return removeInnerTemplateTranslation(message.substring(start, end));
  }
}
function icuStart(ast, tView, lView, updateOpCodes, parentIdx, icuExpression, anchorIdx) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(icuExpression, 'ICU expression must be defined');
  let bindingMask = 0;
  const tIcu = {
    type: icuExpression.type,
    currentCaseLViewIndex: allocExpando(tView, lView, 1, null),
    anchorIdx,
    cases: [],
    create: [],
    remove: [],
    update: []
  };
  addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);
  setTIcu(tView, anchorIdx, tIcu);
  const values = icuExpression.values;
  const cases = [];
  for (let i = 0; i < values.length; i++) {
    const valueArr = values[i];
    const nestedIcus = [];
    for (let j = 0; j < valueArr.length; j++) {
      const value = valueArr[j];
      if (typeof value !== 'string') {
        const icuIndex = nestedIcus.push(value) - 1;
        valueArr[j] = `<!--�${icuIndex}�-->`;
      }
    }
    const caseAst = [];
    cases.push(caseAst);
    bindingMask = parseIcuCase(caseAst, tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i], valueArr.join(''), nestedIcus) | bindingMask;
  }
  if (bindingMask) {
    addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);
  }
  ast.push({
    kind: 3,
    index: anchorIdx,
    cases,
    currentCaseLViewIndex: tIcu.currentCaseLViewIndex
  });
}
function parseICUBlock(pattern) {
  const cases = [];
  const values = [];
  let icuType = 1;
  let mainBinding = 0;
  pattern = pattern.replace(ICU_BLOCK_REGEXP, function (str, binding, type) {
    if (type === 'select') {
      icuType = 0;
    } else {
      icuType = 1;
    }
    mainBinding = parseInt(binding.slice(1), 10);
    return '';
  });
  const parts = i18nParseTextIntoPartsAndICU(pattern);
  for (let pos = 0; pos < parts.length;) {
    let key = parts[pos++].trim();
    if (icuType === 1) {
      key = key.replace(/\s*(?:=)?(\w+)\s*/, '$1');
    }
    if (key.length) {
      cases.push(key);
    }
    const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]);
    if (cases.length > values.length) {
      values.push(blocks);
    }
  }
  return {
    type: icuType,
    mainBinding: mainBinding,
    cases,
    values
  };
}
function i18nParseTextIntoPartsAndICU(pattern) {
  if (!pattern) {
    return [];
  }
  let prevPos = 0;
  const braceStack = [];
  const results = [];
  const braces = /[{}]/g;
  braces.lastIndex = 0;
  let match;
  while (match = braces.exec(pattern)) {
    const pos = match.index;
    if (match[0] == '}') {
      braceStack.pop();
      if (braceStack.length == 0) {
        const block = pattern.substring(prevPos, pos);
        if (ICU_BLOCK_REGEXP.test(block)) {
          results.push(parseICUBlock(block));
        } else {
          results.push(block);
        }
        prevPos = pos + 1;
      }
    } else {
      if (braceStack.length == 0) {
        const substring = pattern.substring(prevPos, pos);
        results.push(substring);
        prevPos = pos + 1;
      }
      braceStack.push('{');
    }
  }
  const substring = pattern.substring(prevPos);
  results.push(substring);
  return results;
}
function parseIcuCase(ast, tView, tIcu, lView, updateOpCodes, parentIdx, caseName, unsafeCaseHtml, nestedIcus) {
  const create = [];
  const remove = [];
  const update = [];
  if (ngDevMode) {
    attachDebugGetter(create, icuCreateOpCodesToString);
    attachDebugGetter(remove, i18nRemoveOpCodesToString);
    attachDebugGetter(update, i18nUpdateOpCodesToString);
  }
  tIcu.cases.push(caseName);
  tIcu.create.push(create);
  tIcu.remove.push(remove);
  tIcu.update.push(update);
  const inertBodyHelper = getInertBodyHelper(getDocument());
  const inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeCaseHtml);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(inertBodyElement, 'Unable to generate inert body element');
  const inertRootNode = getTemplateContent(inertBodyElement) || inertBodyElement;
  if (inertRootNode) {
    return walkIcuTree(ast, tView, tIcu, lView, updateOpCodes, create, remove, update, inertRootNode, parentIdx, nestedIcus, 0);
  } else {
    return 0;
  }
}
function walkIcuTree(ast, tView, tIcu, lView, sharedUpdateOpCodes, create, remove, update, parentNode, parentIdx, nestedIcus, depth) {
  let bindingMask = 0;
  let currentNode = parentNode.firstChild;
  while (currentNode) {
    const newIndex = allocExpando(tView, lView, 1, null);
    switch (currentNode.nodeType) {
      case Node.ELEMENT_NODE:
        const element = currentNode;
        const tagName = element.tagName.toLowerCase();
        if (VALID_ELEMENTS.hasOwnProperty(tagName)) {
          addCreateNodeAndAppend(create, ELEMENT_MARKER, tagName, parentIdx, newIndex);
          tView.data[newIndex] = tagName;
          const elAttrs = element.attributes;
          for (let i = 0; i < elAttrs.length; i++) {
            const attr = elAttrs.item(i);
            const lowerAttrName = attr.name.toLowerCase();
            const hasBinding = !!attr.value.match(BINDING_REGEXP);
            if (hasBinding) {
              if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {
                if (URI_ATTRS[lowerAttrName]) {
                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, _sanitizeUrl);
                } else {
                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, null);
                }
              } else {
                ngDevMode && console.warn(`WARNING: ignoring unsafe attribute value ` + `${lowerAttrName} on element ${tagName} ` + `(see ${_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.XSS_SECURITY_URL})`);
              }
            } else {
              addCreateAttribute(create, newIndex, attr);
            }
          }
          const elementNode = {
            kind: 1,
            index: newIndex,
            children: []
          };
          ast.push(elementNode);
          bindingMask = walkIcuTree(elementNode.children, tView, tIcu, lView, sharedUpdateOpCodes, create, remove, update, currentNode, newIndex, nestedIcus, depth + 1) | bindingMask;
          addRemoveNode(remove, newIndex, depth);
        }
        break;
      case Node.TEXT_NODE:
        const value = currentNode.textContent || '';
        const hasBinding = value.match(BINDING_REGEXP);
        addCreateNodeAndAppend(create, null, hasBinding ? '' : value, parentIdx, newIndex);
        addRemoveNode(remove, newIndex, depth);
        if (hasBinding) {
          bindingMask = generateBindingUpdateOpCodes(update, value, newIndex, null, 0, null) | bindingMask;
        }
        ast.push({
          kind: 0,
          index: newIndex
        });
        break;
      case Node.COMMENT_NODE:
        const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || '');
        if (isNestedIcu) {
          const nestedIcuIndex = parseInt(isNestedIcu[1], 10);
          const icuExpression = nestedIcus[nestedIcuIndex];
          addCreateNodeAndAppend(create, ICU_MARKER, ngDevMode ? `nested ICU ${nestedIcuIndex}` : '', parentIdx, newIndex);
          icuStart(ast, tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);
          addRemoveNestedIcu(remove, newIndex, depth);
        }
        break;
    }
    currentNode = currentNode.nextSibling;
  }
  return bindingMask;
}
function addRemoveNode(remove, index, depth) {
  if (depth === 0) {
    remove.push(index);
  }
}
function addRemoveNestedIcu(remove, index, depth) {
  if (depth === 0) {
    remove.push(~index);
    remove.push(index);
  }
}
function addUpdateIcuSwitch(update, icuExpression, index) {
  update.push(toMaskBit(icuExpression.mainBinding), 2, -1 - icuExpression.mainBinding, index << 2 | 2);
}
function addUpdateIcuUpdate(update, bindingMask, index) {
  update.push(bindingMask, 1, index << 2 | 3);
}
function addCreateNodeAndAppend(create, marker, text, appendToParentIdx, createAtIdx) {
  if (marker !== null) {
    create.push(marker);
  }
  create.push(text, createAtIdx, icuCreateOpCode(0, appendToParentIdx, createAtIdx));
}
function addCreateAttribute(create, newIndex, attr) {
  create.push(newIndex << 1 | 1, attr.name, attr.value);
}
const ROOT_TEMPLATE_ID = 0;
const PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\[(�.+?�?)\]/;
const PP_PLACEHOLDERS_REGEXP = /\[(�.+?�?)\]|(�\/?\*\d+:\d+�)/g;
const PP_ICU_VARS_REGEXP = /({\s*)(VAR_(PLURAL|SELECT)(_\d+)?)(\s*,)/g;
const PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;
const PP_ICUS_REGEXP = /�I18N_EXP_(ICU(_\d+)?)�/g;
const PP_CLOSE_TEMPLATE_REGEXP = /\/\*/;
const PP_TEMPLATE_ID_REGEXP = /\d+\:(\d+)/;
function i18nPostprocess(message, replacements = {}) {
  let result = message;
  if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {
    const matches = {};
    const templateIdsStack = [ROOT_TEMPLATE_ID];
    result = result.replace(PP_PLACEHOLDERS_REGEXP, (m, phs, tmpl) => {
      const content = phs || tmpl;
      const placeholders = matches[content] || [];
      if (!placeholders.length) {
        content.split('|').forEach(placeholder => {
          const match = placeholder.match(PP_TEMPLATE_ID_REGEXP);
          const templateId = match ? parseInt(match[1], 10) : ROOT_TEMPLATE_ID;
          const isCloseTemplateTag = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder);
          placeholders.push([templateId, isCloseTemplateTag, placeholder]);
        });
        matches[content] = placeholders;
      }
      if (!placeholders.length) {
        throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);
      }
      const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];
      let idx = 0;
      for (let i = 0; i < placeholders.length; i++) {
        if (placeholders[i][0] === currentTemplateId) {
          idx = i;
          break;
        }
      }
      const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];
      if (isCloseTemplateTag) {
        templateIdsStack.pop();
      } else if (currentTemplateId !== templateId) {
        templateIdsStack.push(templateId);
      }
      placeholders.splice(idx, 1);
      return placeholder;
    });
  }
  if (!Object.keys(replacements).length) {
    return result;
  }
  result = result.replace(PP_ICU_VARS_REGEXP, (match, start, key, _type, _idx, end) => {
    return replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match;
  });
  result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match, key) => {
    return replacements.hasOwnProperty(key) ? replacements[key] : match;
  });
  result = result.replace(PP_ICUS_REGEXP, (match, key) => {
    if (replacements.hasOwnProperty(key)) {
      const list = replacements[key];
      if (!list.length) {
        throw new Error(`i18n postprocess: unmatched ICU - ${match} with key: ${key}`);
      }
      return list.shift();
    }
    return match;
  });
  return result;
}
function ɵɵi18nStart(index, messageIndex, subTemplateIndex = -1) {
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const adjustedIndex = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET + index;
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(tView, `tView should be defined`);
  const message = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tView.consts, messageIndex);
  const parentTNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentParentTNode)();
  if (tView.firstCreatePass) {
    i18nStartFirstCreatePass(tView, parentTNode === null ? 0 : parentTNode.index, lView, adjustedIndex, message, subTemplateIndex);
  }
  if (tView.type === 2) {
    const componentLView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW];
    componentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] |= 32;
  } else {
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] |= 32;
  }
  const tI18n = tView.data[adjustedIndex];
  const sameViewParentTNode = parentTNode === lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST] ? null : parentTNode;
  const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView);
  const insertInFrontOf = parentTNode && parentTNode.type & 8 ? lView[parentTNode.index] : null;
  prepareI18nBlockForHydration(lView, adjustedIndex, parentTNode, subTemplateIndex);
  applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInI18nBlock)(true);
}
function ɵɵi18nEnd() {
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInI18nBlock)(false);
}
function ɵɵi18n(index, messageIndex, subTemplateIndex) {
  ɵɵi18nStart(index, messageIndex, subTemplateIndex);
  ɵɵi18nEnd();
}
function ɵɵi18nAttributes(index, attrsIndex) {
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(tView, `tView should be defined`);
  const attrs = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tView.consts, attrsIndex);
  i18nAttributesFirstPass(tView, index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET, attrs);
}
function ɵɵi18nExp(value) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  setMaskBit(bindingUpdated(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)(), value));
  return ɵɵi18nExp;
}
function ɵɵi18nApply(index) {
  applyI18n((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET);
}
function ɵɵi18nPostprocess(message, replacements = {}) {
  return i18nPostprocess(message, replacements);
}
function ɵɵlistener(eventName, listenerFn, eventTargetResolver) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  listenerInternal(tView, lView, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], tNode, eventName, listenerFn, eventTargetResolver);
  return ɵɵlistener;
}
function ɵɵsyntheticHostListener(eventName, listenerFn) {
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const currentDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentDirectiveDef)(tView.data);
  const renderer = loadComponentRenderer(currentDef, tNode, lView);
  listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn);
  return ɵɵsyntheticHostListener;
}
function ɵɵdomListener(eventName, listenerFn, eventTargetResolver) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (tNode.type & 3 || eventTargetResolver) {
    listenToDomEvent(tNode, tView, lView, eventTargetResolver, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], eventName, listenerFn, wrapListener(tNode, lView, listenerFn));
  }
  return ɵɵdomListener;
}
function listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, eventTargetResolver) {
  ngDevMode && assertTNodeType(tNode, 3 | 12);
  let processOutputs = true;
  let wrappedListener = null;
  if (tNode.type & 3 || eventTargetResolver) {
    wrappedListener ??= wrapListener(tNode, lView, listenerFn);
    const hasCoalescedDomEvent = listenToDomEvent(tNode, tView, lView, eventTargetResolver, renderer, eventName, listenerFn, wrappedListener);
    if (hasCoalescedDomEvent) {
      processOutputs = false;
    }
  }
  if (processOutputs) {
    const outputConfig = tNode.outputs?.[eventName];
    const hostDirectiveOutputConfig = tNode.hostDirectiveOutputs?.[eventName];
    if (hostDirectiveOutputConfig && hostDirectiveOutputConfig.length) {
      for (let i = 0; i < hostDirectiveOutputConfig.length; i += 2) {
        const index = hostDirectiveOutputConfig[i];
        const lookupName = hostDirectiveOutputConfig[i + 1];
        wrappedListener ??= wrapListener(tNode, lView, listenerFn);
        listenToOutput(tNode, lView, index, lookupName, eventName, wrappedListener);
      }
    }
    if (outputConfig && outputConfig.length) {
      for (const index of outputConfig) {
        wrappedListener ??= wrapListener(tNode, lView, listenerFn);
        listenToOutput(tNode, lView, index, eventName, eventName, wrappedListener);
      }
    }
  }
}
function ɵɵnextContext(level = 1) {
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextContextImpl)(level);
}
function matchingProjectionSlotIndex(tNode, projectionSlots) {
  let wildcardNgContentIndex = null;
  const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);
  for (let i = 0; i < projectionSlots.length; i++) {
    const slotValue = projectionSlots[i];
    if (slotValue === '*') {
      wildcardNgContentIndex = i;
      continue;
    }
    if (ngProjectAsAttrVal === null ? isNodeMatchingSelectorList(tNode, slotValue, true) : isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) {
      return i;
    }
  }
  return wildcardNgContentIndex;
}
function ɵɵprojectionDef(projectionSlots) {
  const componentNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)()[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST];
  if (!componentNode.projection) {
    const numProjectionSlots = projectionSlots ? projectionSlots.length : 1;
    const projectionHeads = componentNode.projection = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.newArray)(numProjectionSlots, null);
    const tails = projectionHeads.slice();
    let componentChild = componentNode.child;
    while (componentChild !== null) {
      if (componentChild.type !== 128) {
        const slotIndex = projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;
        if (slotIndex !== null) {
          if (tails[slotIndex]) {
            tails[slotIndex].projectionNext = componentChild;
          } else {
            projectionHeads[slotIndex] = componentChild;
          }
          tails[slotIndex] = componentChild;
        }
      }
      componentChild = componentChild.next;
    }
  }
}
function ɵɵprojection(nodeIndex, selectorIndex = 0, attrs, fallbackTemplateFn, fallbackDecls, fallbackVars) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const fallbackIndex = fallbackTemplateFn ? nodeIndex + 1 : null;
  if (fallbackIndex !== null) {
    declareNoDirectiveHostTemplate(lView, tView, fallbackIndex, fallbackTemplateFn, fallbackDecls, fallbackVars, null, attrs);
  }
  const tProjectionNode = getOrCreateTNode(tView, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET + nodeIndex, 16, null, attrs || null);
  if (tProjectionNode.projection === null) {
    tProjectionNode.projection = selectorIndex;
  }
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentTNodeAsNotParent)();
  const hydrationInfo = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION];
  const isNodeCreationMode = !hydrationInfo || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isInSkipHydrationBlock)();
  const componentHostNode = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST];
  const isEmpty = componentHostNode.projection[tProjectionNode.projection] === null;
  if (isEmpty && fallbackIndex !== null) {
    insertFallbackContent(lView, tView, fallbackIndex);
  } else if (isNodeCreationMode && !isDetachedByI18n(tProjectionNode)) {
    applyProjection(tView, lView, tProjectionNode);
  }
}
function insertFallbackContent(lView, tView, fallbackIndex) {
  const adjustedIndex = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET + fallbackIndex;
  const fallbackTNode = tView.data[adjustedIndex];
  const fallbackLContainer = lView[adjustedIndex];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNode)(fallbackTNode);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLContainer)(fallbackLContainer);
  const dehydratedView = findMatchingDehydratedView(fallbackLContainer, fallbackTNode.tView.ssrId);
  const fallbackLView = createAndRenderEmbeddedLView(lView, fallbackTNode, undefined, {
    dehydratedView
  });
  addLViewToLContainer(fallbackLContainer, fallbackLView, 0, shouldAddViewToDom(fallbackTNode, dehydratedView));
}
function ɵɵcontentQuery(directiveIndex, predicate, flags, read) {
  createContentQuery(directiveIndex, predicate, flags, read);
  return ɵɵcontentQuery;
}
function ɵɵviewQuery(predicate, flags, read) {
  createViewQuery(predicate, flags, read);
  return ɵɵviewQuery;
}
function ɵɵqueryRefresh(queryList) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const queryIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentQueryIndex)();
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentQueryIndex)(queryIndex + 1);
  const tQuery = getTQuery(tView, queryIndex);
  if (queryList.dirty && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isCreationMode)(lView) === ((tQuery.metadata.flags & 2) === 2)) {
    if (tQuery.matches === null) {
      queryList.reset([]);
    } else {
      const result = getQueryResults(lView, queryIndex);
      queryList.reset(result, unwrapElementRef);
      queryList.notifyOnChanges();
    }
    return true;
  }
  return false;
}
function ɵɵloadQuery() {
  return loadQueryInternal((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentQueryIndex)());
}
function ɵɵcontentQuerySignal(directiveIndex, target, predicate, flags, read) {
  bindQueryToSignal(target, createContentQuery(directiveIndex, predicate, flags, read));
  return ɵɵcontentQuerySignal;
}
function ɵɵviewQuerySignal(target, predicate, flags, read) {
  bindQueryToSignal(target, createViewQuery(predicate, flags, read));
  return ɵɵviewQuerySignal;
}
function ɵɵqueryAdvance(indexOffset = 1) {
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentQueryIndex)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentQueryIndex)() + indexOffset);
}
function ɵɵreference(index) {
  const contextLView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getContextLView)();
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.load)(contextLView, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET + index);
}
function toTStylingRange(prev, next) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumberInRange)(prev, 0, 32767);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumberInRange)(next, 0, 32767);
  return prev << 17 | next << 2;
}
function getTStylingRangePrev(tStylingRange) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(tStylingRange, 'expected number');
  return tStylingRange >> 17 & 32767;
}
function getTStylingRangePrevDuplicate(tStylingRange) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(tStylingRange, 'expected number');
  return (tStylingRange & 2) == 2;
}
function setTStylingRangePrev(tStylingRange, previous) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(tStylingRange, 'expected number');
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumberInRange)(previous, 0, 32767);
  return tStylingRange & ~4294836224 | previous << 17;
}
function setTStylingRangePrevDuplicate(tStylingRange) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(tStylingRange, 'expected number');
  return tStylingRange | 2;
}
function getTStylingRangeNext(tStylingRange) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(tStylingRange, 'expected number');
  return (tStylingRange & 131068) >> 2;
}
function setTStylingRangeNext(tStylingRange, next) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(tStylingRange, 'expected number');
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumberInRange)(next, 0, 32767);
  return tStylingRange & ~131068 | next << 2;
}
function getTStylingRangeNextDuplicate(tStylingRange) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(tStylingRange, 'expected number');
  return (tStylingRange & 1) === 1;
}
function setTStylingRangeNextDuplicate(tStylingRange) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(tStylingRange, 'expected number');
  return tStylingRange | 1;
}
function insertTStylingBinding(tData, tNode, tStylingKeyWithStatic, index, isHostBinding, isClassBinding) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstUpdatePass)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)());
  let tBindings = isClassBinding ? tNode.classBindings : tNode.styleBindings;
  let tmplHead = getTStylingRangePrev(tBindings);
  let tmplTail = getTStylingRangeNext(tBindings);
  tData[index] = tStylingKeyWithStatic;
  let isKeyDuplicateOfStatic = false;
  let tStylingKey;
  if (Array.isArray(tStylingKeyWithStatic)) {
    const staticKeyValueArray = tStylingKeyWithStatic;
    tStylingKey = staticKeyValueArray[1];
    if (tStylingKey === null || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.keyValueArrayIndexOf)(staticKeyValueArray, tStylingKey) > 0) {
      isKeyDuplicateOfStatic = true;
    }
  } else {
    tStylingKey = tStylingKeyWithStatic;
  }
  if (isHostBinding) {
    const hasTemplateBindings = tmplTail !== 0;
    if (hasTemplateBindings) {
      const previousNode = getTStylingRangePrev(tData[tmplHead + 1]);
      tData[index + 1] = toTStylingRange(previousNode, tmplHead);
      if (previousNode !== 0) {
        tData[previousNode + 1] = setTStylingRangeNext(tData[previousNode + 1], index);
      }
      tData[tmplHead + 1] = setTStylingRangePrev(tData[tmplHead + 1], index);
    } else {
      tData[index + 1] = toTStylingRange(tmplHead, 0);
      if (tmplHead !== 0) {
        tData[tmplHead + 1] = setTStylingRangeNext(tData[tmplHead + 1], index);
      }
      tmplHead = index;
    }
  } else {
    tData[index + 1] = toTStylingRange(tmplTail, 0);
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(tmplHead !== 0 && tmplTail === 0, false, 'Adding template bindings after hostBindings is not allowed.');
    if (tmplHead === 0) {
      tmplHead = index;
    } else {
      tData[tmplTail + 1] = setTStylingRangeNext(tData[tmplTail + 1], index);
    }
    tmplTail = index;
  }
  if (isKeyDuplicateOfStatic) {
    tData[index + 1] = setTStylingRangePrevDuplicate(tData[index + 1]);
  }
  markDuplicates(tData, tStylingKey, index, true);
  markDuplicates(tData, tStylingKey, index, false);
  markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding);
  tBindings = toTStylingRange(tmplHead, tmplTail);
  if (isClassBinding) {
    tNode.classBindings = tBindings;
  } else {
    tNode.styleBindings = tBindings;
  }
}
function markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding) {
  const residual = isClassBinding ? tNode.residualClasses : tNode.residualStyles;
  if (residual != null && typeof tStylingKey == 'string' && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.keyValueArrayIndexOf)(residual, tStylingKey) >= 0) {
    tData[index + 1] = setTStylingRangeNextDuplicate(tData[index + 1]);
  }
}
function markDuplicates(tData, tStylingKey, index, isPrevDir) {
  const tStylingAtIndex = tData[index + 1];
  const isMap = tStylingKey === null;
  let cursor = isPrevDir ? getTStylingRangePrev(tStylingAtIndex) : getTStylingRangeNext(tStylingAtIndex);
  let foundDuplicate = false;
  while (cursor !== 0 && (foundDuplicate === false || isMap)) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(tData, cursor);
    const tStylingValueAtCursor = tData[cursor];
    const tStyleRangeAtCursor = tData[cursor + 1];
    if (isStylingMatch(tStylingValueAtCursor, tStylingKey)) {
      foundDuplicate = true;
      tData[cursor + 1] = isPrevDir ? setTStylingRangeNextDuplicate(tStyleRangeAtCursor) : setTStylingRangePrevDuplicate(tStyleRangeAtCursor);
    }
    cursor = isPrevDir ? getTStylingRangePrev(tStyleRangeAtCursor) : getTStylingRangeNext(tStyleRangeAtCursor);
  }
  if (foundDuplicate) {
    tData[index + 1] = isPrevDir ? setTStylingRangePrevDuplicate(tStylingAtIndex) : setTStylingRangeNextDuplicate(tStylingAtIndex);
  }
}
function isStylingMatch(tStylingKeyCursor, tStylingKey) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotEqual)(Array.isArray(tStylingKey), true, "Expected that 'tStylingKey' has been unwrapped");
  if (tStylingKeyCursor === null || tStylingKey == null || (Array.isArray(tStylingKeyCursor) ? tStylingKeyCursor[1] : tStylingKeyCursor) === tStylingKey) {
    return true;
  } else if (Array.isArray(tStylingKeyCursor) && typeof tStylingKey === 'string') {
    return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.keyValueArrayIndexOf)(tStylingKeyCursor, tStylingKey) >= 0;
  }
  return false;
}
const parserState = {
  textEnd: 0,
  key: 0,
  keyEnd: 0,
  value: 0,
  valueEnd: 0
};
function getLastParsedKey(text) {
  return text.substring(parserState.key, parserState.keyEnd);
}
function getLastParsedValue(text) {
  return text.substring(parserState.value, parserState.valueEnd);
}
function parseClassName(text) {
  resetParserState(text);
  return parseClassNameNext(text, consumeWhitespace(text, 0, parserState.textEnd));
}
function parseClassNameNext(text, index) {
  const end = parserState.textEnd;
  if (end === index) {
    return -1;
  }
  index = parserState.keyEnd = consumeClassToken(text, parserState.key = index, end);
  return consumeWhitespace(text, index, end);
}
function parseStyle(text) {
  resetParserState(text);
  return parseStyleNext(text, consumeWhitespace(text, 0, parserState.textEnd));
}
function parseStyleNext(text, startIndex) {
  const end = parserState.textEnd;
  let index = parserState.key = consumeWhitespace(text, startIndex, end);
  if (end === index) {
    return -1;
  }
  index = parserState.keyEnd = consumeStyleKey(text, index, end);
  index = consumeSeparator(text, index, end, 58);
  index = parserState.value = consumeWhitespace(text, index, end);
  index = parserState.valueEnd = consumeStyleValue(text, index, end);
  return consumeSeparator(text, index, end, 59);
}
function resetParserState(text) {
  parserState.key = 0;
  parserState.keyEnd = 0;
  parserState.value = 0;
  parserState.valueEnd = 0;
  parserState.textEnd = text.length;
}
function consumeWhitespace(text, startIndex, endIndex) {
  while (startIndex < endIndex && text.charCodeAt(startIndex) <= 32) {
    startIndex++;
  }
  return startIndex;
}
function consumeClassToken(text, startIndex, endIndex) {
  while (startIndex < endIndex && text.charCodeAt(startIndex) > 32) {
    startIndex++;
  }
  return startIndex;
}
function consumeStyleKey(text, startIndex, endIndex) {
  let ch;
  while (startIndex < endIndex && ((ch = text.charCodeAt(startIndex)) === 45 || ch === 95 || (ch & -33) >= 65 && (ch & -33) <= 90 || ch >= 48 && ch <= 57)) {
    startIndex++;
  }
  return startIndex;
}
function consumeSeparator(text, startIndex, endIndex, separator) {
  startIndex = consumeWhitespace(text, startIndex, endIndex);
  if (startIndex < endIndex) {
    if (ngDevMode && text.charCodeAt(startIndex) !== separator) {
      malformedStyleError(text, String.fromCharCode(separator), startIndex);
    }
    startIndex++;
  }
  return startIndex;
}
function consumeStyleValue(text, startIndex, endIndex) {
  let ch1 = -1;
  let ch2 = -1;
  let ch3 = -1;
  let i = startIndex;
  let lastChIndex = i;
  while (i < endIndex) {
    const ch = text.charCodeAt(i++);
    if (ch === 59) {
      return lastChIndex;
    } else if (ch === 34 || ch === 39) {
      lastChIndex = i = consumeQuotedText(text, ch, i, endIndex);
    } else if (startIndex === i - 4 && ch3 === 85 && ch2 === 82 && ch1 === 76 && ch === 40) {
      lastChIndex = i = consumeQuotedText(text, 41, i, endIndex);
    } else if (ch > 32) {
      lastChIndex = i;
    }
    ch3 = ch2;
    ch2 = ch1;
    ch1 = ch & -33;
  }
  return lastChIndex;
}
function consumeQuotedText(text, quoteCharCode, startIndex, endIndex) {
  let ch1 = -1;
  let index = startIndex;
  while (index < endIndex) {
    const ch = text.charCodeAt(index++);
    if (ch == quoteCharCode && ch1 !== 92) {
      return index;
    }
    if (ch == 92 && ch1 === 92) {
      ch1 = 0;
    } else {
      ch1 = ch;
    }
  }
  throw ngDevMode ? malformedStyleError(text, String.fromCharCode(quoteCharCode), endIndex) : new Error();
}
function malformedStyleError(text, expecting, index) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(typeof text === 'string', true, 'String expected here');
  throw (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)(`Malformed style at location ${index} in string '` + text.substring(0, index) + '[>>' + text.substring(index, index + 1) + '<<]' + text.slice(index + 1) + `'. Expecting '${expecting}'.`);
}
function ɵɵstyleProp(prop, value, suffix) {
  checkStylingProperty(prop, value, suffix, false);
  return ɵɵstyleProp;
}
function ɵɵclassProp(className, value) {
  checkStylingProperty(className, value, null, true);
  return ɵɵclassProp;
}
function ɵɵstyleMap(styles) {
  checkStylingMap(styleKeyValueArraySet, styleStringParser, styles, false);
}
function styleStringParser(keyValueArray, text) {
  for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i)) {
    styleKeyValueArraySet(keyValueArray, getLastParsedKey(text), getLastParsedValue(text));
  }
}
function ɵɵclassMap(classes) {
  checkStylingMap(classKeyValueArraySet, classStringParser, classes, true);
}
function classStringParser(keyValueArray, text) {
  for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.keyValueArraySet)(keyValueArray, getLastParsedKey(text), true);
  }
}
function checkStylingProperty(prop, value, suffix, isClassBased) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.incrementBindingIndex)(2);
  if (tView.firstUpdatePass) {
    stylingFirstUpdatePass(tView, prop, bindingIndex, isClassBased);
  }
  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
    const tNode = tView.data[(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)()];
    updateStyling(tView, tNode, lView, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], prop, lView[bindingIndex + 1] = normalizeSuffix(value, suffix), isClassBased, bindingIndex);
  }
}
function checkStylingMap(keyValueArraySet, stringParser, value, isClassBased) {
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.incrementBindingIndex)(2);
  if (tView.firstUpdatePass) {
    stylingFirstUpdatePass(tView, null, bindingIndex, isClassBased);
  }
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
    const tNode = tView.data[(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)()];
    if (hasStylingInputShadow(tNode, isClassBased) && !isInHostBindings(tView, bindingIndex)) {
      if (ngDevMode) {
        const tStylingKey = tView.data[bindingIndex];
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(Array.isArray(tStylingKey) ? tStylingKey[1] : tStylingKey, false, "Styling linked list shadow input should be marked as 'false'");
      }
      let staticPrefix = isClassBased ? tNode.classesWithoutHost : tNode.stylesWithoutHost;
      ngDevMode && isClassBased === false && staticPrefix !== null && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(staticPrefix.endsWith(';'), true, "Expecting static portion to end with ';'");
      if (staticPrefix !== null) {
        value = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.concatStringsWithSpace)(staticPrefix, value ? value : '');
      }
      setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased);
    } else {
      updateStylingMap(tView, tNode, lView, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], lView[bindingIndex + 1], lView[bindingIndex + 1] = toStylingKeyValueArray(keyValueArraySet, stringParser, value), isClassBased, bindingIndex);
    }
  }
}
function isInHostBindings(tView, bindingIndex) {
  return bindingIndex >= tView.expandoStartIndex;
}
function stylingFirstUpdatePass(tView, tStylingKey, bindingIndex, isClassBased) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstUpdatePass)(tView);
  const tData = tView.data;
  if (tData[bindingIndex + 1] === null) {
    const tNode = tData[(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)()];
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(tNode, 'TNode expected');
    const isHostBindings = isInHostBindings(tView, bindingIndex);
    if (hasStylingInputShadow(tNode, isClassBased) && tStylingKey === null && !isHostBindings) {
      tStylingKey = false;
    }
    tStylingKey = wrapInStaticStylingKey(tData, tNode, tStylingKey, isClassBased);
    insertTStylingBinding(tData, tNode, tStylingKey, bindingIndex, isHostBindings, isClassBased);
  }
}
function wrapInStaticStylingKey(tData, tNode, stylingKey, isClassBased) {
  const hostDirectiveDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentDirectiveDef)(tData);
  let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
  if (hostDirectiveDef === null) {
    const isFirstStylingInstructionInTemplate = (isClassBased ? tNode.classBindings : tNode.styleBindings) === 0;
    if (isFirstStylingInstructionInTemplate) {
      stylingKey = collectStylingFromDirectives(null, tData, tNode, stylingKey, isClassBased);
      stylingKey = collectStylingFromTAttrs(stylingKey, tNode.attrs, isClassBased);
      residual = null;
    }
  } else {
    const directiveStylingLast = tNode.directiveStylingLast;
    const isFirstStylingInstructionInHostBinding = directiveStylingLast === -1 || tData[directiveStylingLast] !== hostDirectiveDef;
    if (isFirstStylingInstructionInHostBinding) {
      stylingKey = collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased);
      if (residual === null) {
        let templateStylingKey = getTemplateHeadTStylingKey(tData, tNode, isClassBased);
        if (templateStylingKey !== undefined && Array.isArray(templateStylingKey)) {
          templateStylingKey = collectStylingFromDirectives(null, tData, tNode, templateStylingKey[1], isClassBased);
          templateStylingKey = collectStylingFromTAttrs(templateStylingKey, tNode.attrs, isClassBased);
          setTemplateHeadTStylingKey(tData, tNode, isClassBased, templateStylingKey);
        }
      } else {
        residual = collectResidual(tData, tNode, isClassBased);
      }
    }
  }
  if (residual !== undefined) {
    isClassBased ? tNode.residualClasses = residual : tNode.residualStyles = residual;
  }
  return stylingKey;
}
function getTemplateHeadTStylingKey(tData, tNode, isClassBased) {
  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
  if (getTStylingRangeNext(bindings) === 0) {
    return undefined;
  }
  return tData[getTStylingRangePrev(bindings)];
}
function setTemplateHeadTStylingKey(tData, tNode, isClassBased, tStylingKey) {
  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotEqual)(getTStylingRangeNext(bindings), 0, 'Expecting to have at least one template styling binding.');
  tData[getTStylingRangePrev(bindings)] = tStylingKey;
}
function collectResidual(tData, tNode, isClassBased) {
  let residual = undefined;
  const directiveEnd = tNode.directiveEnd;
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotEqual)(tNode.directiveStylingLast, -1, 'By the time this function gets called at least one hostBindings-node styling instruction must have executed.');
  for (let i = 1 + tNode.directiveStylingLast; i < directiveEnd; i++) {
    const attrs = tData[i].hostAttrs;
    residual = collectStylingFromTAttrs(residual, attrs, isClassBased);
  }
  return collectStylingFromTAttrs(residual, tNode.attrs, isClassBased);
}
function collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased) {
  let currentDirective = null;
  const directiveEnd = tNode.directiveEnd;
  let directiveStylingLast = tNode.directiveStylingLast;
  if (directiveStylingLast === -1) {
    directiveStylingLast = tNode.directiveStart;
  } else {
    directiveStylingLast++;
  }
  while (directiveStylingLast < directiveEnd) {
    currentDirective = tData[directiveStylingLast];
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(currentDirective, 'expected to be defined');
    stylingKey = collectStylingFromTAttrs(stylingKey, currentDirective.hostAttrs, isClassBased);
    if (currentDirective === hostDirectiveDef) break;
    directiveStylingLast++;
  }
  if (hostDirectiveDef !== null) {
    tNode.directiveStylingLast = directiveStylingLast;
  }
  return stylingKey;
}
function collectStylingFromTAttrs(stylingKey, attrs, isClassBased) {
  const desiredMarker = isClassBased ? 1 : 2;
  let currentMarker = -1;
  if (attrs !== null) {
    for (let i = 0; i < attrs.length; i++) {
      const item = attrs[i];
      if (typeof item === 'number') {
        currentMarker = item;
      } else {
        if (currentMarker === desiredMarker) {
          if (!Array.isArray(stylingKey)) {
            stylingKey = stylingKey === undefined ? [] : ['', stylingKey];
          }
          (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.keyValueArraySet)(stylingKey, item, isClassBased ? true : attrs[++i]);
        }
      }
    }
  }
  return stylingKey === undefined ? null : stylingKey;
}
function toStylingKeyValueArray(keyValueArraySet, stringParser, value) {
  if (value == null || value === '') return _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY;
  const styleKeyValueArray = [];
  const unwrappedValue = unwrapSafeValue(value);
  if (Array.isArray(unwrappedValue)) {
    for (let i = 0; i < unwrappedValue.length; i++) {
      keyValueArraySet(styleKeyValueArray, unwrappedValue[i], true);
    }
  } else if (typeof unwrappedValue === 'object') {
    for (const key in unwrappedValue) {
      if (unwrappedValue.hasOwnProperty(key)) {
        keyValueArraySet(styleKeyValueArray, key, unwrappedValue[key]);
      }
    }
  } else if (typeof unwrappedValue === 'string') {
    stringParser(styleKeyValueArray, unwrappedValue);
  } else {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('Unsupported styling type: ' + typeof unwrappedValue + ' (' + unwrappedValue + ')');
  }
  return styleKeyValueArray;
}
function styleKeyValueArraySet(keyValueArray, key, value) {
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.keyValueArraySet)(keyValueArray, key, unwrapSafeValue(value));
}
function classKeyValueArraySet(keyValueArray, key, value) {
  const stringKey = String(key);
  if (stringKey !== '' && !stringKey.includes(' ')) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.keyValueArraySet)(keyValueArray, stringKey, value);
  }
}
function updateStylingMap(tView, tNode, lView, renderer, oldKeyValueArray, newKeyValueArray, isClassBased, bindingIndex) {
  if (oldKeyValueArray === NO_CHANGE) {
    oldKeyValueArray = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY;
  }
  let oldIndex = 0;
  let newIndex = 0;
  let oldKey = 0 < oldKeyValueArray.length ? oldKeyValueArray[0] : null;
  let newKey = 0 < newKeyValueArray.length ? newKeyValueArray[0] : null;
  while (oldKey !== null || newKey !== null) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLessThan)(oldIndex, 999, 'Are we stuck in infinite loop?');
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLessThan)(newIndex, 999, 'Are we stuck in infinite loop?');
    const oldValue = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex + 1] : undefined;
    const newValue = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex + 1] : undefined;
    let setKey = null;
    let setValue = undefined;
    if (oldKey === newKey) {
      oldIndex += 2;
      newIndex += 2;
      if (oldValue !== newValue) {
        setKey = newKey;
        setValue = newValue;
      }
    } else if (newKey === null || oldKey !== null && oldKey < newKey) {
      oldIndex += 2;
      setKey = oldKey;
    } else {
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(newKey, 'Expecting to have a valid key');
      newIndex += 2;
      setKey = newKey;
      setValue = newValue;
    }
    if (setKey !== null) {
      updateStyling(tView, tNode, lView, renderer, setKey, setValue, isClassBased, bindingIndex);
    }
    oldKey = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex] : null;
    newKey = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex] : null;
  }
}
function updateStyling(tView, tNode, lView, renderer, prop, value, isClassBased, bindingIndex) {
  if (!(tNode.type & 3)) {
    return;
  }
  const tData = tView.data;
  const tRange = tData[bindingIndex + 1];
  const higherPriorityValue = getTStylingRangeNextDuplicate(tRange) ? findStylingValue(tData, tNode, lView, prop, getTStylingRangeNext(tRange), isClassBased) : undefined;
  if (!isStylingValuePresent(higherPriorityValue)) {
    if (!isStylingValuePresent(value)) {
      if (getTStylingRangePrevDuplicate(tRange)) {
        value = findStylingValue(tData, null, lView, prop, bindingIndex, isClassBased);
      }
    }
    const rNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByIndex)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)(), lView);
    applyStyling(renderer, isClassBased, rNode, prop, value);
  }
}
function findStylingValue(tData, tNode, lView, prop, index, isClassBased) {
  const isPrevDirection = tNode === null;
  let value = undefined;
  while (index > 0) {
    const rawKey = tData[index];
    const containsStatics = Array.isArray(rawKey);
    const key = containsStatics ? rawKey[1] : rawKey;
    const isStylingMap = key === null;
    let valueAtLViewIndex = lView[index + 1];
    if (valueAtLViewIndex === NO_CHANGE) {
      valueAtLViewIndex = isStylingMap ? _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY : undefined;
    }
    let currentValue = isStylingMap ? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.keyValueArrayGet)(valueAtLViewIndex, prop) : key === prop ? valueAtLViewIndex : undefined;
    if (containsStatics && !isStylingValuePresent(currentValue)) {
      currentValue = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.keyValueArrayGet)(rawKey, prop);
    }
    if (isStylingValuePresent(currentValue)) {
      value = currentValue;
      if (isPrevDirection) {
        return value;
      }
    }
    const tRange = tData[index + 1];
    index = isPrevDirection ? getTStylingRangePrev(tRange) : getTStylingRangeNext(tRange);
  }
  if (tNode !== null) {
    let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
    if (residual != null) {
      value = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.keyValueArrayGet)(residual, prop);
    }
  }
  return value;
}
function isStylingValuePresent(value) {
  return value !== undefined;
}
function normalizeSuffix(value, suffix) {
  if (value == null || value === '') ;else if (typeof suffix === 'string') {
    value = value + suffix;
  } else if (typeof value === 'object') {
    value = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringify)(unwrapSafeValue(value));
  }
  return value;
}
function hasStylingInputShadow(tNode, isClassBased) {
  return (tNode.flags & (isClassBased ? 8 : 16)) !== 0;
}
function ɵɵtext(index, value = '') {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeCreationIndex)(lView, index);
  const tNode = tView.firstCreatePass ? getOrCreateTNode(tView, adjustedIndex, 1, value, null) : tView.data[adjustedIndex];
  const textNative = _locateOrCreateTextNode(tView, lView, tNode, value, index);
  lView[adjustedIndex] = textNative;
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.wasLastNodeCreated)()) {
    appendChild(tView, lView, textNative, tNode);
  }
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentTNode)(tNode, false);
}
let _locateOrCreateTextNode = (tView, lView, tNode, value, index) => {
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.lastNodeWasCreated)(true);
  return createTextNode(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], value);
};
function locateOrCreateTextNodeImpl(tView, lView, tNode, value, index) {
  const isNodeCreationMode = !canHydrateNode(lView, tNode);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.lastNodeWasCreated)(isNodeCreationMode);
  if (isNodeCreationMode) {
    return createTextNode(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], value);
  }
  const hydrationInfo = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION];
  const textNative = locateNextRNode(hydrationInfo, tView, lView, tNode);
  ngDevMode && validateMatchingNode(textNative, Node.TEXT_NODE, null, lView, tNode);
  ngDevMode && markRNodeAsClaimedByHydration(textNative);
  return textNative;
}
function enableLocateOrCreateTextNodeImpl() {
  _locateOrCreateTextNode = locateOrCreateTextNodeImpl;
}
function interpolationV(lView, values) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLessThan)(2, values.length, 'should have at least 3 values');
  let isBindingUpdated = false;
  let bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingIndex)();
  for (let i = 1; i < values.length; i += 2) {
    isBindingUpdated = bindingUpdated(lView, bindingIndex++, values[i]) || isBindingUpdated;
  }
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setBindingIndex)(bindingIndex);
  if (!isBindingUpdated) {
    return NO_CHANGE;
  }
  let content = values[0];
  for (let i = 1; i < values.length; i += 2) {
    content += (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(values[i]) + (i + 1 !== values.length ? values[i + 1] : '');
  }
  return content;
}
function interpolation1(lView, prefix, v0, suffix = '') {
  const different = bindingUpdated(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)(), v0);
  return different ? prefix + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v0) + suffix : NO_CHANGE;
}
function interpolation2(lView, prefix, v0, i0, v1, suffix = '') {
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingIndex)();
  const different = bindingUpdated2(lView, bindingIndex, v0, v1);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.incrementBindingIndex)(2);
  return different ? prefix + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v0) + i0 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v1) + suffix : NO_CHANGE;
}
function interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix = '') {
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingIndex)();
  const different = bindingUpdated3(lView, bindingIndex, v0, v1, v2);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.incrementBindingIndex)(3);
  return different ? prefix + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v0) + i0 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v1) + i1 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v2) + suffix : NO_CHANGE;
}
function interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix = '') {
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingIndex)();
  const different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.incrementBindingIndex)(4);
  return different ? prefix + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v0) + i0 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v1) + i1 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v2) + i2 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v3) + suffix : NO_CHANGE;
}
function interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix = '') {
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingIndex)();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated(lView, bindingIndex + 4, v4) || different;
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.incrementBindingIndex)(5);
  return different ? prefix + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v0) + i0 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v1) + i1 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v2) + i2 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v3) + i3 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v4) + suffix : NO_CHANGE;
}
function interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix = '') {
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingIndex)();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.incrementBindingIndex)(6);
  return different ? prefix + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v0) + i0 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v1) + i1 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v2) + i2 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v3) + i3 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v4) + i4 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v5) + suffix : NO_CHANGE;
}
function interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix = '') {
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingIndex)();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.incrementBindingIndex)(7);
  return different ? prefix + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v0) + i0 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v1) + i1 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v2) + i2 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v3) + i3 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v4) + i4 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v5) + i5 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v6) + suffix : NO_CHANGE;
}
function interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix = '') {
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingIndex)();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.incrementBindingIndex)(8);
  return different ? prefix + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v0) + i0 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v1) + i1 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v2) + i2 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v3) + i3 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v4) + i4 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v5) + i5 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v6) + i6 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v7) + suffix : NO_CHANGE;
}
function ɵɵtextInterpolate(v0) {
  ɵɵtextInterpolate1('', v0);
  return ɵɵtextInterpolate;
}
function ɵɵtextInterpolate1(prefix, v0, suffix) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const interpolated = interpolation1(lView, prefix, v0, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)(), interpolated);
  }
  return ɵɵtextInterpolate1;
}
function ɵɵtextInterpolate2(prefix, v0, i0, v1, suffix) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const interpolated = interpolation2(lView, prefix, v0, i0, v1, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)(), interpolated);
  }
  return ɵɵtextInterpolate2;
}
function ɵɵtextInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const interpolated = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)(), interpolated);
  }
  return ɵɵtextInterpolate3;
}
function ɵɵtextInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const interpolated = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)(), interpolated);
  }
  return ɵɵtextInterpolate4;
}
function ɵɵtextInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const interpolated = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)(), interpolated);
  }
  return ɵɵtextInterpolate5;
}
function ɵɵtextInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const interpolated = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)(), interpolated);
  }
  return ɵɵtextInterpolate6;
}
function ɵɵtextInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const interpolated = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)(), interpolated);
  }
  return ɵɵtextInterpolate7;
}
function ɵɵtextInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const interpolated = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)(), interpolated);
  }
  return ɵɵtextInterpolate8;
}
function ɵɵtextInterpolateV(values) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const interpolated = interpolationV(lView, values);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)(), interpolated);
  }
  return ɵɵtextInterpolateV;
}
function textBindingInternal(lView, index, value) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertString)(value, 'Value should be a string');
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotSame)(value, NO_CHANGE, 'value should not be NO_CHANGE');
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, index);
  const element = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByIndex)(index, lView);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(element, 'native element should exist');
  updateTextNode(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], element, value);
}
function ɵɵtwoWayProperty(propName, value, sanitizer) {
  if (isWritableSignal(value)) {
    value = value();
  }
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
    const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)();
    setPropertyAndInputs(tNode, lView, propName, value, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], sanitizer);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return ɵɵtwoWayProperty;
}
function ɵɵtwoWayBindingSet(target, value) {
  const canWrite = isWritableSignal(target);
  canWrite && target.set(value);
  return canWrite;
}
function ɵɵtwoWayListener(eventName, listenerFn) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  listenerInternal(tView, lView, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], tNode, eventName, listenerFn);
  return ɵɵtwoWayListener;
}
const UNINITIALIZED_LET = {};
function ɵɵdeclareLet(index) {
  performanceMarkFeature('NgLet');
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const tNode = getOrCreateTNode(tView, adjustedIndex, 128, null, null);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentTNode)(tNode, false);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.store)(tView, lView, adjustedIndex, UNINITIALIZED_LET);
  return ɵɵdeclareLet;
}
function ɵɵstoreLet(value) {
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const index = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)();
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.store)(tView, lView, index, value);
  return value;
}
function ɵɵreadContextLet(index) {
  const contextLView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getContextLView)();
  const value = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.load)(contextLView, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET + index);
  if (value === UNINITIALIZED_LET) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(314, ngDevMode && 'Attempting to access a @let declaration whose value is not available yet');
  }
  return value;
}
function ɵɵattachSourceLocations(templatePath, locations) {
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  const attributeName = 'data-ng-source-location';
  for (const [index, offset, line, column] of locations) {
    const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTNode)(tView, index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET);
    ngDevMode && assertTNodeType(tNode, 2);
    const node = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByIndex)(index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET, lView);
    if (!node.hasAttribute(attributeName)) {
      const attributeValue = `${templatePath}@o:${offset},l:${line},c:${column}`;
      renderer.setAttribute(node, attributeName, attributeValue);
    }
  }
}
function ɵɵinterpolate(v0) {
  return bindingUpdated((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)(), v0) ? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v0) : NO_CHANGE;
}
function ɵɵinterpolate1(prefix, v0, suffix = '') {
  return interpolation1((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), prefix, v0, suffix);
}
function ɵɵinterpolate2(prefix, v0, i0, v1, suffix = '') {
  return interpolation2((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), prefix, v0, i0, v1, suffix);
}
function ɵɵinterpolate3(prefix, v0, i0, v1, i1, v2, suffix = '') {
  return interpolation3((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), prefix, v0, i0, v1, i1, v2, suffix);
}
function ɵɵinterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix = '') {
  return interpolation4((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
}
function ɵɵinterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix = '') {
  return interpolation5((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
}
function ɵɵinterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix = '') {
  return interpolation6((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
}
function ɵɵinterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix = '') {
  return interpolation7((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
}
function ɵɵinterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix = '') {
  return interpolation8((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
}
function ɵɵinterpolateV(values) {
  return interpolationV((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), values);
}
function providersResolver(def, providers, isViewProviders) {
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  if (tView.firstCreatePass) {
    resolveProvider(providers, tView.data, tView.blueprint, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentDef)(def), isViewProviders);
  }
}
function resolveProvider(provider, tInjectables, lInjectablesBlueprint, isComponent, isViewProvider) {
  provider = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(provider);
  if (Array.isArray(provider)) {
    for (let i = 0; i < provider.length; i++) {
      resolveProvider(provider[i], tInjectables, lInjectablesBlueprint, isComponent, isViewProvider);
    }
  } else {
    const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
    const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
    const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
    let token = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isTypeProvider)(provider) ? provider : (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(provider.provide);
    const providerFactory = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.providerToFactory)(provider);
    if (ngDevMode) {
      const injector = new NodeInjector(tNode, lView);
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.runInInjectorProfilerContext)(injector, token, () => {
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.emitProviderConfiguredEvent)(provider, isViewProvider);
      });
    }
    const beginIndex = tNode.providerIndexes & 1048575;
    const endIndex = tNode.directiveStart;
    const cptViewProvidersCount = tNode.providerIndexes >> 20;
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isTypeProvider)(provider) || !provider.multi) {
      const factory = new NodeInjectorFactory(providerFactory, isViewProvider, ɵɵdirectiveInject, ngDevMode ? providerName(provider) : null);
      const existingFactoryIndex = indexOf(token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount, endIndex);
      if (existingFactoryIndex === -1) {
        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
        registerDestroyHooksIfSupported(tView, provider, tInjectables.length);
        tInjectables.push(token);
        tNode.directiveStart++;
        tNode.directiveEnd++;
        if (isViewProvider) {
          tNode.providerIndexes += 1048576;
        }
        lInjectablesBlueprint.push(factory);
        lView.push(factory);
      } else {
        lInjectablesBlueprint[existingFactoryIndex] = factory;
        lView[existingFactoryIndex] = factory;
      }
    } else {
      const existingProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex);
      const existingViewProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount);
      const doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingProvidersFactoryIndex];
      const doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingViewProvidersFactoryIndex];
      if (isViewProvider && !doesViewProvidersFactoryExist || !isViewProvider && !doesProvidersFactoryExist) {
        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
        const factory = multiFactory(isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver, lInjectablesBlueprint.length, isViewProvider, isComponent, providerFactory, provider);
        if (!isViewProvider && doesViewProvidersFactoryExist) {
          lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory;
        }
        registerDestroyHooksIfSupported(tView, provider, tInjectables.length, 0);
        tInjectables.push(token);
        tNode.directiveStart++;
        tNode.directiveEnd++;
        if (isViewProvider) {
          tNode.providerIndexes += 1048576;
        }
        lInjectablesBlueprint.push(factory);
        lView.push(factory);
      } else {
        const indexInFactory = multiFactoryAdd(lInjectablesBlueprint[isViewProvider ? existingViewProvidersFactoryIndex : existingProvidersFactoryIndex], providerFactory, !isViewProvider && isComponent);
        registerDestroyHooksIfSupported(tView, provider, existingProvidersFactoryIndex > -1 ? existingProvidersFactoryIndex : existingViewProvidersFactoryIndex, indexInFactory);
      }
      if (!isViewProvider && isComponent && doesViewProvidersFactoryExist) {
        lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++;
      }
    }
  }
}
function registerDestroyHooksIfSupported(tView, provider, contextIndex, indexInFactory) {
  const providerIsTypeProvider = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isTypeProvider)(provider);
  const providerIsClassProvider = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isClassProvider)(provider);
  if (providerIsTypeProvider || providerIsClassProvider) {
    const classToken = providerIsClassProvider ? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(provider.useClass) : provider;
    const prototype = classToken.prototype;
    const ngOnDestroy = prototype.ngOnDestroy;
    if (ngOnDestroy) {
      const hooks = tView.destroyHooks || (tView.destroyHooks = []);
      if (!providerIsTypeProvider && provider.multi) {
        ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(indexInFactory, 'indexInFactory when registering multi factory destroy hook');
        const existingCallbacksIndex = hooks.indexOf(contextIndex);
        if (existingCallbacksIndex === -1) {
          hooks.push(contextIndex, [indexInFactory, ngOnDestroy]);
        } else {
          hooks[existingCallbacksIndex + 1].push(indexInFactory, ngOnDestroy);
        }
      } else {
        hooks.push(contextIndex, ngOnDestroy);
      }
    }
  }
}
function multiFactoryAdd(multiFactory, factory, isComponentProvider) {
  if (isComponentProvider) {
    multiFactory.componentProviders++;
  }
  return multiFactory.multi.push(factory) - 1;
}
function indexOf(item, arr, begin, end) {
  for (let i = begin; i < end; i++) {
    if (arr[i] === item) return i;
  }
  return -1;
}
function multiProvidersFactoryResolver(_, flags, tData, lData, tNode) {
  return multiResolve(this.multi, []);
}
function multiViewProvidersFactoryResolver(_, _flags, _tData, lView, tNode) {
  const factories = this.multi;
  let result;
  if (this.providerFactory) {
    const componentCount = this.providerFactory.componentProviders;
    const multiProviders = getNodeInjectable(lView, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], this.providerFactory.index, tNode);
    result = multiProviders.slice(0, componentCount);
    multiResolve(factories, result);
    for (let i = componentCount; i < multiProviders.length; i++) {
      result.push(multiProviders[i]);
    }
  } else {
    result = [];
    multiResolve(factories, result);
  }
  return result;
}
function multiResolve(factories, result) {
  for (let i = 0; i < factories.length; i++) {
    const factory = factories[i];
    result.push(factory());
  }
  return result;
}
function multiFactory(factoryFn, index, isViewProvider, isComponent, f, provider) {
  const factory = new NodeInjectorFactory(factoryFn, isViewProvider, ɵɵdirectiveInject, ngDevMode ? providerName(provider) : null);
  factory.multi = [];
  factory.index = index;
  factory.componentProviders = 0;
  multiFactoryAdd(factory, f, isComponent && !isViewProvider);
  return factory;
}
function providerName(provider) {
  if (Array.isArray(provider)) {
    return null;
  }
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isTypeProvider)(provider)) {
    return provider.name;
  } else if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isClassProvider)(provider)) {
    if (provider.provide instanceof _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken) {
      return `('${provider.provide.toString()}':${provider.useClass.name})`;
    }
    return provider.useClass.name;
  } else if (provider.provide instanceof _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken) {
    return provider.provide.toString();
  } else if (typeof provider.provide === 'string') {
    return provider.provide;
  } else {
    return null;
  }
}
function ɵɵProvidersFeature(providers, viewProviders) {
  return definition => {
    definition.providersResolver = (def, processProvidersFn) => providersResolver(def, processProvidersFn ? processProvidersFn(providers) : providers, false);
    if (viewProviders) {
      definition.viewProvidersResolver = (def, processProvidersFn) => providersResolver(def, processProvidersFn ? processProvidersFn(viewProviders) : viewProviders, true);
    }
  };
}
function ɵɵExternalStylesFeature(styleUrls) {
  return definition => {
    if (styleUrls.length < 1) {
      return;
    }
    definition.getExternalStyles = encapsulationId => {
      const urls = styleUrls.map(value => value + '?ngcomp' + (encapsulationId ? '=' + encodeURIComponent(encapsulationId) : '') + '&e=' + definition.encapsulation);
      return urls;
    };
  };
}
function ɵɵsetComponentScope(type, directives, pipes) {
  const def = type.ɵcmp;
  def.directiveDefs = extractDefListOrFactory(directives, extractDirectiveDef);
  def.pipeDefs = extractDefListOrFactory(pipes, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getPipeDef);
}
function ɵɵsetNgModuleScope(type, scope) {
  return noSideEffects(() => {
    const ngModuleDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNgModuleDefOrThrow)(type);
    ngModuleDef.declarations = convertToTypeArray(scope.declarations || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY);
    ngModuleDef.imports = convertToTypeArray(scope.imports || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY);
    ngModuleDef.exports = convertToTypeArray(scope.exports || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY);
    if (scope.bootstrap) {
      ngModuleDef.bootstrap = convertToTypeArray(scope.bootstrap);
    }
    depsTracker.registerNgModule(type, scope);
  });
}
function convertToTypeArray(values) {
  if (typeof values === 'function') {
    return values;
  }
  const flattenValues = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(values);
  if (flattenValues.some(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isForwardRef)) {
    return () => flattenValues.map(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef).map(maybeUnwrapModuleWithProviders);
  } else {
    return flattenValues.map(maybeUnwrapModuleWithProviders);
  }
}
function maybeUnwrapModuleWithProviders(value) {
  return isModuleWithProviders(value) ? value.ngModule : value;
}
function ɵɵpureFunction0(slotOffset, pureFn, thisArg) {
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)() + slotOffset;
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  return lView[bindingIndex] === NO_CHANGE ? updateBinding(lView, bindingIndex, thisArg ? pureFn.call(thisArg) : pureFn()) : getBinding(lView, bindingIndex);
}
function ɵɵpureFunction1(slotOffset, pureFn, exp, thisArg) {
  return pureFunction1Internal((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)(), slotOffset, pureFn, exp, thisArg);
}
function ɵɵpureFunction2(slotOffset, pureFn, exp1, exp2, thisArg) {
  return pureFunction2Internal((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)(), slotOffset, pureFn, exp1, exp2, thisArg);
}
function ɵɵpureFunction3(slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
  return pureFunction3Internal((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)(), slotOffset, pureFn, exp1, exp2, exp3, thisArg);
}
function ɵɵpureFunction4(slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
  return pureFunction4Internal((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)(), slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg);
}
function ɵɵpureFunction5(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, thisArg) {
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)() + slotOffset;
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated(lView, bindingIndex + 4, exp5) || different ? updateBinding(lView, bindingIndex + 5, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5) : pureFn(exp1, exp2, exp3, exp4, exp5)) : getBinding(lView, bindingIndex + 5);
}
function ɵɵpureFunction6(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, thisArg) {
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)() + slotOffset;
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated2(lView, bindingIndex + 4, exp5, exp6) || different ? updateBinding(lView, bindingIndex + 6, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6)) : getBinding(lView, bindingIndex + 6);
}
function ɵɵpureFunction7(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, thisArg) {
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)() + slotOffset;
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  let different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated3(lView, bindingIndex + 4, exp5, exp6, exp7) || different ? updateBinding(lView, bindingIndex + 7, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7)) : getBinding(lView, bindingIndex + 7);
}
function ɵɵpureFunction8(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, thisArg) {
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)() + slotOffset;
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated4(lView, bindingIndex + 4, exp5, exp6, exp7, exp8) || different ? updateBinding(lView, bindingIndex + 8, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)) : getBinding(lView, bindingIndex + 8);
}
function ɵɵpureFunctionV(slotOffset, pureFn, exps, thisArg) {
  return pureFunctionVInternal((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)(), slotOffset, pureFn, exps, thisArg);
}
function getPureFunctionReturnValue(lView, returnValueIndex) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, returnValueIndex);
  const lastReturnValue = lView[returnValueIndex];
  return lastReturnValue === NO_CHANGE ? undefined : lastReturnValue;
}
function pureFunction1Internal(lView, bindingRoot, slotOffset, pureFn, exp, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated(lView, bindingIndex, exp) ? updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) : getPureFunctionReturnValue(lView, bindingIndex + 1);
}
function pureFunction2Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated2(lView, bindingIndex, exp1, exp2) ? updateBinding(lView, bindingIndex + 2, thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) : getPureFunctionReturnValue(lView, bindingIndex + 2);
}
function pureFunction3Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) ? updateBinding(lView, bindingIndex + 3, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3)) : getPureFunctionReturnValue(lView, bindingIndex + 3);
}
function pureFunction4Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) ? updateBinding(lView, bindingIndex + 4, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) : pureFn(exp1, exp2, exp3, exp4)) : getPureFunctionReturnValue(lView, bindingIndex + 4);
}
function pureFunctionVInternal(lView, bindingRoot, slotOffset, pureFn, exps, thisArg) {
  let bindingIndex = bindingRoot + slotOffset;
  let different = false;
  for (let i = 0; i < exps.length; i++) {
    bindingUpdated(lView, bindingIndex++, exps[i]) && (different = true);
  }
  return different ? updateBinding(lView, bindingIndex, pureFn.apply(thisArg, exps)) : getPureFunctionReturnValue(lView, bindingIndex);
}
function ɵɵpipe(index, pipeName) {
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  let pipeDef;
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  if (tView.firstCreatePass) {
    pipeDef = getPipeDef(pipeName, tView.pipeRegistry);
    tView.data[adjustedIndex] = pipeDef;
    if (pipeDef.onDestroy) {
      (tView.destroyHooks ??= []).push(adjustedIndex, pipeDef.onDestroy);
    }
  } else {
    pipeDef = tView.data[adjustedIndex];
  }
  const pipeFactory = pipeDef.factory || (pipeDef.factory = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getFactoryDef)(pipeDef.type, true));
  let previousInjectorProfilerContext;
  if (ngDevMode) {
    previousInjectorProfilerContext = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInjectorProfilerContext)({
      injector: new NodeInjector((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)()),
      token: pipeDef.type
    });
  }
  const previousInjectImplementation = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInjectImplementation)(ɵɵdirectiveInject);
  try {
    const previousIncludeViewProviders = setIncludeViewProviders(false);
    const pipeInstance = pipeFactory();
    setIncludeViewProviders(previousIncludeViewProviders);
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.store)(tView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), adjustedIndex, pipeInstance);
    return pipeInstance;
  } finally {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInjectImplementation)(previousInjectImplementation);
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInjectorProfilerContext)(previousInjectorProfilerContext);
  }
}
function getPipeDef(name, registry) {
  if (registry) {
    if (ngDevMode) {
      const pipes = registry.filter(pipe => pipe.name === name);
      if (pipes.length > 1) {
        console.warn((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(313, getMultipleMatchingPipesMessage(name)));
      }
    }
    for (let i = registry.length - 1; i >= 0; i--) {
      const pipeDef = registry[i];
      if (name === pipeDef.name) {
        return pipeDef;
      }
    }
  }
  if (ngDevMode) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-302, getPipeNotFoundErrorMessage(name));
  }
  return;
}
function getMultipleMatchingPipesMessage(name) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const declarationLView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW];
  const context = declarationLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT];
  const hostIsStandalone = isHostComponentStandalone(lView);
  const componentInfoMessage = context ? ` in the '${context.constructor.name}' component` : '';
  const verifyMessage = `check ${hostIsStandalone ? "'@Component.imports' of this component" : 'the imports of this module'}`;
  const errorMessage = `Multiple pipes match the name \`${name}\`${componentInfoMessage}. ${verifyMessage}`;
  return errorMessage;
}
function getPipeNotFoundErrorMessage(name) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const declarationLView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW];
  const context = declarationLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT];
  const hostIsStandalone = isHostComponentStandalone(lView);
  const componentInfoMessage = context ? ` in the '${context.constructor.name}' component` : '';
  const verifyMessage = `Verify that it is ${hostIsStandalone ? "included in the '@Component.imports' of this component" : 'declared or imported in this module'}`;
  const errorMessage = `The pipe '${name}' could not be found${componentInfoMessage}. ${verifyMessage}`;
  return errorMessage;
}
function ɵɵpipeBind1(index, offset, v1) {
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const pipeInstance = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.load)(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction1Internal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)(), offset, pipeInstance.transform, v1, pipeInstance) : pipeInstance.transform(v1);
}
function ɵɵpipeBind2(index, slotOffset, v1, v2) {
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const pipeInstance = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.load)(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction2Internal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)(), slotOffset, pipeInstance.transform, v1, v2, pipeInstance) : pipeInstance.transform(v1, v2);
}
function ɵɵpipeBind3(index, slotOffset, v1, v2, v3) {
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const pipeInstance = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.load)(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction3Internal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)(), slotOffset, pipeInstance.transform, v1, v2, v3, pipeInstance) : pipeInstance.transform(v1, v2, v3);
}
function ɵɵpipeBind4(index, slotOffset, v1, v2, v3, v4) {
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const pipeInstance = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.load)(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction4Internal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)(), slotOffset, pipeInstance.transform, v1, v2, v3, v4, pipeInstance) : pipeInstance.transform(v1, v2, v3, v4);
}
function ɵɵpipeBindV(index, slotOffset, values) {
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const pipeInstance = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.load)(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunctionVInternal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)(), slotOffset, pipeInstance.transform, values, pipeInstance) : pipeInstance.transform.apply(pipeInstance, values);
}
function isPure(lView, index) {
  return lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data[index].pure;
}
function ɵɵtemplateRefExtractor(tNode, lView) {
  return createTemplateRef(tNode, lView);
}
function ɵɵgetComponentDepsFactory(type, rawImports) {
  return () => {
    try {
      return depsTracker.getComponentDependencies(type, rawImports).dependencies;
    } catch (e) {
      console.error(`Computing dependencies in local compilation mode for the component "${type.name}" failed with the exception:`, e);
      throw e;
    }
  };
}
function ɵsetClassDebugInfo(type, debugInfo) {
  const def = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type);
  if (def !== null) {
    def.debugInfo = debugInfo;
  }
}
function ɵɵgetReplaceMetadataURL(id, timestamp, base) {
  const url = `./@ng/component?c=${id}&t=${encodeURIComponent(timestamp)}`;
  return new URL(url, base).href;
}
function ɵɵreplaceMetadata(type, applyMetadata, namespaces, locals, importMeta = null, id = null) {
  ngDevMode && assertComponentDef(type);
  const currentDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type);
  applyMetadata.apply(null, [type, namespaces, ...locals]);
  const {
    newDef,
    oldDef
  } = mergeWithExistingDefinition(currentDef, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type));
  type[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_COMP_DEF] = newDef;
  if (oldDef.tView) {
    const trackedViews = getTrackedLViews().values();
    for (const root of trackedViews) {
      if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isRootView)(root) && root[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT] === null) {
        recreateMatchingLViews(importMeta, id, newDef, oldDef, root);
      }
    }
  }
}
function mergeWithExistingDefinition(currentDef, newDef) {
  const clone = {
    ...currentDef
  };
  const replacement = Object.assign(currentDef, newDef, {
    directiveDefs: clone.directiveDefs,
    pipeDefs: clone.pipeDefs,
    setInput: clone.setInput,
    type: clone.type
  });
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(replacement, currentDef, 'Expected definition to be merged in place');
  return {
    newDef: replacement,
    oldDef: clone
  };
}
function recreateMatchingLViews(importMeta, id, newDef, oldDef, rootLView) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(oldDef.tView, 'Expected a component definition that has been instantiated at least once');
  const tView = rootLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  if (tView === oldDef.tView) {
    ngDevMode && assertComponentDef(oldDef.type);
    recreateLView(importMeta, id, newDef, oldDef, rootLView);
    return;
  }
  for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    const current = rootLView[i];
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(current)) {
      if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(current[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST])) {
        recreateMatchingLViews(importMeta, id, newDef, oldDef, current[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST]);
      }
      for (let j = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET; j < current.length; j++) {
        recreateMatchingLViews(importMeta, id, newDef, oldDef, current[j]);
      }
    } else if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(current)) {
      recreateMatchingLViews(importMeta, id, newDef, oldDef, current);
    }
  }
}
function clearRendererCache(factory, def) {
  factory.componentReplaced?.(def.id);
}
function recreateLView(importMeta, id, newDef, oldDef, lView) {
  const instance = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT];
  let host = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST];
  const parentLView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLView)(parentLView);
  const tNode = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST];
  ngDevMode && assertTNodeType(tNode, 2);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotEqual)(newDef, oldDef, 'Expected different component definition');
  const zone = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1].get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone, null);
  const recreate = () => {
    if (oldDef.encapsulation === ViewEncapsulation.ShadowDom || oldDef.encapsulation === ViewEncapsulation.ExperimentalIsolatedShadowDom) {
      const newHost = host.cloneNode(false);
      host.replaceWith(newHost);
      host = newHost;
    }
    const newTView = getOrCreateComponentTView(newDef);
    const newLView = createLView(parentLView, newTView, instance, getInitialLViewFlagsFromDef(newDef), host, tNode, null, null, null, null, null);
    replaceLViewInTree(parentLView, lView, newLView, tNode.index);
    destroyLView(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], lView);
    const rendererFactory = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT].rendererFactory;
    clearRendererCache(rendererFactory, oldDef);
    newLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER] = rendererFactory.createRenderer(host, newDef);
    removeViewFromDOM(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], lView);
    resetProjectionState(tNode);
    renderView(newTView, newLView, instance);
    refreshView(newTView, newLView, newTView.template, instance);
  };
  if (zone === null) {
    executeWithInvalidateFallback(importMeta, id, recreate);
  } else {
    zone.run(() => executeWithInvalidateFallback(importMeta, id, recreate));
  }
}
function executeWithInvalidateFallback(importMeta, id, callback) {
  try {
    callback();
  } catch (e) {
    const error = e;
    if (id !== null && error.message) {
      const toLog = error.message + (error.stack ? '\n' + error.stack : '');
      importMeta?.hot?.send?.('angular:invalidate', {
        id,
        message: toLog,
        error: true
      });
    }
    throw e;
  }
}
function replaceLViewInTree(parentLView, oldLView, newLView, index) {
  for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET; i < parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].bindingStartIndex; i++) {
    const current = parentLView[i];
    if (((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(current) || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(current)) && current[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT] === oldLView) {
      current[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT] = newLView;
      break;
    }
  }
  if (parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CHILD_HEAD] === oldLView) {
    parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CHILD_HEAD] = newLView;
  }
  if (parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CHILD_TAIL] === oldLView) {
    parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CHILD_TAIL] = newLView;
  }
  newLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT] = oldLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT];
  oldLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT] = null;
  parentLView[index] = newLView;
}
function resetProjectionState(tNode) {
  if (tNode.projection !== null) {
    for (const current of tNode.projection) {
      if (isTNodeShape(current)) {
        current.projectionNext = null;
        current.flags &= ~2;
      }
    }
    tNode.projection = null;
  }
}
const angularCoreEnv = (() => ({
  'ɵɵanimateEnter': ɵɵanimateEnter,
  'ɵɵanimateEnterListener': ɵɵanimateEnterListener,
  'ɵɵanimateLeave': ɵɵanimateLeave,
  'ɵɵanimateLeaveListener': ɵɵanimateLeaveListener,
  'ɵɵattribute': ɵɵattribute,
  'ɵɵdefineComponent': ɵɵdefineComponent,
  'ɵɵdefineDirective': ɵɵdefineDirective,
  'ɵɵdefineInjectable': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"],
  'ɵɵdefineInjector': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"],
  'ɵɵdefineNgModule': ɵɵdefineNgModule,
  'ɵɵdefinePipe': ɵɵdefinePipe,
  'ɵɵdirectiveInject': ɵɵdirectiveInject,
  'ɵɵgetInheritedFactory': ɵɵgetInheritedFactory,
  'ɵɵinject': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"],
  'ɵɵinjectAttribute': ɵɵinjectAttribute,
  'ɵɵinvalidFactory': ɵɵinvalidFactory,
  'ɵɵinvalidFactoryDep': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵinvalidFactoryDep"],
  'ɵɵtemplateRefExtractor': ɵɵtemplateRefExtractor,
  'ɵɵresetView': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵresetView"],
  'ɵɵHostDirectivesFeature': ɵɵHostDirectivesFeature,
  'ɵɵNgOnChangesFeature': ɵɵNgOnChangesFeature,
  'ɵɵProvidersFeature': ɵɵProvidersFeature,
  'ɵɵInheritDefinitionFeature': ɵɵInheritDefinitionFeature,
  'ɵɵExternalStylesFeature': ɵɵExternalStylesFeature,
  'ɵɵnextContext': ɵɵnextContext,
  'ɵɵnamespaceHTML': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵnamespaceHTML"],
  'ɵɵnamespaceMathML': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵnamespaceMathML"],
  'ɵɵnamespaceSVG': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵnamespaceSVG"],
  'ɵɵenableBindings': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵenableBindings"],
  'ɵɵdisableBindings': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdisableBindings"],
  'ɵɵelementStart': ɵɵelementStart,
  'ɵɵelementEnd': ɵɵelementEnd,
  'ɵɵelement': ɵɵelement,
  'ɵɵelementContainerStart': ɵɵelementContainerStart,
  'ɵɵelementContainerEnd': ɵɵelementContainerEnd,
  'ɵɵdomElement': ɵɵdomElement,
  'ɵɵdomElementStart': ɵɵdomElementStart,
  'ɵɵdomElementEnd': ɵɵdomElementEnd,
  'ɵɵdomElementContainer': ɵɵdomElementContainer,
  'ɵɵdomElementContainerStart': ɵɵdomElementContainerStart,
  'ɵɵdomElementContainerEnd': ɵɵdomElementContainerEnd,
  'ɵɵdomTemplate': ɵɵdomTemplate,
  'ɵɵdomListener': ɵɵdomListener,
  'ɵɵelementContainer': ɵɵelementContainer,
  'ɵɵpureFunction0': ɵɵpureFunction0,
  'ɵɵpureFunction1': ɵɵpureFunction1,
  'ɵɵpureFunction2': ɵɵpureFunction2,
  'ɵɵpureFunction3': ɵɵpureFunction3,
  'ɵɵpureFunction4': ɵɵpureFunction4,
  'ɵɵpureFunction5': ɵɵpureFunction5,
  'ɵɵpureFunction6': ɵɵpureFunction6,
  'ɵɵpureFunction7': ɵɵpureFunction7,
  'ɵɵpureFunction8': ɵɵpureFunction8,
  'ɵɵpureFunctionV': ɵɵpureFunctionV,
  'ɵɵgetCurrentView': ɵɵgetCurrentView,
  'ɵɵrestoreView': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵrestoreView"],
  'ɵɵlistener': ɵɵlistener,
  'ɵɵprojection': ɵɵprojection,
  'ɵɵsyntheticHostProperty': ɵɵsyntheticHostProperty,
  'ɵɵsyntheticHostListener': ɵɵsyntheticHostListener,
  'ɵɵpipeBind1': ɵɵpipeBind1,
  'ɵɵpipeBind2': ɵɵpipeBind2,
  'ɵɵpipeBind3': ɵɵpipeBind3,
  'ɵɵpipeBind4': ɵɵpipeBind4,
  'ɵɵpipeBindV': ɵɵpipeBindV,
  'ɵɵprojectionDef': ɵɵprojectionDef,
  'ɵɵdomProperty': ɵɵdomProperty,
  'ɵɵariaProperty': ɵɵariaProperty,
  'ɵɵproperty': ɵɵproperty,
  'ɵɵcontrol': ɵɵcontrol,
  'ɵɵcontrolCreate': ɵɵcontrolCreate,
  'ɵɵpipe': ɵɵpipe,
  'ɵɵqueryRefresh': ɵɵqueryRefresh,
  'ɵɵqueryAdvance': ɵɵqueryAdvance,
  'ɵɵviewQuery': ɵɵviewQuery,
  'ɵɵviewQuerySignal': ɵɵviewQuerySignal,
  'ɵɵloadQuery': ɵɵloadQuery,
  'ɵɵcontentQuery': ɵɵcontentQuery,
  'ɵɵcontentQuerySignal': ɵɵcontentQuerySignal,
  'ɵɵreference': ɵɵreference,
  'ɵɵclassMap': ɵɵclassMap,
  'ɵɵstyleMap': ɵɵstyleMap,
  'ɵɵstyleProp': ɵɵstyleProp,
  'ɵɵclassProp': ɵɵclassProp,
  'ɵɵadvance': ɵɵadvance,
  'ɵɵtemplate': ɵɵtemplate,
  'ɵɵconditional': ɵɵconditional,
  'ɵɵconditionalCreate': ɵɵconditionalCreate,
  'ɵɵconditionalBranchCreate': ɵɵconditionalBranchCreate,
  'ɵɵdefer': ɵɵdefer,
  'ɵɵdeferWhen': ɵɵdeferWhen,
  'ɵɵdeferOnIdle': ɵɵdeferOnIdle,
  'ɵɵdeferOnImmediate': ɵɵdeferOnImmediate,
  'ɵɵdeferOnTimer': ɵɵdeferOnTimer,
  'ɵɵdeferOnHover': ɵɵdeferOnHover,
  'ɵɵdeferOnInteraction': ɵɵdeferOnInteraction,
  'ɵɵdeferOnViewport': ɵɵdeferOnViewport,
  'ɵɵdeferPrefetchWhen': ɵɵdeferPrefetchWhen,
  'ɵɵdeferPrefetchOnIdle': ɵɵdeferPrefetchOnIdle,
  'ɵɵdeferPrefetchOnImmediate': ɵɵdeferPrefetchOnImmediate,
  'ɵɵdeferPrefetchOnTimer': ɵɵdeferPrefetchOnTimer,
  'ɵɵdeferPrefetchOnHover': ɵɵdeferPrefetchOnHover,
  'ɵɵdeferPrefetchOnInteraction': ɵɵdeferPrefetchOnInteraction,
  'ɵɵdeferPrefetchOnViewport': ɵɵdeferPrefetchOnViewport,
  'ɵɵdeferHydrateWhen': ɵɵdeferHydrateWhen,
  'ɵɵdeferHydrateNever': ɵɵdeferHydrateNever,
  'ɵɵdeferHydrateOnIdle': ɵɵdeferHydrateOnIdle,
  'ɵɵdeferHydrateOnImmediate': ɵɵdeferHydrateOnImmediate,
  'ɵɵdeferHydrateOnTimer': ɵɵdeferHydrateOnTimer,
  'ɵɵdeferHydrateOnHover': ɵɵdeferHydrateOnHover,
  'ɵɵdeferHydrateOnInteraction': ɵɵdeferHydrateOnInteraction,
  'ɵɵdeferHydrateOnViewport': ɵɵdeferHydrateOnViewport,
  'ɵɵdeferEnableTimerScheduling': ɵɵdeferEnableTimerScheduling,
  'ɵɵrepeater': ɵɵrepeater,
  'ɵɵrepeaterCreate': ɵɵrepeaterCreate,
  'ɵɵrepeaterTrackByIndex': ɵɵrepeaterTrackByIndex,
  'ɵɵrepeaterTrackByIdentity': ɵɵrepeaterTrackByIdentity,
  'ɵɵcomponentInstance': ɵɵcomponentInstance,
  'ɵɵtext': ɵɵtext,
  'ɵɵtextInterpolate': ɵɵtextInterpolate,
  'ɵɵtextInterpolate1': ɵɵtextInterpolate1,
  'ɵɵtextInterpolate2': ɵɵtextInterpolate2,
  'ɵɵtextInterpolate3': ɵɵtextInterpolate3,
  'ɵɵtextInterpolate4': ɵɵtextInterpolate4,
  'ɵɵtextInterpolate5': ɵɵtextInterpolate5,
  'ɵɵtextInterpolate6': ɵɵtextInterpolate6,
  'ɵɵtextInterpolate7': ɵɵtextInterpolate7,
  'ɵɵtextInterpolate8': ɵɵtextInterpolate8,
  'ɵɵtextInterpolateV': ɵɵtextInterpolateV,
  'ɵɵi18n': ɵɵi18n,
  'ɵɵi18nAttributes': ɵɵi18nAttributes,
  'ɵɵi18nExp': ɵɵi18nExp,
  'ɵɵi18nStart': ɵɵi18nStart,
  'ɵɵi18nEnd': ɵɵi18nEnd,
  'ɵɵi18nApply': ɵɵi18nApply,
  'ɵɵi18nPostprocess': ɵɵi18nPostprocess,
  'ɵɵresolveWindow': ɵɵresolveWindow,
  'ɵɵresolveDocument': ɵɵresolveDocument,
  'ɵɵresolveBody': ɵɵresolveBody,
  'ɵɵsetComponentScope': ɵɵsetComponentScope,
  'ɵɵsetNgModuleScope': ɵɵsetNgModuleScope,
  'ɵɵregisterNgModuleType': registerNgModuleType,
  'ɵɵgetComponentDepsFactory': ɵɵgetComponentDepsFactory,
  'ɵsetClassDebugInfo': ɵsetClassDebugInfo,
  'ɵɵdeclareLet': ɵɵdeclareLet,
  'ɵɵstoreLet': ɵɵstoreLet,
  'ɵɵreadContextLet': ɵɵreadContextLet,
  'ɵɵattachSourceLocations': ɵɵattachSourceLocations,
  'ɵɵinterpolate': ɵɵinterpolate,
  'ɵɵinterpolate1': ɵɵinterpolate1,
  'ɵɵinterpolate2': ɵɵinterpolate2,
  'ɵɵinterpolate3': ɵɵinterpolate3,
  'ɵɵinterpolate4': ɵɵinterpolate4,
  'ɵɵinterpolate5': ɵɵinterpolate5,
  'ɵɵinterpolate6': ɵɵinterpolate6,
  'ɵɵinterpolate7': ɵɵinterpolate7,
  'ɵɵinterpolate8': ɵɵinterpolate8,
  'ɵɵinterpolateV': ɵɵinterpolateV,
  'ɵɵsanitizeHtml': ɵɵsanitizeHtml,
  'ɵɵsanitizeStyle': ɵɵsanitizeStyle,
  'ɵɵsanitizeResourceUrl': ɵɵsanitizeResourceUrl,
  'ɵɵsanitizeScript': ɵɵsanitizeScript,
  'ɵɵvalidateAttribute': ɵɵvalidateAttribute,
  'ɵɵsanitizeUrl': ɵɵsanitizeUrl,
  'ɵɵsanitizeUrlOrResourceUrl': ɵɵsanitizeUrlOrResourceUrl,
  'ɵɵtrustConstantHtml': ɵɵtrustConstantHtml,
  'ɵɵtrustConstantResourceUrl': ɵɵtrustConstantResourceUrl,
  'forwardRef': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.forwardRef,
  'resolveForwardRef': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef,
  'ɵɵtwoWayProperty': ɵɵtwoWayProperty,
  'ɵɵtwoWayBindingSet': ɵɵtwoWayBindingSet,
  'ɵɵtwoWayListener': ɵɵtwoWayListener,
  'ɵɵreplaceMetadata': ɵɵreplaceMetadata,
  'ɵɵgetReplaceMetadataURL': ɵɵgetReplaceMetadataURL
}))();
let jitOptions = null;
function setJitOptions(options) {
  if (jitOptions !== null) {
    if (options.defaultEncapsulation !== jitOptions.defaultEncapsulation) {
      ngDevMode && console.error('Provided value for `defaultEncapsulation` can not be changed once it has been set.');
      return;
    }
    if (options.preserveWhitespaces !== jitOptions.preserveWhitespaces) {
      ngDevMode && console.error('Provided value for `preserveWhitespaces` can not be changed once it has been set.');
      return;
    }
  }
  jitOptions = options;
}
function getJitOptions() {
  return jitOptions;
}
function resetJitOptions() {
  jitOptions = null;
}
const moduleQueue = [];
function enqueueModuleForDelayedScoping(moduleType, ngModule) {
  moduleQueue.push({
    moduleType,
    ngModule
  });
}
let flushingModuleQueue = false;
function flushModuleScopingQueueAsMuchAsPossible() {
  if (!flushingModuleQueue) {
    flushingModuleQueue = true;
    try {
      for (let i = moduleQueue.length - 1; i >= 0; i--) {
        const {
          moduleType,
          ngModule
        } = moduleQueue[i];
        if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {
          moduleQueue.splice(i, 1);
          setScopeOnDeclaredComponents(moduleType, ngModule);
        }
      }
    } finally {
      flushingModuleQueue = false;
    }
  }
}
function isResolvedDeclaration(declaration) {
  if (Array.isArray(declaration)) {
    return declaration.every(isResolvedDeclaration);
  }
  return !!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(declaration);
}
function compileNgModule(moduleType, ngModule = {}) {
  compileNgModuleDefs(moduleType, ngModule);
  if (ngModule.id !== undefined) {
    registerNgModuleType(moduleType, ngModule.id);
  }
  enqueueModuleForDelayedScoping(moduleType, ngModule);
}
function compileNgModuleDefs(moduleType, ngModule, allowDuplicateDeclarationsInRoot = false) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(moduleType, 'Required value moduleType');
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(ngModule, 'Required value ngModule');
  const declarations = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(ngModule.declarations || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY);
  let ngModuleDef = null;
  Object.defineProperty(moduleType, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_MOD_DEF, {
    configurable: true,
    get: () => {
      if (ngModuleDef === null) {
        if (ngDevMode && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) {
          throw new Error(`'${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(moduleType)}' module can't import itself`);
        }
        const compiler = getCompilerFacade({
          usage: 0,
          kind: 'NgModule',
          type: moduleType
        });
        ngModuleDef = compiler.compileNgModule(angularCoreEnv, `ng:///${moduleType.name}/ɵmod.js`, {
          type: moduleType,
          bootstrap: (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(ngModule.bootstrap || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY).map(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef),
          declarations: declarations.map(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef),
          imports: (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(ngModule.imports || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY).map(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef).map(expandModuleWithProviders),
          exports: (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(ngModule.exports || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY).map(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef).map(expandModuleWithProviders),
          schemas: ngModule.schemas ? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(ngModule.schemas) : null,
          id: ngModule.id || null
        });
        if (!ngModuleDef.schemas) {
          ngModuleDef.schemas = [];
        }
      }
      return ngModuleDef;
    }
  });
  let ngFactoryDef = null;
  Object.defineProperty(moduleType, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const compiler = getCompilerFacade({
          usage: 0,
          kind: 'NgModule',
          type: moduleType
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${moduleType.name}/ɵfac.js`, {
          name: moduleType.name,
          type: moduleType,
          deps: reflectDependencies(moduleType),
          target: compiler.FactoryTarget.NgModule,
          typeArgumentCount: 0
        });
      }
      return ngFactoryDef;
    },
    configurable: !!ngDevMode
  });
  let ngInjectorDef = null;
  Object.defineProperty(moduleType, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_INJ_DEF, {
    get: () => {
      if (ngInjectorDef === null) {
        ngDevMode && verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot);
        const meta = {
          name: moduleType.name,
          type: moduleType,
          providers: ngModule.providers || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY,
          imports: [(ngModule.imports || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY).map(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef), (ngModule.exports || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY).map(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)]
        };
        const compiler = getCompilerFacade({
          usage: 0,
          kind: 'NgModule',
          type: moduleType
        });
        ngInjectorDef = compiler.compileInjector(angularCoreEnv, `ng:///${moduleType.name}/ɵinj.js`, meta);
      }
      return ngInjectorDef;
    },
    configurable: !!ngDevMode
  });
}
function generateStandaloneInDeclarationsError(type, location) {
  const prefix = `Unexpected "${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)}" found in the "declarations" array of the`;
  const suffix = `"${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)}" is marked as standalone and can't be declared ` + 'in any NgModule - did you intend to import it instead (by adding it to the "imports" array)?';
  return `${prefix} ${location}, ${suffix}`;
}
function verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot, importingModule) {
  if (verifiedNgModule.get(moduleType)) return;
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isStandalone)(moduleType)) return;
  verifiedNgModule.set(moduleType, true);
  moduleType = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(moduleType);
  let ngModuleDef;
  if (importingModule) {
    ngModuleDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNgModuleDef)(moduleType);
    if (!ngModuleDef) {
      throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);
    }
  } else {
    ngModuleDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNgModuleDefOrThrow)(moduleType);
  }
  const errors = [];
  const declarations = maybeUnwrapFn(ngModuleDef.declarations);
  const imports = maybeUnwrapFn(ngModuleDef.imports);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(imports).map(unwrapModuleWithProvidersImports).forEach(modOrStandaloneCmpt => {
    verifySemanticsOfNgModuleImport(modOrStandaloneCmpt, moduleType);
    verifySemanticsOfNgModuleDef(modOrStandaloneCmpt, false, moduleType);
  });
  const exports = maybeUnwrapFn(ngModuleDef.exports);
  declarations.forEach(verifyDeclarationsHaveDefinitions);
  declarations.forEach(verifyDirectivesHaveSelector);
  declarations.forEach(declarationType => verifyNotStandalone(declarationType, moduleType));
  const combinedDeclarations = [...declarations.map(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef), ...(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(imports.map(computeCombinedExports)).map(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)];
  exports.forEach(verifyExportsAreDeclaredOrReExported);
  declarations.forEach(decl => verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));
  const ngModule = getAnnotation(moduleType, 'NgModule');
  if (ngModule) {
    ngModule.imports && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach(mod => {
      verifySemanticsOfNgModuleImport(mod, moduleType);
      verifySemanticsOfNgModuleDef(mod, false, moduleType);
    });
    ngModule.bootstrap && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.deepForEach)(ngModule.bootstrap, verifyCorrectBootstrapType);
    ngModule.bootstrap && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.deepForEach)(ngModule.bootstrap, verifyComponentIsPartOfNgModule);
  }
  if (errors.length) {
    throw new Error(errors.join('\n'));
  }
  function verifyDeclarationsHaveDefinitions(type) {
    type = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(type);
    const def = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type) || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(type) || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getPipeDef)(type);
    if (!def) {
      errors.push(`Unexpected value '${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)}' declared by the module '${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`);
    }
  }
  function verifyDirectivesHaveSelector(type) {
    type = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(type);
    const def = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(type);
    if (!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type) && def && def.selectors.length == 0) {
      errors.push(`Directive ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)} has no selector, please add it!`);
    }
  }
  function verifyNotStandalone(type, moduleType) {
    type = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(type);
    const def = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type) || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(type) || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getPipeDef)(type);
    if (def?.standalone) {
      const location = `"${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(moduleType)}" NgModule`;
      errors.push(generateStandaloneInDeclarationsError(type, location));
    }
  }
  function verifyExportsAreDeclaredOrReExported(type) {
    type = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(type);
    const kind = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type) && 'component' || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(type) && 'directive' || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getPipeDef)(type) && 'pipe';
    if (kind) {
      if (combinedDeclarations.lastIndexOf(type) === -1) {
        errors.push(`Can't export ${kind} ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)} from ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(moduleType)} as it was neither declared nor imported!`);
      }
    }
  }
  function verifyDeclarationIsUnique(type, suppressErrors) {
    type = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(type);
    const existingModule = ownerNgModule.get(type);
    if (existingModule && existingModule !== moduleType) {
      if (!suppressErrors) {
        const modules = [existingModule, moduleType].map(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError).sort();
        errors.push(`Type ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)} is part of the declarations of 2 modules: ${modules[0]} and ${modules[1]}! ` + `Please consider moving ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)} to a higher module that imports ${modules[0]} and ${modules[1]}. ` + `You can also create a new NgModule that exports and includes ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)} then import that NgModule in ${modules[0]} and ${modules[1]}.`);
      }
    } else {
      ownerNgModule.set(type, moduleType);
    }
  }
  function verifyComponentIsPartOfNgModule(type) {
    type = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(type);
    const existingModule = ownerNgModule.get(type);
    if (!existingModule && !(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isStandalone)(type)) {
      errors.push(`Component ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)} is not part of any NgModule or the module has not been imported into your module.`);
    }
  }
  function verifyCorrectBootstrapType(type) {
    type = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(type);
    if (!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type)) {
      errors.push(`${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)} cannot be used as an entry component.`);
    }
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isStandalone)(type)) {
      errors.push(`The \`${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)}\` class is a standalone component, which can ` + `not be used in the \`@NgModule.bootstrap\` array. Use the \`bootstrapApplication\` ` + `function for bootstrap instead.`);
    }
  }
  function verifySemanticsOfNgModuleImport(type, importingModule) {
    type = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(type);
    const directiveDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type) || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(type);
    if (directiveDef !== null && !directiveDef.standalone) {
      throw new Error(`Unexpected directive '${type.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);
    }
    const pipeDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getPipeDef)(type);
    if (pipeDef !== null && !pipeDef.standalone) {
      throw new Error(`Unexpected pipe '${type.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);
    }
  }
}
function unwrapModuleWithProvidersImports(typeOrWithProviders) {
  typeOrWithProviders = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(typeOrWithProviders);
  return typeOrWithProviders.ngModule || typeOrWithProviders;
}
function getAnnotation(type, name) {
  let annotation = null;
  collect(type.__annotations__);
  collect(type.decorators);
  return annotation;
  function collect(annotations) {
    if (annotations) {
      annotations.forEach(readAnnotation);
    }
  }
  function readAnnotation(decorator) {
    if (!annotation) {
      const proto = Object.getPrototypeOf(decorator);
      if (proto.ngMetadataName == name) {
        annotation = decorator;
      } else if (decorator.type) {
        const proto = Object.getPrototypeOf(decorator.type);
        if (proto.ngMetadataName == name) {
          annotation = decorator.args[0];
        }
      }
    }
  }
}
let ownerNgModule = new WeakMap();
let verifiedNgModule = new WeakMap();
function resetCompiledComponents() {
  ownerNgModule = new WeakMap();
  verifiedNgModule = new WeakMap();
  moduleQueue.length = 0;
  GENERATED_COMP_IDS.clear();
}
function computeCombinedExports(type) {
  type = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(type);
  const ngModuleDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNgModuleDef)(type);
  if (ngModuleDef === null) {
    return [type];
  }
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(maybeUnwrapFn(ngModuleDef.exports).map(type => {
    const ngModuleDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNgModuleDef)(type);
    if (ngModuleDef) {
      verifySemanticsOfNgModuleDef(type, false);
      return computeCombinedExports(type);
    } else {
      return type;
    }
  }));
}
function setScopeOnDeclaredComponents(moduleType, ngModule) {
  const declarations = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(ngModule.declarations || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY);
  const transitiveScopes = transitiveScopesFor(moduleType);
  declarations.forEach(declaration => {
    declaration = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(declaration);
    if (declaration.hasOwnProperty(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_COMP_DEF)) {
      const component = declaration;
      const componentDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(component);
      patchComponentDefWithScope(componentDef, transitiveScopes);
    } else if (!declaration.hasOwnProperty(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_DIR_DEF) && !declaration.hasOwnProperty(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_PIPE_DEF)) {
      declaration.ngSelectorScope = moduleType;
    }
  });
}
function patchComponentDefWithScope(componentDef, transitiveScopes) {
  componentDef.directiveDefs = () => Array.from(transitiveScopes.compilation.directives).map(dir => dir.hasOwnProperty(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_COMP_DEF) ? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(dir) : (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(dir)).filter(def => !!def);
  componentDef.pipeDefs = () => Array.from(transitiveScopes.compilation.pipes).map(pipe => (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getPipeDef)(pipe));
  componentDef.schemas = transitiveScopes.schemas;
  componentDef.tView = null;
}
function transitiveScopesFor(type) {
  if (isNgModule(type)) {
    const scope = depsTracker.getNgModuleScope(type);
    const def = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNgModuleDefOrThrow)(type);
    return {
      schemas: def.schemas || null,
      ...scope
    };
  } else if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isStandalone)(type)) {
    const directiveDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type) || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(type);
    if (directiveDef !== null) {
      return {
        schemas: null,
        compilation: {
          directives: new Set(),
          pipes: new Set()
        },
        exported: {
          directives: new Set([type]),
          pipes: new Set()
        }
      };
    }
    const pipeDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getPipeDef)(type);
    if (pipeDef !== null) {
      return {
        schemas: null,
        compilation: {
          directives: new Set(),
          pipes: new Set()
        },
        exported: {
          directives: new Set(),
          pipes: new Set([type])
        }
      };
    }
  }
  throw new Error(`${type.name} does not have a module def (ɵmod property)`);
}
function expandModuleWithProviders(value) {
  if (isModuleWithProviders(value)) {
    return value.ngModule;
  }
  return value;
}
let compilationDepth = 0;
function compileComponent(type, metadata) {
  (typeof ngDevMode === 'undefined' || ngDevMode) && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.initNgDevMode)();
  let ngComponentDef = null;
  maybeQueueResolutionOfComponentResources(type, metadata);
  addDirectiveFactoryDef(type, metadata);
  Object.defineProperty(type, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_COMP_DEF, {
    get: () => {
      if (ngComponentDef === null) {
        const compiler = getCompilerFacade({
          usage: 0,
          kind: 'component',
          type: type
        });
        if (componentNeedsResolution(metadata)) {
          const error = [`Component '${type.name}' is not resolved:`];
          if (metadata.templateUrl) {
            error.push(` - templateUrl: ${metadata.templateUrl}`);
          }
          if (metadata.styleUrls && metadata.styleUrls.length) {
            error.push(` - styleUrls: ${JSON.stringify(metadata.styleUrls)}`);
          }
          if (metadata.styleUrl) {
            error.push(` - styleUrl: ${metadata.styleUrl}`);
          }
          error.push(`Did you run and wait for 'resolveComponentResources()'?`);
          throw new Error(error.join('\n'));
        }
        const options = getJitOptions();
        let preserveWhitespaces = metadata.preserveWhitespaces;
        if (preserveWhitespaces === undefined) {
          if (options !== null && options.preserveWhitespaces !== undefined) {
            preserveWhitespaces = options.preserveWhitespaces;
          } else {
            preserveWhitespaces = false;
          }
        }
        let encapsulation = metadata.encapsulation;
        if (encapsulation === undefined) {
          if (options !== null && options.defaultEncapsulation !== undefined) {
            encapsulation = options.defaultEncapsulation;
          } else {
            encapsulation = ViewEncapsulation.Emulated;
          }
        }
        const templateUrl = metadata.templateUrl || `ng:///${type.name}/template.html`;
        const baseMeta = directiveMetadata(type, metadata);
        const meta = {
          ...baseMeta,
          typeSourceSpan: compiler.createParseSourceSpan('Component', type.name, templateUrl),
          template: metadata.template || '',
          preserveWhitespaces,
          styles: typeof metadata.styles === 'string' ? [metadata.styles] : metadata.styles || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY,
          animations: metadata.animations,
          declarations: [],
          changeDetection: metadata.changeDetection,
          encapsulation,
          viewProviders: metadata.viewProviders || null,
          hasDirectiveDependencies: !baseMeta.isStandalone || metadata.imports != null && metadata.imports.length > 0
        };
        compilationDepth++;
        try {
          if (meta.usesInheritance) {
            addDirectiveDefToUndecoratedParents(type);
          }
          ngComponentDef = compiler.compileComponent(angularCoreEnv, templateUrl, meta);
          if (meta.isStandalone) {
            const imports = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(metadata.imports || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY);
            const {
              directiveDefs,
              pipeDefs
            } = getStandaloneDefFunctions(type, imports);
            ngComponentDef.directiveDefs = directiveDefs;
            ngComponentDef.pipeDefs = pipeDefs;
            ngComponentDef.dependencies = () => imports.map(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef);
          }
        } finally {
          compilationDepth--;
        }
        if (compilationDepth === 0) {
          flushModuleScopingQueueAsMuchAsPossible();
        }
        if (hasSelectorScope(type)) {
          const scopes = transitiveScopesFor(type.ngSelectorScope);
          patchComponentDefWithScope(ngComponentDef, scopes);
        }
        if (metadata.schemas) {
          if (meta.isStandalone) {
            ngComponentDef.schemas = metadata.schemas;
          } else {
            throw new Error(`The 'schemas' was specified for the ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)} but is only valid on a component that is standalone.`);
          }
        } else if (meta.isStandalone) {
          ngComponentDef.schemas = [];
        }
      }
      return ngComponentDef;
    },
    set: def => {
      ngComponentDef = def;
    },
    configurable: !!ngDevMode
  });
}
function getStandaloneDefFunctions(type, imports) {
  const directiveDefs = () => {
    if (ngDevMode) {
      for (const rawDep of imports) {
        verifyStandaloneImport(rawDep, type);
      }
    }
    if (!isComponent(type)) {
      return [];
    }
    const scope = depsTracker.getStandaloneComponentScope(type, imports);
    return [...scope.compilation.directives].map(p => (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(p) || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(p)).filter(d => d !== null);
  };
  const pipeDefs = () => {
    if (ngDevMode) {
      for (const rawDep of imports) {
        verifyStandaloneImport(rawDep, type);
      }
    }
    if (!isComponent(type)) {
      return [];
    }
    const scope = depsTracker.getStandaloneComponentScope(type, imports);
    return [...scope.compilation.pipes].map(p => (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getPipeDef)(p)).filter(d => d !== null);
  };
  return {
    directiveDefs,
    pipeDefs
  };
}
function hasSelectorScope(component) {
  return component.ngSelectorScope !== undefined;
}
function compileDirective(type, directive) {
  let ngDirectiveDef = null;
  addDirectiveFactoryDef(type, directive || {});
  Object.defineProperty(type, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_DIR_DEF, {
    get: () => {
      if (ngDirectiveDef === null) {
        const meta = getDirectiveMetadata(type, directive || {});
        const compiler = getCompilerFacade({
          usage: 0,
          kind: 'directive',
          type
        });
        ngDirectiveDef = compiler.compileDirective(angularCoreEnv, meta.sourceMapUrl, meta.metadata);
      }
      return ngDirectiveDef;
    },
    configurable: !!ngDevMode
  });
}
function getDirectiveMetadata(type, metadata) {
  const name = type && type.name;
  const sourceMapUrl = `ng:///${name}/ɵdir.js`;
  const compiler = getCompilerFacade({
    usage: 0,
    kind: 'directive',
    type
  });
  const facade = directiveMetadata(type, metadata);
  facade.typeSourceSpan = compiler.createParseSourceSpan('Directive', name, sourceMapUrl);
  if (facade.usesInheritance) {
    addDirectiveDefToUndecoratedParents(type);
  }
  return {
    metadata: facade,
    sourceMapUrl
  };
}
function addDirectiveFactoryDef(type, metadata) {
  let ngFactoryDef = null;
  Object.defineProperty(type, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const meta = getDirectiveMetadata(type, metadata);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: 'directive',
          type
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${type.name}/ɵfac.js`, {
          name: meta.metadata.name,
          type: meta.metadata.type,
          typeArgumentCount: 0,
          deps: reflectDependencies(type),
          target: compiler.FactoryTarget.Directive
        });
      }
      return ngFactoryDef;
    },
    configurable: !!ngDevMode
  });
}
function extendsDirectlyFromObject(type) {
  return Object.getPrototypeOf(type.prototype) === Object.prototype;
}
function directiveMetadata(type, metadata) {
  const reflect = getReflect();
  const propMetadata = reflect.ownPropMetadata(type);
  return {
    name: type.name,
    type: type,
    selector: metadata.selector !== undefined ? metadata.selector : null,
    host: metadata.host || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    propMetadata: propMetadata,
    inputs: metadata.inputs || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY,
    outputs: metadata.outputs || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY,
    queries: extractQueriesMetadata(type, propMetadata, isContentQuery),
    lifecycle: {
      usesOnChanges: reflect.hasLifecycleHook(type, 'ngOnChanges')
    },
    typeSourceSpan: null,
    usesInheritance: !extendsDirectlyFromObject(type),
    exportAs: extractExportAs(metadata.exportAs),
    providers: metadata.providers || null,
    viewQueries: extractQueriesMetadata(type, propMetadata, isViewQuery),
    isStandalone: metadata.standalone === undefined ? true : !!metadata.standalone,
    isSignal: !!metadata.signals,
    hostDirectives: metadata.hostDirectives?.map(directive => typeof directive === 'function' ? {
      directive
    } : directive) || null
  };
}
function addDirectiveDefToUndecoratedParents(type) {
  const objPrototype = Object.prototype;
  let parent = Object.getPrototypeOf(type.prototype).constructor;
  while (parent && parent !== objPrototype) {
    if (!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(parent) && !(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(parent) && shouldAddAbstractDirective(parent)) {
      compileDirective(parent, null);
    }
    parent = Object.getPrototypeOf(parent);
  }
}
function convertToR3QueryPredicate(selector) {
  return typeof selector === 'string' ? splitByComma(selector) : (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(selector);
}
function convertToR3QueryMetadata(propertyName, ann) {
  return {
    propertyName: propertyName,
    predicate: convertToR3QueryPredicate(ann.selector),
    descendants: ann.descendants,
    first: ann.first,
    read: ann.read ? ann.read : null,
    static: !!ann.static,
    emitDistinctChangesOnly: !!ann.emitDistinctChangesOnly,
    isSignal: !!ann.isSignal
  };
}
function extractQueriesMetadata(type, propMetadata, isQueryAnn) {
  const queriesMeta = [];
  for (const field in propMetadata) {
    if (propMetadata.hasOwnProperty(field)) {
      const annotations = propMetadata[field];
      annotations.forEach(ann => {
        if (isQueryAnn(ann)) {
          if (!ann.selector) {
            throw new Error(`Can't construct a query for the property "${field}" of ` + `"${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)}" since the query selector wasn't defined.`);
          }
          if (annotations.some(isInputAnnotation)) {
            throw new Error(`Cannot combine @Input decorators with query decorators`);
          }
          queriesMeta.push(convertToR3QueryMetadata(field, ann));
        }
      });
    }
  }
  return queriesMeta;
}
function extractExportAs(exportAs) {
  return exportAs === undefined ? null : splitByComma(exportAs);
}
function isContentQuery(value) {
  const name = value.ngMetadataName;
  return name === 'ContentChild' || name === 'ContentChildren';
}
function isViewQuery(value) {
  const name = value.ngMetadataName;
  return name === 'ViewChild' || name === 'ViewChildren';
}
function isInputAnnotation(value) {
  return value.ngMetadataName === 'Input';
}
function splitByComma(value) {
  return value.split(',').map(piece => piece.trim());
}
const LIFECYCLE_HOOKS = ['ngOnChanges', 'ngOnInit', 'ngOnDestroy', 'ngDoCheck', 'ngAfterViewInit', 'ngAfterViewChecked', 'ngAfterContentInit', 'ngAfterContentChecked'];
function shouldAddAbstractDirective(type) {
  const reflect = getReflect();
  if (LIFECYCLE_HOOKS.some(hookName => reflect.hasLifecycleHook(type, hookName))) {
    return true;
  }
  const propMetadata = reflect.propMetadata(type);
  for (const field in propMetadata) {
    const annotations = propMetadata[field];
    for (let i = 0; i < annotations.length; i++) {
      const current = annotations[i];
      const metadataName = current.ngMetadataName;
      if (isInputAnnotation(current) || isContentQuery(current) || isViewQuery(current) || metadataName === 'Output' || metadataName === 'HostBinding' || metadataName === 'HostListener') {
        return true;
      }
    }
  }
  return false;
}
function compilePipe(type, meta) {
  let ngPipeDef = null;
  let ngFactoryDef = null;
  Object.defineProperty(type, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const metadata = getPipeMetadata(type, meta);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: 'pipe',
          type: metadata.type
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${metadata.name}/ɵfac.js`, {
          name: metadata.name,
          type: metadata.type,
          typeArgumentCount: 0,
          deps: reflectDependencies(type),
          target: compiler.FactoryTarget.Pipe
        });
      }
      return ngFactoryDef;
    },
    configurable: !!ngDevMode
  });
  Object.defineProperty(type, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_PIPE_DEF, {
    get: () => {
      if (ngPipeDef === null) {
        const metadata = getPipeMetadata(type, meta);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: 'pipe',
          type: metadata.type
        });
        ngPipeDef = compiler.compilePipe(angularCoreEnv, `ng:///${metadata.name}/ɵpipe.js`, metadata);
      }
      return ngPipeDef;
    },
    configurable: !!ngDevMode
  });
}
function getPipeMetadata(type, meta) {
  return {
    type: type,
    name: type.name,
    pipeName: meta.name,
    pure: meta.pure !== undefined ? meta.pure : true,
    isStandalone: meta.standalone === undefined ? true : !!meta.standalone
  };
}
const Directive = makeDecorator('Directive', (dir = {}) => dir, undefined, undefined, (type, meta) => compileDirective(type, meta));
const Component = makeDecorator('Component', (c = {}) => ({
  changeDetection: ChangeDetectionStrategy.Default,
  ...c
}), Directive, undefined, (type, meta) => compileComponent(type, meta));
const Pipe = makeDecorator('Pipe', p => ({
  pure: true,
  ...p
}), undefined, undefined, (type, meta) => compilePipe(type, meta));
const Input = makePropDecorator('Input', arg => {
  if (!arg) {
    return {};
  }
  return typeof arg === 'string' ? {
    alias: arg
  } : arg;
});
const Output = makePropDecorator('Output', alias => ({
  alias
}));
const HostBinding = makePropDecorator('HostBinding', hostPropertyName => ({
  hostPropertyName
}));
const HostListener = makePropDecorator('HostListener', (eventName, args) => ({
  eventName,
  args
}));
const NgModule = makeDecorator('NgModule', ngModule => ngModule, undefined, undefined, (type, meta) => compileNgModule(type, meta));
class ModuleWithComponentFactories {
  ngModuleFactory;
  componentFactories;
  constructor(ngModuleFactory, componentFactories) {
    this.ngModuleFactory = ngModuleFactory;
    this.componentFactories = componentFactories;
  }
}
class Compiler {
  compileModuleSync(moduleType) {
    return new NgModuleFactory(moduleType);
  }
  compileModuleAsync(moduleType) {
    return Promise.resolve(this.compileModuleSync(moduleType));
  }
  compileModuleAndAllComponentsSync(moduleType) {
    const ngModuleFactory = this.compileModuleSync(moduleType);
    const moduleDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNgModuleDef)(moduleType);
    const componentFactories = maybeUnwrapFn(moduleDef.declarations).reduce((factories, declaration) => {
      const componentDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(declaration);
      componentDef && factories.push(new ComponentFactory(componentDef));
      return factories;
    }, []);
    return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);
  }
  compileModuleAndAllComponentsAsync(moduleType) {
    return Promise.resolve(this.compileModuleAndAllComponentsSync(moduleType));
  }
  clearCache() {}
  clearCacheFor(type) {}
  getModuleId(moduleType) {
    return undefined;
  }
  static ɵfac = function Compiler_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || Compiler)();
  };
  static ɵprov = /*@__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
    token: Compiler,
    factory: Compiler.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Compiler, [{
    type: Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], null, null);
})();
const COMPILER_OPTIONS = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'compilerOptions' : '');
class CompilerFactory {}
const CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT = 100;
let consecutiveMicrotaskNotifications = 0;
let stackFromLastFewNotifications = [];
function trackMicrotaskNotificationForDebugging() {
  consecutiveMicrotaskNotifications++;
  if (CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT - consecutiveMicrotaskNotifications < 5) {
    const stack = new Error().stack;
    if (stack) {
      stackFromLastFewNotifications.push(stack);
    }
  }
  if (consecutiveMicrotaskNotifications === CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(103, 'Angular could not stabilize because there were endless change notifications within the browser event loop. ' + 'The stack from the last several notifications: \n' + stackFromLastFewNotifications.join('\n'));
  }
}
class ChangeDetectionSchedulerImpl {
  applicationErrorHandler = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INTERNAL_APPLICATION_ERROR_HANDLER);
  appRef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(ApplicationRef);
  taskService = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PendingTasksInternal);
  ngZone = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone);
  zonelessEnabled = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ZONELESS_ENABLED);
  tracing = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(TracingService, {
    optional: true
  });
  zoneIsDefined = typeof Zone !== 'undefined' && !!Zone.root.run;
  schedulerTickApplyArgs = [{
    data: {
      '__scheduler_tick__': true
    }
  }];
  subscriptions = new rxjs__WEBPACK_IMPORTED_MODULE_4__.Subscription();
  angularZoneId = this.zoneIsDefined ? this.ngZone._inner?.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.angularZoneInstanceIdProperty) : null;
  scheduleInRootZone = !this.zonelessEnabled && this.zoneIsDefined && ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.SCHEDULE_IN_ROOT_ZONE, {
    optional: true
  }) ?? false);
  cancelScheduledCallback = null;
  useMicrotaskScheduler = false;
  runningTick = false;
  pendingRenderTaskId = null;
  constructor() {
    this.subscriptions.add(this.appRef.afterTick.subscribe(() => {
      if (!this.runningTick) {
        this.cleanup();
      }
    }));
    this.subscriptions.add(this.ngZone.onUnstable.subscribe(() => {
      if (!this.runningTick) {
        this.cleanup();
      }
    }));
  }
  notify(source) {
    if (!this.zonelessEnabled && source === 5) {
      return;
    }
    switch (source) {
      case 0:
        {
          this.appRef.dirtyFlags |= 2;
          break;
        }
      case 3:
      case 2:
      case 4:
      case 5:
      case 1:
        {
          this.appRef.dirtyFlags |= 4;
          break;
        }
      case 6:
        {
          this.appRef.dirtyFlags |= 2;
          break;
        }
      case 12:
        {
          this.appRef.dirtyFlags |= 16;
          break;
        }
      case 13:
        {
          this.appRef.dirtyFlags |= 2;
          break;
        }
      case 11:
        {
          break;
        }
      case 9:
      case 8:
      case 7:
      case 10:
      default:
        {
          this.appRef.dirtyFlags |= 8;
        }
    }
    this.appRef.tracingSnapshot = this.tracing?.snapshot(this.appRef.tracingSnapshot) ?? null;
    if (!this.shouldScheduleTick()) {
      return;
    }
    if (typeof ngDevMode === 'undefined' || ngDevMode) {
      if (this.useMicrotaskScheduler) {
        trackMicrotaskNotificationForDebugging();
      } else {
        consecutiveMicrotaskNotifications = 0;
        stackFromLastFewNotifications.length = 0;
      }
    }
    const scheduleCallback = this.useMicrotaskScheduler ? _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.scheduleCallbackWithMicrotask : _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.scheduleCallbackWithRafRace;
    this.pendingRenderTaskId = this.taskService.add();
    if (this.scheduleInRootZone) {
      this.cancelScheduledCallback = Zone.root.run(() => scheduleCallback(() => this.tick()));
    } else {
      this.cancelScheduledCallback = this.ngZone.runOutsideAngular(() => scheduleCallback(() => this.tick()));
    }
  }
  shouldScheduleTick() {
    if (this.appRef.destroyed) {
      return false;
    }
    if (this.pendingRenderTaskId !== null || this.runningTick || this.appRef._runningTick) {
      return false;
    }
    if (!this.zonelessEnabled && this.zoneIsDefined && Zone.current.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.angularZoneInstanceIdProperty + this.angularZoneId)) {
      return false;
    }
    return true;
  }
  tick() {
    if (this.runningTick || this.appRef.destroyed) {
      return;
    }
    if (this.appRef.dirtyFlags === 0) {
      this.cleanup();
      return;
    }
    if (!this.zonelessEnabled && this.appRef.dirtyFlags & 7) {
      this.appRef.dirtyFlags |= 1;
    }
    const task = this.taskService.add();
    try {
      this.ngZone.run(() => {
        this.runningTick = true;
        this.appRef._tick();
      }, undefined, this.schedulerTickApplyArgs);
    } catch (e) {
      this.taskService.remove(task);
      this.applicationErrorHandler(e);
    } finally {
      this.cleanup();
    }
    this.useMicrotaskScheduler = true;
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.scheduleCallbackWithMicrotask)(() => {
      this.useMicrotaskScheduler = false;
      this.taskService.remove(task);
    });
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
    this.cleanup();
  }
  cleanup() {
    this.runningTick = false;
    this.cancelScheduledCallback?.();
    this.cancelScheduledCallback = null;
    if (this.pendingRenderTaskId !== null) {
      const taskId = this.pendingRenderTaskId;
      this.pendingRenderTaskId = null;
      this.taskService.remove(taskId);
    }
  }
  static ɵfac = function ChangeDetectionSchedulerImpl_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || ChangeDetectionSchedulerImpl)();
  };
  static ɵprov = /*@__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
    token: ChangeDetectionSchedulerImpl,
    factory: ChangeDetectionSchedulerImpl.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChangeDetectionSchedulerImpl, [{
    type: Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], () => [], null);
})();
function provideZonelessChangeDetection() {
  performanceMarkFeature('NgZoneless');
  if ((typeof ngDevMode === 'undefined' || ngDevMode) && typeof Zone !== 'undefined' && Zone) {
    const message = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(914, `The application is using zoneless change detection, but is still loading Zone.js. ` + `Consider removing Zone.js to get the full benefits of zoneless. ` + `In applications using the Angular CLI, Zone.js is typically included in the "polyfills" section of the angular.json file.`);
    console.warn(message);
  }
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.makeEnvironmentProviders)([...provideZonelessChangeDetectionInternal(), typeof ngDevMode === 'undefined' || ngDevMode ? [{
    provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PROVIDED_ZONELESS,
    useValue: true
  }] : []]);
}
function provideZonelessChangeDetectionInternal() {
  return [{
    provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ChangeDetectionScheduler,
    useExisting: ChangeDetectionSchedulerImpl
  }, {
    provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone,
    useClass: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NoopNgZone
  }, {
    provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ZONELESS_ENABLED,
    useValue: true
  }];
}
function getGlobalLocale() {
  if (typeof ngI18nClosureMode !== 'undefined' && ngI18nClosureMode && typeof goog !== 'undefined' && goog.LOCALE !== 'en') {
    return goog.LOCALE;
  } else {
    return typeof $localize !== 'undefined' && $localize.locale || DEFAULT_LOCALE_ID;
  }
}
const LOCALE_ID = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'LocaleId' : '', {
  factory: () => (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(LOCALE_ID, {
    optional: true,
    skipSelf: true
  }) || getGlobalLocale()
});
const DEFAULT_CURRENCY_CODE = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'DefaultCurrencyCode' : '', {
  factory: () => USD_CURRENCY_CODE
});
const TRANSLATIONS = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Translations' : '');
const TRANSLATIONS_FORMAT = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'TranslationsFormat' : '');
var MissingTranslationStrategy;
(function (MissingTranslationStrategy) {
  MissingTranslationStrategy[MissingTranslationStrategy["Error"] = 0] = "Error";
  MissingTranslationStrategy[MissingTranslationStrategy["Warning"] = 1] = "Warning";
  MissingTranslationStrategy[MissingTranslationStrategy["Ignore"] = 2] = "Ignore";
})(MissingTranslationStrategy || (MissingTranslationStrategy = {}));
class DebugEventListener {
  name;
  callback;
  constructor(name, callback) {
    this.name = name;
    this.callback = callback;
  }
}
function asNativeElements(debugEls) {
  return debugEls.map(el => el.nativeElement);
}
class DebugNode {
  nativeNode;
  constructor(nativeNode) {
    this.nativeNode = nativeNode;
  }
  get parent() {
    const parent = this.nativeNode.parentNode;
    return parent ? new DebugElement(parent) : null;
  }
  get injector() {
    return getInjector(this.nativeNode);
  }
  get componentInstance() {
    const nativeElement = this.nativeNode;
    return nativeElement && (getComponent(nativeElement) || getOwningComponent(nativeElement));
  }
  get context() {
    return getComponent(this.nativeNode) || getContext(this.nativeNode);
  }
  get listeners() {
    return getListeners(this.nativeNode).filter(listener => listener.type === 'dom');
  }
  get references() {
    return getLocalRefs(this.nativeNode);
  }
  get providerTokens() {
    return getInjectionTokens(this.nativeNode);
  }
}
class DebugElement extends DebugNode {
  constructor(nativeNode) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDomNode)(nativeNode);
    super(nativeNode);
  }
  get nativeElement() {
    return this.nativeNode.nodeType == Node.ELEMENT_NODE ? this.nativeNode : null;
  }
  get name() {
    const context = getLContext(this.nativeNode);
    const lView = context ? context.lView : null;
    if (lView !== null) {
      const tData = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data;
      const tNode = tData[context.nodeIndex];
      return tNode.value;
    } else {
      return this.nativeNode.nodeName;
    }
  }
  get properties() {
    const context = getLContext(this.nativeNode);
    const lView = context ? context.lView : null;
    if (lView === null) {
      return {};
    }
    const tData = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data;
    const tNode = tData[context.nodeIndex];
    const properties = {};
    copyDomProperties(this.nativeElement, properties);
    collectPropertyBindings(properties, tNode, lView, tData);
    return properties;
  }
  get attributes() {
    const attributes = {};
    const element = this.nativeElement;
    if (!element) {
      return attributes;
    }
    const context = getLContext(element);
    const lView = context ? context.lView : null;
    if (lView === null) {
      return {};
    }
    const tNodeAttrs = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data[context.nodeIndex].attrs;
    const lowercaseTNodeAttrs = [];
    if (tNodeAttrs) {
      let i = 0;
      while (i < tNodeAttrs.length) {
        const attrName = tNodeAttrs[i];
        if (typeof attrName !== 'string') break;
        const attrValue = tNodeAttrs[i + 1];
        attributes[attrName] = attrValue;
        lowercaseTNodeAttrs.push(attrName.toLowerCase());
        i += 2;
      }
    }
    for (const attr of element.attributes) {
      if (!lowercaseTNodeAttrs.includes(attr.name)) {
        attributes[attr.name] = attr.value;
      }
    }
    return attributes;
  }
  get styles() {
    const element = this.nativeElement;
    return element?.style ?? {};
  }
  get classes() {
    const result = {};
    const element = this.nativeElement;
    const className = element.className;
    const classes = typeof className !== 'string' ? className.baseVal.split(' ') : className.split(' ');
    classes.forEach(value => result[value] = true);
    return result;
  }
  get childNodes() {
    const childNodes = this.nativeNode.childNodes;
    const children = [];
    for (let i = 0; i < childNodes.length; i++) {
      const element = childNodes[i];
      children.push(getDebugNode(element));
    }
    return children;
  }
  get children() {
    const nativeElement = this.nativeElement;
    if (!nativeElement) return [];
    const childNodes = nativeElement.children;
    const children = [];
    for (let i = 0; i < childNodes.length; i++) {
      const element = childNodes[i];
      children.push(getDebugNode(element));
    }
    return children;
  }
  query(predicate) {
    const results = this.queryAll(predicate);
    return results[0] || null;
  }
  queryAll(predicate) {
    const matches = [];
    _queryAll(this, predicate, matches, true);
    return matches;
  }
  queryAllNodes(predicate) {
    const matches = [];
    _queryAll(this, predicate, matches, false);
    return matches;
  }
  triggerEventHandler(eventName, eventObj) {
    const node = this.nativeNode;
    const invokedListeners = [];
    this.listeners.forEach(listener => {
      if (listener.name === eventName) {
        const callback = listener.callback;
        callback.call(node, eventObj);
        invokedListeners.push(callback);
      }
    });
    if (typeof node.eventListeners === 'function') {
      node.eventListeners(eventName).forEach(listener => {
        if (listener.toString().indexOf('__ngUnwrap__') !== -1) {
          const unwrappedListener = listener('__ngUnwrap__');
          return invokedListeners.indexOf(unwrappedListener) === -1 && unwrappedListener.call(node, eventObj);
        }
      });
    }
  }
}
function copyDomProperties(element, properties) {
  if (element) {
    let obj = Object.getPrototypeOf(element);
    const NodePrototype = Node.prototype;
    while (obj !== null && obj !== NodePrototype) {
      const descriptors = Object.getOwnPropertyDescriptors(obj);
      for (let key in descriptors) {
        if (!key.startsWith('__') && !key.startsWith('on')) {
          const value = element[key];
          if (isPrimitiveValue(value)) {
            properties[key] = value;
          }
        }
      }
      obj = Object.getPrototypeOf(obj);
    }
  }
}
function isPrimitiveValue(value) {
  return typeof value === 'string' || typeof value === 'boolean' || typeof value === 'number' || value === null;
}
function _queryAll(parentElement, predicate, matches, elementsOnly) {
  const context = getLContext(parentElement.nativeNode);
  const lView = context ? context.lView : null;
  if (lView !== null) {
    const parentTNode = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data[context.nodeIndex];
    _queryNodeChildren(parentTNode, lView, predicate, matches, elementsOnly, parentElement.nativeNode);
  } else {
    _queryNativeNodeDescendants(parentElement.nativeNode, predicate, matches, elementsOnly);
  }
}
function _queryNodeChildren(tNode, lView, predicate, matches, elementsOnly, rootNativeNode) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForLView)(tNode, lView);
  const nativeNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNodeOrNull)(tNode, lView);
  if (tNode.type & (3 | 8)) {
    _addQueryMatch(nativeNode, predicate, matches, elementsOnly, rootNativeNode);
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentHost)(tNode)) {
      const componentView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(tNode.index, lView);
      if (componentView && componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].firstChild) {
        _queryNodeChildren(componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].firstChild, componentView, predicate, matches, elementsOnly, rootNativeNode);
      }
    } else {
      if (tNode.child) {
        _queryNodeChildren(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode);
      }
      nativeNode && _queryNativeNodeDescendants(nativeNode, predicate, matches, elementsOnly);
    }
    const nodeOrContainer = lView[tNode.index];
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(nodeOrContainer)) {
      _queryNodeChildrenInContainer(nodeOrContainer, predicate, matches, elementsOnly, rootNativeNode);
    }
  } else if (tNode.type & 4) {
    const lContainer = lView[tNode.index];
    _addQueryMatch(lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NATIVE], predicate, matches, elementsOnly, rootNativeNode);
    _queryNodeChildrenInContainer(lContainer, predicate, matches, elementsOnly, rootNativeNode);
  } else if (tNode.type & 16) {
    const componentView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW];
    const componentHost = componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST];
    const head = componentHost.projection[tNode.projection];
    if (Array.isArray(head)) {
      for (let nativeNode of head) {
        _addQueryMatch(nativeNode, predicate, matches, elementsOnly, rootNativeNode);
      }
    } else if (head) {
      const nextLView = componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT];
      const nextTNode = nextLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data[head.index];
      _queryNodeChildren(nextTNode, nextLView, predicate, matches, elementsOnly, rootNativeNode);
    }
  } else if (tNode.child) {
    _queryNodeChildren(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode);
  }
  if (rootNativeNode !== nativeNode) {
    const nextTNode = tNode.flags & 2 ? tNode.projectionNext : tNode.next;
    if (nextTNode) {
      _queryNodeChildren(nextTNode, lView, predicate, matches, elementsOnly, rootNativeNode);
    }
  }
}
function _queryNodeChildrenInContainer(lContainer, predicate, matches, elementsOnly, rootNativeNode) {
  for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    const childView = lContainer[i];
    const firstChild = childView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].firstChild;
    if (firstChild) {
      _queryNodeChildren(firstChild, childView, predicate, matches, elementsOnly, rootNativeNode);
    }
  }
}
function _addQueryMatch(nativeNode, predicate, matches, elementsOnly, rootNativeNode) {
  if (rootNativeNode !== nativeNode) {
    const debugNode = getDebugNode(nativeNode);
    if (!debugNode) {
      return;
    }
    if (elementsOnly && debugNode instanceof DebugElement && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
      matches.push(debugNode);
    } else if (!elementsOnly && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
      matches.push(debugNode);
    }
  }
}
function _queryNativeNodeDescendants(parentNode, predicate, matches, elementsOnly) {
  const nodes = parentNode.childNodes;
  const length = nodes.length;
  for (let i = 0; i < length; i++) {
    const node = nodes[i];
    const debugNode = getDebugNode(node);
    if (debugNode) {
      if (elementsOnly && debugNode instanceof DebugElement && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
        matches.push(debugNode);
      } else if (!elementsOnly && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
        matches.push(debugNode);
      }
      _queryNativeNodeDescendants(node, predicate, matches, elementsOnly);
    }
  }
}
function collectPropertyBindings(properties, tNode, lView, tData) {
  let bindingIndexes = tNode.propertyBindings;
  if (bindingIndexes !== null) {
    for (let i = 0; i < bindingIndexes.length; i++) {
      const bindingIndex = bindingIndexes[i];
      const propMetadata = tData[bindingIndex];
      const metadataParts = propMetadata.split(INTERPOLATION_DELIMITER);
      const propertyName = metadataParts[0];
      if (metadataParts.length > 1) {
        let value = metadataParts[1];
        for (let j = 1; j < metadataParts.length - 1; j++) {
          value += (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(lView[bindingIndex + j - 1]) + metadataParts[j + 1];
        }
        properties[propertyName] = value;
      } else {
        properties[propertyName] = lView[bindingIndex];
      }
    }
  }
}
const NG_DEBUG_PROPERTY = '__ng_debug__';
function getDebugNode(nativeNode) {
  if (nativeNode instanceof Node) {
    if (!nativeNode.hasOwnProperty(NG_DEBUG_PROPERTY)) {
      nativeNode[NG_DEBUG_PROPERTY] = nativeNode.nodeType == Node.ELEMENT_NODE ? new DebugElement(nativeNode) : new DebugNode(nativeNode);
    }
    return nativeNode[NG_DEBUG_PROPERTY];
  }
  return null;
}


/***/ }),

/***/ 7376:
/*!*********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@angular+platform-browser@21.0.5_@angular+animations@21.0.5_@angular+common@21.0.5_@angular+core@21.0.5/node_modules/@angular/platform-browser/fesm2022/platform-browser.mjs ***!
  \*********************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BrowserModule: () => (/* reexport safe */ _browser_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.BrowserModule),
/* harmony export */   By: () => (/* binding */ By),
/* harmony export */   DomSanitizer: () => (/* binding */ DomSanitizer),
/* harmony export */   EVENT_MANAGER_PLUGINS: () => (/* reexport safe */ _dom_renderer_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__.EVENT_MANAGER_PLUGINS),
/* harmony export */   EventManager: () => (/* reexport safe */ _dom_renderer_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__.EventManager),
/* harmony export */   EventManagerPlugin: () => (/* reexport safe */ _dom_renderer_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__.EventManagerPlugin),
/* harmony export */   HAMMER_GESTURE_CONFIG: () => (/* binding */ HAMMER_GESTURE_CONFIG),
/* harmony export */   HAMMER_LOADER: () => (/* binding */ HAMMER_LOADER),
/* harmony export */   HammerGestureConfig: () => (/* binding */ HammerGestureConfig),
/* harmony export */   HammerModule: () => (/* binding */ HammerModule),
/* harmony export */   HydrationFeatureKind: () => (/* binding */ HydrationFeatureKind),
/* harmony export */   Meta: () => (/* binding */ Meta),
/* harmony export */   REMOVE_STYLES_ON_COMPONENT_DESTROY: () => (/* reexport safe */ _dom_renderer_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__.REMOVE_STYLES_ON_COMPONENT_DESTROY),
/* harmony export */   Title: () => (/* binding */ Title),
/* harmony export */   VERSION: () => (/* binding */ VERSION),
/* harmony export */   bootstrapApplication: () => (/* reexport safe */ _browser_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.bootstrapApplication),
/* harmony export */   createApplication: () => (/* reexport safe */ _browser_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.createApplication),
/* harmony export */   disableDebugTools: () => (/* binding */ disableDebugTools),
/* harmony export */   enableDebugTools: () => (/* binding */ enableDebugTools),
/* harmony export */   platformBrowser: () => (/* reexport safe */ _browser_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.platformBrowser),
/* harmony export */   provideClientHydration: () => (/* binding */ provideClientHydration),
/* harmony export */   provideProtractorTestingSupport: () => (/* reexport safe */ _browser_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.provideProtractorTestingSupport),
/* harmony export */   withEventReplay: () => (/* binding */ withEventReplay),
/* harmony export */   withHttpTransferCacheOptions: () => (/* binding */ withHttpTransferCacheOptions),
/* harmony export */   withI18nSupport: () => (/* binding */ withI18nSupport),
/* harmony export */   withIncrementalHydration: () => (/* binding */ withIncrementalHydration),
/* harmony export */   withNoHttpTransferCache: () => (/* binding */ withNoHttpTransferCache),
/* harmony export */   "ɵBrowserDomAdapter": () => (/* reexport safe */ _browser_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.BrowserDomAdapter),
/* harmony export */   "ɵBrowserGetTestability": () => (/* reexport safe */ _browser_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.BrowserGetTestability),
/* harmony export */   "ɵDomEventsPlugin": () => (/* reexport safe */ _dom_renderer_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__.DomEventsPlugin),
/* harmony export */   "ɵDomRendererFactory2": () => (/* reexport safe */ _dom_renderer_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__.DomRendererFactory2),
/* harmony export */   "ɵDomSanitizerImpl": () => (/* binding */ DomSanitizerImpl),
/* harmony export */   "ɵHammerGesturesPlugin": () => (/* binding */ HammerGesturesPlugin),
/* harmony export */   "ɵKeyEventsPlugin": () => (/* reexport safe */ _browser_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.KeyEventsPlugin),
/* harmony export */   "ɵSharedStylesHost": () => (/* reexport safe */ _dom_renderer_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__.SharedStylesHost),
/* harmony export */   "ɵgetDOM": () => (/* reexport safe */ _angular_common__WEBPACK_IMPORTED_MODULE_2__.getDOM)
/* harmony export */ });
/* harmony import */ var _browser_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_browser-chunk.mjs */ 8323);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ 64);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ 8021);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/core */ 7367);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/core */ 8357);
/* harmony import */ var _dom_renderer_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_dom_renderer-chunk.mjs */ 519);
/* harmony import */ var _angular_common_http__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/common/http */ 3477);
/**
 * @license Angular v21.0.5
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */









class Meta {
  _doc;
  _dom;
  constructor(_doc) {
    this._doc = _doc;
    this._dom = (0,_angular_common__WEBPACK_IMPORTED_MODULE_2__.getDOM)();
  }
  addTag(tag, forceCreation = false) {
    if (!tag) return null;
    return this._getOrCreateElement(tag, forceCreation);
  }
  addTags(tags, forceCreation = false) {
    if (!tags) return [];
    return tags.reduce((result, tag) => {
      if (tag) {
        result.push(this._getOrCreateElement(tag, forceCreation));
      }
      return result;
    }, []);
  }
  getTag(attrSelector) {
    if (!attrSelector) return null;
    return this._doc.querySelector(`meta[${attrSelector}]`) || null;
  }
  getTags(attrSelector) {
    if (!attrSelector) return [];
    const list = this._doc.querySelectorAll(`meta[${attrSelector}]`);
    return list ? [].slice.call(list) : [];
  }
  updateTag(tag, selector) {
    if (!tag) return null;
    selector = selector || this._parseSelector(tag);
    const meta = this.getTag(selector);
    if (meta) {
      return this._setMetaElementAttributes(tag, meta);
    }
    return this._getOrCreateElement(tag, true);
  }
  removeTag(attrSelector) {
    this.removeTagElement(this.getTag(attrSelector));
  }
  removeTagElement(meta) {
    if (meta) {
      this._dom.remove(meta);
    }
  }
  _getOrCreateElement(meta, forceCreation = false) {
    if (!forceCreation) {
      const selector = this._parseSelector(meta);
      const elem = this.getTags(selector).filter(elem => this._containsAttributes(meta, elem))[0];
      if (elem !== undefined) return elem;
    }
    const element = this._dom.createElement('meta');
    this._setMetaElementAttributes(meta, element);
    const head = this._doc.getElementsByTagName('head')[0];
    head.appendChild(element);
    return element;
  }
  _setMetaElementAttributes(tag, el) {
    Object.keys(tag).forEach(prop => el.setAttribute(this._getMetaKeyMap(prop), tag[prop]));
    return el;
  }
  _parseSelector(tag) {
    const attr = tag.name ? 'name' : 'property';
    return `${attr}="${tag[attr]}"`;
  }
  _containsAttributes(tag, elem) {
    return Object.keys(tag).every(key => elem.getAttribute(this._getMetaKeyMap(key)) === tag[key]);
  }
  _getMetaKeyMap(prop) {
    return META_KEYS_MAP[prop] || prop;
  }
  static ɵfac = function Meta_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || Meta)(_angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT));
  };
  static ɵprov = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: Meta,
    factory: Meta.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(Meta, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], () => [{
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Inject,
      args: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT]
    }]
  }], null);
})();
const META_KEYS_MAP = {
  httpEquiv: 'http-equiv'
};
class Title {
  _doc;
  constructor(_doc) {
    this._doc = _doc;
  }
  getTitle() {
    return this._doc.title;
  }
  setTitle(newTitle) {
    this._doc.title = newTitle || '';
  }
  static ɵfac = function Title_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || Title)(_angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT));
  };
  static ɵprov = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: Title,
    factory: Title.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(Title, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], () => [{
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Inject,
      args: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT]
    }]
  }], null);
})();
function exportNgVar(name, value) {
  if (typeof COMPILED === 'undefined' || !COMPILED) {
    const ng = _angular_common__WEBPACK_IMPORTED_MODULE_1__._global['ng'] = _angular_common__WEBPACK_IMPORTED_MODULE_1__._global['ng'] || {};
    ng[name] = value;
  }
}
class ChangeDetectionPerfRecord {
  msPerTick;
  numTicks;
  constructor(msPerTick, numTicks) {
    this.msPerTick = msPerTick;
    this.numTicks = numTicks;
  }
}
class AngularProfiler {
  appRef;
  constructor(ref) {
    this.appRef = ref.injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_3__.ApplicationRef);
  }
  timeChangeDetection(config) {
    const record = config && config['record'];
    const profileName = 'Change Detection';
    if (record && 'profile' in console && typeof console.profile === 'function') {
      console.profile(profileName);
    }
    const start = performance.now();
    let numTicks = 0;
    while (numTicks < 5 || performance.now() - start < 500) {
      this.appRef.tick();
      numTicks++;
    }
    const end = performance.now();
    if (record && 'profileEnd' in console && typeof console.profileEnd === 'function') {
      console.profileEnd(profileName);
    }
    const msPerTick = (end - start) / numTicks;
    console.log(`ran ${numTicks} change detection cycles`);
    console.log(`${msPerTick.toFixed(2)} ms per check`);
    return new ChangeDetectionPerfRecord(msPerTick, numTicks);
  }
}
const PROFILER_GLOBAL_NAME = 'profiler';
function enableDebugTools(ref) {
  exportNgVar(PROFILER_GLOBAL_NAME, new AngularProfiler(ref));
  return ref;
}
function disableDebugTools() {
  exportNgVar(PROFILER_GLOBAL_NAME, null);
}
class By {
  static all() {
    return () => true;
  }
  static css(selector) {
    return debugElement => {
      return debugElement.nativeElement != null ? elementMatches(debugElement.nativeElement, selector) : false;
    };
  }
  static directive(type) {
    return debugNode => debugNode.providerTokens.indexOf(type) !== -1;
  }
}
function elementMatches(n, selector) {
  if ((0,_angular_common__WEBPACK_IMPORTED_MODULE_2__.getDOM)().isElementNode(n)) {
    return n.matches && n.matches(selector) || n.msMatchesSelector && n.msMatchesSelector(selector) || n.webkitMatchesSelector && n.webkitMatchesSelector(selector);
  }
  return false;
}
const EVENT_NAMES = {
  'pan': true,
  'panstart': true,
  'panmove': true,
  'panend': true,
  'pancancel': true,
  'panleft': true,
  'panright': true,
  'panup': true,
  'pandown': true,
  'pinch': true,
  'pinchstart': true,
  'pinchmove': true,
  'pinchend': true,
  'pinchcancel': true,
  'pinchin': true,
  'pinchout': true,
  'press': true,
  'pressup': true,
  'rotate': true,
  'rotatestart': true,
  'rotatemove': true,
  'rotateend': true,
  'rotatecancel': true,
  'swipe': true,
  'swipeleft': true,
  'swiperight': true,
  'swipeup': true,
  'swipedown': true,
  'tap': true,
  'doubletap': true
};
const HAMMER_GESTURE_CONFIG = new _angular_common__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'HammerGestureConfig' : '');
const HAMMER_LOADER = new _angular_common__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'HammerLoader' : '');
class HammerGestureConfig {
  events = [];
  overrides = {};
  options;
  buildHammer(element) {
    const mc = new Hammer(element, this.options);
    mc.get('pinch').set({
      enable: true
    });
    mc.get('rotate').set({
      enable: true
    });
    for (const eventName in this.overrides) {
      mc.get(eventName).set(this.overrides[eventName]);
    }
    return mc;
  }
  static ɵfac = function HammerGestureConfig_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || HammerGestureConfig)();
  };
  static ɵprov = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: HammerGestureConfig,
    factory: HammerGestureConfig.ɵfac
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(HammerGestureConfig, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable
  }], null, null);
})();
class HammerGesturesPlugin extends _dom_renderer_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__.EventManagerPlugin {
  _config;
  _injector;
  loader;
  _loaderPromise = null;
  constructor(doc, _config, _injector, loader) {
    super(doc);
    this._config = _config;
    this._injector = _injector;
    this.loader = loader;
  }
  supports(eventName) {
    if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {
      return false;
    }
    if (!window.Hammer && !this.loader) {
      if (typeof ngDevMode === 'undefined' || ngDevMode) {
        const _console = this._injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_3__.Console);
        _console.warn(`The "${eventName}" event cannot be bound because Hammer.JS is not ` + `loaded and no custom loader has been specified.`);
      }
      return false;
    }
    return true;
  }
  addEventListener(element, eventName, handler) {
    const zone = this.manager.getZone();
    eventName = eventName.toLowerCase();
    if (!window.Hammer && this.loader) {
      this._loaderPromise = this._loaderPromise || zone.runOutsideAngular(() => this.loader());
      let cancelRegistration = false;
      let deregister = () => {
        cancelRegistration = true;
      };
      zone.runOutsideAngular(() => this._loaderPromise.then(() => {
        if (!window.Hammer) {
          if (typeof ngDevMode === 'undefined' || ngDevMode) {
            const _console = this._injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_3__.Console);
            _console.warn(`The custom HAMMER_LOADER completed, but Hammer.JS is not present.`);
          }
          deregister = () => {};
          return;
        }
        if (!cancelRegistration) {
          deregister = this.addEventListener(element, eventName, handler);
        }
      }).catch(() => {
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
          const _console = this._injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_3__.Console);
          _console.warn(`The "${eventName}" event cannot be bound because the custom ` + `Hammer.JS loader failed.`);
        }
        deregister = () => {};
      }));
      return () => {
        deregister();
      };
    }
    return zone.runOutsideAngular(() => {
      const mc = this._config.buildHammer(element);
      const callback = function (eventObj) {
        zone.runGuarded(function () {
          handler(eventObj);
        });
      };
      mc.on(eventName, callback);
      return () => {
        mc.off(eventName, callback);
        if (typeof mc.destroy === 'function') {
          mc.destroy();
        }
      };
    });
  }
  isCustomEvent(eventName) {
    return this._config.events.indexOf(eventName) > -1;
  }
  static ɵfac = function HammerGesturesPlugin_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || HammerGesturesPlugin)(_angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT), _angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](HAMMER_GESTURE_CONFIG), _angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_1__.Injector), _angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](HAMMER_LOADER, 8));
  };
  static ɵprov = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: HammerGesturesPlugin,
    factory: HammerGesturesPlugin.ɵfac
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(HammerGesturesPlugin, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable
  }], () => [{
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Inject,
      args: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT]
    }]
  }, {
    type: HammerGestureConfig,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Inject,
      args: [HAMMER_GESTURE_CONFIG]
    }]
  }, {
    type: _angular_common__WEBPACK_IMPORTED_MODULE_1__.Injector
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Inject,
      args: [HAMMER_LOADER]
    }]
  }], null);
})();
class HammerModule {
  static ɵfac = function HammerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || HammerModule)();
  };
  static ɵmod = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineNgModule"]({
    type: HammerModule
  });
  static ɵinj = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
    providers: [{
      provide: _dom_renderer_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__.EVENT_MANAGER_PLUGINS,
      useClass: HammerGesturesPlugin,
      multi: true,
      deps: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT, HAMMER_GESTURE_CONFIG, _angular_common__WEBPACK_IMPORTED_MODULE_1__.Injector, [new _angular_core__WEBPACK_IMPORTED_MODULE_3__.Optional(), HAMMER_LOADER]]
    }, {
      provide: HAMMER_GESTURE_CONFIG,
      useClass: HammerGestureConfig
    }]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(HammerModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.NgModule,
    args: [{
      providers: [{
        provide: _dom_renderer_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__.EVENT_MANAGER_PLUGINS,
        useClass: HammerGesturesPlugin,
        multi: true,
        deps: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT, HAMMER_GESTURE_CONFIG, _angular_common__WEBPACK_IMPORTED_MODULE_1__.Injector, [new _angular_core__WEBPACK_IMPORTED_MODULE_3__.Optional(), HAMMER_LOADER]]
      }, {
        provide: HAMMER_GESTURE_CONFIG,
        useClass: HammerGestureConfig
      }]
    }]
  }], null, null);
})();
class DomSanitizer {
  static ɵfac = function DomSanitizer_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || DomSanitizer)();
  };
  static ɵprov = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: DomSanitizer,
    factory: function DomSanitizer_Factory(__ngFactoryType__) {
      let __ngConditionalFactory__ = null;
      if (__ngFactoryType__) {
        __ngConditionalFactory__ = new (__ngFactoryType__ || DomSanitizer)();
      } else {
        __ngConditionalFactory__ = _angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](DomSanitizerImpl);
      }
      return __ngConditionalFactory__;
    },
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(DomSanitizer, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
    args: [{
      providedIn: 'root',
      useExisting: (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(() => DomSanitizerImpl)
    }]
  }], null, null);
})();
class DomSanitizerImpl extends DomSanitizer {
  _doc;
  constructor(_doc) {
    super();
    this._doc = _doc;
  }
  sanitize(ctx, value) {
    if (value == null) return null;
    switch (ctx) {
      case _angular_core__WEBPACK_IMPORTED_MODULE_3__.SecurityContext.NONE:
        return value;
      case _angular_core__WEBPACK_IMPORTED_MODULE_3__.SecurityContext.HTML:
        if ((0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.allowSanitizationBypassAndThrow)(value, "HTML")) {
          return (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.unwrapSafeValue)(value);
        }
        return (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__._sanitizeHtml)(this._doc, String(value)).toString();
      case _angular_core__WEBPACK_IMPORTED_MODULE_3__.SecurityContext.STYLE:
        if ((0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.allowSanitizationBypassAndThrow)(value, "Style")) {
          return (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.unwrapSafeValue)(value);
        }
        return value;
      case _angular_core__WEBPACK_IMPORTED_MODULE_3__.SecurityContext.SCRIPT:
        if ((0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.allowSanitizationBypassAndThrow)(value, "Script")) {
          return (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.unwrapSafeValue)(value);
        }
        throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(5200, (typeof ngDevMode === 'undefined' || ngDevMode) && 'unsafe value used in a script context');
      case _angular_core__WEBPACK_IMPORTED_MODULE_3__.SecurityContext.URL:
        if ((0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.allowSanitizationBypassAndThrow)(value, "URL")) {
          return (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.unwrapSafeValue)(value);
        }
        return (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__._sanitizeUrl)(String(value));
      case _angular_core__WEBPACK_IMPORTED_MODULE_3__.SecurityContext.RESOURCE_URL:
        if ((0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.allowSanitizationBypassAndThrow)(value, "ResourceURL")) {
          return (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.unwrapSafeValue)(value);
        }
        throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(5201, (typeof ngDevMode === 'undefined' || ngDevMode) && `unsafe value used in a resource URL context (see ${_angular_common__WEBPACK_IMPORTED_MODULE_1__.XSS_SECURITY_URL})`);
      default:
        throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(5202, (typeof ngDevMode === 'undefined' || ngDevMode) && `Unexpected SecurityContext ${ctx} (see ${_angular_common__WEBPACK_IMPORTED_MODULE_1__.XSS_SECURITY_URL})`);
    }
  }
  bypassSecurityTrustHtml(value) {
    return (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.bypassSanitizationTrustHtml)(value);
  }
  bypassSecurityTrustStyle(value) {
    return (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.bypassSanitizationTrustStyle)(value);
  }
  bypassSecurityTrustScript(value) {
    return (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.bypassSanitizationTrustScript)(value);
  }
  bypassSecurityTrustUrl(value) {
    return (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.bypassSanitizationTrustUrl)(value);
  }
  bypassSecurityTrustResourceUrl(value) {
    return (0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.bypassSanitizationTrustResourceUrl)(value);
  }
  static ɵfac = function DomSanitizerImpl_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || DomSanitizerImpl)(_angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT));
  };
  static ɵprov = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: DomSanitizerImpl,
    factory: DomSanitizerImpl.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__.setClassMetadata(DomSanitizerImpl, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], () => [{
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Inject,
      args: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT]
    }]
  }], null);
})();
var HydrationFeatureKind;
(function (HydrationFeatureKind) {
  HydrationFeatureKind[HydrationFeatureKind["NoHttpTransferCache"] = 0] = "NoHttpTransferCache";
  HydrationFeatureKind[HydrationFeatureKind["HttpTransferCacheOptions"] = 1] = "HttpTransferCacheOptions";
  HydrationFeatureKind[HydrationFeatureKind["I18nSupport"] = 2] = "I18nSupport";
  HydrationFeatureKind[HydrationFeatureKind["EventReplay"] = 3] = "EventReplay";
  HydrationFeatureKind[HydrationFeatureKind["IncrementalHydration"] = 4] = "IncrementalHydration";
})(HydrationFeatureKind || (HydrationFeatureKind = {}));
function hydrationFeature(ɵkind, ɵproviders = [], ɵoptions = {}) {
  return {
    ɵkind,
    ɵproviders
  };
}
function withNoHttpTransferCache() {
  return hydrationFeature(HydrationFeatureKind.NoHttpTransferCache);
}
function withHttpTransferCacheOptions(options) {
  return hydrationFeature(HydrationFeatureKind.HttpTransferCacheOptions, (0,_angular_common_http__WEBPACK_IMPORTED_MODULE_6__["ɵwithHttpTransferCache"])(options));
}
function withI18nSupport() {
  return hydrationFeature(HydrationFeatureKind.I18nSupport, (0,_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵwithI18nSupport"])());
}
function withEventReplay() {
  return hydrationFeature(HydrationFeatureKind.EventReplay, (0,_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵwithEventReplay"])());
}
function withIncrementalHydration() {
  return hydrationFeature(HydrationFeatureKind.IncrementalHydration, (0,_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵwithIncrementalHydration"])());
}
function provideEnabledBlockingInitialNavigationDetector() {
  return [{
    provide: _angular_common__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT_INITIALIZER,
    useValue: () => {
      const isEnabledBlockingInitialNavigation = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_3__.IS_ENABLED_BLOCKING_INITIAL_NAVIGATION, {
        optional: true
      });
      if (isEnabledBlockingInitialNavigation) {
        const console = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_3__.Console);
        const message = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(5001, 'Configuration error: found both hydration and enabledBlocking initial navigation ' + 'in the same application, which is a contradiction.');
        console.warn(message);
      }
    },
    multi: true
  }];
}
function provideClientHydration(...features) {
  const providers = [];
  const featuresKind = new Set();
  for (const {
    ɵproviders,
    ɵkind
  } of features) {
    featuresKind.add(ɵkind);
    if (ɵproviders.length) {
      providers.push(ɵproviders);
    }
  }
  const hasHttpTransferCacheOptions = featuresKind.has(HydrationFeatureKind.HttpTransferCacheOptions);
  if (typeof ngDevMode !== 'undefined' && ngDevMode && featuresKind.has(HydrationFeatureKind.NoHttpTransferCache) && hasHttpTransferCacheOptions) {
    throw new _angular_common__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(5001, 'Configuration error: found both withHttpTransferCacheOptions() and withNoHttpTransferCache() in the same call to provideClientHydration(), which is a contradiction.');
  }
  return (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.makeEnvironmentProviders)([typeof ngDevMode !== 'undefined' && ngDevMode ? provideEnabledBlockingInitialNavigationDetector() : [], (0,_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵwithDomHydration"])(), featuresKind.has(HydrationFeatureKind.NoHttpTransferCache) || hasHttpTransferCacheOptions ? [] : (0,_angular_common_http__WEBPACK_IMPORTED_MODULE_6__["ɵwithHttpTransferCache"])({}), providers]);
}
const VERSION = /* @__PURE__ */new _angular_common__WEBPACK_IMPORTED_MODULE_1__.Version('21.0.5');


/***/ }),

/***/ 7742:
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/util/isAsyncIterable.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable)
/* harmony export */ });
/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction */ 4010);

function isAsyncIterable(obj) {
  return Symbol.asyncIterator && (0,_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

/***/ }),

/***/ 7802:
/*!****************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@angular+common@21.0.5_@angular+core@21.0.5_rxjs@7.8.2/node_modules/@angular/common/fesm2022/_xhr-chunk.mjs ***!
  \****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   XhrFactory: () => (/* binding */ XhrFactory),
/* harmony export */   parseCookieValue: () => (/* binding */ parseCookieValue)
/* harmony export */ });
/**
 * @license Angular v21.0.5
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */

function parseCookieValue(cookieStr, name) {
  name = encodeURIComponent(name);
  for (const cookie of cookieStr.split(';')) {
    const eqIndex = cookie.indexOf('=');
    const [cookieName, cookieValue] = eqIndex == -1 ? [cookie, ''] : [cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1)];
    if (cookieName.trim() === name) {
      return decodeURIComponent(cookieValue);
    }
  }
  return null;
}
class XhrFactory {}


/***/ }),

/***/ 7831:
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/util/errorContext.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   captureError: () => (/* binding */ captureError),
/* harmony export */   errorContext: () => (/* binding */ errorContext)
/* harmony export */ });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ 1157);

let context = null;
function errorContext(cb) {
  if (_config__WEBPACK_IMPORTED_MODULE_0__.config.useDeprecatedSynchronousErrorHandling) {
    const isRoot = !context;
    if (isRoot) {
      context = {
        errorThrown: false,
        error: null
      };
    }
    cb();
    if (isRoot) {
      const {
        errorThrown,
        error
      } = context;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (_config__WEBPACK_IMPORTED_MODULE_0__.config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

/***/ }),

/***/ 7909:
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/observable/from.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   from: () => (/* binding */ from)
/* harmony export */ });
/* harmony import */ var _scheduled_scheduled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scheduled/scheduled */ 3800);
/* harmony import */ var _innerFrom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./innerFrom */ 5829);


function from(input, scheduler) {
  return scheduler ? (0,_scheduled_scheduled__WEBPACK_IMPORTED_MODULE_0__.scheduled)(input, scheduler) : (0,_innerFrom__WEBPACK_IMPORTED_MODULE_1__.innerFrom)(input);
}

/***/ }),

/***/ 8021:
/*!******************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@angular+common@21.0.5_@angular+core@21.0.5_rxjs@7.8.2/node_modules/@angular/common/fesm2022/_platform_location-chunk.mjs ***!
  \******************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BrowserPlatformLocation: () => (/* binding */ BrowserPlatformLocation),
/* harmony export */   DomAdapter: () => (/* binding */ DomAdapter),
/* harmony export */   LOCATION_INITIALIZED: () => (/* binding */ LOCATION_INITIALIZED),
/* harmony export */   PlatformLocation: () => (/* binding */ PlatformLocation),
/* harmony export */   getDOM: () => (/* binding */ getDOM),
/* harmony export */   setRootDomAdapter: () => (/* binding */ setRootDomAdapter)
/* harmony export */ });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ 64);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ 7367);
/**
 * @license Angular v21.0.5
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */



let _DOM = null;
function getDOM() {
  return _DOM;
}
function setRootDomAdapter(adapter) {
  _DOM ??= adapter;
}
class DomAdapter {}
class PlatformLocation {
  historyGo(relativePosition) {
    throw new Error(ngDevMode ? 'Not implemented' : '');
  }
  static ɵfac = function PlatformLocation_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || PlatformLocation)();
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: PlatformLocation,
    factory: () => (() => (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(BrowserPlatformLocation))(),
    providedIn: 'platform'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(PlatformLocation, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,
    args: [{
      providedIn: 'platform',
      useFactory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(BrowserPlatformLocation)
    }]
  }], null, null);
})();
const LOCATION_INITIALIZED = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Location Initialized' : '');
class BrowserPlatformLocation extends PlatformLocation {
  _location;
  _history;
  _doc = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT);
  constructor() {
    super();
    this._location = window.location;
    this._history = window.history;
  }
  getBaseHrefFromDOM() {
    return getDOM().getBaseHref(this._doc);
  }
  onPopState(fn) {
    const window = getDOM().getGlobalEventTarget(this._doc, 'window');
    window.addEventListener('popstate', fn, false);
    return () => window.removeEventListener('popstate', fn);
  }
  onHashChange(fn) {
    const window = getDOM().getGlobalEventTarget(this._doc, 'window');
    window.addEventListener('hashchange', fn, false);
    return () => window.removeEventListener('hashchange', fn);
  }
  get href() {
    return this._location.href;
  }
  get protocol() {
    return this._location.protocol;
  }
  get hostname() {
    return this._location.hostname;
  }
  get port() {
    return this._location.port;
  }
  get pathname() {
    return this._location.pathname;
  }
  get search() {
    return this._location.search;
  }
  get hash() {
    return this._location.hash;
  }
  set pathname(newPath) {
    this._location.pathname = newPath;
  }
  pushState(state, title, url) {
    this._history.pushState(state, title, url);
  }
  replaceState(state, title, url) {
    this._history.replaceState(state, title, url);
  }
  forward() {
    this._history.forward();
  }
  back() {
    this._history.back();
  }
  historyGo(relativePosition = 0) {
    this._history.go(relativePosition);
  }
  getState() {
    return this._history.state;
  }
  static ɵfac = function BrowserPlatformLocation_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || BrowserPlatformLocation)();
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: BrowserPlatformLocation,
    factory: () => (() => new BrowserPlatformLocation())(),
    providedIn: 'platform'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__.setClassMetadata(BrowserPlatformLocation, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,
    args: [{
      providedIn: 'platform',
      useFactory: () => new BrowserPlatformLocation()
    }]
  }], () => [], null);
})();


/***/ }),

/***/ 8083:
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/util/reportUnhandledError.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   reportUnhandledError: () => (/* binding */ reportUnhandledError)
/* harmony export */ });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ 1157);
/* harmony import */ var _scheduler_timeoutProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../scheduler/timeoutProvider */ 6275);


function reportUnhandledError(err) {
  _scheduler_timeoutProvider__WEBPACK_IMPORTED_MODULE_1__.timeoutProvider.setTimeout(() => {
    const {
      onUnhandledError
    } = _config__WEBPACK_IMPORTED_MODULE_0__.config;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

/***/ }),

/***/ 8192:
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/util/createErrorClass.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createErrorClass: () => (/* binding */ createErrorClass)
/* harmony export */ });
function createErrorClass(createImpl) {
  const _super = instance => {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  const ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

/***/ }),

/***/ 8277:
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/BehaviorSubject.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BehaviorSubject: () => (/* binding */ BehaviorSubject)
/* harmony export */ });
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Subject */ 1171);

class BehaviorSubject extends _Subject__WEBPACK_IMPORTED_MODULE_0__.Subject {
  constructor(_value) {
    super();
    this._value = _value;
  }
  get value() {
    return this.getValue();
  }
  _subscribe(subscriber) {
    const subscription = super._subscribe(subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  }
  getValue() {
    const {
      hasError,
      thrownError,
      _value
    } = this;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  }
  next(value) {
    super.next(this._value = value);
  }
}

/***/ }),

/***/ 8310:
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/operators/mergeAll.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mergeAll: () => (/* binding */ mergeAll)
/* harmony export */ });
/* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mergeMap */ 1991);
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/identity */ 5232);


function mergeAll(concurrent = Infinity) {
  return (0,_mergeMap__WEBPACK_IMPORTED_MODULE_0__.mergeMap)(_util_identity__WEBPACK_IMPORTED_MODULE_1__.identity, concurrent);
}

/***/ }),

/***/ 8323:
/*!*******************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@angular+platform-browser@21.0.5_@angular+animations@21.0.5_@angular+common@21.0.5_@angular+core@21.0.5/node_modules/@angular/platform-browser/fesm2022/_browser-chunk.mjs ***!
  \*******************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BrowserDomAdapter: () => (/* binding */ BrowserDomAdapter),
/* harmony export */   BrowserGetTestability: () => (/* binding */ BrowserGetTestability),
/* harmony export */   BrowserModule: () => (/* binding */ BrowserModule),
/* harmony export */   KeyEventsPlugin: () => (/* binding */ KeyEventsPlugin),
/* harmony export */   bootstrapApplication: () => (/* binding */ bootstrapApplication),
/* harmony export */   createApplication: () => (/* binding */ createApplication),
/* harmony export */   platformBrowser: () => (/* binding */ platformBrowser),
/* harmony export */   provideProtractorTestingSupport: () => (/* binding */ provideProtractorTestingSupport)
/* harmony export */ });
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ 64);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ 5726);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ 7802);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/common */ 8021);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/common */ 3126);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/core */ 7367);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/core */ 8357);
/* harmony import */ var _dom_renderer_chunk_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_dom_renderer-chunk.mjs */ 519);
/**
 * @license Angular v21.0.5
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */





class BrowserDomAdapter extends _angular_common__WEBPACK_IMPORTED_MODULE_3__.DomAdapter {
  supportsDOMEvents = true;
  static makeCurrent() {
    (0,_angular_common__WEBPACK_IMPORTED_MODULE_3__.setRootDomAdapter)(new BrowserDomAdapter());
  }
  onAndCancel(el, evt, listener, options) {
    el.addEventListener(evt, listener, options);
    return () => {
      el.removeEventListener(evt, listener, options);
    };
  }
  dispatchEvent(el, evt) {
    el.dispatchEvent(evt);
  }
  remove(node) {
    node.remove();
  }
  createElement(tagName, doc) {
    doc = doc || this.getDefaultDocument();
    return doc.createElement(tagName);
  }
  createHtmlDocument() {
    return document.implementation.createHTMLDocument('fakeTitle');
  }
  getDefaultDocument() {
    return document;
  }
  isElementNode(node) {
    return node.nodeType === Node.ELEMENT_NODE;
  }
  isShadowRoot(node) {
    return node instanceof DocumentFragment;
  }
  getGlobalEventTarget(doc, target) {
    if (target === 'window') {
      return window;
    }
    if (target === 'document') {
      return doc;
    }
    if (target === 'body') {
      return doc.body;
    }
    return null;
  }
  getBaseHref(doc) {
    const href = getBaseElementHref();
    return href == null ? null : relativePath(href);
  }
  resetBaseElement() {
    baseElement = null;
  }
  getUserAgent() {
    return window.navigator.userAgent;
  }
  getCookie(name) {
    return (0,_angular_common__WEBPACK_IMPORTED_MODULE_2__.parseCookieValue)(document.cookie, name);
  }
}
let baseElement = null;
function getBaseElementHref() {
  baseElement = baseElement || document.head.querySelector('base');
  return baseElement ? baseElement.getAttribute('href') : null;
}
function relativePath(url) {
  return new URL(url, document.baseURI).pathname;
}
class BrowserGetTestability {
  addToWindow(registry) {
    _angular_common__WEBPACK_IMPORTED_MODULE_0__._global['getAngularTestability'] = (elem, findInAncestors = true) => {
      const testability = registry.findTestabilityInTree(elem, findInAncestors);
      if (testability == null) {
        throw new _angular_common__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(5103, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Could not find testability for element.');
      }
      return testability;
    };
    _angular_common__WEBPACK_IMPORTED_MODULE_0__._global['getAllAngularTestabilities'] = () => registry.getAllTestabilities();
    _angular_common__WEBPACK_IMPORTED_MODULE_0__._global['getAllAngularRootElements'] = () => registry.getAllRootElements();
    const whenAllStable = callback => {
      const testabilities = _angular_common__WEBPACK_IMPORTED_MODULE_0__._global['getAllAngularTestabilities']();
      let count = testabilities.length;
      const decrement = function () {
        count--;
        if (count == 0) {
          callback();
        }
      };
      testabilities.forEach(testability => {
        testability.whenStable(decrement);
      });
    };
    if (!_angular_common__WEBPACK_IMPORTED_MODULE_0__._global['frameworkStabilizers']) {
      _angular_common__WEBPACK_IMPORTED_MODULE_0__._global['frameworkStabilizers'] = [];
    }
    _angular_common__WEBPACK_IMPORTED_MODULE_0__._global['frameworkStabilizers'].push(whenAllStable);
  }
  findTestabilityInTree(registry, elem, findInAncestors) {
    if (elem == null) {
      return null;
    }
    const t = registry.getTestability(elem);
    if (t != null) {
      return t;
    } else if (!findInAncestors) {
      return null;
    }
    if ((0,_angular_common__WEBPACK_IMPORTED_MODULE_3__.getDOM)().isShadowRoot(elem)) {
      return this.findTestabilityInTree(registry, elem.host, true);
    }
    return this.findTestabilityInTree(registry, elem.parentElement, true);
  }
}
class BrowserXhr {
  build() {
    return new XMLHttpRequest();
  }
  static ɵfac = function BrowserXhr_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || BrowserXhr)();
  };
  static ɵprov = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: BrowserXhr,
    factory: BrowserXhr.ɵfac
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_5__.setClassMetadata(BrowserXhr, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Injectable
  }], null, null);
})();
const MODIFIER_KEYS = ['alt', 'control', 'meta', 'shift'];
const _keyMap = {
  '\b': 'Backspace',
  '\t': 'Tab',
  '\x7F': 'Delete',
  '\x1B': 'Escape',
  'Del': 'Delete',
  'Esc': 'Escape',
  'Left': 'ArrowLeft',
  'Right': 'ArrowRight',
  'Up': 'ArrowUp',
  'Down': 'ArrowDown',
  'Menu': 'ContextMenu',
  'Scroll': 'ScrollLock',
  'Win': 'OS'
};
const MODIFIER_KEY_GETTERS = {
  'alt': event => event.altKey,
  'control': event => event.ctrlKey,
  'meta': event => event.metaKey,
  'shift': event => event.shiftKey
};
class KeyEventsPlugin extends _dom_renderer_chunk_mjs__WEBPACK_IMPORTED_MODULE_7__.EventManagerPlugin {
  constructor(doc) {
    super(doc);
  }
  supports(eventName) {
    return KeyEventsPlugin.parseEventName(eventName) != null;
  }
  addEventListener(element, eventName, handler, options) {
    const parsedEvent = KeyEventsPlugin.parseEventName(eventName);
    const outsideHandler = KeyEventsPlugin.eventCallback(parsedEvent['fullKey'], handler, this.manager.getZone());
    return this.manager.getZone().runOutsideAngular(() => {
      return (0,_angular_common__WEBPACK_IMPORTED_MODULE_3__.getDOM)().onAndCancel(element, parsedEvent['domEventName'], outsideHandler, options);
    });
  }
  static parseEventName(eventName) {
    const parts = eventName.toLowerCase().split('.');
    const domEventName = parts.shift();
    if (parts.length === 0 || !(domEventName === 'keydown' || domEventName === 'keyup')) {
      return null;
    }
    const key = KeyEventsPlugin._normalizeKey(parts.pop());
    let fullKey = '';
    let codeIX = parts.indexOf('code');
    if (codeIX > -1) {
      parts.splice(codeIX, 1);
      fullKey = 'code.';
    }
    MODIFIER_KEYS.forEach(modifierName => {
      const index = parts.indexOf(modifierName);
      if (index > -1) {
        parts.splice(index, 1);
        fullKey += modifierName + '.';
      }
    });
    fullKey += key;
    if (parts.length != 0 || key.length === 0) {
      return null;
    }
    const result = {};
    result['domEventName'] = domEventName;
    result['fullKey'] = fullKey;
    return result;
  }
  static matchEventFullKeyCode(event, fullKeyCode) {
    let keycode = _keyMap[event.key] || event.key;
    let key = '';
    if (fullKeyCode.indexOf('code.') > -1) {
      keycode = event.code;
      key = 'code.';
    }
    if (keycode == null || !keycode) return false;
    keycode = keycode.toLowerCase();
    if (keycode === ' ') {
      keycode = 'space';
    } else if (keycode === '.') {
      keycode = 'dot';
    }
    MODIFIER_KEYS.forEach(modifierName => {
      if (modifierName !== keycode) {
        const modifierGetter = MODIFIER_KEY_GETTERS[modifierName];
        if (modifierGetter(event)) {
          key += modifierName + '.';
        }
      }
    });
    key += keycode;
    return key === fullKeyCode;
  }
  static eventCallback(fullKey, handler, zone) {
    return event => {
      if (KeyEventsPlugin.matchEventFullKeyCode(event, fullKey)) {
        zone.runGuarded(() => handler(event));
      }
    };
  }
  static _normalizeKey(keyName) {
    return keyName === 'esc' ? 'escape' : keyName;
  }
  static ɵfac = function KeyEventsPlugin_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || KeyEventsPlugin)(_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT));
  };
  static ɵprov = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: KeyEventsPlugin,
    factory: KeyEventsPlugin.ɵfac
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_5__.setClassMetadata(KeyEventsPlugin, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Injectable
  }], () => [{
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Inject,
      args: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT]
    }]
  }], null);
})();
function bootstrapApplication(rootComponent, options, context) {
  const config = {
    rootComponent,
    platformRef: context?.platformRef,
    ...createProvidersConfig(options)
  };
  if ((typeof ngJitMode === 'undefined' || ngJitMode) && typeof fetch === 'function') {
    return (0,_angular_core__WEBPACK_IMPORTED_MODULE_5__.resolveComponentResources)(fetch).catch(error => {
      console.error(error);
      return Promise.resolve();
    }).then(() => (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__["ɵinternalCreateApplication"])(config));
  }
  return (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__["ɵinternalCreateApplication"])(config);
}
function createApplication(options) {
  return (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__["ɵinternalCreateApplication"])(createProvidersConfig(options));
}
function createProvidersConfig(options) {
  return {
    appProviders: [...BROWSER_MODULE_PROVIDERS, ...(options?.providers ?? [])],
    platformProviders: INTERNAL_BROWSER_PLATFORM_PROVIDERS
  };
}
function provideProtractorTestingSupport() {
  return [...TESTABILITY_PROVIDERS];
}
function initDomAdapter() {
  BrowserDomAdapter.makeCurrent();
}
function errorHandler() {
  return new _angular_common__WEBPACK_IMPORTED_MODULE_0__.ErrorHandler();
}
function _document() {
  (0,_angular_core__WEBPACK_IMPORTED_MODULE_5__.setDocument)(document);
  return document;
}
const INTERNAL_BROWSER_PLATFORM_PROVIDERS = [{
  provide: _angular_core__WEBPACK_IMPORTED_MODULE_5__.PLATFORM_ID,
  useValue: _angular_common__WEBPACK_IMPORTED_MODULE_4__["ɵPLATFORM_BROWSER_ID"]
}, {
  provide: _angular_core__WEBPACK_IMPORTED_MODULE_5__.PLATFORM_INITIALIZER,
  useValue: initDomAdapter,
  multi: true
}, {
  provide: _angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT,
  useFactory: _document
}];
const platformBrowser = (0,_angular_core__WEBPACK_IMPORTED_MODULE_6__.createPlatformFactory)(_angular_core__WEBPACK_IMPORTED_MODULE_6__.platformCore, 'browser', INTERNAL_BROWSER_PLATFORM_PROVIDERS);
const BROWSER_MODULE_PROVIDERS_MARKER = new _angular_common__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'BrowserModule Providers Marker' : '');
const TESTABILITY_PROVIDERS = [{
  provide: _angular_core__WEBPACK_IMPORTED_MODULE_5__.TESTABILITY_GETTER,
  useClass: BrowserGetTestability
}, {
  provide: _angular_core__WEBPACK_IMPORTED_MODULE_5__.TESTABILITY,
  useClass: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Testability
}, {
  provide: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Testability,
  useClass: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Testability
}];
const BROWSER_MODULE_PROVIDERS = [{
  provide: _angular_common__WEBPACK_IMPORTED_MODULE_0__.INJECTOR_SCOPE,
  useValue: 'root'
}, {
  provide: _angular_common__WEBPACK_IMPORTED_MODULE_0__.ErrorHandler,
  useFactory: errorHandler
}, {
  provide: _dom_renderer_chunk_mjs__WEBPACK_IMPORTED_MODULE_7__.EVENT_MANAGER_PLUGINS,
  useClass: _dom_renderer_chunk_mjs__WEBPACK_IMPORTED_MODULE_7__.DomEventsPlugin,
  multi: true
}, {
  provide: _dom_renderer_chunk_mjs__WEBPACK_IMPORTED_MODULE_7__.EVENT_MANAGER_PLUGINS,
  useClass: KeyEventsPlugin,
  multi: true
}, _dom_renderer_chunk_mjs__WEBPACK_IMPORTED_MODULE_7__.DomRendererFactory2, _dom_renderer_chunk_mjs__WEBPACK_IMPORTED_MODULE_7__.SharedStylesHost, _dom_renderer_chunk_mjs__WEBPACK_IMPORTED_MODULE_7__.EventManager, {
  provide: _angular_core__WEBPACK_IMPORTED_MODULE_5__.RendererFactory2,
  useExisting: _dom_renderer_chunk_mjs__WEBPACK_IMPORTED_MODULE_7__.DomRendererFactory2
}, {
  provide: _angular_common__WEBPACK_IMPORTED_MODULE_2__.XhrFactory,
  useClass: BrowserXhr
}, typeof ngDevMode === 'undefined' || ngDevMode ? {
  provide: BROWSER_MODULE_PROVIDERS_MARKER,
  useValue: true
} : []];
class BrowserModule {
  constructor() {
    if (typeof ngDevMode === 'undefined' || ngDevMode) {
      const providersAlreadyPresent = (0,_angular_common__WEBPACK_IMPORTED_MODULE_0__.inject)(BROWSER_MODULE_PROVIDERS_MARKER, {
        optional: true,
        skipSelf: true
      });
      if (providersAlreadyPresent) {
        throw new _angular_common__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(5100, `Providers from the \`BrowserModule\` have already been loaded. If you need access ` + `to common directives such as NgIf and NgFor, import the \`CommonModule\` instead.`);
      }
    }
  }
  static ɵfac = function BrowserModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || BrowserModule)();
  };
  static ɵmod = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵɵdefineNgModule"]({
    type: BrowserModule
  });
  static ɵinj = /* @__PURE__ */_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
    providers: [...BROWSER_MODULE_PROVIDERS, ...TESTABILITY_PROVIDERS],
    imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule, _angular_core__WEBPACK_IMPORTED_MODULE_6__.ApplicationModule]
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_5__.setClassMetadata(BrowserModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.NgModule,
    args: [{
      providers: [...BROWSER_MODULE_PROVIDERS, ...TESTABILITY_PROVIDERS],
      exports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule, _angular_core__WEBPACK_IMPORTED_MODULE_6__.ApplicationModule]
    }]
  }], () => [], null);
})();


/***/ }),

/***/ 8357:
/*!*************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@angular+core@21.0.5_@angular+compiler@21.0.5_rxjs@7.8.2_zone.js@0.16.0/node_modules/@angular/core/fesm2022/core.mjs ***!
  \*************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ANIMATION_MODULE_TYPE: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ANIMATION_MODULE_TYPE),
/* harmony export */   APP_BOOTSTRAP_LISTENER: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.APP_BOOTSTRAP_LISTENER),
/* harmony export */   APP_ID: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.APP_ID),
/* harmony export */   APP_INITIALIZER: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.APP_INITIALIZER),
/* harmony export */   ApplicationInitStatus: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ApplicationInitStatus),
/* harmony export */   ApplicationModule: () => (/* binding */ ApplicationModule),
/* harmony export */   ApplicationRef: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ApplicationRef),
/* harmony export */   Attribute: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Attribute),
/* harmony export */   COMPILER_OPTIONS: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.COMPILER_OPTIONS),
/* harmony export */   CSP_NONCE: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.CSP_NONCE),
/* harmony export */   CUSTOM_ELEMENTS_SCHEMA: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.CUSTOM_ELEMENTS_SCHEMA),
/* harmony export */   ChangeDetectionStrategy: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectionStrategy),
/* harmony export */   ChangeDetectorRef: () => (/* binding */ ChangeDetectorRef),
/* harmony export */   Compiler: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Compiler),
/* harmony export */   CompilerFactory: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.CompilerFactory),
/* harmony export */   Component: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Component),
/* harmony export */   ComponentFactory: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ComponentFactory$1),
/* harmony export */   ComponentFactoryResolver: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ComponentFactoryResolver),
/* harmony export */   ComponentRef: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ComponentRef),
/* harmony export */   ContentChild: () => (/* binding */ ContentChild),
/* harmony export */   ContentChildren: () => (/* binding */ ContentChildren),
/* harmony export */   DEFAULT_CURRENCY_CODE: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_CURRENCY_CODE),
/* harmony export */   DOCUMENT: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT),
/* harmony export */   DebugElement: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DebugElement),
/* harmony export */   DebugEventListener: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DebugEventListener),
/* harmony export */   DebugNode: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DebugNode),
/* harmony export */   DefaultIterableDiffer: () => (/* binding */ DefaultIterableDiffer),
/* harmony export */   DestroyRef: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.DestroyRef),
/* harmony export */   Directive: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Directive),
/* harmony export */   ENVIRONMENT_INITIALIZER: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ENVIRONMENT_INITIALIZER),
/* harmony export */   ElementRef: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ElementRef),
/* harmony export */   EmbeddedViewRef: () => (/* binding */ EmbeddedViewRef),
/* harmony export */   EnvironmentInjector: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.EnvironmentInjector),
/* harmony export */   ErrorHandler: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ErrorHandler),
/* harmony export */   EventEmitter: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.EventEmitter),
/* harmony export */   HOST_TAG_NAME: () => (/* binding */ HOST_TAG_NAME),
/* harmony export */   Host: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Host),
/* harmony export */   HostAttributeToken: () => (/* binding */ HostAttributeToken),
/* harmony export */   HostBinding: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.HostBinding),
/* harmony export */   HostListener: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.HostListener),
/* harmony export */   INJECTOR: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.INJECTOR),
/* harmony export */   Inject: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Inject),
/* harmony export */   Injectable: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Injectable),
/* harmony export */   InjectionToken: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.InjectionToken),
/* harmony export */   Injector: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.Injector),
/* harmony export */   Input: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Input),
/* harmony export */   IterableDiffers: () => (/* binding */ IterableDiffers),
/* harmony export */   KeyValueDiffers: () => (/* binding */ KeyValueDiffers),
/* harmony export */   LOCALE_ID: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.LOCALE_ID),
/* harmony export */   MAX_ANIMATION_TIMEOUT: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.MAX_ANIMATION_TIMEOUT),
/* harmony export */   MissingTranslationStrategy: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.MissingTranslationStrategy),
/* harmony export */   ModuleWithComponentFactories: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ModuleWithComponentFactories),
/* harmony export */   NO_ERRORS_SCHEMA: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NO_ERRORS_SCHEMA),
/* harmony export */   NgModule: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NgModule),
/* harmony export */   NgModuleFactory: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NgModuleFactory$1),
/* harmony export */   NgModuleRef: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NgModuleRef$1),
/* harmony export */   NgZone: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NgZone),
/* harmony export */   Optional: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Optional),
/* harmony export */   Output: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Output),
/* harmony export */   OutputEmitterRef: () => (/* reexport safe */ _resource_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.OutputEmitterRef),
/* harmony export */   PLATFORM_ID: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.PLATFORM_ID),
/* harmony export */   PLATFORM_INITIALIZER: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.PLATFORM_INITIALIZER),
/* harmony export */   PendingTasks: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.PendingTasks),
/* harmony export */   Pipe: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Pipe),
/* harmony export */   PlatformRef: () => (/* binding */ PlatformRef),
/* harmony export */   Query: () => (/* binding */ Query),
/* harmony export */   QueryList: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.QueryList),
/* harmony export */   REQUEST: () => (/* binding */ REQUEST),
/* harmony export */   REQUEST_CONTEXT: () => (/* binding */ REQUEST_CONTEXT),
/* harmony export */   RESPONSE_INIT: () => (/* binding */ RESPONSE_INIT),
/* harmony export */   Renderer2: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Renderer2),
/* harmony export */   RendererFactory2: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.RendererFactory2),
/* harmony export */   RendererStyleFlags2: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.RendererStyleFlags2),
/* harmony export */   Sanitizer: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Sanitizer),
/* harmony export */   SecurityContext: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SecurityContext),
/* harmony export */   Self: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Self),
/* harmony export */   SimpleChange: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SimpleChange),
/* harmony export */   SkipSelf: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SkipSelf),
/* harmony export */   TRANSLATIONS: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TRANSLATIONS),
/* harmony export */   TRANSLATIONS_FORMAT: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TRANSLATIONS_FORMAT),
/* harmony export */   TemplateRef: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TemplateRef),
/* harmony export */   Testability: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Testability),
/* harmony export */   TestabilityRegistry: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TestabilityRegistry),
/* harmony export */   TransferState: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TransferState),
/* harmony export */   Type: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Type),
/* harmony export */   VERSION: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.VERSION),
/* harmony export */   Version: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.Version),
/* harmony export */   ViewChild: () => (/* binding */ ViewChild),
/* harmony export */   ViewChildren: () => (/* binding */ ViewChildren),
/* harmony export */   ViewContainerRef: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ViewContainerRef),
/* harmony export */   ViewEncapsulation: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ViewEncapsulation),
/* harmony export */   ViewRef: () => (/* binding */ ViewRef),
/* harmony export */   afterEveryRender: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.afterEveryRender),
/* harmony export */   afterNextRender: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.afterNextRender),
/* harmony export */   afterRenderEffect: () => (/* binding */ afterRenderEffect),
/* harmony export */   asNativeElements: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.asNativeElements),
/* harmony export */   assertInInjectionContext: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertInInjectionContext),
/* harmony export */   assertNotInReactiveContext: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertNotInReactiveContext),
/* harmony export */   assertPlatform: () => (/* binding */ assertPlatform),
/* harmony export */   booleanAttribute: () => (/* binding */ booleanAttribute),
/* harmony export */   computed: () => (/* reexport safe */ _resource_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.computed),
/* harmony export */   contentChild: () => (/* binding */ contentChild),
/* harmony export */   contentChildren: () => (/* binding */ contentChildren),
/* harmony export */   createComponent: () => (/* binding */ createComponent),
/* harmony export */   createEnvironmentInjector: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.createEnvironmentInjector),
/* harmony export */   createNgModule: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.createNgModule),
/* harmony export */   createNgModuleRef: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.createNgModuleRef),
/* harmony export */   createPlatform: () => (/* binding */ createPlatform),
/* harmony export */   createPlatformFactory: () => (/* binding */ createPlatformFactory),
/* harmony export */   destroyPlatform: () => (/* binding */ destroyPlatform),
/* harmony export */   effect: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.effect),
/* harmony export */   enableProdMode: () => (/* binding */ enableProdMode),
/* harmony export */   enableProfiling: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enableProfiling),
/* harmony export */   forwardRef: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.forwardRef),
/* harmony export */   getDebugNode: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getDebugNode),
/* harmony export */   getModuleFactory: () => (/* binding */ getModuleFactory),
/* harmony export */   getNgModuleById: () => (/* binding */ getNgModuleById),
/* harmony export */   getPlatform: () => (/* binding */ getPlatform),
/* harmony export */   importProvidersFrom: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.importProvidersFrom),
/* harmony export */   inject: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   input: () => (/* binding */ input),
/* harmony export */   inputBinding: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.inputBinding),
/* harmony export */   isDevMode: () => (/* binding */ isDevMode),
/* harmony export */   isSignal: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isSignal),
/* harmony export */   isStandalone: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isStandalone),
/* harmony export */   isWritableSignal: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isWritableSignal),
/* harmony export */   linkedSignal: () => (/* reexport safe */ _resource_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.linkedSignal),
/* harmony export */   makeEnvironmentProviders: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.makeEnvironmentProviders),
/* harmony export */   makeStateKey: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.makeStateKey),
/* harmony export */   mergeApplicationConfig: () => (/* binding */ mergeApplicationConfig),
/* harmony export */   model: () => (/* binding */ model),
/* harmony export */   numberAttribute: () => (/* binding */ numberAttribute),
/* harmony export */   output: () => (/* binding */ output),
/* harmony export */   outputBinding: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.outputBinding),
/* harmony export */   platformCore: () => (/* binding */ platformCore),
/* harmony export */   provideAppInitializer: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.provideAppInitializer),
/* harmony export */   provideBrowserGlobalErrorListeners: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.provideBrowserGlobalErrorListeners),
/* harmony export */   provideCheckNoChangesConfig: () => (/* binding */ provideCheckNoChangesConfig),
/* harmony export */   provideEnvironmentInitializer: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.provideEnvironmentInitializer),
/* harmony export */   provideNgReflectAttributes: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.provideNgReflectAttributes),
/* harmony export */   providePlatformInitializer: () => (/* binding */ providePlatformInitializer),
/* harmony export */   provideZoneChangeDetection: () => (/* binding */ provideZoneChangeDetection),
/* harmony export */   provideZonelessChangeDetection: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.provideZonelessChangeDetection),
/* harmony export */   reflectComponentType: () => (/* binding */ reflectComponentType),
/* harmony export */   resolveForwardRef: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.resolveForwardRef),
/* harmony export */   resource: () => (/* reexport safe */ _resource_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.resource),
/* harmony export */   runInInjectionContext: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.runInInjectionContext),
/* harmony export */   setTestabilityGetter: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setTestabilityGetter),
/* harmony export */   signal: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.signal),
/* harmony export */   twoWayBinding: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.twoWayBinding),
/* harmony export */   untracked: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.untracked),
/* harmony export */   viewChild: () => (/* binding */ viewChild),
/* harmony export */   viewChildren: () => (/* binding */ viewChildren),
/* harmony export */   "ɵANIMATIONS_DISABLED": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ANIMATIONS_DISABLED),
/* harmony export */   "ɵAcxChangeDetectionStrategy": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.AcxChangeDetectionStrategy),
/* harmony export */   "ɵAcxViewEncapsulation": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.AcxViewEncapsulation),
/* harmony export */   "ɵAfterRenderManager": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.AfterRenderManager),
/* harmony export */   "ɵCLIENT_RENDER_MODE_FLAG": () => (/* binding */ CLIENT_RENDER_MODE_FLAG),
/* harmony export */   "ɵCONTAINER_HEADER_OFFSET": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.CONTAINER_HEADER_OFFSET),
/* harmony export */   "ɵCONTROL": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵCONTROL"]),
/* harmony export */   "ɵChangeDetectionScheduler": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionScheduler),
/* harmony export */   "ɵComponentFactory": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ComponentFactory$1),
/* harmony export */   "ɵConsole": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Console),
/* harmony export */   "ɵDEFAULT_LOCALE_ID": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_LOCALE_ID),
/* harmony export */   "ɵDEFER_BLOCK_CONFIG": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFER_BLOCK_CONFIG),
/* harmony export */   "ɵDEFER_BLOCK_DEPENDENCY_INTERCEPTOR": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFER_BLOCK_DEPENDENCY_INTERCEPTOR),
/* harmony export */   "ɵDEHYDRATED_BLOCK_REGISTRY": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEHYDRATED_BLOCK_REGISTRY),
/* harmony export */   "ɵDeferBlockBehavior": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DeferBlockBehavior),
/* harmony export */   "ɵDeferBlockState": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DeferBlockState),
/* harmony export */   "ɵENABLE_ROOT_COMPONENT_BOOTSTRAP": () => (/* binding */ ENABLE_ROOT_COMPONENT_BOOTSTRAP),
/* harmony export */   "ɵEffectScheduler": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.EffectScheduler),
/* harmony export */   "ɵFramework": () => (/* binding */ Framework),
/* harmony export */   "ɵHydrationStatus": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.HydrationStatus),
/* harmony export */   "ɵIMAGE_CONFIG": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IMAGE_CONFIG),
/* harmony export */   "ɵIMAGE_CONFIG_DEFAULTS": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IMAGE_CONFIG_DEFAULTS),
/* harmony export */   "ɵINJECTOR_SCOPE": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.INJECTOR_SCOPE),
/* harmony export */   "ɵINPUT_SIGNAL_BRAND_WRITE_TYPE": () => (/* binding */ ɵINPUT_SIGNAL_BRAND_WRITE_TYPE),
/* harmony export */   "ɵINTERNAL_APPLICATION_ERROR_HANDLER": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_APPLICATION_ERROR_HANDLER),
/* harmony export */   "ɵIS_ENABLED_BLOCKING_INITIAL_NAVIGATION": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_ENABLED_BLOCKING_INITIAL_NAVIGATION),
/* harmony export */   "ɵIS_HYDRATION_DOM_REUSE_ENABLED": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_HYDRATION_DOM_REUSE_ENABLED),
/* harmony export */   "ɵIS_INCREMENTAL_HYDRATION_ENABLED": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_INCREMENTAL_HYDRATION_ENABLED),
/* harmony export */   "ɵJSACTION_BLOCK_ELEMENT_MAP": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.JSACTION_BLOCK_ELEMENT_MAP),
/* harmony export */   "ɵJSACTION_EVENT_CONTRACT": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.JSACTION_EVENT_CONTRACT),
/* harmony export */   "ɵLContext": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.LContext),
/* harmony export */   "ɵLocaleDataIndex": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.LocaleDataIndex),
/* harmony export */   "ɵNG_COMP_DEF": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NG_COMP_DEF),
/* harmony export */   "ɵNG_DIR_DEF": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NG_DIR_DEF),
/* harmony export */   "ɵNG_ELEMENT_ID": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NG_ELEMENT_ID),
/* harmony export */   "ɵNG_INJ_DEF": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NG_INJ_DEF),
/* harmony export */   "ɵNG_MOD_DEF": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NG_MOD_DEF),
/* harmony export */   "ɵNG_PIPE_DEF": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NG_PIPE_DEF),
/* harmony export */   "ɵNG_PROV_DEF": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NG_PROV_DEF),
/* harmony export */   "ɵNOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR),
/* harmony export */   "ɵNO_CHANGE": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NO_CHANGE),
/* harmony export */   "ɵNgModuleFactory": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NgModuleFactory),
/* harmony export */   "ɵNoopNgZone": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NoopNgZone),
/* harmony export */   "ɵPERFORMANCE_MARK_PREFIX": () => (/* binding */ PERFORMANCE_MARK_PREFIX),
/* harmony export */   "ɵPROVIDED_NG_ZONE": () => (/* binding */ PROVIDED_NG_ZONE),
/* harmony export */   "ɵPROVIDED_ZONELESS": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.PROVIDED_ZONELESS),
/* harmony export */   "ɵPendingTasksInternal": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.PendingTasksInternal),
/* harmony export */   "ɵProfilerEvent": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ProfilerEvent),
/* harmony export */   "ɵR3Injector": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.R3Injector),
/* harmony export */   "ɵReflectionCapabilities": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ReflectionCapabilities),
/* harmony export */   "ɵRender3ComponentFactory": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ComponentFactory),
/* harmony export */   "ɵRender3ComponentRef": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ComponentRef$1),
/* harmony export */   "ɵRender3NgModuleRef": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NgModuleRef),
/* harmony export */   "ɵResourceImpl": () => (/* reexport safe */ _resource_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.ResourceImpl),
/* harmony export */   "ɵRuntimeError": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError),
/* harmony export */   "ɵSIGNAL": () => (/* reexport safe */ _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.SIGNAL),
/* harmony export */   "ɵSSR_CONTENT_INTEGRITY_MARKER": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SSR_CONTENT_INTEGRITY_MARKER),
/* harmony export */   "ɵTESTABILITY": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TESTABILITY),
/* harmony export */   "ɵTESTABILITY_GETTER": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TESTABILITY_GETTER),
/* harmony export */   "ɵTimerScheduler": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TimerScheduler),
/* harmony export */   "ɵTracingAction": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TracingAction),
/* harmony export */   "ɵTracingService": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TracingService),
/* harmony export */   "ɵViewRef": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ViewRef),
/* harmony export */   "ɵXSS_SECURITY_URL": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.XSS_SECURITY_URL),
/* harmony export */   "ɵZONELESS_ENABLED": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ZONELESS_ENABLED),
/* harmony export */   "ɵ_sanitizeHtml": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__._sanitizeHtml),
/* harmony export */   "ɵ_sanitizeUrl": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__._sanitizeUrl),
/* harmony export */   "ɵallLeavingAnimations": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.allLeavingAnimations),
/* harmony export */   "ɵallowSanitizationBypassAndThrow": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.allowSanitizationBypassAndThrow),
/* harmony export */   "ɵannotateForHydration": () => (/* binding */ annotateForHydration),
/* harmony export */   "ɵassertType": () => (/* binding */ ɵassertType),
/* harmony export */   "ɵbypassSanitizationTrustHtml": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.bypassSanitizationTrustHtml),
/* harmony export */   "ɵbypassSanitizationTrustResourceUrl": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.bypassSanitizationTrustResourceUrl),
/* harmony export */   "ɵbypassSanitizationTrustScript": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.bypassSanitizationTrustScript),
/* harmony export */   "ɵbypassSanitizationTrustStyle": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.bypassSanitizationTrustStyle),
/* harmony export */   "ɵbypassSanitizationTrustUrl": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.bypassSanitizationTrustUrl),
/* harmony export */   "ɵclearResolutionOfComponentResourcesQueue": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.clearResolutionOfComponentResourcesQueue),
/* harmony export */   "ɵcompileComponent": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.compileComponent),
/* harmony export */   "ɵcompileDirective": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.compileDirective),
/* harmony export */   "ɵcompileNgModule": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.compileNgModule),
/* harmony export */   "ɵcompileNgModuleDefs": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.compileNgModuleDefs),
/* harmony export */   "ɵcompileNgModuleFactory": () => (/* binding */ compileNgModuleFactory),
/* harmony export */   "ɵcompilePipe": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.compilePipe),
/* harmony export */   "ɵcontrolUpdate": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵcontrolUpdate"]),
/* harmony export */   "ɵconvertToBitFlags": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.convertToBitFlags),
/* harmony export */   "ɵcreateInjector": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.createInjector),
/* harmony export */   "ɵcreateOrReusePlatformInjector": () => (/* binding */ createOrReusePlatformInjector),
/* harmony export */   "ɵdefaultIterableDiffers": () => (/* binding */ defaultIterableDiffers),
/* harmony export */   "ɵdefaultKeyValueDiffers": () => (/* binding */ defaultKeyValueDiffers),
/* harmony export */   "ɵdepsTracker": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.depsTracker),
/* harmony export */   "ɵdevModeEqual": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.devModeEqual),
/* harmony export */   "ɵdisableProfiling": () => (/* binding */ disableProfiling),
/* harmony export */   "ɵenableProfiling": () => (/* binding */ enableProfiling),
/* harmony export */   "ɵencapsulateResourceError": () => (/* reexport safe */ _resource_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.encapsulateResourceError),
/* harmony export */   "ɵfindLocaleData": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.findLocaleData),
/* harmony export */   "ɵflushModuleScopingQueueAsMuchAsPossible": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.flushModuleScopingQueueAsMuchAsPossible),
/* harmony export */   "ɵformatRuntimeError": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.formatRuntimeError),
/* harmony export */   "ɵgenerateStandaloneInDeclarationsError": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.generateStandaloneInDeclarationsError),
/* harmony export */   "ɵgetAsyncClassMetadataFn": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getAsyncClassMetadataFn),
/* harmony export */   "ɵgetClosestComponentName": () => (/* binding */ getClosestComponentName),
/* harmony export */   "ɵgetComponentDef": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getComponentDef),
/* harmony export */   "ɵgetDebugNode": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getDebugNode),
/* harmony export */   "ɵgetDeferBlocks": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getDeferBlocks),
/* harmony export */   "ɵgetDirectives": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getDirectives),
/* harmony export */   "ɵgetDocument": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getDocument),
/* harmony export */   "ɵgetHostElement": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getHostElement),
/* harmony export */   "ɵgetInjectableDef": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getInjectableDef),
/* harmony export */   "ɵgetLContext": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getLContext),
/* harmony export */   "ɵgetLocaleCurrencyCode": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getLocaleCurrencyCode),
/* harmony export */   "ɵgetLocalePluralCase": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getLocalePluralCase),
/* harmony export */   "ɵgetOutputDestroyRef": () => (/* reexport safe */ _resource_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.getOutputDestroyRef),
/* harmony export */   "ɵgetSanitizationBypassType": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getSanitizationBypassType),
/* harmony export */   "ɵgetTransferState": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getTransferState),
/* harmony export */   "ɵgetUnknownElementStrictMode": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵgetUnknownElementStrictMode"]),
/* harmony export */   "ɵgetUnknownPropertyStrictMode": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵgetUnknownPropertyStrictMode"]),
/* harmony export */   "ɵglobal": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__._global),
/* harmony export */   "ɵinferTagNameFromDefinition": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.inferTagNameFromDefinition),
/* harmony export */   "ɵinjectChangeDetectorRef": () => (/* binding */ injectChangeDetectorRef),
/* harmony export */   "ɵinternalCreateApplication": () => (/* binding */ internalCreateApplication),
/* harmony export */   "ɵinternalProvideZoneChangeDetection": () => (/* binding */ internalProvideZoneChangeDetection),
/* harmony export */   "ɵisBoundToModule": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isBoundToModule),
/* harmony export */   "ɵisComponentDefPendingResolution": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isComponentDefPendingResolution),
/* harmony export */   "ɵisEnvironmentProviders": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isEnvironmentProviders),
/* harmony export */   "ɵisInjectable": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isInjectable),
/* harmony export */   "ɵisNgModule": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isNgModule),
/* harmony export */   "ɵisPromise": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isPromise),
/* harmony export */   "ɵisSubscribable": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isSubscribable),
/* harmony export */   "ɵisViewDirty": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isViewDirty),
/* harmony export */   "ɵmarkForRefresh": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.markForRefresh),
/* harmony export */   "ɵnoSideEffects": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.noSideEffects),
/* harmony export */   "ɵpatchComponentDefWithScope": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.patchComponentDefWithScope),
/* harmony export */   "ɵperformanceMarkFeature": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.performanceMarkFeature),
/* harmony export */   "ɵprovideZonelessChangeDetectionInternal": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.provideZonelessChangeDetectionInternal),
/* harmony export */   "ɵpublishExternalGlobalUtil": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.publishExternalGlobalUtil),
/* harmony export */   "ɵreadHydrationInfo": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.readHydrationInfo),
/* harmony export */   "ɵregisterLocaleData": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.registerLocaleData),
/* harmony export */   "ɵrenderDeferBlockState": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.renderDeferBlockState),
/* harmony export */   "ɵresetCompiledComponents": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.resetCompiledComponents),
/* harmony export */   "ɵresetIncrementalHydrationEnabledWarnedForTests": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.resetIncrementalHydrationEnabledWarnedForTests),
/* harmony export */   "ɵresetJitOptions": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.resetJitOptions),
/* harmony export */   "ɵresolveComponentResources": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.resolveComponentResources),
/* harmony export */   "ɵrestoreComponentResolutionQueue": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.restoreComponentResolutionQueue),
/* harmony export */   "ɵsetAllowDuplicateNgModuleIdsForTest": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setAllowDuplicateNgModuleIdsForTest),
/* harmony export */   "ɵsetAlternateWeakRefImpl": () => (/* reexport safe */ _weak_ref_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__.setAlternateWeakRefImpl),
/* harmony export */   "ɵsetClassDebugInfo": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵsetClassDebugInfo"]),
/* harmony export */   "ɵsetClassMetadata": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata),
/* harmony export */   "ɵsetClassMetadataAsync": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setClassMetadataAsync),
/* harmony export */   "ɵsetCurrentInjector": () => (/* reexport safe */ _not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_6__.setCurrentInjector),
/* harmony export */   "ɵsetDocument": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setDocument),
/* harmony export */   "ɵsetInjectorProfilerContext": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.setInjectorProfilerContext),
/* harmony export */   "ɵsetLocaleId": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setLocaleId),
/* harmony export */   "ɵsetUnknownElementStrictMode": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵsetUnknownElementStrictMode"]),
/* harmony export */   "ɵsetUnknownPropertyStrictMode": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵsetUnknownPropertyStrictMode"]),
/* harmony export */   "ɵstartMeasuring": () => (/* binding */ startMeasuring),
/* harmony export */   "ɵstopMeasuring": () => (/* binding */ stopMeasuring),
/* harmony export */   "ɵstore": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.store),
/* harmony export */   "ɵstringify": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.stringify),
/* harmony export */   "ɵtransitiveScopesFor": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.transitiveScopesFor),
/* harmony export */   "ɵtriggerResourceLoading": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.triggerResourceLoading),
/* harmony export */   "ɵtruncateMiddle": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.truncateMiddle),
/* harmony export */   "ɵunregisterLocaleData": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.unregisterAllLocaleData),
/* harmony export */   "ɵunwrapSafeValue": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.unwrapSafeValue),
/* harmony export */   "ɵunwrapWritableSignal": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵunwrapWritableSignal"]),
/* harmony export */   "ɵwithDomHydration": () => (/* binding */ withDomHydration),
/* harmony export */   "ɵwithEventReplay": () => (/* binding */ withEventReplay),
/* harmony export */   "ɵwithI18nSupport": () => (/* binding */ withI18nSupport),
/* harmony export */   "ɵwithIncrementalHydration": () => (/* binding */ withIncrementalHydration),
/* harmony export */   "ɵɵExternalStylesFeature": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵExternalStylesFeature"]),
/* harmony export */   "ɵɵFactoryTarget": () => (/* binding */ FactoryTarget),
/* harmony export */   "ɵɵHostDirectivesFeature": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵHostDirectivesFeature"]),
/* harmony export */   "ɵɵInheritDefinitionFeature": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵInheritDefinitionFeature"]),
/* harmony export */   "ɵɵNgOnChangesFeature": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵNgOnChangesFeature"]),
/* harmony export */   "ɵɵProvidersFeature": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵProvidersFeature"]),
/* harmony export */   "ɵɵadvance": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"]),
/* harmony export */   "ɵɵanimateEnter": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵanimateEnter"]),
/* harmony export */   "ɵɵanimateEnterListener": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵanimateEnterListener"]),
/* harmony export */   "ɵɵanimateLeave": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵanimateLeave"]),
/* harmony export */   "ɵɵanimateLeaveListener": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵanimateLeaveListener"]),
/* harmony export */   "ɵɵariaProperty": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵariaProperty"]),
/* harmony export */   "ɵɵattachSourceLocations": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵattachSourceLocations"]),
/* harmony export */   "ɵɵattribute": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵattribute"]),
/* harmony export */   "ɵɵclassMap": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵclassMap"]),
/* harmony export */   "ɵɵclassProp": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵclassProp"]),
/* harmony export */   "ɵɵcomponentInstance": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵcomponentInstance"]),
/* harmony export */   "ɵɵconditional": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵconditional"]),
/* harmony export */   "ɵɵconditionalBranchCreate": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵconditionalBranchCreate"]),
/* harmony export */   "ɵɵconditionalCreate": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵconditionalCreate"]),
/* harmony export */   "ɵɵcontentQuery": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵcontentQuery"]),
/* harmony export */   "ɵɵcontentQuerySignal": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵcontentQuerySignal"]),
/* harmony export */   "ɵɵcontrol": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵcontrol"]),
/* harmony export */   "ɵɵcontrolCreate": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵcontrolCreate"]),
/* harmony export */   "ɵɵdeclareLet": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeclareLet"]),
/* harmony export */   "ɵɵdefer": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefer"]),
/* harmony export */   "ɵɵdeferEnableTimerScheduling": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferEnableTimerScheduling"]),
/* harmony export */   "ɵɵdeferHydrateNever": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferHydrateNever"]),
/* harmony export */   "ɵɵdeferHydrateOnHover": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferHydrateOnHover"]),
/* harmony export */   "ɵɵdeferHydrateOnIdle": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferHydrateOnIdle"]),
/* harmony export */   "ɵɵdeferHydrateOnImmediate": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferHydrateOnImmediate"]),
/* harmony export */   "ɵɵdeferHydrateOnInteraction": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferHydrateOnInteraction"]),
/* harmony export */   "ɵɵdeferHydrateOnTimer": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferHydrateOnTimer"]),
/* harmony export */   "ɵɵdeferHydrateOnViewport": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferHydrateOnViewport"]),
/* harmony export */   "ɵɵdeferHydrateWhen": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferHydrateWhen"]),
/* harmony export */   "ɵɵdeferOnHover": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferOnHover"]),
/* harmony export */   "ɵɵdeferOnIdle": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferOnIdle"]),
/* harmony export */   "ɵɵdeferOnImmediate": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferOnImmediate"]),
/* harmony export */   "ɵɵdeferOnInteraction": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferOnInteraction"]),
/* harmony export */   "ɵɵdeferOnTimer": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferOnTimer"]),
/* harmony export */   "ɵɵdeferOnViewport": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferOnViewport"]),
/* harmony export */   "ɵɵdeferPrefetchOnHover": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferPrefetchOnHover"]),
/* harmony export */   "ɵɵdeferPrefetchOnIdle": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferPrefetchOnIdle"]),
/* harmony export */   "ɵɵdeferPrefetchOnImmediate": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferPrefetchOnImmediate"]),
/* harmony export */   "ɵɵdeferPrefetchOnInteraction": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferPrefetchOnInteraction"]),
/* harmony export */   "ɵɵdeferPrefetchOnTimer": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferPrefetchOnTimer"]),
/* harmony export */   "ɵɵdeferPrefetchOnViewport": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferPrefetchOnViewport"]),
/* harmony export */   "ɵɵdeferPrefetchWhen": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferPrefetchWhen"]),
/* harmony export */   "ɵɵdeferWhen": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferWhen"]),
/* harmony export */   "ɵɵdefineComponent": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineComponent"]),
/* harmony export */   "ɵɵdefineDirective": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineDirective"]),
/* harmony export */   "ɵɵdefineInjectable": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]),
/* harmony export */   "ɵɵdefineInjector": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]),
/* harmony export */   "ɵɵdefineNgModule": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineNgModule"]),
/* harmony export */   "ɵɵdefinePipe": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefinePipe"]),
/* harmony export */   "ɵɵdirectiveInject": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"]),
/* harmony export */   "ɵɵdisableBindings": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵdisableBindings"]),
/* harmony export */   "ɵɵdomElement": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdomElement"]),
/* harmony export */   "ɵɵdomElementContainer": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdomElementContainer"]),
/* harmony export */   "ɵɵdomElementContainerEnd": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdomElementContainerEnd"]),
/* harmony export */   "ɵɵdomElementContainerStart": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdomElementContainerStart"]),
/* harmony export */   "ɵɵdomElementEnd": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdomElementEnd"]),
/* harmony export */   "ɵɵdomElementStart": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdomElementStart"]),
/* harmony export */   "ɵɵdomListener": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdomListener"]),
/* harmony export */   "ɵɵdomProperty": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdomProperty"]),
/* harmony export */   "ɵɵdomTemplate": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdomTemplate"]),
/* harmony export */   "ɵɵelement": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"]),
/* harmony export */   "ɵɵelementContainer": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementContainer"]),
/* harmony export */   "ɵɵelementContainerEnd": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementContainerEnd"]),
/* harmony export */   "ɵɵelementContainerStart": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementContainerStart"]),
/* harmony export */   "ɵɵelementEnd": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]),
/* harmony export */   "ɵɵelementStart": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"]),
/* harmony export */   "ɵɵenableBindings": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵenableBindings"]),
/* harmony export */   "ɵɵgetComponentDepsFactory": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵgetComponentDepsFactory"]),
/* harmony export */   "ɵɵgetCurrentView": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵgetCurrentView"]),
/* harmony export */   "ɵɵgetInheritedFactory": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵgetInheritedFactory"]),
/* harmony export */   "ɵɵgetReplaceMetadataURL": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵgetReplaceMetadataURL"]),
/* harmony export */   "ɵɵi18n": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵi18n"]),
/* harmony export */   "ɵɵi18nApply": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵi18nApply"]),
/* harmony export */   "ɵɵi18nAttributes": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵi18nAttributes"]),
/* harmony export */   "ɵɵi18nEnd": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵi18nEnd"]),
/* harmony export */   "ɵɵi18nExp": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵi18nExp"]),
/* harmony export */   "ɵɵi18nPostprocess": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵi18nPostprocess"]),
/* harmony export */   "ɵɵi18nStart": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵi18nStart"]),
/* harmony export */   "ɵɵinject": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"]),
/* harmony export */   "ɵɵinjectAttribute": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵinjectAttribute"]),
/* harmony export */   "ɵɵinterpolate": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵinterpolate"]),
/* harmony export */   "ɵɵinterpolate1": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵinterpolate1"]),
/* harmony export */   "ɵɵinterpolate2": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵinterpolate2"]),
/* harmony export */   "ɵɵinterpolate3": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵinterpolate3"]),
/* harmony export */   "ɵɵinterpolate4": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵinterpolate4"]),
/* harmony export */   "ɵɵinterpolate5": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵinterpolate5"]),
/* harmony export */   "ɵɵinterpolate6": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵinterpolate6"]),
/* harmony export */   "ɵɵinterpolate7": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵinterpolate7"]),
/* harmony export */   "ɵɵinterpolate8": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵinterpolate8"]),
/* harmony export */   "ɵɵinterpolateV": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵinterpolateV"]),
/* harmony export */   "ɵɵinvalidFactory": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵinvalidFactory"]),
/* harmony export */   "ɵɵinvalidFactoryDep": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵinvalidFactoryDep"]),
/* harmony export */   "ɵɵlistener": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵlistener"]),
/* harmony export */   "ɵɵloadQuery": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵloadQuery"]),
/* harmony export */   "ɵɵnamespaceHTML": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵnamespaceHTML"]),
/* harmony export */   "ɵɵnamespaceMathML": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵnamespaceMathML"]),
/* harmony export */   "ɵɵnamespaceSVG": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵnamespaceSVG"]),
/* harmony export */   "ɵɵnextContext": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]),
/* harmony export */   "ɵɵngDeclareClassMetadata": () => (/* binding */ ɵɵngDeclareClassMetadata),
/* harmony export */   "ɵɵngDeclareClassMetadataAsync": () => (/* binding */ ɵɵngDeclareClassMetadataAsync),
/* harmony export */   "ɵɵngDeclareComponent": () => (/* binding */ ɵɵngDeclareComponent),
/* harmony export */   "ɵɵngDeclareDirective": () => (/* binding */ ɵɵngDeclareDirective),
/* harmony export */   "ɵɵngDeclareFactory": () => (/* binding */ ɵɵngDeclareFactory),
/* harmony export */   "ɵɵngDeclareInjectable": () => (/* binding */ ɵɵngDeclareInjectable),
/* harmony export */   "ɵɵngDeclareInjector": () => (/* binding */ ɵɵngDeclareInjector),
/* harmony export */   "ɵɵngDeclareNgModule": () => (/* binding */ ɵɵngDeclareNgModule),
/* harmony export */   "ɵɵngDeclarePipe": () => (/* binding */ ɵɵngDeclarePipe),
/* harmony export */   "ɵɵpipe": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpipe"]),
/* harmony export */   "ɵɵpipeBind1": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpipeBind1"]),
/* harmony export */   "ɵɵpipeBind2": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpipeBind2"]),
/* harmony export */   "ɵɵpipeBind3": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpipeBind3"]),
/* harmony export */   "ɵɵpipeBind4": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpipeBind4"]),
/* harmony export */   "ɵɵpipeBindV": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpipeBindV"]),
/* harmony export */   "ɵɵprojection": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵprojection"]),
/* harmony export */   "ɵɵprojectionDef": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵprojectionDef"]),
/* harmony export */   "ɵɵproperty": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]),
/* harmony export */   "ɵɵpureFunction0": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpureFunction0"]),
/* harmony export */   "ɵɵpureFunction1": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpureFunction1"]),
/* harmony export */   "ɵɵpureFunction2": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpureFunction2"]),
/* harmony export */   "ɵɵpureFunction3": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpureFunction3"]),
/* harmony export */   "ɵɵpureFunction4": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpureFunction4"]),
/* harmony export */   "ɵɵpureFunction5": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpureFunction5"]),
/* harmony export */   "ɵɵpureFunction6": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpureFunction6"]),
/* harmony export */   "ɵɵpureFunction7": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpureFunction7"]),
/* harmony export */   "ɵɵpureFunction8": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpureFunction8"]),
/* harmony export */   "ɵɵpureFunctionV": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpureFunctionV"]),
/* harmony export */   "ɵɵqueryAdvance": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵqueryAdvance"]),
/* harmony export */   "ɵɵqueryRefresh": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵqueryRefresh"]),
/* harmony export */   "ɵɵreadContextLet": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵreadContextLet"]),
/* harmony export */   "ɵɵreference": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵreference"]),
/* harmony export */   "ɵɵregisterNgModuleType": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.registerNgModuleType),
/* harmony export */   "ɵɵrepeater": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵrepeater"]),
/* harmony export */   "ɵɵrepeaterCreate": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵrepeaterCreate"]),
/* harmony export */   "ɵɵrepeaterTrackByIdentity": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵrepeaterTrackByIdentity"]),
/* harmony export */   "ɵɵrepeaterTrackByIndex": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵrepeaterTrackByIndex"]),
/* harmony export */   "ɵɵreplaceMetadata": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵreplaceMetadata"]),
/* harmony export */   "ɵɵresetView": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵresetView"]),
/* harmony export */   "ɵɵresolveBody": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵresolveBody"]),
/* harmony export */   "ɵɵresolveDocument": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵresolveDocument"]),
/* harmony export */   "ɵɵresolveWindow": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵresolveWindow"]),
/* harmony export */   "ɵɵrestoreView": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"]),
/* harmony export */   "ɵɵsanitizeHtml": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵsanitizeHtml"]),
/* harmony export */   "ɵɵsanitizeResourceUrl": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵsanitizeResourceUrl"]),
/* harmony export */   "ɵɵsanitizeScript": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵsanitizeScript"]),
/* harmony export */   "ɵɵsanitizeStyle": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵsanitizeStyle"]),
/* harmony export */   "ɵɵsanitizeUrl": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵsanitizeUrl"]),
/* harmony export */   "ɵɵsanitizeUrlOrResourceUrl": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵsanitizeUrlOrResourceUrl"]),
/* harmony export */   "ɵɵsetComponentScope": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵsetComponentScope"]),
/* harmony export */   "ɵɵsetNgModuleScope": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵsetNgModuleScope"]),
/* harmony export */   "ɵɵstoreLet": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵstoreLet"]),
/* harmony export */   "ɵɵstyleMap": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵstyleMap"]),
/* harmony export */   "ɵɵstyleProp": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵstyleProp"]),
/* harmony export */   "ɵɵsyntheticHostListener": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵsyntheticHostListener"]),
/* harmony export */   "ɵɵsyntheticHostProperty": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵsyntheticHostProperty"]),
/* harmony export */   "ɵɵtemplate": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"]),
/* harmony export */   "ɵɵtemplateRefExtractor": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplateRefExtractor"]),
/* harmony export */   "ɵɵtext": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtext"]),
/* harmony export */   "ɵɵtextInterpolate": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtextInterpolate"]),
/* harmony export */   "ɵɵtextInterpolate1": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtextInterpolate1"]),
/* harmony export */   "ɵɵtextInterpolate2": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtextInterpolate2"]),
/* harmony export */   "ɵɵtextInterpolate3": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtextInterpolate3"]),
/* harmony export */   "ɵɵtextInterpolate4": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtextInterpolate4"]),
/* harmony export */   "ɵɵtextInterpolate5": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtextInterpolate5"]),
/* harmony export */   "ɵɵtextInterpolate6": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtextInterpolate6"]),
/* harmony export */   "ɵɵtextInterpolate7": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtextInterpolate7"]),
/* harmony export */   "ɵɵtextInterpolate8": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtextInterpolate8"]),
/* harmony export */   "ɵɵtextInterpolateV": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtextInterpolateV"]),
/* harmony export */   "ɵɵtrustConstantHtml": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtrustConstantHtml"]),
/* harmony export */   "ɵɵtrustConstantResourceUrl": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtrustConstantResourceUrl"]),
/* harmony export */   "ɵɵtwoWayBindingSet": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtwoWayBindingSet"]),
/* harmony export */   "ɵɵtwoWayListener": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtwoWayListener"]),
/* harmony export */   "ɵɵtwoWayProperty": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtwoWayProperty"]),
/* harmony export */   "ɵɵvalidateAttribute": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵvalidateAttribute"]),
/* harmony export */   "ɵɵviewQuery": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵviewQuery"]),
/* harmony export */   "ɵɵviewQuerySignal": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵviewQuerySignal"])
/* harmony export */ });
/* harmony import */ var _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_untracked-chunk.mjs */ 64);
/* harmony import */ var _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_effect-chunk.mjs */ 476);
/* harmony import */ var _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_debug_node-chunk.mjs */ 7367);
/* harmony import */ var _resource_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_resource-chunk.mjs */ 3863);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ 1038);
/* harmony import */ var _weak_ref_chunk_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_weak_ref-chunk.mjs */ 7049);
/* harmony import */ var _not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_not_found-chunk.mjs */ 3667);
/* harmony import */ var _primitives_event_dispatch_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./primitives-event-dispatch.mjs */ 552);
/**
 * @license Angular v21.0.5
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */

















const REQUIRED_UNSET_VALUE = /* @__PURE__ */Symbol('InputSignalNode#UNSET');
const INPUT_SIGNAL_NODE = /* @__PURE__ */(() => {
  return {
    ..._effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.SIGNAL_NODE,
    transformFn: undefined,
    applyValueToInputSignal(node, value) {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.signalSetFn)(node, value);
    }
  };
})();
const ɵINPUT_SIGNAL_BRAND_WRITE_TYPE = /* @__PURE__ */Symbol();
function createInputSignal(initialValue, options) {
  const node = Object.create(INPUT_SIGNAL_NODE);
  node.value = initialValue;
  node.transformFn = options?.transform;
  function inputValueFn() {
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.producerAccessed)(node);
    if (node.value === REQUIRED_UNSET_VALUE) {
      let message = null;
      if (ngDevMode) {
        const name = options?.debugName ?? options?.alias;
        message = `Input${name ? ` "${name}"` : ''} is required but no value is available yet.`;
      }
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(-950, message);
    }
    return node.value;
  }
  inputValueFn[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.SIGNAL] = node;
  if (ngDevMode) {
    inputValueFn.toString = () => `[Input Signal: ${inputValueFn()}]`;
    node.debugName = options?.debugName;
  }
  return inputValueFn;
}
var FactoryTarget;
(function (FactoryTarget) {
  FactoryTarget[FactoryTarget["Directive"] = 0] = "Directive";
  FactoryTarget[FactoryTarget["Component"] = 1] = "Component";
  FactoryTarget[FactoryTarget["Injectable"] = 2] = "Injectable";
  FactoryTarget[FactoryTarget["Pipe"] = 3] = "Pipe";
  FactoryTarget[FactoryTarget["NgModule"] = 4] = "NgModule";
})(FactoryTarget || (FactoryTarget = {}));
var R3TemplateDependencyKind;
(function (R3TemplateDependencyKind) {
  R3TemplateDependencyKind[R3TemplateDependencyKind["Directive"] = 0] = "Directive";
  R3TemplateDependencyKind[R3TemplateDependencyKind["Pipe"] = 1] = "Pipe";
  R3TemplateDependencyKind[R3TemplateDependencyKind["NgModule"] = 2] = "NgModule";
})(R3TemplateDependencyKind || (R3TemplateDependencyKind = {}));
var ViewEncapsulation;
(function (ViewEncapsulation) {
  ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated";
  ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
  ViewEncapsulation[ViewEncapsulation["ShadowDom"] = 3] = "ShadowDom";
  ViewEncapsulation[ViewEncapsulation["ExperimentalIsolatedShadowDom"] = 4] = "ExperimentalIsolatedShadowDom";
})(ViewEncapsulation || (ViewEncapsulation = {}));
var Framework;
(function (Framework) {
  Framework["Angular"] = "angular";
  Framework["ACX"] = "acx";
  Framework["Wiz"] = "wiz";
})(Framework || (Framework = {}));
class HostAttributeToken {
  attributeName;
  constructor(attributeName) {
    this.attributeName = attributeName;
  }
  __NG_ELEMENT_ID__ = () => (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵinjectAttribute"])(this.attributeName);
  toString() {
    return `HostAttributeToken ${this.attributeName}`;
  }
}
const HOST_TAG_NAME = /* @__PURE__ */(() => {
  const HOST_TAG_NAME_TOKEN = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'HOST_TAG_NAME' : '');
  HOST_TAG_NAME_TOKEN.__NG_ELEMENT_ID__ = flags => {
    const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getCurrentTNode)();
    if (tNode === null) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(204, ngDevMode && 'HOST_TAG_NAME can only be injected in directives and components ' + 'during construction time (in a class constructor or as a class field initializer)');
    }
    if (tNode.type & 2) {
      return tNode.value;
    }
    if (flags & 8) {
      return null;
    }
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(204, ngDevMode && `HOST_TAG_NAME was used on ${getDevModeNodeName(tNode)} which doesn't have an underlying element in the DOM. ` + `This is invalid, and so the dependency should be marked as optional.`);
  };
  return HOST_TAG_NAME_TOKEN;
})();
function getDevModeNodeName(tNode) {
  if (tNode.type & 8) {
    return 'an <ng-container>';
  } else if (tNode.type & 4) {
    return 'an <ng-template>';
  } else if (tNode.type & 128) {
    return 'an @let declaration';
  } else {
    return 'a node';
  }
}
function output(opts) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertInInjectionContext)(output);
  return new _resource_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.OutputEmitterRef();
}
function inputFunction(initialValue, opts) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertInInjectionContext)(input);
  return createInputSignal(initialValue, opts);
}
function inputRequiredFunction(opts) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertInInjectionContext)(input);
  return createInputSignal(REQUIRED_UNSET_VALUE, opts);
}
const input = (() => {
  inputFunction.required = inputRequiredFunction;
  return inputFunction;
})();
function viewChildFn(locator, opts) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertInInjectionContext)(viewChild);
  return (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.createSingleResultOptionalQuerySignalFn)(opts);
}
function viewChildRequiredFn(locator, opts) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertInInjectionContext)(viewChild);
  return (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.createSingleResultRequiredQuerySignalFn)(opts);
}
const viewChild = (() => {
  viewChildFn.required = viewChildRequiredFn;
  return viewChildFn;
})();
function viewChildren(locator, opts) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertInInjectionContext)(viewChildren);
  return (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.createMultiResultQuerySignalFn)(opts);
}
function contentChildFn(locator, opts) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertInInjectionContext)(contentChild);
  return (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.createSingleResultOptionalQuerySignalFn)(opts);
}
function contentChildRequiredFn(locator, opts) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertInInjectionContext)(contentChildren);
  return (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.createSingleResultRequiredQuerySignalFn)(opts);
}
const contentChild = (() => {
  contentChildFn.required = contentChildRequiredFn;
  return contentChildFn;
})();
function contentChildren(locator, opts) {
  return (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.createMultiResultQuerySignalFn)(opts);
}
function createModelSignal(initialValue, opts) {
  const node = Object.create(INPUT_SIGNAL_NODE);
  const emitterRef = new _resource_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.OutputEmitterRef();
  node.value = initialValue;
  function getter() {
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.producerAccessed)(node);
    assertModelSet(node.value);
    return node.value;
  }
  getter[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.SIGNAL] = node;
  getter.asReadonly = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.signalAsReadonlyFn.bind(getter);
  getter.set = newValue => {
    if (!node.equal(node.value, newValue)) {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.signalSetFn)(node, newValue);
      emitterRef.emit(newValue);
    }
  };
  getter.update = updateFn => {
    assertModelSet(node.value);
    getter.set(updateFn(node.value));
  };
  getter.subscribe = emitterRef.subscribe.bind(emitterRef);
  getter.destroyRef = emitterRef.destroyRef;
  if (ngDevMode) {
    getter.toString = () => `[Model Signal: ${getter()}]`;
    node.debugName = opts?.debugName;
  }
  return getter;
}
function assertModelSet(value) {
  if (value === REQUIRED_UNSET_VALUE) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(952, ngDevMode && 'Model is required but no value is available yet.');
  }
}
function modelFunction(initialValue, opts) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertInInjectionContext)(model);
  return createModelSignal(initialValue, opts);
}
function modelRequiredFunction(opts) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertInInjectionContext)(model);
  return createModelSignal(REQUIRED_UNSET_VALUE, opts);
}
const model = (() => {
  modelFunction.required = modelRequiredFunction;
  return modelFunction;
})();
const emitDistinctChangesOnlyDefaultValue = true;
class Query {}
const ContentChildren = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.makePropDecorator)('ContentChildren', (selector, opts = {}) => ({
  selector,
  first: false,
  isViewQuery: false,
  descendants: false,
  emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue,
  ...opts
}), Query);
const ContentChild = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.makePropDecorator)('ContentChild', (selector, opts = {}) => ({
  selector,
  first: true,
  isViewQuery: false,
  descendants: true,
  ...opts
}), Query);
const ViewChildren = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.makePropDecorator)('ViewChildren', (selector, opts = {}) => ({
  selector,
  first: false,
  isViewQuery: true,
  descendants: true,
  emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue,
  ...opts
}), Query);
const ViewChild = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.makePropDecorator)('ViewChild', (selector, opts) => ({
  selector,
  first: true,
  isViewQuery: true,
  descendants: true,
  ...opts
}), Query);
function compileNgModuleFactory(injector, options, moduleType) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertNgModuleType)(moduleType);
  const moduleFactory = new _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NgModuleFactory(moduleType);
  if (typeof ngJitMode !== 'undefined' && !ngJitMode) {
    return Promise.resolve(moduleFactory);
  }
  const compilerOptions = injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.COMPILER_OPTIONS, []).concat(options);
  (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setJitOptions)({
    defaultEncapsulation: _lastDefined(compilerOptions.map(opts => opts.defaultEncapsulation)),
    preserveWhitespaces: _lastDefined(compilerOptions.map(opts => opts.preserveWhitespaces))
  });
  if ((0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isComponentResourceResolutionQueueEmpty)()) {
    return Promise.resolve(moduleFactory);
  }
  const compilerProviders = compilerOptions.flatMap(option => option.providers ?? []);
  if (compilerProviders.length === 0) {
    return Promise.resolve(moduleFactory);
  }
  const compiler = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getCompilerFacade)({
    usage: 0,
    kind: 'NgModule',
    type: moduleType
  });
  const compilerInjector = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.Injector.create({
    providers: compilerProviders
  });
  const resourceLoader = compilerInjector.get(compiler.ResourceLoader);
  return (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.resolveComponentResources)(url => Promise.resolve(resourceLoader.get(url))).then(() => moduleFactory);
}
function _lastDefined(args) {
  for (let i = args.length - 1; i >= 0; i--) {
    if (args[i] !== undefined) {
      return args[i];
    }
  }
  return undefined;
}
class NgZoneChangeDetectionScheduler {
  zone = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NgZone);
  changeDetectionScheduler = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionScheduler);
  applicationRef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ApplicationRef);
  applicationErrorHandler = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_APPLICATION_ERROR_HANDLER);
  _onMicrotaskEmptySubscription;
  initialize() {
    if (this._onMicrotaskEmptySubscription) {
      return;
    }
    this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({
      next: () => {
        if (this.changeDetectionScheduler.runningTick) {
          return;
        }
        this.zone.run(() => {
          try {
            this.applicationRef.dirtyFlags |= 1;
            this.applicationRef._tick();
          } catch (e) {
            this.applicationErrorHandler(e);
          }
        });
      }
    });
  }
  ngOnDestroy() {
    this._onMicrotaskEmptySubscription?.unsubscribe();
  }
  static ɵfac = function NgZoneChangeDetectionScheduler_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || NgZoneChangeDetectionScheduler)();
  };
  static ɵprov = /*@__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
    token: NgZoneChangeDetectionScheduler,
    factory: NgZoneChangeDetectionScheduler.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata)(NgZoneChangeDetectionScheduler, [{
    type: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], null, null);
})();
const PROVIDED_NG_ZONE = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'provideZoneChangeDetection token' : '', {
  factory: () => false
});
function internalProvideZoneChangeDetection({
  ngZoneFactory,
  scheduleInRootZone
}) {
  ngZoneFactory ??= () => new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NgZone({
    ...getNgZoneOptions(),
    scheduleInRootZone
  });
  return [{
    provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ZONELESS_ENABLED,
    useValue: false
  }, {
    provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NgZone,
    useFactory: ngZoneFactory
  }, {
    provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ENVIRONMENT_INITIALIZER,
    multi: true,
    useFactory: () => {
      const ngZoneChangeDetectionScheduler = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(NgZoneChangeDetectionScheduler, {
        optional: true
      });
      if ((typeof ngDevMode === 'undefined' || ngDevMode) && ngZoneChangeDetectionScheduler === null) {
        throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(402, `A required Injectable was not found in the dependency injection tree. ` + 'If you are bootstrapping an NgModule, make sure that the `BrowserModule` is imported.');
      }
      return () => ngZoneChangeDetectionScheduler.initialize();
    }
  }, {
    provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ENVIRONMENT_INITIALIZER,
    multi: true,
    useFactory: () => {
      const service = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(ZoneStablePendingTask);
      return () => {
        service.initialize();
      };
    }
  }, {
    provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.SCHEDULE_IN_ROOT_ZONE,
    useValue: scheduleInRootZone ?? _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.SCHEDULE_IN_ROOT_ZONE_DEFAULT
  }];
}
function provideZoneChangeDetection(options) {
  const scheduleInRootZone = options?.scheduleInRootZone;
  const zoneProviders = internalProvideZoneChangeDetection({
    ngZoneFactory: () => {
      const ngZoneOptions = getNgZoneOptions(options);
      ngZoneOptions.scheduleInRootZone = scheduleInRootZone;
      if (ngZoneOptions.shouldCoalesceEventChangeDetection) {
        (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.performanceMarkFeature)('NgZone_CoalesceEvent');
      }
      return new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NgZone(ngZoneOptions);
    },
    scheduleInRootZone
  });
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.makeEnvironmentProviders)([{
    provide: PROVIDED_NG_ZONE,
    useValue: true
  }, zoneProviders]);
}
function getNgZoneOptions(options) {
  return {
    enableLongStackTrace: typeof ngDevMode === 'undefined' ? false : !!ngDevMode,
    shouldCoalesceEventChangeDetection: options?.eventCoalescing ?? false,
    shouldCoalesceRunChangeDetection: options?.runCoalescing ?? false
  };
}
class ZoneStablePendingTask {
  subscription = new rxjs__WEBPACK_IMPORTED_MODULE_4__.Subscription();
  initialized = false;
  zone = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NgZone);
  pendingTasks = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.PendingTasksInternal);
  initialize() {
    if (this.initialized) {
      return;
    }
    this.initialized = true;
    let task = null;
    if (!this.zone.isStable && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks) {
      task = this.pendingTasks.add();
    }
    this.zone.runOutsideAngular(() => {
      this.subscription.add(this.zone.onStable.subscribe(() => {
        _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NgZone.assertNotInAngularZone();
        queueMicrotask(() => {
          if (task !== null && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks) {
            this.pendingTasks.remove(task);
            task = null;
          }
        });
      }));
    });
    this.subscription.add(this.zone.onUnstable.subscribe(() => {
      _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NgZone.assertInAngularZone();
      task ??= this.pendingTasks.add();
    }));
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  static ɵfac = function ZoneStablePendingTask_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || ZoneStablePendingTask)();
  };
  static ɵprov = /*@__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
    token: ZoneStablePendingTask,
    factory: ZoneStablePendingTask.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata)(ZoneStablePendingTask, [{
    type: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], null, null);
})();
const SCAN_DELAY = 200;
const OVERSIZED_IMAGE_TOLERANCE = 1200;
class ImagePerformanceWarning {
  window = null;
  observer = null;
  options = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IMAGE_CONFIG);
  lcpImageUrl;
  start() {
    if (typeof ngServerMode !== 'undefined' && ngServerMode || typeof PerformanceObserver === 'undefined' || this.options?.disableImageSizeWarning && this.options?.disableImageLazyLoadWarning) {
      return;
    }
    this.observer = this.initPerformanceObserver();
    const doc = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getDocument)();
    const win = doc.defaultView;
    if (win) {
      this.window = win;
      const waitToScan = () => {
        setTimeout(this.scanImages.bind(this), SCAN_DELAY);
      };
      const setup = () => {
        if (doc.readyState === 'complete') {
          waitToScan();
        } else {
          this.window?.addEventListener('load', waitToScan, {
            once: true
          });
        }
      };
      if (typeof Zone !== 'undefined') {
        Zone.root.run(() => setup());
      } else {
        setup();
      }
    }
  }
  ngOnDestroy() {
    this.observer?.disconnect();
  }
  initPerformanceObserver() {
    if (typeof PerformanceObserver === 'undefined') {
      return null;
    }
    const observer = new PerformanceObserver(entryList => {
      const entries = entryList.getEntries();
      if (entries.length === 0) return;
      const lcpElement = entries[entries.length - 1];
      const imgSrc = lcpElement.element?.src ?? '';
      if (imgSrc.startsWith('data:') || imgSrc.startsWith('blob:')) return;
      this.lcpImageUrl = imgSrc;
    });
    observer.observe({
      type: 'largest-contentful-paint',
      buffered: true
    });
    return observer;
  }
  scanImages() {
    const images = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getDocument)().querySelectorAll('img');
    let lcpElementFound,
      lcpElementLoadedCorrectly = false;
    for (let index = 0; index < images.length; index++) {
      const image = images[index];
      if (!image) {
        continue;
      }
      if (!this.options?.disableImageSizeWarning) {
        if (!image.getAttribute('ng-img') && this.isOversized(image)) {
          logOversizedImageWarning(image.src);
        }
      }
      if (!this.options?.disableImageLazyLoadWarning && this.lcpImageUrl) {
        if (image.src === this.lcpImageUrl) {
          lcpElementFound = true;
          if (image.loading !== 'lazy' || image.getAttribute('ng-img')) {
            lcpElementLoadedCorrectly = true;
          }
        }
      }
    }
    if (lcpElementFound && !lcpElementLoadedCorrectly && this.lcpImageUrl && !this.options?.disableImageLazyLoadWarning) {
      logLazyLCPWarning(this.lcpImageUrl);
    }
  }
  isOversized(image) {
    if (!this.window) {
      return false;
    }
    const nonOversizedImageExtentions = ['.svg'];
    const imageSource = (image.src || '').toLowerCase();
    if (nonOversizedImageExtentions.some(extension => imageSource.endsWith(extension))) {
      return false;
    }
    const computedStyle = this.window.getComputedStyle(image);
    let renderedWidth = parseFloat(computedStyle.getPropertyValue('width'));
    let renderedHeight = parseFloat(computedStyle.getPropertyValue('height'));
    const boxSizing = computedStyle.getPropertyValue('box-sizing');
    const objectFit = computedStyle.getPropertyValue('object-fit');
    if (objectFit === `cover`) {
      return false;
    }
    if (boxSizing === 'border-box') {
      const paddingTop = computedStyle.getPropertyValue('padding-top');
      const paddingRight = computedStyle.getPropertyValue('padding-right');
      const paddingBottom = computedStyle.getPropertyValue('padding-bottom');
      const paddingLeft = computedStyle.getPropertyValue('padding-left');
      renderedWidth -= parseFloat(paddingRight) + parseFloat(paddingLeft);
      renderedHeight -= parseFloat(paddingTop) + parseFloat(paddingBottom);
    }
    const intrinsicWidth = image.naturalWidth;
    const intrinsicHeight = image.naturalHeight;
    const recommendedWidth = this.window.devicePixelRatio * renderedWidth;
    const recommendedHeight = this.window.devicePixelRatio * renderedHeight;
    const oversizedWidth = intrinsicWidth - recommendedWidth >= OVERSIZED_IMAGE_TOLERANCE;
    const oversizedHeight = intrinsicHeight - recommendedHeight >= OVERSIZED_IMAGE_TOLERANCE;
    return oversizedWidth || oversizedHeight;
  }
  static ɵfac = function ImagePerformanceWarning_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || ImagePerformanceWarning)();
  };
  static ɵprov = /*@__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
    token: ImagePerformanceWarning,
    factory: ImagePerformanceWarning.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata)(ImagePerformanceWarning, [{
    type: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], null, null);
})();
function logLazyLCPWarning(src) {
  console.warn((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.formatRuntimeError)(-913, `An image with src ${src} is the Largest Contentful Paint (LCP) element ` + `but was given a "loading" value of "lazy", which can negatively impact ` + `application loading performance. This warning can be addressed by ` + `changing the loading value of the LCP image to "eager", or by using the ` + `NgOptimizedImage directive's prioritization utilities. For more ` + `information about addressing or disabling this warning, see ` + `https://angular.dev/errors/NG0913`));
}
function logOversizedImageWarning(src) {
  console.warn((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.formatRuntimeError)(-913, `An image with src ${src} has intrinsic file dimensions much larger than its ` + `rendered size. This can negatively impact application loading performance. ` + `For more information about addressing or disabling this warning, see ` + `https://angular.dev/errors/NG0913`));
}
const PLATFORM_DESTROY_LISTENERS = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'PlatformDestroyListeners' : '');
const ENABLE_ROOT_COMPONENT_BOOTSTRAP = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'ENABLE_ROOT_COMPONENT_BOOTSTRAP' : '');
function isApplicationBootstrapConfig(config) {
  return !config.moduleRef;
}
function bootstrap(config) {
  const envInjector = isApplicationBootstrapConfig(config) ? config.r3Injector : config.moduleRef.injector;
  const ngZone = envInjector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NgZone);
  return ngZone.run(() => {
    if (isApplicationBootstrapConfig(config)) {
      config.r3Injector.resolveInjectorInitializers();
    } else {
      config.moduleRef.resolveInjectorInitializers();
    }
    const exceptionHandler = envInjector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_APPLICATION_ERROR_HANDLER);
    if (typeof ngDevMode === 'undefined' || ngDevMode) {
      if (envInjector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.PROVIDED_ZONELESS) && envInjector.get(PROVIDED_NG_ZONE)) {
        console.warn((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.formatRuntimeError)(408, 'Both provideZoneChangeDetection and provideZonelessChangeDetection are provided. ' + 'This is likely a mistake. Update the application providers to use only one of the two.'));
      }
    }
    let onErrorSubscription;
    ngZone.runOutsideAngular(() => {
      onErrorSubscription = ngZone.onError.subscribe({
        next: exceptionHandler
      });
    });
    if (isApplicationBootstrapConfig(config)) {
      const destroyListener = () => envInjector.destroy();
      const onPlatformDestroyListeners = config.platformInjector.get(PLATFORM_DESTROY_LISTENERS);
      onPlatformDestroyListeners.add(destroyListener);
      envInjector.onDestroy(() => {
        onErrorSubscription.unsubscribe();
        onPlatformDestroyListeners.delete(destroyListener);
      });
    } else {
      const destroyListener = () => config.moduleRef.destroy();
      const onPlatformDestroyListeners = config.platformInjector.get(PLATFORM_DESTROY_LISTENERS);
      onPlatformDestroyListeners.add(destroyListener);
      config.moduleRef.onDestroy(() => {
        (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.remove)(config.allPlatformModules, config.moduleRef);
        onErrorSubscription.unsubscribe();
        onPlatformDestroyListeners.delete(destroyListener);
      });
    }
    return _callAndReportToErrorHandler(exceptionHandler, ngZone, () => {
      const pendingTasks = envInjector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.PendingTasksInternal);
      const taskId = pendingTasks.add();
      const initStatus = envInjector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ApplicationInitStatus);
      initStatus.runInitializers();
      return initStatus.donePromise.then(() => {
        const localeId = envInjector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.LOCALE_ID, _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_LOCALE_ID);
        (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setLocaleId)(localeId || _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_LOCALE_ID);
        const enableRootComponentbootstrap = envInjector.get(ENABLE_ROOT_COMPONENT_BOOTSTRAP, true);
        if (!enableRootComponentbootstrap) {
          if (isApplicationBootstrapConfig(config)) {
            return envInjector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ApplicationRef);
          }
          config.allPlatformModules.push(config.moduleRef);
          return config.moduleRef;
        }
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
          const imagePerformanceService = envInjector.get(ImagePerformanceWarning);
          imagePerformanceService.start();
        }
        if (isApplicationBootstrapConfig(config)) {
          const appRef = envInjector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ApplicationRef);
          if (config.rootComponent !== undefined) {
            appRef.bootstrap(config.rootComponent);
          }
          return appRef;
        } else {
          moduleBootstrapImpl?.(config.moduleRef, config.allPlatformModules);
          return config.moduleRef;
        }
      }).finally(() => void pendingTasks.remove(taskId));
    });
  });
}
let moduleBootstrapImpl;
function setModuleBootstrapImpl() {
  moduleBootstrapImpl = _moduleDoBootstrap;
}
function _moduleDoBootstrap(moduleRef, allPlatformModules) {
  const appRef = moduleRef.injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ApplicationRef);
  if (moduleRef._bootstrapComponents.length > 0) {
    moduleRef._bootstrapComponents.forEach(f => appRef.bootstrap(f));
  } else if (moduleRef.instance.ngDoBootstrap) {
    moduleRef.instance.ngDoBootstrap(appRef);
  } else {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(-403, ngDevMode && `The module ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.stringify)(moduleRef.instance.constructor)} was bootstrapped, ` + `but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. ` + `Please define one of these.`);
  }
  allPlatformModules.push(moduleRef);
}
function _callAndReportToErrorHandler(errorHandler, ngZone, callback) {
  try {
    const result = callback();
    if ((0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isPromise)(result)) {
      return result.catch(e => {
        ngZone.runOutsideAngular(() => errorHandler(e));
        throw e;
      });
    }
    return result;
  } catch (e) {
    ngZone.runOutsideAngular(() => errorHandler(e));
    throw e;
  }
}
class PlatformRef {
  _injector;
  _modules = [];
  _destroyListeners = [];
  _destroyed = false;
  constructor(_injector) {
    this._injector = _injector;
  }
  bootstrapModuleFactory(moduleFactory, options) {
    const allAppProviders = [(0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.provideZonelessChangeDetectionInternal)(), ...(options?.applicationProviders ?? []), _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.errorHandlerEnvironmentInitializer, ...(ngDevMode ? [_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.validAppIdInitializer] : [])];
    const moduleRef = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.createNgModuleRefWithProviders)(moduleFactory.moduleType, this.injector, allAppProviders);
    setModuleBootstrapImpl();
    return bootstrap({
      moduleRef,
      allPlatformModules: this._modules,
      platformInjector: this.injector
    });
  }
  bootstrapModule(moduleType, compilerOptions = []) {
    const options = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.optionsReducer)({}, compilerOptions);
    setModuleBootstrapImpl();
    return compileNgModuleFactory(this.injector, options, moduleType).then(moduleFactory => this.bootstrapModuleFactory(moduleFactory, options));
  }
  onDestroy(callback) {
    this._destroyListeners.push(callback);
  }
  get injector() {
    return this._injector;
  }
  destroy() {
    if (this._destroyed) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(404, ngDevMode && 'The platform has already been destroyed!');
    }
    this._modules.slice().forEach(module => module.destroy());
    this._destroyListeners.forEach(listener => listener());
    const destroyListeners = this._injector.get(PLATFORM_DESTROY_LISTENERS, null);
    if (destroyListeners) {
      destroyListeners.forEach(listener => listener());
      destroyListeners.clear();
    }
    this._destroyed = true;
  }
  get destroyed() {
    return this._destroyed;
  }
  static ɵfac = function PlatformRef_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || PlatformRef)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.Injector));
  };
  static ɵprov = /*@__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
    token: PlatformRef,
    factory: PlatformRef.ɵfac,
    providedIn: 'platform'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata)(PlatformRef, [{
    type: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Injectable,
    args: [{
      providedIn: 'platform'
    }]
  }], () => [{
    type: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.Injector
  }], null);
})();
let _platformInjector = null;
function createPlatform(injector) {
  if (getPlatform()) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(400, ngDevMode && 'There can be only one platform. Destroy the previous one to create a new one.');
  }
  (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.publishDefaultGlobalUtils)();
  (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.publishSignalConfiguration)();
  _platformInjector = typeof ngServerMode === 'undefined' || !ngServerMode ? injector : null;
  const platform = injector.get(PlatformRef);
  runPlatformInitializers(injector);
  return platform;
}
function createPlatformFactory(parentPlatformFactory, name, providers = []) {
  const desc = `Platform: ${name}`;
  const marker = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(desc);
  return (extraProviders = []) => {
    let platform = getPlatform();
    if (!platform) {
      const platformProviders = [...providers, ...extraProviders, {
        provide: marker,
        useValue: true
      }];
      platform = parentPlatformFactory?.(platformProviders) ?? createPlatform(createPlatformInjector(platformProviders, desc));
    }
    return typeof ngServerMode !== 'undefined' && ngServerMode ? platform : assertPlatform(marker);
  };
}
function createPlatformInjector(providers = [], name) {
  return _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.Injector.create({
    name,
    providers: [{
      provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.INJECTOR_SCOPE,
      useValue: 'platform'
    }, {
      provide: PLATFORM_DESTROY_LISTENERS,
      useValue: new Set([() => _platformInjector = null])
    }, ...providers]
  });
}
function assertPlatform(requiredToken) {
  const platform = getPlatform();
  if (!platform) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(-401, ngDevMode && 'No platform exists!');
  }
  if ((typeof ngDevMode === 'undefined' || ngDevMode) && !platform.injector.get(requiredToken, null)) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(400, 'A platform with a different configuration has been created. Please destroy it first.');
  }
  return platform;
}
function getPlatform() {
  if (typeof ngServerMode !== 'undefined' && ngServerMode) {
    return null;
  }
  return _platformInjector?.get(PlatformRef) ?? null;
}
function destroyPlatform() {
  getPlatform()?.destroy();
}
function createOrReusePlatformInjector(providers = []) {
  if (_platformInjector) return _platformInjector;
  (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.publishDefaultGlobalUtils)();
  const injector = createPlatformInjector(providers);
  if (typeof ngServerMode === 'undefined' || !ngServerMode) {
    _platformInjector = injector;
  }
  (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.publishSignalConfiguration)();
  runPlatformInitializers(injector);
  return injector;
}
function providePlatformInitializer(initializerFn) {
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.makeEnvironmentProviders)([{
    provide: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.PLATFORM_INITIALIZER,
    useValue: initializerFn,
    multi: true
  }]);
}
function runPlatformInitializers(injector) {
  const inits = injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.PLATFORM_INITIALIZER, null);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.runInInjectionContext)(injector, () => {
    inits?.forEach(init => init());
  });
}
function exhaustiveCheckNoChangesInterval(interval) {
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.provideEnvironmentInitializer)(() => {
    const applicationRef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ApplicationRef);
    const errorHandler = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ErrorHandler);
    const scheduler = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectionSchedulerImpl);
    const ngZone = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NgZone);
    function scheduleCheckNoChanges() {
      ngZone.runOutsideAngular(() => {
        setTimeout(() => {
          if (applicationRef.destroyed) {
            return;
          }
          if (scheduler.pendingRenderTaskId || scheduler.runningTick) {
            scheduleCheckNoChanges();
            return;
          }
          for (const view of applicationRef.allViews) {
            try {
              (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.checkNoChangesInternal)(view._lView, true);
            } catch (e) {
              errorHandler.handleError(e);
            }
          }
          scheduleCheckNoChanges();
        }, interval);
      });
    }
    scheduleCheckNoChanges();
  });
}
function provideCheckNoChangesConfig(options) {
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.makeEnvironmentProviders)(typeof ngDevMode === 'undefined' || ngDevMode ? [{
    provide: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.UseExhaustiveCheckNoChanges,
    useValue: options.exhaustive
  }, options?.interval !== undefined ? exhaustiveCheckNoChangesInterval(options.interval) : []] : []);
}
function isDevMode() {
  return typeof ngDevMode === 'undefined' || !!ngDevMode;
}
function enableProdMode() {
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
    _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__._global['ngDevMode'] = false;
  }
}
function getModuleFactory(id) {
  const type = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getRegisteredNgModuleType)(id);
  if (!type) throw noModuleError(id);
  return new _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NgModuleFactory(type);
}
function getNgModuleById(id) {
  const type = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getRegisteredNgModuleType)(id);
  if (!type) throw noModuleError(id);
  return type;
}
function noModuleError(id) {
  return new Error(`No module with ID ${id} loaded`);
}
class ChangeDetectorRef {
  static __NG_ELEMENT_ID__ = injectChangeDetectorRef;
}
function injectChangeDetectorRef(flags) {
  return createViewRef((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getCurrentTNode)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getLView)(), (flags & 16) === 16);
}
function createViewRef(tNode, lView, isPipe) {
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isComponentHost)(tNode) && !isPipe) {
    const componentView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getComponentLViewByIndex)(tNode.index, lView);
    return new _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ViewRef(componentView, componentView);
  } else if (tNode.type & (3 | 12 | 32 | 128)) {
    const hostComponentView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.DECLARATION_COMPONENT_VIEW];
    return new _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ViewRef(hostComponentView, lView);
  }
  return null;
}
class ViewRef extends ChangeDetectorRef {}
class EmbeddedViewRef extends ViewRef {}
class DefaultIterableDifferFactory {
  constructor() {}
  supports(obj) {
    return (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isListLikeIterable)(obj);
  }
  create(trackByFn) {
    return new DefaultIterableDiffer(trackByFn);
  }
}
const trackByIdentity = (index, item) => item;
class DefaultIterableDiffer {
  length = 0;
  collection;
  _linkedRecords = null;
  _unlinkedRecords = null;
  _previousItHead = null;
  _itHead = null;
  _itTail = null;
  _additionsHead = null;
  _additionsTail = null;
  _movesHead = null;
  _movesTail = null;
  _removalsHead = null;
  _removalsTail = null;
  _identityChangesHead = null;
  _identityChangesTail = null;
  _trackByFn;
  constructor(trackByFn) {
    this._trackByFn = trackByFn || trackByIdentity;
  }
  forEachItem(fn) {
    let record;
    for (record = this._itHead; record !== null; record = record._next) {
      fn(record);
    }
  }
  forEachOperation(fn) {
    let nextIt = this._itHead;
    let nextRemove = this._removalsHead;
    let addRemoveOffset = 0;
    let moveOffsets = null;
    while (nextIt || nextRemove) {
      const record = !nextRemove || nextIt && nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ? nextIt : nextRemove;
      const adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
      const currentIndex = record.currentIndex;
      if (record === nextRemove) {
        addRemoveOffset--;
        nextRemove = nextRemove._nextRemoved;
      } else {
        nextIt = nextIt._next;
        if (record.previousIndex == null) {
          addRemoveOffset++;
        } else {
          if (!moveOffsets) moveOffsets = [];
          const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
          const localCurrentIndex = currentIndex - addRemoveOffset;
          if (localMovePreviousIndex != localCurrentIndex) {
            for (let i = 0; i < localMovePreviousIndex; i++) {
              const offset = i < moveOffsets.length ? moveOffsets[i] : moveOffsets[i] = 0;
              const index = offset + i;
              if (localCurrentIndex <= index && index < localMovePreviousIndex) {
                moveOffsets[i] = offset + 1;
              }
            }
            const previousIndex = record.previousIndex;
            moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
          }
        }
      }
      if (adjPreviousIndex !== currentIndex) {
        fn(record, adjPreviousIndex, currentIndex);
      }
    }
  }
  forEachPreviousItem(fn) {
    let record;
    for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
      fn(record);
    }
  }
  forEachAddedItem(fn) {
    let record;
    for (record = this._additionsHead; record !== null; record = record._nextAdded) {
      fn(record);
    }
  }
  forEachMovedItem(fn) {
    let record;
    for (record = this._movesHead; record !== null; record = record._nextMoved) {
      fn(record);
    }
  }
  forEachRemovedItem(fn) {
    let record;
    for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
      fn(record);
    }
  }
  forEachIdentityChange(fn) {
    let record;
    for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
      fn(record);
    }
  }
  diff(collection) {
    if (collection == null) collection = [];
    if (!(0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isListLikeIterable)(collection)) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(900, ngDevMode && `Error trying to diff '${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.stringify)(collection)}'. Only arrays and iterables are allowed`);
    }
    if (this.check(collection)) {
      return this;
    } else {
      return null;
    }
  }
  onDestroy() {}
  check(collection) {
    this._reset();
    let record = this._itHead;
    let mayBeDirty = false;
    let index;
    let item;
    let itemTrackBy;
    if (Array.isArray(collection)) {
      this.length = collection.length;
      for (let index = 0; index < this.length; index++) {
        item = collection[index];
        itemTrackBy = this._trackByFn(index, item);
        if (record === null || !Object.is(record.trackById, itemTrackBy)) {
          record = this._mismatch(record, item, itemTrackBy, index);
          mayBeDirty = true;
        } else {
          if (mayBeDirty) {
            record = this._verifyReinsertion(record, item, itemTrackBy, index);
          }
          if (!Object.is(record.item, item)) this._addIdentityChange(record, item);
        }
        record = record._next;
      }
    } else {
      index = 0;
      (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.iterateListLike)(collection, item => {
        itemTrackBy = this._trackByFn(index, item);
        if (record === null || !Object.is(record.trackById, itemTrackBy)) {
          record = this._mismatch(record, item, itemTrackBy, index);
          mayBeDirty = true;
        } else {
          if (mayBeDirty) {
            record = this._verifyReinsertion(record, item, itemTrackBy, index);
          }
          if (!Object.is(record.item, item)) this._addIdentityChange(record, item);
        }
        record = record._next;
        index++;
      });
      this.length = index;
    }
    this._truncate(record);
    this.collection = collection;
    return this.isDirty;
  }
  get isDirty() {
    return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null || this._identityChangesHead !== null;
  }
  _reset() {
    if (this.isDirty) {
      let record;
      for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
        record._nextPrevious = record._next;
      }
      for (record = this._additionsHead; record !== null; record = record._nextAdded) {
        record.previousIndex = record.currentIndex;
      }
      this._additionsHead = this._additionsTail = null;
      for (record = this._movesHead; record !== null; record = record._nextMoved) {
        record.previousIndex = record.currentIndex;
      }
      this._movesHead = this._movesTail = null;
      this._removalsHead = this._removalsTail = null;
      this._identityChangesHead = this._identityChangesTail = null;
    }
  }
  _mismatch(record, item, itemTrackBy, index) {
    let previousRecord;
    if (record === null) {
      previousRecord = this._itTail;
    } else {
      previousRecord = record._prev;
      this._remove(record);
    }
    record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
    if (record !== null) {
      if (!Object.is(record.item, item)) this._addIdentityChange(record, item);
      this._reinsertAfter(record, previousRecord, index);
    } else {
      record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
      if (record !== null) {
        if (!Object.is(record.item, item)) this._addIdentityChange(record, item);
        this._moveAfter(record, previousRecord, index);
      } else {
        record = this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index);
      }
    }
    return record;
  }
  _verifyReinsertion(record, item, itemTrackBy, index) {
    let reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
    if (reinsertRecord !== null) {
      record = this._reinsertAfter(reinsertRecord, record._prev, index);
    } else if (record.currentIndex != index) {
      record.currentIndex = index;
      this._addToMoves(record, index);
    }
    return record;
  }
  _truncate(record) {
    while (record !== null) {
      const nextRecord = record._next;
      this._addToRemovals(this._unlink(record));
      record = nextRecord;
    }
    if (this._unlinkedRecords !== null) {
      this._unlinkedRecords.clear();
    }
    if (this._additionsTail !== null) {
      this._additionsTail._nextAdded = null;
    }
    if (this._movesTail !== null) {
      this._movesTail._nextMoved = null;
    }
    if (this._itTail !== null) {
      this._itTail._next = null;
    }
    if (this._removalsTail !== null) {
      this._removalsTail._nextRemoved = null;
    }
    if (this._identityChangesTail !== null) {
      this._identityChangesTail._nextIdentityChange = null;
    }
  }
  _reinsertAfter(record, prevRecord, index) {
    if (this._unlinkedRecords !== null) {
      this._unlinkedRecords.remove(record);
    }
    const prev = record._prevRemoved;
    const next = record._nextRemoved;
    if (prev === null) {
      this._removalsHead = next;
    } else {
      prev._nextRemoved = next;
    }
    if (next === null) {
      this._removalsTail = prev;
    } else {
      next._prevRemoved = prev;
    }
    this._insertAfter(record, prevRecord, index);
    this._addToMoves(record, index);
    return record;
  }
  _moveAfter(record, prevRecord, index) {
    this._unlink(record);
    this._insertAfter(record, prevRecord, index);
    this._addToMoves(record, index);
    return record;
  }
  _addAfter(record, prevRecord, index) {
    this._insertAfter(record, prevRecord, index);
    if (this._additionsTail === null) {
      this._additionsTail = this._additionsHead = record;
    } else {
      this._additionsTail = this._additionsTail._nextAdded = record;
    }
    return record;
  }
  _insertAfter(record, prevRecord, index) {
    const next = prevRecord === null ? this._itHead : prevRecord._next;
    record._next = next;
    record._prev = prevRecord;
    if (next === null) {
      this._itTail = record;
    } else {
      next._prev = record;
    }
    if (prevRecord === null) {
      this._itHead = record;
    } else {
      prevRecord._next = record;
    }
    if (this._linkedRecords === null) {
      this._linkedRecords = new _DuplicateMap();
    }
    this._linkedRecords.put(record);
    record.currentIndex = index;
    return record;
  }
  _remove(record) {
    return this._addToRemovals(this._unlink(record));
  }
  _unlink(record) {
    if (this._linkedRecords !== null) {
      this._linkedRecords.remove(record);
    }
    const prev = record._prev;
    const next = record._next;
    if (prev === null) {
      this._itHead = next;
    } else {
      prev._next = next;
    }
    if (next === null) {
      this._itTail = prev;
    } else {
      next._prev = prev;
    }
    return record;
  }
  _addToMoves(record, toIndex) {
    if (record.previousIndex === toIndex) {
      return record;
    }
    if (this._movesTail === null) {
      this._movesTail = this._movesHead = record;
    } else {
      this._movesTail = this._movesTail._nextMoved = record;
    }
    return record;
  }
  _addToRemovals(record) {
    if (this._unlinkedRecords === null) {
      this._unlinkedRecords = new _DuplicateMap();
    }
    this._unlinkedRecords.put(record);
    record.currentIndex = null;
    record._nextRemoved = null;
    if (this._removalsTail === null) {
      this._removalsTail = this._removalsHead = record;
      record._prevRemoved = null;
    } else {
      record._prevRemoved = this._removalsTail;
      this._removalsTail = this._removalsTail._nextRemoved = record;
    }
    return record;
  }
  _addIdentityChange(record, item) {
    record.item = item;
    if (this._identityChangesTail === null) {
      this._identityChangesTail = this._identityChangesHead = record;
    } else {
      this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
    }
    return record;
  }
}
class IterableChangeRecord_ {
  item;
  trackById;
  currentIndex = null;
  previousIndex = null;
  _nextPrevious = null;
  _prev = null;
  _next = null;
  _prevDup = null;
  _nextDup = null;
  _prevRemoved = null;
  _nextRemoved = null;
  _nextAdded = null;
  _nextMoved = null;
  _nextIdentityChange = null;
  constructor(item, trackById) {
    this.item = item;
    this.trackById = trackById;
  }
}
class _DuplicateItemRecordList {
  _head = null;
  _tail = null;
  add(record) {
    if (this._head === null) {
      this._head = this._tail = record;
      record._nextDup = null;
      record._prevDup = null;
    } else {
      this._tail._nextDup = record;
      record._prevDup = this._tail;
      record._nextDup = null;
      this._tail = record;
    }
  }
  get(trackById, atOrAfterIndex) {
    let record;
    for (record = this._head; record !== null; record = record._nextDup) {
      if ((atOrAfterIndex === null || atOrAfterIndex <= record.currentIndex) && Object.is(record.trackById, trackById)) {
        return record;
      }
    }
    return null;
  }
  remove(record) {
    const prev = record._prevDup;
    const next = record._nextDup;
    if (prev === null) {
      this._head = next;
    } else {
      prev._nextDup = next;
    }
    if (next === null) {
      this._tail = prev;
    } else {
      next._prevDup = prev;
    }
    return this._head === null;
  }
}
class _DuplicateMap {
  map = new Map();
  put(record) {
    const key = record.trackById;
    let duplicates = this.map.get(key);
    if (!duplicates) {
      duplicates = new _DuplicateItemRecordList();
      this.map.set(key, duplicates);
    }
    duplicates.add(record);
  }
  get(trackById, atOrAfterIndex) {
    const key = trackById;
    const recordList = this.map.get(key);
    return recordList ? recordList.get(trackById, atOrAfterIndex) : null;
  }
  remove(record) {
    const key = record.trackById;
    const recordList = this.map.get(key);
    if (recordList.remove(record)) {
      this.map.delete(key);
    }
    return record;
  }
  get isEmpty() {
    return this.map.size === 0;
  }
  clear() {
    this.map.clear();
  }
}
function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
  const previousIndex = item.previousIndex;
  if (previousIndex === null) return previousIndex;
  let moveOffset = 0;
  if (moveOffsets && previousIndex < moveOffsets.length) {
    moveOffset = moveOffsets[previousIndex];
  }
  return previousIndex + addRemoveOffset + moveOffset;
}
class DefaultKeyValueDifferFactory {
  constructor() {}
  supports(obj) {
    return obj instanceof Map || (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isJsObject)(obj);
  }
  create() {
    return new DefaultKeyValueDiffer();
  }
}
class DefaultKeyValueDiffer {
  _records = new Map();
  _mapHead = null;
  _appendAfter = null;
  _previousMapHead = null;
  _changesHead = null;
  _changesTail = null;
  _additionsHead = null;
  _additionsTail = null;
  _removalsHead = null;
  _removalsTail = null;
  get isDirty() {
    return this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null;
  }
  forEachItem(fn) {
    let record;
    for (record = this._mapHead; record !== null; record = record._next) {
      fn(record);
    }
  }
  forEachPreviousItem(fn) {
    let record;
    for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
      fn(record);
    }
  }
  forEachChangedItem(fn) {
    let record;
    for (record = this._changesHead; record !== null; record = record._nextChanged) {
      fn(record);
    }
  }
  forEachAddedItem(fn) {
    let record;
    for (record = this._additionsHead; record !== null; record = record._nextAdded) {
      fn(record);
    }
  }
  forEachRemovedItem(fn) {
    let record;
    for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
      fn(record);
    }
  }
  diff(map) {
    if (!map) {
      map = new Map();
    } else if (!(map instanceof Map || (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isJsObject)(map))) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(900, ngDevMode && `Error trying to diff '${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.stringify)(map)}'. Only maps and objects are allowed`);
    }
    return this.check(map) ? this : null;
  }
  onDestroy() {}
  check(map) {
    this._reset();
    let insertBefore = this._mapHead;
    this._appendAfter = null;
    this._forEach(map, (value, key) => {
      if (insertBefore && insertBefore.key === key) {
        this._maybeAddToChanges(insertBefore, value);
        this._appendAfter = insertBefore;
        insertBefore = insertBefore._next;
      } else {
        const record = this._getOrCreateRecordForKey(key, value);
        insertBefore = this._insertBeforeOrAppend(insertBefore, record);
      }
    });
    if (insertBefore) {
      if (insertBefore._prev) {
        insertBefore._prev._next = null;
      }
      this._removalsHead = insertBefore;
      for (let record = insertBefore; record !== null; record = record._nextRemoved) {
        if (record === this._mapHead) {
          this._mapHead = null;
        }
        this._records.delete(record.key);
        record._nextRemoved = record._next;
        record.previousValue = record.currentValue;
        record.currentValue = null;
        record._prev = null;
        record._next = null;
      }
    }
    if (this._changesTail) this._changesTail._nextChanged = null;
    if (this._additionsTail) this._additionsTail._nextAdded = null;
    return this.isDirty;
  }
  _insertBeforeOrAppend(before, record) {
    if (before) {
      const prev = before._prev;
      record._next = before;
      record._prev = prev;
      before._prev = record;
      if (prev) {
        prev._next = record;
      }
      if (before === this._mapHead) {
        this._mapHead = record;
      }
      this._appendAfter = before;
      return before;
    }
    if (this._appendAfter) {
      this._appendAfter._next = record;
      record._prev = this._appendAfter;
    } else {
      this._mapHead = record;
    }
    this._appendAfter = record;
    return null;
  }
  _getOrCreateRecordForKey(key, value) {
    if (this._records.has(key)) {
      const record = this._records.get(key);
      this._maybeAddToChanges(record, value);
      const prev = record._prev;
      const next = record._next;
      if (prev) {
        prev._next = next;
      }
      if (next) {
        next._prev = prev;
      }
      record._next = null;
      record._prev = null;
      return record;
    }
    const record = new KeyValueChangeRecord_(key);
    this._records.set(key, record);
    record.currentValue = value;
    this._addToAdditions(record);
    return record;
  }
  _reset() {
    if (this.isDirty) {
      let record;
      this._previousMapHead = this._mapHead;
      for (record = this._previousMapHead; record !== null; record = record._next) {
        record._nextPrevious = record._next;
      }
      for (record = this._changesHead; record !== null; record = record._nextChanged) {
        record.previousValue = record.currentValue;
      }
      for (record = this._additionsHead; record != null; record = record._nextAdded) {
        record.previousValue = record.currentValue;
      }
      this._changesHead = this._changesTail = null;
      this._additionsHead = this._additionsTail = null;
      this._removalsHead = null;
    }
  }
  _maybeAddToChanges(record, newValue) {
    if (!Object.is(newValue, record.currentValue)) {
      record.previousValue = record.currentValue;
      record.currentValue = newValue;
      this._addToChanges(record);
    }
  }
  _addToAdditions(record) {
    if (this._additionsHead === null) {
      this._additionsHead = this._additionsTail = record;
    } else {
      this._additionsTail._nextAdded = record;
      this._additionsTail = record;
    }
  }
  _addToChanges(record) {
    if (this._changesHead === null) {
      this._changesHead = this._changesTail = record;
    } else {
      this._changesTail._nextChanged = record;
      this._changesTail = record;
    }
  }
  _forEach(obj, fn) {
    if (obj instanceof Map) {
      obj.forEach(fn);
    } else {
      Object.keys(obj).forEach(k => fn(obj[k], k));
    }
  }
}
class KeyValueChangeRecord_ {
  key;
  previousValue = null;
  currentValue = null;
  _nextPrevious = null;
  _next = null;
  _prev = null;
  _nextAdded = null;
  _nextRemoved = null;
  _nextChanged = null;
  constructor(key) {
    this.key = key;
  }
}
function defaultIterableDiffersFactory() {
  return new IterableDiffers([new DefaultIterableDifferFactory()]);
}
class IterableDiffers {
  factories;
  static ɵprov = /* @__PURE__ */
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
    token: IterableDiffers,
    providedIn: 'root',
    factory: defaultIterableDiffersFactory
  });
  constructor(factories) {
    this.factories = factories;
  }
  static create(factories, parent) {
    if (parent != null) {
      const copied = parent.factories.slice();
      factories = factories.concat(copied);
    }
    return new IterableDiffers(factories);
  }
  static extend(factories) {
    return {
      provide: IterableDiffers,
      useFactory: () => {
        const parent = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(IterableDiffers, {
          optional: true,
          skipSelf: true
        });
        return IterableDiffers.create(factories, parent || defaultIterableDiffersFactory());
      }
    };
  }
  find(iterable) {
    const factory = this.factories.find(f => f.supports(iterable));
    if (factory != null) {
      return factory;
    } else {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(901, ngDevMode && `Cannot find a differ supporting object '${iterable}' of type '${getTypeNameForDebugging(iterable)}'`);
    }
  }
}
function getTypeNameForDebugging(type) {
  return type['name'] || typeof type;
}
function defaultKeyValueDiffersFactory() {
  return new KeyValueDiffers([new DefaultKeyValueDifferFactory()]);
}
class KeyValueDiffers {
  static ɵprov = /* @__PURE__ */
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
    token: KeyValueDiffers,
    providedIn: 'root',
    factory: defaultKeyValueDiffersFactory
  });
  factories;
  constructor(factories) {
    this.factories = factories;
  }
  static create(factories, parent) {
    if (parent) {
      const copied = parent.factories.slice();
      factories = factories.concat(copied);
    }
    return new KeyValueDiffers(factories);
  }
  static extend(factories) {
    return {
      provide: KeyValueDiffers,
      useFactory: () => {
        const parent = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(KeyValueDiffers, {
          optional: true,
          skipSelf: true
        });
        return KeyValueDiffers.create(factories, parent || defaultKeyValueDiffersFactory());
      }
    };
  }
  find(kv) {
    const factory = this.factories.find(f => f.supports(kv));
    if (factory) {
      return factory;
    }
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(901, ngDevMode && `Cannot find a differ supporting object '${kv}'`);
  }
}
const keyValDiff = [new DefaultKeyValueDifferFactory()];
const iterableDiff = [new DefaultIterableDifferFactory()];
const defaultIterableDiffers = new IterableDiffers(iterableDiff);
const defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);
const platformCore = createPlatformFactory(null, 'core', []);
class ApplicationModule {
  constructor(appRef) {}
  static ɵfac = function ApplicationModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || ApplicationModule)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ApplicationRef));
  };
  static ɵmod = /*@__PURE__*/(0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineNgModule"])({
    type: ApplicationModule
  });
  static ɵinj = /*@__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"])({});
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata)(ApplicationModule, [{
    type: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NgModule
  }], () => [{
    type: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ApplicationRef
  }], null);
})();
function internalCreateApplication(config) {
  const {
    rootComponent,
    appProviders,
    platformProviders,
    platformRef
  } = config;
  (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.profiler)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ProfilerEvent.BootstrapApplicationStart);
  if (typeof ngServerMode !== 'undefined' && ngServerMode && !platformRef) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(-401, ngDevMode && 'Missing Platform: This may be due to using `bootstrapApplication` on the server without passing a `BootstrapContext`. ' + 'Please make sure that `bootstrapApplication` is called with a `context` argument.');
  }
  try {
    const platformInjector = platformRef?.injector ?? createOrReusePlatformInjector(platformProviders);
    if ((typeof ngDevMode === 'undefined' || ngDevMode) && rootComponent !== undefined) {
      (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.assertStandaloneComponentType)(rootComponent);
    }
    const allAppProviders = [(0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.provideZonelessChangeDetectionInternal)(), _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.errorHandlerEnvironmentInitializer, ...(ngDevMode ? [_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.validAppIdInitializer] : []), ...(appProviders || [])];
    const adapter = new _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.EnvironmentNgModuleRefAdapter({
      providers: allAppProviders,
      parent: platformInjector,
      debugName: typeof ngDevMode === 'undefined' || ngDevMode ? 'Environment Injector' : '',
      runEnvironmentInitializers: false
    });
    return bootstrap({
      r3Injector: adapter.injector,
      platformInjector,
      rootComponent
    });
  } catch (e) {
    return Promise.reject(e);
  } finally {
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.profiler)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ProfilerEvent.BootstrapApplicationEnd);
  }
}
const appsWithEventReplay = new WeakSet();
const EAGER_CONTENT_LISTENERS_KEY = '';
let blockEventQueue = [];
function shouldEnableEventReplay(injector) {
  return injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_EVENT_REPLAY_ENABLED, _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.EVENT_REPLAY_ENABLED_DEFAULT);
}
function withEventReplay() {
  const providers = [{
    provide: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_EVENT_REPLAY_ENABLED,
    useFactory: () => {
      let isEnabled = true;
      if (typeof ngServerMode === 'undefined' || !ngServerMode) {
        const appId = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.APP_ID);
        isEnabled = !!window._ejsas?.[appId];
      }
      if (isEnabled) {
        (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.performanceMarkFeature)('NgEventReplay');
      }
      return isEnabled;
    }
  }];
  if (typeof ngServerMode === 'undefined' || !ngServerMode) {
    providers.push({
      provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ENVIRONMENT_INITIALIZER,
      useValue: () => {
        const appRef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ApplicationRef);
        const {
          injector
        } = appRef;
        if (!appsWithEventReplay.has(appRef)) {
          const jsActionMap = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.JSACTION_BLOCK_ELEMENT_MAP);
          if (shouldEnableEventReplay(injector)) {
            (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enableStashEventListenerImpl)();
            const appId = injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.APP_ID);
            const clearStashFn = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setStashFn)(appId, (rEl, eventName, listenerFn) => {
              if (rEl.nodeType !== Node.ELEMENT_NODE) return;
              (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.sharedStashFunction)(rEl, eventName, listenerFn);
              (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.sharedMapFunction)(rEl, jsActionMap);
            });
            appRef.onDestroy(clearStashFn);
          }
        }
      },
      multi: true
    }, {
      provide: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.APP_BOOTSTRAP_LISTENER,
      useFactory: () => {
        const appRef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ApplicationRef);
        const {
          injector
        } = appRef;
        return () => {
          if (!shouldEnableEventReplay(injector) || appsWithEventReplay.has(appRef)) {
            return;
          }
          appsWithEventReplay.add(appRef);
          const appId = injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.APP_ID);
          appRef.onDestroy(() => {
            appsWithEventReplay.delete(appRef);
            if (typeof ngServerMode !== 'undefined' && !ngServerMode) {
              (0,_primitives_event_dispatch_mjs__WEBPACK_IMPORTED_MODULE_7__.clearAppScopedEarlyEventContract)(appId);
            }
          });
          appRef.whenStable().then(() => {
            if (appRef.destroyed) {
              return;
            }
            const eventContractDetails = injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.JSACTION_EVENT_CONTRACT);
            initEventReplay(eventContractDetails, injector);
            const jsActionMap = injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.JSACTION_BLOCK_ELEMENT_MAP);
            jsActionMap.get(EAGER_CONTENT_LISTENERS_KEY)?.forEach(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.removeListeners);
            jsActionMap.delete(EAGER_CONTENT_LISTENERS_KEY);
            const eventContract = eventContractDetails.instance;
            if ((0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isIncrementalHydrationEnabled)(injector)) {
              appRef.onDestroy(() => eventContract.cleanUp());
            } else {
              eventContract.cleanUp();
            }
          });
        };
      },
      multi: true
    });
  }
  return providers;
}
const initEventReplay = (eventDelegation, injector) => {
  const appId = injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.APP_ID);
  const earlyJsactionData = window._ejsas[appId];
  const eventContract = eventDelegation.instance = new _primitives_event_dispatch_mjs__WEBPACK_IMPORTED_MODULE_7__.EventContract(new _primitives_event_dispatch_mjs__WEBPACK_IMPORTED_MODULE_7__.EventContractContainer(earlyJsactionData.c));
  for (const et of earlyJsactionData.et) {
    eventContract.addEvent(et);
  }
  for (const et of earlyJsactionData.etc) {
    eventContract.addEvent(et);
  }
  const eventInfos = (0,_primitives_event_dispatch_mjs__WEBPACK_IMPORTED_MODULE_7__.getAppScopedQueuedEventInfos)(appId);
  eventContract.replayEarlyEventInfos(eventInfos);
  (0,_primitives_event_dispatch_mjs__WEBPACK_IMPORTED_MODULE_7__.clearAppScopedEarlyEventContract)(appId);
  const dispatcher = new _primitives_event_dispatch_mjs__WEBPACK_IMPORTED_MODULE_7__.EventDispatcher(event => {
    invokeRegisteredReplayListeners(injector, event, event.currentTarget);
  });
  (0,_primitives_event_dispatch_mjs__WEBPACK_IMPORTED_MODULE_7__.registerDispatcher)(eventContract, dispatcher);
};
function collectDomEventsInfo(tView, lView, eventTypesToReplay) {
  const domEventsInfo = new Map();
  const lCleanup = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.CLEANUP];
  const tCleanup = tView.cleanup;
  if (!tCleanup || !lCleanup) {
    return domEventsInfo;
  }
  for (let i = 0; i < tCleanup.length;) {
    const firstParam = tCleanup[i++];
    const secondParam = tCleanup[i++];
    if (typeof firstParam !== 'string') {
      continue;
    }
    const eventType = firstParam;
    if (!(0,_primitives_event_dispatch_mjs__WEBPACK_IMPORTED_MODULE_7__.isEarlyEventType)(eventType)) {
      continue;
    }
    if ((0,_primitives_event_dispatch_mjs__WEBPACK_IMPORTED_MODULE_7__.isCaptureEventType)(eventType)) {
      eventTypesToReplay.capture.add(eventType);
    } else {
      eventTypesToReplay.regular.add(eventType);
    }
    const listenerElement = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.unwrapRNode)(lView[secondParam]);
    i++;
    const useCaptureOrIndx = tCleanup[i++];
    const isDomEvent = typeof useCaptureOrIndx === 'boolean' || useCaptureOrIndx >= 0;
    if (!isDomEvent) {
      continue;
    }
    if (!domEventsInfo.has(listenerElement)) {
      domEventsInfo.set(listenerElement, [eventType]);
    } else {
      domEventsInfo.get(listenerElement).push(eventType);
    }
  }
  return domEventsInfo;
}
function invokeRegisteredReplayListeners(injector, event, currentTarget) {
  const blockName = (currentTarget && currentTarget.getAttribute(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFER_BLOCK_SSR_ID_ATTRIBUTE)) ?? '';
  if (/d\d+/.test(blockName)) {
    hydrateAndInvokeBlockListeners(blockName, injector, event, currentTarget);
  } else if (event.eventPhase === _primitives_event_dispatch_mjs__WEBPACK_IMPORTED_MODULE_7__.EventPhase.REPLAY) {
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.invokeListeners)(event, currentTarget);
  }
}
function hydrateAndInvokeBlockListeners(blockName, injector, event, currentTarget) {
  blockEventQueue.push({
    event,
    currentTarget
  });
  (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.triggerHydrationFromBlockName)(injector, blockName, replayQueuedBlockEvents);
}
function replayQueuedBlockEvents(hydratedBlocks) {
  const queue = [...blockEventQueue];
  const hydrated = new Set(hydratedBlocks);
  blockEventQueue = [];
  for (let {
    event,
    currentTarget
  } of queue) {
    const blockName = currentTarget.getAttribute(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFER_BLOCK_SSR_ID_ATTRIBUTE);
    if (hydrated.has(blockName)) {
      (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.invokeListeners)(event, currentTarget);
    } else {
      blockEventQueue.push({
        event,
        currentTarget
      });
    }
  }
}
class SerializedViewCollection {
  views = [];
  indexByContent = new Map();
  add(serializedView) {
    const viewAsString = JSON.stringify(serializedView);
    if (!this.indexByContent.has(viewAsString)) {
      const index = this.views.length;
      this.views.push(serializedView);
      this.indexByContent.set(viewAsString, index);
      return index;
    }
    return this.indexByContent.get(viewAsString);
  }
  getAll() {
    return this.views;
  }
}
let tViewSsrId = 0;
function getSsrId(tView) {
  if (!tView.ssrId) {
    tView.ssrId = `t${tViewSsrId++}`;
  }
  return tView.ssrId;
}
function calcNumRootNodes(tView, lView, tNode) {
  const rootNodes = [];
  (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.collectNativeNodes)(tView, lView, tNode, rootNodes);
  return rootNodes.length;
}
function calcNumRootNodesInLContainer(lContainer) {
  const rootNodes = [];
  (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.collectNativeNodesInLContainer)(lContainer, rootNodes);
  return rootNodes.length;
}
function annotateComponentLViewForHydration(lView, context, injector) {
  const hostElement = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HOST];
  if (hostElement && !hostElement.hasAttribute(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SKIP_HYDRATION_ATTR_NAME)) {
    return annotateHostElementForHydration(hostElement, lView, null, context);
  }
  return null;
}
function annotateLContainerForHydration(lContainer, context, injector) {
  const componentLView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.unwrapLView)(lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HOST]);
  const componentLViewNghIndex = annotateComponentLViewForHydration(componentLView, context);
  if (componentLViewNghIndex === null) {
    return;
  }
  const hostElement = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.unwrapRNode)(componentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HOST]);
  const rootLView = lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.PARENT];
  const rootLViewNghIndex = annotateHostElementForHydration(hostElement, rootLView, null, context);
  const renderer = componentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RENDERER];
  const finalIndex = `${componentLViewNghIndex}|${rootLViewNghIndex}`;
  renderer.setAttribute(hostElement, _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NGH_ATTR_NAME, finalIndex);
}
function annotateForHydration(appRef, doc) {
  const injector = appRef.injector;
  const isI18nHydrationEnabledVal = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isI18nHydrationEnabled)(injector);
  const isIncrementalHydrationEnabledVal = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isIncrementalHydrationEnabled)(injector);
  const serializedViewCollection = new SerializedViewCollection();
  const corruptedTextNodes = new Map();
  const viewRefs = appRef._views;
  const shouldReplayEvents = injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_EVENT_REPLAY_ENABLED, _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.EVENT_REPLAY_ENABLED_DEFAULT);
  const eventTypesToReplay = {
    regular: new Set(),
    capture: new Set()
  };
  const deferBlocks = new Map();
  const appId = appRef.injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.APP_ID);
  for (const viewRef of viewRefs) {
    const lNode = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getLNodeForHydration)(viewRef);
    if (lNode !== null) {
      const context = {
        serializedViewCollection,
        corruptedTextNodes,
        isI18nHydrationEnabled: isI18nHydrationEnabledVal,
        isIncrementalHydrationEnabled: isIncrementalHydrationEnabledVal,
        i18nChildren: new Map(),
        eventTypesToReplay,
        shouldReplayEvents,
        appId,
        deferBlocks
      };
      if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isLContainer)(lNode)) {
        annotateLContainerForHydration(lNode, context);
      } else {
        annotateComponentLViewForHydration(lNode, context);
      }
      insertCorruptedTextNodeMarkers(corruptedTextNodes, doc);
    }
  }
  const serializedViews = serializedViewCollection.getAll();
  const transferState = injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TransferState);
  transferState.set(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NGH_DATA_KEY, serializedViews);
  if (deferBlocks.size > 0) {
    const blocks = {};
    for (const [id, info] of deferBlocks.entries()) {
      blocks[id] = info;
    }
    transferState.set(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NGH_DEFER_BLOCKS_KEY, blocks);
  }
  return eventTypesToReplay;
}
function serializeLContainer(lContainer, tNode, lView, parentDeferBlockId, context) {
  const views = [];
  let lastViewAsString = '';
  for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    let childLView = lContainer[i];
    let template;
    let numRootNodes;
    let serializedView;
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isRootView)(childLView)) {
      childLView = childLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HEADER_OFFSET];
      if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isLContainer)(childLView)) {
        numRootNodes = calcNumRootNodesInLContainer(childLView) + 1;
        annotateLContainerForHydration(childLView, context);
        const componentLView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.unwrapLView)(childLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HOST]);
        serializedView = {
          [_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TEMPLATE_ID]: componentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.TVIEW].ssrId,
          [_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NUM_ROOT_NODES]: numRootNodes
        };
      }
    }
    if (!serializedView) {
      const childTView = childLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.TVIEW];
      if (childTView.type === 1) {
        template = childTView.ssrId;
        numRootNodes = 1;
      } else {
        template = getSsrId(childTView);
        numRootNodes = calcNumRootNodes(childTView, childLView, childTView.firstChild);
      }
      serializedView = {
        [_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TEMPLATE_ID]: template,
        [_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NUM_ROOT_NODES]: numRootNodes
      };
      let isHydrateNeverBlock = false;
      if ((0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isDeferBlock)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.TVIEW], tNode)) {
        const lDetails = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getLDeferBlockDetails)(lView, tNode);
        const tDetails = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getTDeferBlockDetails)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.TVIEW], tNode);
        if (context.isIncrementalHydrationEnabled && tDetails.hydrateTriggers !== null) {
          const deferBlockId = `d${context.deferBlocks.size}`;
          if (tDetails.hydrateTriggers.has(7)) {
            isHydrateNeverBlock = true;
          }
          let rootNodes = [];
          (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.collectNativeNodesInLContainer)(lContainer, rootNodes);
          const deferBlockInfo = {
            [_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NUM_ROOT_NODES]: rootNodes.length,
            [_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFER_BLOCK_STATE]: lDetails[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFER_BLOCK_STATE$1]
          };
          const serializedTriggers = serializeHydrateTriggers(tDetails.hydrateTriggers);
          if (serializedTriggers.length > 0) {
            deferBlockInfo[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFER_HYDRATE_TRIGGERS] = serializedTriggers;
          }
          if (parentDeferBlockId !== null) {
            deferBlockInfo[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFER_PARENT_BLOCK_ID] = parentDeferBlockId;
          }
          context.deferBlocks.set(deferBlockId, deferBlockInfo);
          const node = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.unwrapRNode)(lContainer);
          if (node !== undefined) {
            if (node.nodeType === Node.COMMENT_NODE) {
              annotateDeferBlockAnchorForHydration(node, deferBlockId);
            }
          } else {
            ngDevMode && (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.validateNodeExists)(node, childLView, tNode);
            ngDevMode && (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.validateMatchingNode)(node, Node.COMMENT_NODE, null, childLView, tNode, true);
            annotateDeferBlockAnchorForHydration(node, deferBlockId);
          }
          if (!isHydrateNeverBlock) {
            annotateDeferBlockRootNodesWithJsAction(tDetails, rootNodes, deferBlockId, context);
          }
          parentDeferBlockId = deferBlockId;
          serializedView[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFER_BLOCK_ID] = deferBlockId;
        }
        serializedView[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFER_BLOCK_STATE] = lDetails[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFER_BLOCK_STATE$1];
      }
      if (!isHydrateNeverBlock) {
        Object.assign(serializedView, serializeLView(lContainer[i], parentDeferBlockId, context));
      }
    }
    const currentViewAsString = JSON.stringify(serializedView);
    if (views.length > 0 && currentViewAsString === lastViewAsString) {
      const previousView = views[views.length - 1];
      previousView[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.MULTIPLIER] ??= 1;
      previousView[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.MULTIPLIER]++;
    } else {
      lastViewAsString = currentViewAsString;
      views.push(serializedView);
    }
  }
  return views;
}
function serializeHydrateTriggers(triggerMap) {
  const serializableDeferBlockTrigger = new Set([0, 1, 2, 5]);
  let triggers = [];
  for (let [trigger, details] of triggerMap) {
    if (serializableDeferBlockTrigger.has(trigger)) {
      if (details === null) {
        triggers.push(trigger);
      } else if (details.type === 5) {
        triggers.push({
          trigger,
          delay: details.delay
        });
      } else {
        triggers.push({
          trigger,
          intersectionObserverOptions: details.intersectionObserverOptions
        });
      }
    }
  }
  return triggers;
}
function appendSerializedNodePath(ngh, tNode, lView, excludedParentNodes) {
  const noOffsetIndex = tNode.index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HEADER_OFFSET;
  ngh[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NODES] ??= {};
  ngh[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NODES][noOffsetIndex] ??= (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.calcPathForNode)(tNode, lView, excludedParentNodes);
}
function appendDisconnectedNodeIndex(ngh, tNodeOrNoOffsetIndex) {
  const noOffsetIndex = typeof tNodeOrNoOffsetIndex === 'number' ? tNodeOrNoOffsetIndex : tNodeOrNoOffsetIndex.index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HEADER_OFFSET;
  ngh[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DISCONNECTED_NODES] ??= [];
  if (!ngh[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DISCONNECTED_NODES].includes(noOffsetIndex)) {
    ngh[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DISCONNECTED_NODES].push(noOffsetIndex);
  }
}
function serializeLView(lView, parentDeferBlockId = null, context) {
  const ngh = {};
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.TVIEW];
  const i18nChildren = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getOrComputeI18nChildren)(tView, context);
  const nativeElementsToEventTypes = context.shouldReplayEvents ? collectDomEventsInfo(tView, lView, context.eventTypesToReplay) : null;
  for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    const tNode = tView.data[i];
    const noOffsetIndex = i - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HEADER_OFFSET;
    const i18nData = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.trySerializeI18nBlock)(lView, i, context);
    if (i18nData) {
      ngh[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.I18N_DATA] ??= {};
      ngh[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.I18N_DATA][noOffsetIndex] = i18nData.caseQueue;
      for (const nodeNoOffsetIndex of i18nData.disconnectedNodes) {
        appendDisconnectedNodeIndex(ngh, nodeNoOffsetIndex);
      }
      for (const nodeNoOffsetIndex of i18nData.disjointNodes) {
        const tNode = tView.data[nodeNoOffsetIndex + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HEADER_OFFSET];
        ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertTNode)(tNode);
        appendSerializedNodePath(ngh, tNode, lView, i18nChildren);
      }
      continue;
    }
    if (!(0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isTNodeShape)(tNode)) {
      continue;
    }
    if ((0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isDetachedByI18n)(tNode)) {
      continue;
    }
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isLContainer)(lView[i]) && tNode.tView) {
      ngh[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TEMPLATES] ??= {};
      ngh[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TEMPLATES][noOffsetIndex] = getSsrId(tNode.tView);
    }
    if ((0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isDisconnectedNode)(tNode, lView) && isContentProjectedNode(tNode)) {
      appendDisconnectedNodeIndex(ngh, tNode);
      continue;
    }
    if (Array.isArray(tNode.projection)) {
      for (const projectionHeadTNode of tNode.projection) {
        if (!projectionHeadTNode) continue;
        if (!Array.isArray(projectionHeadTNode)) {
          if (!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isProjectionTNode)(projectionHeadTNode) && !(0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isInSkipHydrationBlock)(projectionHeadTNode)) {
            if ((0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isDisconnectedNode)(projectionHeadTNode, lView)) {
              appendDisconnectedNodeIndex(ngh, projectionHeadTNode);
            } else {
              appendSerializedNodePath(ngh, projectionHeadTNode, lView, i18nChildren);
            }
          }
        } else {
          throw (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.unsupportedProjectionOfDomNodes)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.unwrapRNode)(lView[i]));
        }
      }
    }
    conditionallyAnnotateNodePath(ngh, tNode, lView, i18nChildren);
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isLContainer)(lView[i])) {
      const hostNode = lView[i][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HOST];
      if (Array.isArray(hostNode)) {
        const targetNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.unwrapRNode)(hostNode);
        if (!targetNode.hasAttribute(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SKIP_HYDRATION_ATTR_NAME)) {
          annotateHostElementForHydration(targetNode, hostNode, parentDeferBlockId, context);
        }
      }
      ngh[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.CONTAINERS] ??= {};
      ngh[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.CONTAINERS][noOffsetIndex] = serializeLContainer(lView[i], tNode, lView, parentDeferBlockId, context);
    } else if (Array.isArray(lView[i]) && !(0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isLetDeclaration)(tNode)) {
      const targetNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.unwrapRNode)(lView[i][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HOST]);
      if (!targetNode.hasAttribute(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SKIP_HYDRATION_ATTR_NAME)) {
        annotateHostElementForHydration(targetNode, lView[i], parentDeferBlockId, context);
      }
    } else {
      if (tNode.type & 8) {
        ngh[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ELEMENT_CONTAINERS] ??= {};
        ngh[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ELEMENT_CONTAINERS][noOffsetIndex] = calcNumRootNodes(tView, lView, tNode.child);
      } else if (tNode.type & (16 | 128)) {
        let nextTNode = tNode.next;
        while (nextTNode !== null && nextTNode.type & (16 | 128)) {
          nextTNode = nextTNode.next;
        }
        if (nextTNode && !(0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isInSkipHydrationBlock)(nextTNode)) {
          appendSerializedNodePath(ngh, nextTNode, lView, i18nChildren);
        }
      } else if (tNode.type & 1) {
        const rNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.unwrapRNode)(lView[i]);
        (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.processTextNodeBeforeSerialization)(context, rNode);
      }
    }
    if (nativeElementsToEventTypes && tNode.type & 2) {
      const nativeElement = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.unwrapRNode)(lView[i]);
      if (nativeElementsToEventTypes.has(nativeElement)) {
        (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setJSActionAttributes)(nativeElement, nativeElementsToEventTypes.get(nativeElement), parentDeferBlockId);
      }
    }
  }
  return ngh;
}
function conditionallyAnnotateNodePath(ngh, tNode, lView, excludedParentNodes) {
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isProjectionTNode)(tNode)) {
    return;
  }
  if (tNode.projectionNext && tNode.projectionNext !== tNode.next && !(0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isInSkipHydrationBlock)(tNode.projectionNext)) {
    appendSerializedNodePath(ngh, tNode.projectionNext, lView, excludedParentNodes);
  }
  if (tNode.prev === null && tNode.parent !== null && (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isDisconnectedNode)(tNode.parent, lView) && !(0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isDisconnectedNode)(tNode, lView)) {
    appendSerializedNodePath(ngh, tNode, lView, excludedParentNodes);
  }
}
function componentUsesShadowDomEncapsulation(lView) {
  const instance = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.CONTEXT];
  if (!instance?.constructor) return false;
  const def = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getComponentDef)(instance.constructor);
  return def?.encapsulation === _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ViewEncapsulation.ShadowDom || def?.encapsulation === _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ViewEncapsulation.ExperimentalIsolatedShadowDom;
}
function annotateHostElementForHydration(element, lView, parentDeferBlockId, context) {
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RENDERER];
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.hasI18n)(lView) && !(0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isI18nHydrationSupportEnabled)() || componentUsesShadowDomEncapsulation(lView)) {
    renderer.setAttribute(element, _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SKIP_HYDRATION_ATTR_NAME, '');
    return null;
  } else {
    const ngh = serializeLView(lView, parentDeferBlockId, context);
    const index = context.serializedViewCollection.add(ngh);
    renderer.setAttribute(element, _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NGH_ATTR_NAME, index.toString());
    return index;
  }
}
function annotateDeferBlockAnchorForHydration(comment, deferBlockId) {
  comment.textContent = `ngh=${deferBlockId}`;
}
function insertCorruptedTextNodeMarkers(corruptedTextNodes, doc) {
  for (const [textNode, marker] of corruptedTextNodes) {
    textNode.after(doc.createComment(marker));
  }
}
function isContentProjectedNode(tNode) {
  let currentTNode = tNode;
  while (currentTNode != null) {
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isComponentHost)(currentTNode)) {
      return true;
    }
    currentTNode = currentTNode.parent;
  }
  return false;
}
function annotateDeferBlockRootNodesWithJsAction(tDetails, rootNodes, parentDeferBlockId, context) {
  const actionList = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.convertHydrateTriggersToJsAction)(tDetails.hydrateTriggers);
  for (let et of actionList) {
    context.eventTypesToReplay.regular.add(et);
  }
  if (actionList.length > 0) {
    const elementNodes = rootNodes.filter(rn => rn.nodeType === Node.ELEMENT_NODE);
    for (let rNode of elementNodes) {
      (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setJSActionAttributes)(rNode, actionList, parentDeferBlockId);
    }
  }
}
let isHydrationSupportEnabled = false;
let isI18nHydrationRuntimeSupportEnabled = false;
let isIncrementalHydrationRuntimeSupportEnabled = false;
const APPLICATION_IS_STABLE_TIMEOUT = 10_000;
function enableHydrationRuntimeSupport() {
  if (!isHydrationSupportEnabled) {
    isHydrationSupportEnabled = true;
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enableRetrieveHydrationInfoImpl)();
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enableLocateOrCreateElementNodeImpl)();
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enableLocateOrCreateTextNodeImpl)();
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enableLocateOrCreateElementContainerNodeImpl)();
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enableLocateOrCreateContainerAnchorImpl)();
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enableLocateOrCreateContainerRefImpl)();
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enableFindMatchingDehydratedViewImpl)();
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enableApplyRootElementTransformImpl)();
  }
}
function enableI18nHydrationRuntimeSupport() {
  if (!isI18nHydrationRuntimeSupportEnabled) {
    isI18nHydrationRuntimeSupportEnabled = true;
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enableLocateOrCreateI18nNodeImpl)();
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enablePrepareI18nBlockForHydrationImpl)();
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enableClaimDehydratedIcuCaseImpl)();
  }
}
function enableIncrementalHydrationRuntimeSupport() {
  if (!isIncrementalHydrationRuntimeSupportEnabled) {
    isIncrementalHydrationRuntimeSupportEnabled = true;
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enableRetrieveDeferBlockDataImpl)();
  }
}
function printHydrationStats(injector) {
  const console = injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Console);
  const message = `Angular hydrated ${ngDevMode.hydratedComponents} component(s) ` + `and ${ngDevMode.hydratedNodes} node(s), ` + `${ngDevMode.componentsSkippedHydration} component(s) were skipped. ` + ((0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isIncrementalHydrationEnabled)(injector) ? `${ngDevMode.deferBlocksWithIncrementalHydration} defer block(s) were configured to use incremental hydration. ` : '') + `Learn more at https://angular.dev/guide/hydration.`;
  console.log(message);
}
function whenStableWithTimeout(appRef) {
  const whenStablePromise = appRef.whenStable();
  if (typeof ngDevMode !== 'undefined' && ngDevMode) {
    const timeoutTime = APPLICATION_IS_STABLE_TIMEOUT;
    const console = appRef.injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Console);
    const ngZone = appRef.injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NgZone);
    const timeoutId = ngZone.runOutsideAngular(() => {
      return setTimeout(() => logWarningOnStableTimedout(timeoutTime, console), timeoutTime);
    });
    whenStablePromise.finally(() => clearTimeout(timeoutId));
  }
  return whenStablePromise;
}
const CLIENT_RENDER_MODE_FLAG = 'ngcm';
function isClientRenderModeEnabled(doc) {
  return (typeof ngServerMode === 'undefined' || !ngServerMode) && doc.body.hasAttribute(CLIENT_RENDER_MODE_FLAG);
}
function withDomHydration() {
  const providers = [{
    provide: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_HYDRATION_DOM_REUSE_ENABLED,
    useFactory: () => {
      let isEnabled = true;
      if (typeof ngServerMode === 'undefined' || !ngServerMode) {
        const transferState = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TransferState, {
          optional: true
        });
        isEnabled = !!transferState?.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NGH_DATA_KEY, null);
      }
      if (isEnabled) {
        (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.performanceMarkFeature)('NgHydration');
      }
      return isEnabled;
    }
  }, {
    provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ENVIRONMENT_INITIALIZER,
    useValue: () => {
      (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setIsI18nHydrationSupportEnabled)(false);
      if (typeof ngServerMode !== 'undefined' && ngServerMode) {
        return;
      }
      const doc = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT);
      if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_HYDRATION_DOM_REUSE_ENABLED)) {
        (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.verifySsrContentsIntegrity)(doc);
        enableHydrationRuntimeSupport();
      } else if (typeof ngDevMode !== 'undefined' && ngDevMode && !isClientRenderModeEnabled(doc)) {
        const console = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Console);
        const message = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.formatRuntimeError)(-505, 'Angular hydration was requested on the client, but there was no ' + 'serialized information present in the server response, ' + 'thus hydration was not enabled. ' + 'Make sure the `provideClientHydration()` is included into the list ' + 'of providers in the server part of the application configuration.');
        console.warn(message);
      }
    },
    multi: true
  }];
  if (typeof ngServerMode === 'undefined' || !ngServerMode) {
    providers.push({
      provide: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.PRESERVE_HOST_CONTENT,
      useFactory: () => {
        return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_HYDRATION_DOM_REUSE_ENABLED);
      }
    }, {
      provide: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.APP_BOOTSTRAP_LISTENER,
      useFactory: () => {
        if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_HYDRATION_DOM_REUSE_ENABLED)) {
          const appRef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ApplicationRef);
          return () => {
            whenStableWithTimeout(appRef).then(() => {
              if (appRef.destroyed) {
                return;
              }
              (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.cleanupDehydratedViews)(appRef);
              if (typeof ngDevMode !== 'undefined' && ngDevMode) {
                (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.countBlocksSkippedByHydration)(appRef.injector);
                printHydrationStats(appRef.injector);
              }
            });
          };
        }
        return () => {};
      },
      multi: true
    });
  }
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.makeEnvironmentProviders)(providers);
}
function withI18nSupport() {
  return [{
    provide: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_I18N_HYDRATION_ENABLED,
    useFactory: () => (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_HYDRATION_DOM_REUSE_ENABLED)
  }, {
    provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ENVIRONMENT_INITIALIZER,
    useValue: () => {
      if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_HYDRATION_DOM_REUSE_ENABLED)) {
        enableI18nHydrationRuntimeSupport();
        (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setIsI18nHydrationSupportEnabled)(true);
        (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.performanceMarkFeature)('NgI18nHydration');
      }
    },
    multi: true
  }];
}
function withIncrementalHydration() {
  const providers = [withEventReplay(), {
    provide: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_INCREMENTAL_HYDRATION_ENABLED,
    useValue: true
  }, {
    provide: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEHYDRATED_BLOCK_REGISTRY,
    useClass: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DehydratedBlockRegistry
  }, {
    provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ENVIRONMENT_INITIALIZER,
    useValue: () => {
      enableIncrementalHydrationRuntimeSupport();
      (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.performanceMarkFeature)('NgIncrementalHydration');
    },
    multi: true
  }];
  if (typeof ngServerMode === 'undefined' || !ngServerMode) {
    providers.push({
      provide: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.APP_BOOTSTRAP_LISTENER,
      useFactory: () => {
        const injector = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.Injector);
        const doc = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT);
        return () => {
          const deferBlockData = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.processBlockData)(injector);
          const commentsByBlockId = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.gatherDeferBlocksCommentNodes)(doc, doc.body);
          (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.processAndInitTriggers)(injector, deferBlockData, commentsByBlockId);
          (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.appendDeferBlocksToJSActionMap)(doc, injector);
        };
      },
      multi: true
    });
  }
  return providers;
}
function logWarningOnStableTimedout(time, console) {
  const message = `Angular hydration expected the ApplicationRef.isStable() to emit \`true\`, but it ` + `didn't happen within ${time}ms. Angular hydration logic depends on the application becoming stable ` + `as a signal to complete hydration process.`;
  console.warn((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.formatRuntimeError)(-506, message));
}
function booleanAttribute(value) {
  return typeof value === 'boolean' ? value : value != null && value !== 'false';
}
function numberAttribute(value, fallbackValue = NaN) {
  const isNumberValue = !isNaN(parseFloat(value)) && !isNaN(Number(value));
  return isNumberValue ? Number(value) : fallbackValue;
}
const PERFORMANCE_MARK_PREFIX = '🅰️';
let enablePerfLogging = false;
function startMeasuring(label) {
  if (!enablePerfLogging) {
    return;
  }
  const {
    startLabel
  } = labels(label);
  performance.mark(startLabel);
}
function stopMeasuring(label) {
  if (!enablePerfLogging) {
    return;
  }
  const {
    startLabel,
    labelName,
    endLabel
  } = labels(label);
  performance.mark(endLabel);
  performance.measure(labelName, startLabel, endLabel);
  performance.clearMarks(startLabel);
  performance.clearMarks(endLabel);
}
function labels(label) {
  const labelName = `${PERFORMANCE_MARK_PREFIX}:${label}`;
  return {
    labelName,
    startLabel: `start:${labelName}`,
    endLabel: `end:${labelName}`
  };
}
let warningLogged = false;
function enableProfiling() {
  if (!warningLogged && (typeof performance === 'undefined' || !performance.mark || !performance.measure)) {
    warningLogged = true;
    console.warn('Performance API is not supported on this platform');
    return;
  }
  enablePerfLogging = true;
}
function disableProfiling() {
  enablePerfLogging = false;
}
function getClosestComponentName(node) {
  let currentNode = node;
  while (currentNode) {
    const lView = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.readPatchedLView)(currentNode);
    if (lView !== null) {
      for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HEADER_OFFSET; i < lView.length; i++) {
        const current = lView[i];
        if (!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isLView)(current) && !(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isLContainer)(current) || current[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HOST] !== currentNode) {
          continue;
        }
        const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.TVIEW];
        const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getTNode)(tView, i);
        if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isComponentHost)(tNode)) {
          const def = tView.data[tNode.directiveStart + tNode.componentOffset];
          const name = def.debugInfo?.className || def.type.name;
          if (name) {
            return name;
          } else {
            break;
          }
        }
      }
    }
    currentNode = currentNode.parentNode;
  }
  return null;
}
function ɵassertType(value) {}
function ɵɵngDeclareDirective(decl) {
  const compiler = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getCompilerFacade)({
    usage: 1,
    kind: 'directive',
    type: decl.type
  });
  return compiler.compileDirectiveDeclaration(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.angularCoreEnv, `ng:///${decl.type.name}/ɵfac.js`, decl);
}
function ɵɵngDeclareClassMetadata(decl) {
  (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata)(decl.type, decl.decorators, decl.ctorParameters ?? null, decl.propDecorators ?? null);
}
function ɵɵngDeclareClassMetadataAsync(decl) {
  (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setClassMetadataAsync)(decl.type, decl.resolveDeferredDeps, (...types) => {
    const meta = decl.resolveMetadata(...types);
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata)(decl.type, meta.decorators, meta.ctorParameters, meta.propDecorators);
  });
}
function ɵɵngDeclareComponent(decl) {
  const compiler = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getCompilerFacade)({
    usage: 1,
    kind: 'component',
    type: decl.type
  });
  return compiler.compileComponentDeclaration(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.angularCoreEnv, `ng:///${decl.type.name}/ɵcmp.js`, decl);
}
function ɵɵngDeclareFactory(decl) {
  const compiler = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getCompilerFacade)({
    usage: 1,
    kind: getFactoryKind(decl.target),
    type: decl.type
  });
  return compiler.compileFactoryDeclaration(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.angularCoreEnv, `ng:///${decl.type.name}/ɵfac.js`, decl);
}
function getFactoryKind(target) {
  switch (target) {
    case FactoryTarget.Directive:
      return 'directive';
    case FactoryTarget.Component:
      return 'component';
    case FactoryTarget.Injectable:
      return 'injectable';
    case FactoryTarget.Pipe:
      return 'pipe';
    case FactoryTarget.NgModule:
      return 'NgModule';
  }
}
function ɵɵngDeclareInjectable(decl) {
  const compiler = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getCompilerFacade)({
    usage: 1,
    kind: 'injectable',
    type: decl.type
  });
  return compiler.compileInjectableDeclaration(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.angularCoreEnv, `ng:///${decl.type.name}/ɵprov.js`, decl);
}
function ɵɵngDeclareInjector(decl) {
  const compiler = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getCompilerFacade)({
    usage: 1,
    kind: 'NgModule',
    type: decl.type
  });
  return compiler.compileInjectorDeclaration(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.angularCoreEnv, `ng:///${decl.type.name}/ɵinj.js`, decl);
}
function ɵɵngDeclareNgModule(decl) {
  const compiler = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getCompilerFacade)({
    usage: 1,
    kind: 'NgModule',
    type: decl.type
  });
  return compiler.compileNgModuleDeclaration(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.angularCoreEnv, `ng:///${decl.type.name}/ɵmod.js`, decl);
}
function ɵɵngDeclarePipe(decl) {
  const compiler = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getCompilerFacade)({
    usage: 1,
    kind: 'pipe',
    type: decl.type
  });
  return compiler.compilePipeDeclaration(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.angularCoreEnv, `ng:///${decl.type.name}/ɵpipe.js`, decl);
}
const NOT_SET = /* @__PURE__ */Symbol('NOT_SET');
const EMPTY_CLEANUP_SET = /* @__PURE__ */new Set();
const AFTER_RENDER_PHASE_EFFECT_NODE = /* @__PURE__ */(() => ({
  ..._effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.SIGNAL_NODE,
  kind: 'afterRenderEffectPhase',
  consumerIsAlwaysLive: true,
  consumerAllowSignalWrites: true,
  value: NOT_SET,
  cleanup: null,
  consumerMarkedDirty() {
    if (this.sequence.impl.executing) {
      if (this.sequence.lastPhase === null || this.sequence.lastPhase < this.phase) {
        return;
      }
      this.sequence.erroredOrDestroyed = true;
    }
    this.sequence.scheduler.notify(7);
  },
  phaseFn(previousValue) {
    this.sequence.lastPhase = this.phase;
    if (!this.dirty) {
      return this.signal;
    }
    this.dirty = false;
    if (this.value !== NOT_SET && !(0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.consumerPollProducersForChange)(this)) {
      return this.signal;
    }
    try {
      for (const cleanupFn of this.cleanup ?? EMPTY_CLEANUP_SET) {
        cleanupFn();
      }
    } finally {
      this.cleanup?.clear();
    }
    const args = [];
    if (previousValue !== undefined) {
      args.push(previousValue);
    }
    args.push(this.registerCleanupFn);
    const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.consumerBeforeComputation)(this);
    let newValue;
    try {
      newValue = this.userFn.apply(null, args);
    } finally {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.consumerAfterComputation)(this, prevConsumer);
    }
    if (this.value === NOT_SET || !this.equal(this.value, newValue)) {
      this.value = newValue;
      this.version++;
    }
    return this.signal;
  }
}))();
class AfterRenderEffectSequence extends _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.AfterRenderSequence {
  scheduler;
  lastPhase = null;
  nodes = [undefined, undefined, undefined, undefined];
  onDestroyFns = null;
  constructor(impl, effectHooks, view, scheduler, injector, snapshot = null) {
    super(impl, [undefined, undefined, undefined, undefined], view, false, injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.DestroyRef), snapshot);
    this.scheduler = scheduler;
    for (const phase of _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.AFTER_RENDER_PHASES) {
      const effectHook = effectHooks[phase];
      if (effectHook === undefined) {
        continue;
      }
      const node = Object.create(AFTER_RENDER_PHASE_EFFECT_NODE);
      node.sequence = this;
      node.phase = phase;
      node.userFn = effectHook;
      node.dirty = true;
      node.signal = () => {
        (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.producerAccessed)(node);
        return node.value;
      };
      node.signal[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.SIGNAL] = node;
      node.registerCleanupFn = fn => (node.cleanup ??= new Set()).add(fn);
      this.nodes[phase] = node;
      this.hooks[phase] = value => node.phaseFn(value);
      if (ngDevMode) {
        setupDebugInfo(node, injector);
      }
    }
  }
  afterRun() {
    super.afterRun();
    this.lastPhase = null;
  }
  destroy() {
    if (this.onDestroyFns !== null) {
      for (const fn of this.onDestroyFns) {
        fn();
      }
    }
    super.destroy();
    for (const node of this.nodes) {
      if (node) {
        try {
          for (const fn of node.cleanup ?? EMPTY_CLEANUP_SET) {
            fn();
          }
        } finally {
          (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.consumerDestroy)(node);
        }
      }
    }
  }
}
function afterRenderEffect(callbackOrSpec, options) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertNotInReactiveContext)(afterRenderEffect, 'Call `afterRenderEffect` outside of a reactive context. For example, create the render ' + 'effect inside the component constructor`.');
  if (ngDevMode && !options?.injector) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertInInjectionContext)(afterRenderEffect);
  }
  if (typeof ngServerMode !== 'undefined' && ngServerMode) {
    return _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NOOP_AFTER_RENDER_REF;
  }
  const injector = options?.injector ?? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.Injector);
  const scheduler = injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionScheduler);
  const manager = injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.AfterRenderManager);
  const tracing = injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TracingService, null, {
    optional: true
  });
  manager.impl ??= injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.AfterRenderImpl);
  let spec = callbackOrSpec;
  if (typeof spec === 'function') {
    spec = {
      mixedReadWrite: callbackOrSpec
    };
  }
  const viewContext = injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ViewContext, null, {
    optional: true
  });
  const sequence = new AfterRenderEffectSequence(manager.impl, [spec.earlyRead, spec.write, spec.mixedReadWrite, spec.read], viewContext?.view, scheduler, injector, tracing?.snapshot(null));
  manager.impl.register(sequence);
  return sequence;
}
function setupDebugInfo(node, injector) {
  node.debugName = `afterRenderEffect - ${phaseDebugName(node.phase)} phase`;
  const prevInjectorProfilerContext = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.setInjectorProfilerContext)({
    injector,
    token: null
  });
  try {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.emitAfterRenderEffectPhaseCreatedEvent)(node);
  } finally {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.setInjectorProfilerContext)(prevInjectorProfilerContext);
  }
}
function phaseDebugName(phase) {
  switch (phase) {
    case 0:
      return 'EarlyRead';
    case 1:
      return 'Write';
    case 2:
      return 'MixedReadWrite';
    case 3:
      return 'Read';
  }
}
function createComponent(component, options) {
  ngDevMode && (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.assertComponentDef)(component);
  const componentDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getComponentDef)(component);
  const elementInjector = options.elementInjector || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getNullInjector)();
  const factory = new _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ComponentFactory(componentDef);
  return factory.create(elementInjector, options.projectableNodes, options.hostElement, options.environmentInjector, options.directives, options.bindings);
}
function reflectComponentType(component) {
  const componentDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getComponentDef)(component);
  if (!componentDef) return null;
  const factory = new _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ComponentFactory(componentDef);
  return {
    get selector() {
      return factory.selector;
    },
    get type() {
      return factory.componentType;
    },
    get inputs() {
      return factory.inputs;
    },
    get outputs() {
      return factory.outputs;
    },
    get ngContentSelectors() {
      return factory.ngContentSelectors;
    },
    get isStandalone() {
      return componentDef.standalone;
    },
    get isSignal() {
      return componentDef.signals;
    }
  };
}
function mergeApplicationConfig(...configs) {
  return configs.reduce((prev, curr) => {
    return Object.assign(prev, curr, {
      providers: [...prev.providers, ...curr.providers]
    });
  }, {
    providers: []
  });
}
const REQUEST = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'REQUEST' : '', {
  providedIn: 'platform',
  factory: () => null
});
const RESPONSE_INIT = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'RESPONSE_INIT' : '', {
  providedIn: 'platform',
  factory: () => null
});
const REQUEST_CONTEXT = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'REQUEST_CONTEXT' : '', {
  providedIn: 'platform',
  factory: () => null
});


/***/ }),

/***/ 8419:
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/util/lift.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hasLift: () => (/* binding */ hasLift),
/* harmony export */   operate: () => (/* binding */ operate)
/* harmony export */ });
/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction */ 4010);

function hasLift(source) {
  return (0,_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return source => {
    if (hasLift(source)) {
      return source.lift(function (liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError('Unable to lift unknown Observable type');
  };
}

/***/ }),

/***/ 8808:
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/scheduled/scheduleIterable.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   scheduleIterable: () => (/* binding */ scheduleIterable)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ 1814);
/* harmony import */ var _symbol_iterator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../symbol/iterator */ 4956);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/isFunction */ 4010);
/* harmony import */ var _util_executeSchedule__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/executeSchedule */ 3494);




function scheduleIterable(input, scheduler) {
  return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(subscriber => {
    let iterator;
    (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_3__.executeSchedule)(subscriber, scheduler, () => {
      iterator = input[_symbol_iterator__WEBPACK_IMPORTED_MODULE_1__.iterator]();
      (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_3__.executeSchedule)(subscriber, scheduler, () => {
        let value;
        let done;
        try {
          ({
            value,
            done
          } = iterator.next());
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return () => (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_2__.isFunction)(iterator === null || iterator === void 0 ? void 0 : iterator.return) && iterator.return();
  });
}

/***/ }),

/***/ 9338:
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/operators/takeLast.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   takeLast: () => (/* binding */ takeLast)
/* harmony export */ });
/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observable/empty */ 5672);
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/lift */ 8419);
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OperatorSubscriber */ 3943);



function takeLast(count) {
  return count <= 0 ? () => _observable_empty__WEBPACK_IMPORTED_MODULE_0__.EMPTY : (0,_util_lift__WEBPACK_IMPORTED_MODULE_1__.operate)((source, subscriber) => {
    let buffer = [];
    source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__.createOperatorSubscriber)(subscriber, value => {
      buffer.push(value);
      count < buffer.length && buffer.shift();
    }, () => {
      for (const value of buffer) {
        subscriber.next(value);
      }
      subscriber.complete();
    }, undefined, () => {
      buffer = null;
    }));
  });
}

/***/ }),

/***/ 9582:
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/util/throwUnobservableError.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createInvalidObservableTypeError: () => (/* binding */ createInvalidObservableTypeError)
/* harmony export */ });
function createInvalidObservableTypeError(input) {
  return new TypeError(`You provided ${input !== null && typeof input === 'object' ? 'an invalid object' : `'${input}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`);
}

/***/ }),

/***/ 9596:
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/observable/of.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   of: () => (/* binding */ of)
/* harmony export */ });
/* harmony import */ var _util_args__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/args */ 1683);
/* harmony import */ var _from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./from */ 7909);


function of(...args) {
  const scheduler = (0,_util_args__WEBPACK_IMPORTED_MODULE_0__.popScheduler)(args);
  return (0,_from__WEBPACK_IMPORTED_MODULE_1__.from)(args, scheduler);
}

/***/ }),

/***/ 9671:
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/operators/switchMap.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   switchMap: () => (/* binding */ switchMap)
/* harmony export */ });
/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observable/innerFrom */ 5829);
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/lift */ 8419);
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OperatorSubscriber */ 3943);



function switchMap(project, resultSelector) {
  return (0,_util_lift__WEBPACK_IMPORTED_MODULE_1__.operate)((source, subscriber) => {
    let innerSubscriber = null;
    let index = 0;
    let isComplete = false;
    const checkComplete = () => isComplete && !innerSubscriber && subscriber.complete();
    source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__.createOperatorSubscriber)(subscriber, value => {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      let innerIndex = 0;
      const outerIndex = index++;
      (0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_0__.innerFrom)(project(value, outerIndex)).subscribe(innerSubscriber = (0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__.createOperatorSubscriber)(subscriber, innerValue => subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue), () => {
        innerSubscriber = null;
        checkComplete();
      }));
    }, () => {
      isComplete = true;
      checkComplete();
    }));
  });
}

/***/ }),

/***/ 9856:
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/operators/scanInternals.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   scanInternals: () => (/* binding */ scanInternals)
/* harmony export */ });
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./OperatorSubscriber */ 3943);

function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
  return (source, subscriber) => {
    let hasState = hasSeed;
    let state = seed;
    let index = 0;
    source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_0__.createOperatorSubscriber)(subscriber, value => {
      const i = index++;
      state = hasState ? accumulator(state, value, i) : (hasState = true, value);
      emitOnNext && subscriber.next(state);
    }, emitBeforeComplete && (() => {
      hasState && subscriber.next(state);
      subscriber.complete();
    })));
  };
}

/***/ }),

/***/ 9905:
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm/internal/util/isReadableStreamLike.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isReadableStreamLike: () => (/* binding */ isReadableStreamLike),
/* harmony export */   readableStreamLikeToAsyncGenerator: () => (/* binding */ readableStreamLikeToAsyncGenerator)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ 945);
/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction */ 4010);


function readableStreamLikeToAsyncGenerator(readableStream) {
  return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__asyncGenerator)(this, arguments, function* readableStreamLikeToAsyncGenerator_1() {
    const reader = readableStream.getReader();
    try {
      while (true) {
        const {
          value,
          done
        } = yield (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__await)(reader.read());
        if (done) {
          return yield (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__await)(void 0);
        }
        yield yield (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__await)(value);
      }
    } finally {
      reader.releaseLock();
    }
  });
}
function isReadableStreamLike(obj) {
  return (0,_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

/***/ })

}]);
//# sourceMappingURL=vendor.js.map